<android.companion.IOnAssociationsChangedListener: void onAssociationsChanged(java.util.List)>
<android.hardware.usb.IUsbManager: void setDevicePackage(android.hardware.usb.UsbDevice,java.lang.String,int)>
<android.hardware.usb.IUsbManager: boolean registerForDisplayPortEvents(android.hardware.usb.IDisplayPortAltModeInfoListener)>
<android.hardware.usb.IUsbManager: int semGetPowerRoleStatus()>
<android.hardware.usb.IUsbManager: void semSetDevicePackage(android.hardware.usb.UsbDevice,java.lang.String,int)>
<android.hardware.usb.IUsbManager: void setScreenUnlockedFunctions(long)>
<android.hardware.usb.IUsbManager: int restrictUsbHostInterface(boolean,java.lang.String)>
<android.hardware.usb.IUsbManager: void clearDefaults(java.lang.String,int)>
<android.hardware.usb.IUsbManager: void resetUsbPort(java.lang.String,int,android.hardware.usb.IUsbOperationInternal)>
<android.hardware.usb.IUsbManager: boolean isSupportDexRestrict()>
<android.hardware.usb.IUsbManager: android.hardware.usb.UsbAccessory getCurrentAccessory()>
<android.hardware.usb.IUsbManager: boolean isFunctionEnabled(java.lang.String)>
<android.hardware.usb.IUsbManager: java.util.List getPorts()>
<android.hardware.usb.IUsbManager: int semGetDataRoleStatus()>
<android.hardware.usb.IUsbManager: void setAccessoryPackage(android.hardware.usb.UsbAccessory,java.lang.String,int)>
<android.hardware.usb.IUsbManager: void addAccessoryPackagesToPreferenceDenied(android.hardware.usb.UsbAccessory,java.lang.String[],android.os.UserHandle)>
<android.hardware.usb.IUsbManager: void semGrantDevicePermission(android.hardware.usb.UsbDevice,int)>
<android.hardware.usb.IUsbManager: void requestDevicePermission(android.hardware.usb.UsbDevice,java.lang.String,android.app.PendingIntent)>
<android.hardware.usb.IUsbManager: void unregisterForDisplayPortEvents(android.hardware.usb.IDisplayPortAltModeInfoListener)>
<android.hardware.usb.IUsbManager: android.hardware.usb.UsbPortStatus getPortStatus(java.lang.String)>
<android.hardware.usb.IUsbManager: boolean enableUsbData(java.lang.String,boolean,int,android.hardware.usb.IUsbOperationInternal)>
<android.hardware.usb.IUsbManager: long getCurrentFunctions()>
<android.hardware.usb.IUsbManager: void getDeviceList(android.os.Bundle)>
<android.hardware.usb.IUsbManager: void semSetMode(int)>
<android.hardware.usb.IUsbManager: void enableContaminantDetection(java.lang.String,boolean)>
<android.hardware.usb.IUsbManager: boolean hasDefaults(java.lang.String,int)>
<android.hardware.usb.IUsbManager: void requestAccessoryPermission(android.hardware.usb.UsbAccessory,java.lang.String,android.app.PendingIntent)>
<android.hardware.usb.IUsbManager: void resetUsbGadget()>
<android.hardware.usb.IUsbManager: void enableLimitPowerTransfer(java.lang.String,boolean,int,android.hardware.usb.IUsbOperationInternal)>
<android.hardware.usb.IUsbManager: void setUsbDeviceConnectionHandler(android.content.ComponentName)>
<android.hardware.usb.IUsbManager: int getCurrentUsbSpeed()>
<android.hardware.usb.IUsbManager: boolean hasDevicePermissionWithIdentity(android.hardware.usb.UsbDevice,java.lang.String,int,int)>
<android.hardware.usb.IUsbManager: void grantAccessoryPermission(android.hardware.usb.UsbAccessory,int)>
<android.hardware.usb.IUsbManager: void grantDevicePermission(android.hardware.usb.UsbDevice,int)>
<android.hardware.usb.IUsbManager: int getUsbHalVersion()>
<android.hardware.usb.IUsbManager: android.os.ParcelFileDescriptor getControlFd(long)>
<android.hardware.usb.IUsbManager: void setAccessoryPersistentPermission(android.hardware.usb.UsbAccessory,int,android.os.UserHandle,boolean)>
<android.hardware.usb.IUsbManager: int getGadgetHalVersion()>
<android.hardware.usb.IUsbManager: boolean hasDevicePermission(android.hardware.usb.UsbDevice,java.lang.String)>
<android.hardware.usb.IUsbManager: boolean hasAccessoryPermission(android.hardware.usb.UsbAccessory)>
<android.hardware.usb.IUsbManager: void addDevicePackagesToPreferenceDenied(android.hardware.usb.UsbDevice,java.lang.String[],android.os.UserHandle)>
<android.hardware.usb.IUsbManager: long getScreenUnlockedFunctions()>
<android.hardware.usb.IUsbManager: void removeDevicePackagesFromPreferenceDenied(android.hardware.usb.UsbDevice,java.lang.String[],android.os.UserHandle)>
<android.hardware.usb.IUsbManager: android.os.ParcelFileDescriptor openDevice(java.lang.String,java.lang.String)>
<android.hardware.usb.IUsbManager: boolean hasAccessoryPermissionWithIdentity(android.hardware.usb.UsbAccessory,int,int)>
<android.hardware.usb.IUsbManager: void removeAccessoryPackagesFromPreferenceDenied(android.hardware.usb.UsbAccessory,java.lang.String[],android.os.UserHandle)>
<android.hardware.usb.IUsbManager: android.os.ParcelFileDescriptor openAccessory(android.hardware.usb.UsbAccessory)>
<android.hardware.usb.IUsbManager: void enableUsbDataWhileDocked(java.lang.String,int,android.hardware.usb.IUsbOperationInternal)>
<android.hardware.usb.IUsbManager: boolean isUsbBlocked()>
<android.hardware.usb.IUsbManager: void setCurrentFunction(java.lang.String,boolean,int)>
<android.hardware.usb.IUsbManager: void setUsbHiddenMenuState(boolean)>
<android.hardware.usb.IUsbManager: void setCurrentFunctions(long,int)>
<android.hardware.usb.IUsbManager: void setPortRoles(java.lang.String,int,int)>
<android.hardware.usb.IUsbManager: void setDevicePersistentPermission(android.hardware.usb.UsbDevice,int,android.os.UserHandle,boolean)>
<android.app.INotificationPlayerOnCompletionListener: void onCompletion()>
<android.hardware.camera2.extension.IRequestCallback: void onCaptureCompleted(int,android.hardware.camera2.extension.ParcelTotalCaptureResult)>
<android.hardware.camera2.extension.IRequestCallback: void onCaptureSequenceAborted(int)>
<android.hardware.camera2.extension.IRequestCallback: void onCaptureSequenceCompleted(int,long)>
<android.hardware.camera2.extension.IRequestCallback: void onCaptureBufferLost(int,long,int)>
<android.hardware.camera2.extension.IRequestCallback: void onCaptureProgressed(int,android.hardware.camera2.extension.ParcelCaptureResult)>
<android.hardware.camera2.extension.IRequestCallback: void onCaptureFailed(int,android.hardware.camera2.extension.CaptureFailure)>
<android.hardware.camera2.extension.IRequestCallback: void onCaptureStarted(int,long,long)>
<com.android.ims.ImsConfigListener: void onGetFeatureResponse(int,int,int,int)>
<com.android.ims.ImsConfigListener: void onGetVideoQuality(int,int)>
<com.android.ims.ImsConfigListener: void onSetFeatureResponse(int,int,int,int)>
<com.android.ims.ImsConfigListener: void onSetVideoQuality(int)>
<android.location.provider.ILocationProviderManager: void onFlushComplete()>
<android.location.provider.ILocationProviderManager: void onReportLocations(java.util.List)>
<android.location.provider.ILocationProviderManager: void onSetProperties(android.location.provider.ProviderProperties)>
<android.location.provider.ILocationProviderManager: void onReportLocation(android.location.Location)>
<android.location.provider.ILocationProviderManager: void onSetAllowed(boolean)>
<android.location.provider.ILocationProviderManager: void onInitialize(boolean,android.location.provider.ProviderProperties,java.lang.String)>
<android.database.IBulkCursor: android.os.Bundle respond(android.os.Bundle)>
<android.database.IBulkCursor: void deactivate()>
<android.database.IBulkCursor: int requery(android.database.IContentObserver)>
<android.database.IBulkCursor: android.database.CursorWindow getWindow(int)>
<android.database.IBulkCursor: void onMove(int)>
<android.database.IBulkCursor: void close()>
<android.database.IBulkCursor: android.os.Bundle getExtras()>
<android.os.image.IDynamicSystemService: boolean setAshmem(android.os.ParcelFileDescriptor,long)>
<android.os.image.IDynamicSystemService: android.gsi.GsiProgress getInstallationProgress()>
<android.os.image.IDynamicSystemService: boolean remove()>
<android.os.image.IDynamicSystemService: boolean setEnable(boolean,boolean)>
<android.os.image.IDynamicSystemService: int createPartition(java.lang.String,long,boolean)>
<android.os.image.IDynamicSystemService: boolean closePartition()>
<android.os.image.IDynamicSystemService: long suggestScratchSize()>
<android.os.image.IDynamicSystemService: boolean isInUse()>
<android.os.image.IDynamicSystemService: boolean startInstallation(java.lang.String)>
<android.os.image.IDynamicSystemService: boolean isInstalled()>
<android.os.image.IDynamicSystemService: boolean getAvbPublicKey(android.gsi.AvbPublicKey)>
<android.os.image.IDynamicSystemService: boolean submitFromAshmem(long)>
<android.os.image.IDynamicSystemService: boolean finishInstallation()>
<android.os.image.IDynamicSystemService: boolean isEnabled()>
<android.os.image.IDynamicSystemService: boolean abort()>
<android.media.IDevicesForAttributesCallback: void onDevicesForAttributesChanged(android.media.AudioAttributes,boolean,java.util.List)>
<com.samsung.android.content.clipboard.IOnUserChangedListener: void onUserChanged(int)>
<android.content.om.ISamsungOverlayCallback: void onOverlayStateChanged(java.lang.String,java.lang.String,int)>
<android.hardware.gnss.IAGnssCallback: int getInterfaceVersion()>
<android.hardware.gnss.IAGnssCallback: java.lang.String getInterfaceHash()>
<android.hardware.gnss.IAGnssCallback: void agnssStatusCb(int,int)>
<android.hardware.hdmi.IHdmiCecSettingChangeListener: void onChange(java.lang.String)>
<android.content.ISyncCallBack: void deletePersonaData(int)>
<android.content.ISyncCallBack: void doSync(java.lang.String,int)>
<android.hardware.biometrics.IBiometricContextListener: void onDisplayStateChanged(int)>
<android.hardware.biometrics.IBiometricContextListener: void onFoldChanged(int)>
<android.media.tv.ITvInputHardware: void overrideAudioSink(int,java.lang.String,int,int,int)>
<android.media.tv.ITvInputHardware: void setStreamVolume(float)>
<android.media.tv.ITvInputHardware: boolean setSurface(android.view.Surface,android.media.tv.TvStreamConfig)>
<com.android.internal.telephony.IImsStateCallback: void onAvailable()>
<com.android.internal.telephony.IImsStateCallback: void onUnavailable(int)>
<android.app.IForegroundServiceObserver: void onForegroundStateChanged(android.os.IBinder,java.lang.String,int,boolean)>
<android.media.tv.interactive.ITvInteractiveAppManagerCallback: void onInteractiveAppServiceAdded(java.lang.String)>
<android.media.tv.interactive.ITvInteractiveAppManagerCallback: void onTvInteractiveAppServiceInfoUpdated(android.media.tv.interactive.TvInteractiveAppServiceInfo)>
<android.media.tv.interactive.ITvInteractiveAppManagerCallback: void onInteractiveAppServiceUpdated(java.lang.String)>
<android.media.tv.interactive.ITvInteractiveAppManagerCallback: void onInteractiveAppServiceRemoved(java.lang.String)>
<android.media.tv.interactive.ITvInteractiveAppManagerCallback: void onStateChanged(java.lang.String,int,int,int)>
<android.media.projection.IMediaProjectionManager: android.media.projection.IMediaProjection createProjection(int,java.lang.String,int,boolean)>
<android.media.projection.IMediaProjectionManager: void removeCallback(android.media.projection.IMediaProjectionWatcherCallback)>
<android.media.projection.IMediaProjectionManager: boolean setContentRecordingSession(android.view.ContentRecordingSession,android.media.projection.IMediaProjection)>
<android.media.projection.IMediaProjectionManager: android.media.projection.MediaProjectionInfo getActiveProjectionInfo()>
<android.media.projection.IMediaProjectionManager: boolean isCurrentProjection(android.media.projection.IMediaProjection)>
<android.media.projection.IMediaProjectionManager: void requestConsentForInvalidProjection(android.media.projection.IMediaProjection)>
<android.media.projection.IMediaProjectionManager: void notifyActiveProjectionCapturedContentVisibilityChanged(boolean)>
<android.media.projection.IMediaProjectionManager: void addCallback(android.media.projection.IMediaProjectionWatcherCallback)>
<android.media.projection.IMediaProjectionManager: android.media.projection.IMediaProjection getProjection(int,java.lang.String)>
<android.media.projection.IMediaProjectionManager: void stopActiveProjection()>
<android.media.projection.IMediaProjectionManager: void setUserReviewGrantedConsentResult(int,android.media.projection.IMediaProjection)>
<android.media.projection.IMediaProjectionManager: boolean hasProjectionPermission(int,java.lang.String)>
<android.media.projection.IMediaProjectionManager: void notifyActiveProjectionCapturedContentResized(int,int)>
<android.app.IAlarmListener: void doAlarm(android.app.IAlarmCompleteListener)>
<com.samsung.android.displaysolution.ISemDisplaySolutionManager: void onAutoCurrentLimitStateChangedWithBrightness(boolean)>
<com.samsung.android.displaysolution.ISemDisplaySolutionManager: void setDouAppModeEnable(boolean)>
<com.samsung.android.displaysolution.ISemDisplaySolutionManager: void setBlfEnableTimeBySchedule(boolean,int)>
<com.samsung.android.displaysolution.ISemDisplaySolutionManager: void onAutoCurrentLimitOffMode(boolean)>
<com.samsung.android.displaysolution.ISemDisplaySolutionManager: void onDetailVeiwStateChanged(boolean)>
<com.samsung.android.displaysolution.ISemDisplaySolutionManager: void setEyeComfortWeightingFactor(float)>
<com.samsung.android.displaysolution.ISemDisplaySolutionManager: void setMdnieScenarioControlServiceEnable(boolean)>
<com.samsung.android.displaysolution.ISemDisplaySolutionManager: void setMultipleScreenBrightness(java.lang.String)>
<com.samsung.android.displaysolution.ISemDisplaySolutionManager: void setMultipleScreenBrightnessValueForHDR(float)>
<com.samsung.android.displaysolution.ISemDisplaySolutionManager: boolean getCameraModeEnable()>
<com.samsung.android.displaysolution.ISemDisplaySolutionManager: void setHighDynamicRangeMode(boolean)>
<com.samsung.android.displaysolution.ISemDisplaySolutionManager: void setScreenBrightnessForPreview(int)>
<com.samsung.android.displaysolution.ISemDisplaySolutionManager: boolean isMdnieScenarioControlServiceEnabled()>
<com.samsung.android.displaysolution.ISemDisplaySolutionManager: float getFingerPrintBacklightValue(int)>
<com.samsung.android.displaysolution.ISemDisplaySolutionManager: boolean getGalleryModeEnable()>
<com.samsung.android.displaysolution.ISemDisplaySolutionManager: java.lang.String getOnPixelRatioValueForPMS()>
<com.samsung.android.displaysolution.ISemDisplaySolutionManager: void setSleepPatternBLF(java.lang.String,long,long,float)>
<com.samsung.android.displaysolution.ISemDisplaySolutionManager: void setVideoEnhancerSettingState(java.lang.String,int)>
<com.samsung.android.displaysolution.ISemDisplaySolutionManager: void setIRCompensationMode(boolean)>
<com.samsung.android.displaysolution.ISemDisplaySolutionManager: boolean getDouAppModeEnable()>
<com.samsung.android.displaysolution.ISemDisplaySolutionManager: void setGalleryModeEnable(boolean)>
<com.samsung.android.displaysolution.ISemDisplaySolutionManager: void setCameraModeEnable(boolean)>
<com.samsung.android.displaysolution.ISemDisplaySolutionManager: void setEadIndexOffset(int)>
<com.samsung.android.displaysolution.ISemDisplaySolutionManager: float getAlphaMaskLevel(float,float,float)>
<com.samsung.android.displaysolution.ISemDisplaySolutionManager: void onAutoCurrentLimitStateChangedInt(int)>
<com.samsung.android.displaysolution.ISemDisplaySolutionManager: int getVideoEnhancerSettingState(java.lang.String)>
<com.samsung.android.displaysolution.ISemDisplaySolutionManager: boolean getVideoModeEnable()>
<com.samsung.android.displaysolution.ISemDisplaySolutionManager: void onBurnInPreventionDisabled(boolean)>
<com.samsung.android.displaysolution.ISemDisplaySolutionManager: boolean isBlueLightFilterScheduledTime()>
<com.samsung.android.displaysolution.ISemDisplaySolutionManager: boolean getAutoCurrentLimitOffModeEnabled()>
<com.samsung.android.displaysolution.ISemDisplaySolutionManager: void onAutoCurrentLimitStateChanged(boolean)>
<com.samsung.android.displaysolution.ISemDisplaySolutionManager: void setOnPixelRatioValueForPMS(java.lang.String)>
<com.samsung.android.displaysolution.ISemDisplaySolutionManager: void setVideoModeEnable(boolean)>
<com.samsung.android.displaysolution.ISemDisplaySolutionManager: void setAutoCurrentLimitOffModeEnabled(boolean)>
<android.se.omapi.ISecureElementSession: java.lang.String getInterfaceHash()>
<android.se.omapi.ISecureElementSession: int getInterfaceVersion()>
<android.se.omapi.ISecureElementSession: boolean isClosed()>
<android.se.omapi.ISecureElementSession: android.se.omapi.ISecureElementChannel openLogicalChannel(byte[],byte,android.se.omapi.ISecureElementListener)>
<android.se.omapi.ISecureElementSession: android.se.omapi.ISecureElementChannel openBasicChannel(byte[],byte,android.se.omapi.ISecureElementListener)>
<android.se.omapi.ISecureElementSession: byte[] getAtr()>
<android.se.omapi.ISecureElementSession: void close()>
<android.se.omapi.ISecureElementSession: void closeChannels()>
<com.samsung.android.edge.IEdgeLightingCallback: void onEdgeLightingStarted()>
<com.samsung.android.edge.IEdgeLightingCallback: void onScreenChanged(boolean)>
<com.samsung.android.edge.IEdgeLightingCallback: void onStartEdgeLighting(java.lang.String,com.samsung.android.edge.SemEdgeLightingInfo,int)>
<com.samsung.android.edge.IEdgeLightingCallback: void onStopEdgeLighting(java.lang.String,int)>
<com.samsung.android.edge.IEdgeLightingCallback: void onEdgeLightingStopped()>
<com.samsung.android.authnrservice.manager.ISemAuthnrService: boolean terminatePreloadedTa(int)>
<com.samsung.android.authnrservice.manager.ISemAuthnrService: boolean terminateDrk()>
<com.samsung.android.authnrservice.manager.ISemAuthnrService: boolean initialize(android.os.ParcelFileDescriptor,long,long)>
<com.samsung.android.authnrservice.manager.ISemAuthnrService: byte[] process(byte[])>
<com.samsung.android.authnrservice.manager.ISemAuthnrService: java.util.List getMatchedFilePaths(java.lang.String,java.lang.String)>
<com.samsung.android.authnrservice.manager.ISemAuthnrService: boolean initializeDrk()>
<com.samsung.android.authnrservice.manager.ISemAuthnrService: byte[] processPreloadedTa(int,byte[])>
<com.samsung.android.authnrservice.manager.ISemAuthnrService: boolean deleteFile(java.lang.String)>
<com.samsung.android.authnrservice.manager.ISemAuthnrService: boolean setChallenge(byte[])>
<com.samsung.android.authnrservice.manager.ISemAuthnrService: byte[] getDrkKeyHandle()>
<com.samsung.android.authnrservice.manager.ISemAuthnrService: java.util.List getFiles(java.lang.String,java.lang.String)>
<com.samsung.android.authnrservice.manager.ISemAuthnrService: int getVersion()>
<com.samsung.android.authnrservice.manager.ISemAuthnrService: byte[] getWrappedObject(byte[])>
<com.samsung.android.authnrservice.manager.ISemAuthnrService: boolean terminate()>
<com.samsung.android.authnrservice.manager.ISemAuthnrService: boolean writeFile(byte[],java.lang.String)>
<com.samsung.android.authnrservice.manager.ISemAuthnrService: byte[] processWithPreloadedTa(byte[],java.lang.String)>
<com.samsung.android.authnrservice.manager.ISemAuthnrService: java.lang.String readFile(java.lang.String)>
<com.samsung.android.authnrservice.manager.ISemAuthnrService: boolean initializePreloadedTa(int)>
<com.samsung.android.authnrservice.manager.ISemAuthnrService: boolean initializeWithPreloadedTa()>
<com.samsung.android.authnrservice.manager.ISemAuthnrService: boolean terminateWithPreloadedTa()>
<android.app.admin.IDevicePolicyManager: boolean resetPasswordWithTokenMDM(android.content.ComponentName,java.lang.String,byte[],int,int)>
<android.app.admin.IDevicePolicyManager: boolean semGetAllowStorageCard(android.content.ComponentName,int)>
<android.app.admin.IDevicePolicyManager: boolean hasDelegatedPermission(java.lang.String,int,java.lang.String)>
<android.app.admin.IDevicePolicyManager: void setPasswordMinimumLowerCaseMDM(android.content.ComponentName,int,int)>
<android.app.admin.IDevicePolicyManager: void reboot(android.content.ComponentName)>
<android.app.admin.IDevicePolicyManager: boolean getSamsungSDcardEncryptionStatus(android.content.ComponentName,int)>
<android.app.admin.IDevicePolicyManager: void setCertInstallerPackage(android.content.ComponentName,java.lang.String)>
<android.app.admin.IDevicePolicyManager: int setGlobalPrivateDns(android.content.ComponentName,int,java.lang.String)>
<android.app.admin.IDevicePolicyManager: boolean setStatusBarDisabled(android.content.ComponentName,java.lang.String,boolean)>
<android.app.admin.IDevicePolicyManager: long forceNetworkLogs()>
<android.app.admin.IDevicePolicyManager: java.lang.String getDeviceOwnerName()>
<android.app.admin.IDevicePolicyManager: void clearApplicationUserData(android.content.ComponentName,java.lang.String,android.content.pm.IPackageDataObserver)>
<android.app.admin.IDevicePolicyManager: boolean isCaCertApproved(java.lang.String,int)>
<android.app.admin.IDevicePolicyManager: boolean isUsbDataSignalingEnabledForUser(int)>
<android.app.admin.IDevicePolicyManager: void semSetAllowDesktopSync(android.content.ComponentName,boolean)>
<android.app.admin.IDevicePolicyManager: boolean removeOverrideApn(android.content.ComponentName,int)>
<android.app.admin.IDevicePolicyManager: void semSetAllowBluetoothMode(android.content.ComponentName,int)>
<android.app.admin.IDevicePolicyManager: boolean isBackupServiceEnabled(android.content.ComponentName)>
<android.app.admin.IDevicePolicyManager: void setPermissionGrantState(android.content.ComponentName,java.lang.String,java.lang.String,java.lang.String,int,android.os.RemoteCallback)>
<android.app.admin.IDevicePolicyManager: java.lang.String getAlwaysOnVpnPackageForUser(int)>
<android.app.admin.IDevicePolicyManager: boolean generateKeyPair(android.content.ComponentName,java.lang.String,java.lang.String,android.security.keystore.ParcelableKeyGenParameterSpec,int,android.security.keymaster.KeymasterCertificateChain)>
<android.app.admin.IDevicePolicyManager: boolean canProfileOwnerResetPasswordWhenLocked(int)>
<android.app.admin.IDevicePolicyManager: int getDeviceOwnerType(android.content.ComponentName)>
<android.app.admin.IDevicePolicyManager: boolean isPackageAllowedToAccessCalendarForUser(java.lang.String,int)>
<android.app.admin.IDevicePolicyManager: int getLockTaskFeatures(android.content.ComponentName,java.lang.String)>
<android.app.admin.IDevicePolicyManager: boolean isStatusBarDisabled(java.lang.String)>
<android.app.admin.IDevicePolicyManager: java.util.List getBindDeviceAdminTargetUsers(android.content.ComponentName)>
<android.app.admin.IDevicePolicyManager: boolean isMeteredDataDisabledPackageForUser(android.content.ComponentName,java.lang.String,int)>
<android.app.admin.IDevicePolicyManager: boolean isAccessibilityServicePermittedByAdmin(android.content.ComponentName,java.lang.String,int)>
<android.app.admin.IDevicePolicyManager: void getRemoveWarning(android.content.ComponentName,android.os.RemoteCallback,int)>
<android.app.admin.IDevicePolicyManager: void setManagedProfileCallerIdAccessPolicy(android.app.admin.PackagePolicy)>
<android.app.admin.IDevicePolicyManager: boolean isManagedProfile(android.content.ComponentName)>
<android.app.admin.IDevicePolicyManager: android.os.Bundle getUserRestrictions(android.content.ComponentName,java.lang.String,boolean)>
<android.app.admin.IDevicePolicyManager: boolean isDeviceProvisioningConfigApplied()>
<android.app.admin.IDevicePolicyManager: boolean isLogoutEnabled()>
<android.app.admin.IDevicePolicyManager: java.lang.CharSequence getLongSupportMessage(android.content.ComponentName)>
<android.app.admin.IDevicePolicyManager: boolean isAlwaysOnVpnLockdownEnabled(android.content.ComponentName)>
<android.app.admin.IDevicePolicyManager: void setPasswordMinimumNumericMDM(android.content.ComponentName,int,int)>
<android.app.admin.IDevicePolicyManager: java.lang.CharSequence getStartUserSessionMessage(android.content.ComponentName)>
<android.app.admin.IDevicePolicyManager: void enableSystemApp(android.content.ComponentName,java.lang.String,java.lang.String)>
<android.app.admin.IDevicePolicyManager: void setDefaultSmsApplication(android.content.ComponentName,java.lang.String,java.lang.String,boolean)>
<android.app.admin.IDevicePolicyManager: boolean bindDeviceAdminServiceAsUser(android.content.ComponentName,android.app.IApplicationThread,android.os.IBinder,android.content.Intent,android.app.IServiceConnection,long,int)>
<android.app.admin.IDevicePolicyManager: void semSetAllowIrda(android.content.ComponentName,boolean)>
<android.app.admin.IDevicePolicyManager: void setCrossProfileContactsSearchDisabled(android.content.ComponentName,boolean)>
<android.app.admin.IDevicePolicyManager: void setDefaultDialerApplication(java.lang.String)>
<android.app.admin.IDevicePolicyManager: java.util.List getPreferentialNetworkServiceConfigs()>
<android.app.admin.IDevicePolicyManager: void setManagedSubscriptionsPolicy(android.app.admin.ManagedSubscriptionsPolicy)>
<android.app.admin.IDevicePolicyManager: android.app.admin.WifiSsidPolicy getWifiSsidPolicy(java.lang.String)>
<android.app.admin.IDevicePolicyManager: int stopUser(android.content.ComponentName,android.os.UserHandle)>
<android.app.admin.IDevicePolicyManager: void addCrossProfileIntentFilter(android.content.ComponentName,java.lang.String,android.content.IntentFilter,int)>
<android.app.admin.IDevicePolicyManager: int logoutUserInternal()>
<android.app.admin.IDevicePolicyManager: void setPasswordQuality(android.content.ComponentName,int,boolean)>
<android.app.admin.IDevicePolicyManager: void setSecurityLoggingEnabled(android.content.ComponentName,java.lang.String,boolean)>
<android.app.admin.IDevicePolicyManager: java.util.List getAlwaysOnVpnLockdownAllowlist(android.content.ComponentName)>
<android.app.admin.IDevicePolicyManager: java.util.List getPermittedAccessibilityServicesForUser(int)>
<android.app.admin.IDevicePolicyManager: int getOrganizationColor(android.content.ComponentName)>
<android.app.admin.IDevicePolicyManager: int getPasswordMinimumLength(android.content.ComponentName,int,boolean)>
<android.app.admin.IDevicePolicyManager: long getRequiredStrongAuthTimeout(android.content.ComponentName,int,boolean)>
<android.app.admin.IDevicePolicyManager: void clearProfileOwner(android.content.ComponentName)>
<android.app.admin.IDevicePolicyManager: void choosePrivateKeyAlias(int,android.net.Uri,java.lang.String,android.os.IBinder)>
<android.app.admin.IDevicePolicyManager: java.util.List getMeteredDataDisabledPackages(android.content.ComponentName)>
<android.app.admin.IDevicePolicyManager: void setMaximumFailedPasswordsForWipeMDM(android.content.ComponentName,int,int)>
<android.app.admin.IDevicePolicyManager: boolean getCrossProfileCallerIdDisabledForUser(int)>
<android.app.admin.IDevicePolicyManager: void setUsbDataSignalingEnabled(java.lang.String,boolean)>
<android.app.admin.IDevicePolicyManager: boolean isCallerApplicationRestrictionsManagingPackage(java.lang.String)>
<android.app.admin.IDevicePolicyManager: boolean triggerDevicePolicyEngineMigration(boolean)>
<android.app.admin.IDevicePolicyManager: void semSetPasswordMinimumSymbols(android.content.ComponentName,int)>
<android.app.admin.IDevicePolicyManager: void setUserControlDisabledPackages(android.content.ComponentName,java.lang.String,java.util.List)>
<android.app.admin.IDevicePolicyManager: void setScreenCaptureDisabled(android.content.ComponentName,java.lang.String,boolean,boolean)>
<android.app.admin.IDevicePolicyManager: boolean setPermittedInputMethods(android.content.ComponentName,java.lang.String,java.util.List,boolean)>
<android.app.admin.IDevicePolicyManager: java.lang.String getCertInstallerPackage(android.content.ComponentName)>
<android.app.admin.IDevicePolicyManager: boolean hasManagedProfileCallerIdAccess(int,java.lang.String)>
<android.app.admin.IDevicePolicyManager: void semSetAllowStorageCard(android.content.ComponentName,boolean)>
<android.app.admin.IDevicePolicyManager: boolean isUnattendedManagedKiosk()>
<android.app.admin.IDevicePolicyManager: int getPersonalAppsSuspendedReasons(android.content.ComponentName)>
<android.app.admin.IDevicePolicyManager: boolean shouldAllowBypassingDevicePolicyManagementRoleQualification()>
<android.app.admin.IDevicePolicyManager: java.lang.CharSequence getShortSupportMessageForUser(android.content.ComponentName,int)>
<android.app.admin.IDevicePolicyManager: boolean removeCrossProfileWidgetProvider(android.content.ComponentName,java.lang.String,java.lang.String)>
<android.app.admin.IDevicePolicyManager: boolean getAutoTimeRequired()>
<android.app.admin.IDevicePolicyManager: boolean semGetAllowIrda(android.content.ComponentName,int)>
<android.app.admin.IDevicePolicyManager: void setDeviceOwnerType(android.content.ComponentName,int)>
<android.app.admin.IDevicePolicyManager: java.lang.String getEnrollmentSpecificId(java.lang.String)>
<android.app.admin.IDevicePolicyManager: boolean getDoNotAskCredentialsOnBoot()>
<android.app.admin.IDevicePolicyManager: boolean isActivePasswordSufficient(java.lang.String,int,boolean)>
<android.app.admin.IDevicePolicyManager: void setCrossProfileCallerIdDisabled(android.content.ComponentName,boolean)>
<android.app.admin.IDevicePolicyManager: boolean removeKeyPair(android.content.ComponentName,java.lang.String,java.lang.String)>
<android.app.admin.IDevicePolicyManager: java.util.List getTrustAgentConfiguration(android.content.ComponentName,android.content.ComponentName,int,boolean)>
<android.app.admin.IDevicePolicyManager: android.os.Bundle getApplicationRestrictions(android.content.ComponentName,java.lang.String,java.lang.String)>
<android.app.admin.IDevicePolicyManager: void forceRemoveActiveAdmin(android.content.ComponentName,int)>
<android.app.admin.IDevicePolicyManager: void resetShouldAllowBypassingDevicePolicyManagementRoleQualificationState()>
<android.app.admin.IDevicePolicyManager: void setCrossProfileCalendarPackages(android.content.ComponentName,java.util.List)>
<android.app.admin.IDevicePolicyManager: boolean isOverrideApnEnabled(android.content.ComponentName)>
<android.app.admin.IDevicePolicyManager: int semGetAllowBluetoothMode(android.content.ComponentName,int)>
<android.app.admin.IDevicePolicyManager: void setProfileName(android.content.ComponentName,java.lang.String)>
<android.app.admin.IDevicePolicyManager: android.app.admin.SystemUpdatePolicy getSystemUpdatePolicy()>
<android.app.admin.IDevicePolicyManager: int getOrganizationColorForUser(int)>
<android.app.admin.IDevicePolicyManager: void setPermissionPolicy(android.content.ComponentName,java.lang.String,int)>
<android.app.admin.IDevicePolicyManager: void forceUpdateUserSetupComplete(int)>
<android.app.admin.IDevicePolicyManager: boolean updateOverrideApn(android.content.ComponentName,int,android.telephony.data.ApnSetting)>
<android.app.admin.IDevicePolicyManager: boolean isNewUserDisclaimerAcknowledged(int)>
<android.app.admin.IDevicePolicyManager: void reportFailedBiometricAttempt(int)>
<android.app.admin.IDevicePolicyManager: void setManagedProfileContactsAccessPolicy(android.app.admin.PackagePolicy)>
<android.app.admin.IDevicePolicyManager: boolean isUninstallInQueue(java.lang.String)>
<android.app.admin.IDevicePolicyManager: void acknowledgeNewUserDisclaimer(int)>
<android.app.admin.IDevicePolicyManager: int getPasswordMinimumLowerCase(android.content.ComponentName,int,boolean)>
<android.app.admin.IDevicePolicyManager: void setManagedProfileMaximumTimeOff(android.content.ComponentName,long)>
<android.app.admin.IDevicePolicyManager: void setShortSupportMessage(android.content.ComponentName,java.lang.String,java.lang.CharSequence)>
<android.app.admin.IDevicePolicyManager: void setPasswordMinimumLowerCase(android.content.ComponentName,int,boolean)>
<android.app.admin.IDevicePolicyManager: java.util.List getKeepUninstalledPackages(android.content.ComponentName,java.lang.String)>
<android.app.admin.IDevicePolicyManager: boolean checkDeviceIdentifierAccess(java.lang.String,int,int)>
<android.app.admin.IDevicePolicyManager: android.content.Intent createAdminSupportIntent(java.lang.String)>
<android.app.admin.IDevicePolicyManager: boolean getBluetoothContactSharingEnabledForKnox(int)>
<android.app.admin.IDevicePolicyManager: int getPasswordQuality(android.content.ComponentName,int,boolean)>
<android.app.admin.IDevicePolicyManager: void reportSuccessfulPasswordAttempt(int)>
<android.app.admin.IDevicePolicyManager: java.util.List getDelegatePackages(android.content.ComponentName,java.lang.String)>
<android.app.admin.IDevicePolicyManager: boolean isCurrentInputMethodSetByOwner()>
<android.app.admin.IDevicePolicyManager: boolean isFactoryResetProtectionPolicySupported()>
<android.app.admin.IDevicePolicyManager: boolean isAffiliatedUser(int)>
<android.app.admin.IDevicePolicyManager: void semSetPasswordMinimumLength(android.content.ComponentName,int)>
<android.app.admin.IDevicePolicyManager: void setPasswordMinimumLetters(android.content.ComponentName,int,boolean)>
<android.app.admin.IDevicePolicyManager: boolean getAutoTimeEnabled(android.content.ComponentName,java.lang.String)>
<android.app.admin.IDevicePolicyManager: void semSetAllowTextMessaging(android.content.ComponentName,boolean)>
<android.app.admin.IDevicePolicyManager: void uninstallPackageWithActiveAdmins(java.lang.String)>
<android.app.admin.IDevicePolicyManager: void setLongSupportMessage(android.content.ComponentName,java.lang.CharSequence)>
<android.app.admin.IDevicePolicyManager: java.util.List getCrossProfileCalendarPackagesForUser(int)>
<android.app.admin.IDevicePolicyManager: int getMtePolicy(java.lang.String)>
<android.app.admin.IDevicePolicyManager: int getNearbyNotificationStreamingPolicy(int)>
<android.app.admin.IDevicePolicyManager: int getLogoutUserId()>
<android.app.admin.IDevicePolicyManager: int getPasswordMinimumSymbols(android.content.ComponentName,int,boolean)>
<android.app.admin.IDevicePolicyManager: boolean isKeyPairGrantedToWifiAuth(java.lang.String,java.lang.String)>
<android.app.admin.IDevicePolicyManager: boolean setKeyguardDisabled(android.content.ComponentName,boolean)>
<android.app.admin.IDevicePolicyManager: void setPasswordMinimumLengthMDM(android.content.ComponentName,int,int)>
<android.app.admin.IDevicePolicyManager: boolean isResetPasswordTokenActive(android.content.ComponentName,java.lang.String)>
<android.app.admin.IDevicePolicyManager: boolean removeUser(android.content.ComponentName,android.os.UserHandle)>
<android.app.admin.IDevicePolicyManager: void semSetPasswordMinimumLowerCase(android.content.ComponentName,int)>
<android.app.admin.IDevicePolicyManager: android.app.admin.ManagedSubscriptionsPolicy getManagedSubscriptionsPolicy()>
<android.app.admin.IDevicePolicyManager: void setAffiliationIds(android.content.ComponentName,java.util.List)>
<android.app.admin.IDevicePolicyManager: void removeActiveAdmin(android.content.ComponentName,int)>
<android.app.admin.IDevicePolicyManager: boolean setTime(android.content.ComponentName,java.lang.String,long)>
<android.app.admin.IDevicePolicyManager: boolean semGetAllowWifi(android.content.ComponentName,int)>
<android.app.admin.IDevicePolicyManager: boolean hasKeyPair(java.lang.String,java.lang.String)>
<android.app.admin.IDevicePolicyManager: boolean isProvisioningAllowed(java.lang.String,java.lang.String)>
<android.app.admin.IDevicePolicyManager: void setUserRestriction(android.content.ComponentName,java.lang.String,java.lang.String,boolean,boolean)>
<android.app.admin.IDevicePolicyManager: android.content.ComponentName setGlobalProxy(android.content.ComponentName,java.lang.String,java.lang.String)>
<android.app.admin.IDevicePolicyManager: int getAggregatedPasswordComplexityForUser(int,boolean)>
<android.app.admin.IDevicePolicyManager: boolean getCrossProfileContactsSearchDisabledForUser(int)>
<android.app.admin.IDevicePolicyManager: void setLocationEnabled(android.content.ComponentName,boolean)>
<android.app.admin.IDevicePolicyManager: boolean semIsSimplePasswordEnabled(android.content.ComponentName,int)>
<android.app.admin.IDevicePolicyManager: void setPasswordMinimumSymbols(android.content.ComponentName,int,boolean)>
<android.app.admin.IDevicePolicyManager: boolean isApplicationHidden(android.content.ComponentName,java.lang.String,java.lang.String,boolean)>
<android.app.admin.IDevicePolicyManager: void setAutoTimeRequired(android.content.ComponentName,boolean)>
<android.app.admin.IDevicePolicyManager: void resetDefaultCrossProfileIntentFilters(int)>
<android.app.admin.IDevicePolicyManager: boolean isCommonCriteriaModeEnabled(android.content.ComponentName)>
<android.app.admin.IDevicePolicyManager: boolean resetPassword(java.lang.String,int)>
<android.app.admin.IDevicePolicyManager: void semSetAllowInternetSharing(android.content.ComponentName,boolean)>
<android.app.admin.IDevicePolicyManager: boolean setPermittedCrossProfileNotificationListeners(android.content.ComponentName,java.util.List)>
<android.app.admin.IDevicePolicyManager: void setPasswordMinimumUpperCaseMDM(android.content.ComponentName,int,int)>
<android.app.admin.IDevicePolicyManager: void clearSystemUpdatePolicyFreezePeriodRecord()>
<android.app.admin.IDevicePolicyManager: int getMinimumRequiredWifiSecurityLevel()>
<android.app.admin.IDevicePolicyManager: boolean clearResetPasswordTokenMDM(android.content.ComponentName,int)>
<android.app.admin.IDevicePolicyManager: void setPasswordMinimumUpperCase(android.content.ComponentName,int,boolean)>
<android.app.admin.IDevicePolicyManager: java.util.List getSecondaryUsers(android.content.ComponentName)>
<android.app.admin.IDevicePolicyManager: boolean getStorageEncryption(android.content.ComponentName,int)>
<android.app.admin.IDevicePolicyManager: void setEndUserSessionMessage(android.content.ComponentName,java.lang.CharSequence)>
<android.app.admin.IDevicePolicyManager: void setPasswordHistoryLengthMDM(android.content.ComponentName,int,int)>
<android.app.admin.IDevicePolicyManager: boolean isCallingUserAffiliated()>
<android.app.admin.IDevicePolicyManager: void setGlobalSetting(android.content.ComponentName,java.lang.String,java.lang.String)>
<android.app.admin.IDevicePolicyManager: void setDelegatedScopes(android.content.ComponentName,java.lang.String,java.util.List)>
<android.app.admin.IDevicePolicyManager: boolean setResetPasswordToken(android.content.ComponentName,java.lang.String,byte[])>
<android.app.admin.IDevicePolicyManager: void reportPasswordChanged(android.app.admin.PasswordMetrics,int)>
<android.app.admin.IDevicePolicyManager: boolean getCrossProfileContactsSearchDisabled(android.content.ComponentName)>
<android.app.admin.IDevicePolicyManager: boolean isOrganizationOwnedDeviceWithManagedProfile()>
<android.app.admin.IDevicePolicyManager: int getPasswordMinimumNonLetter(android.content.ComponentName,int,boolean)>
<android.app.admin.IDevicePolicyManager: int getKeyguardDisabledFeatures(android.content.ComponentName,int,boolean)>
<android.app.admin.IDevicePolicyManager: boolean isAdminActive(android.content.ComponentName,int)>
<android.app.admin.IDevicePolicyManager: android.os.UserHandle createAndManageUser(android.content.ComponentName,java.lang.String,android.content.ComponentName,android.os.PersistableBundle,int)>
<android.app.admin.IDevicePolicyManager: java.util.List getAllCrossProfilePackages(int)>
<android.app.admin.IDevicePolicyManager: void setBluetoothContactSharingEnabledForKnox(int,boolean)>
<android.app.admin.IDevicePolicyManager: java.util.List getDefaultCrossProfilePackages()>
<android.app.admin.IDevicePolicyManager: void setDpcDownloaded(boolean)>
<android.app.admin.IDevicePolicyManager: boolean getAutoTimeZoneEnabled(android.content.ComponentName,java.lang.String)>
<android.app.admin.IDevicePolicyManager: void setLockTaskPackages(android.content.ComponentName,java.lang.String,java.lang.String[])>
<android.app.admin.IDevicePolicyManager: void setPasswordMinimumSymbolsMDM(android.content.ComponentName,int,int)>
<android.app.admin.IDevicePolicyManager: boolean hasGrantedPolicy(android.content.ComponentName,int,int)>
<android.app.admin.IDevicePolicyManager: java.util.List getCrossProfileWidgetProviders(android.content.ComponentName,java.lang.String)>
<android.app.admin.IDevicePolicyManager: boolean isLockTaskPermitted(java.lang.String)>
<android.app.admin.IDevicePolicyManager: boolean isRemovingAdmin(android.content.ComponentName,int)>
<android.app.admin.IDevicePolicyManager: java.lang.String getFinancedDeviceKioskRoleHolder(java.lang.String)>
<android.app.admin.IDevicePolicyManager: void setLockTaskFeatures(android.content.ComponentName,java.lang.String,int)>
<android.app.admin.IDevicePolicyManager: int[] getApplicationExemptions(java.lang.String)>
<android.app.admin.IDevicePolicyManager: android.content.ComponentName getRestrictionsProvider(int)>
<android.app.admin.IDevicePolicyManager: boolean resetPasswordWithToken(android.content.ComponentName,java.lang.String,java.lang.String,byte[],int)>
<android.app.admin.IDevicePolicyManager: void semSetPasswordHistoryLength(android.content.ComponentName,int)>
<android.app.admin.IDevicePolicyManager: int getPasswordMinimumNumeric(android.content.ComponentName,int,boolean)>
<android.app.admin.IDevicePolicyManager: int addOverrideApn(android.content.ComponentName,android.telephony.data.ApnSetting)>
<android.app.admin.IDevicePolicyManager: java.lang.String[] getAccountTypesWithManagementDisabled(java.lang.String)>
<android.app.admin.IDevicePolicyManager: boolean isSafeOperation(int)>
<android.app.admin.IDevicePolicyManager: android.content.pm.ParceledListSlice retrieveSecurityLogs(android.content.ComponentName,java.lang.String)>
<android.app.admin.IDevicePolicyManager: android.app.admin.ParcelableGranteeMap getKeyPairGrants(java.lang.String,java.lang.String)>
<android.app.admin.IDevicePolicyManager: void setNextOperationSafety(int,int)>
<android.app.admin.IDevicePolicyManager: java.lang.CharSequence getLongSupportMessageForUser(android.content.ComponentName,int)>
<android.app.admin.IDevicePolicyManager: void setPasswordMinimumNumeric(android.content.ComponentName,int,boolean)>
<android.app.admin.IDevicePolicyManager: void setAutoTimeZoneEnabled(android.content.ComponentName,java.lang.String,boolean)>
<android.app.admin.IDevicePolicyManager: long getLastSecurityLogRetrievalTime()>
<android.app.admin.IDevicePolicyManager: long getPasswordExpirationTimeout(android.content.ComponentName,int,boolean)>
<android.app.admin.IDevicePolicyManager: void setActiveAdmin(android.content.ComponentName,boolean,int)>
<android.app.admin.IDevicePolicyManager: void setNetworkLoggingEnabled(android.content.ComponentName,java.lang.String,boolean)>
<android.app.admin.IDevicePolicyManager: java.lang.String getProfileOwnerName(int)>
<android.app.admin.IDevicePolicyManager: boolean setDeviceOwner(android.content.ComponentName,int,boolean)>
<android.app.admin.IDevicePolicyManager: java.lang.String[] getAccountTypesWithManagementDisabledAsUser(int,java.lang.String,boolean)>
<android.app.admin.IDevicePolicyManager: boolean setKeyGrantForApp(android.content.ComponentName,java.lang.String,java.lang.String,java.lang.String,boolean)>
<android.app.admin.IDevicePolicyManager: boolean semIsActivePasswordSufficient(int)>
<android.app.admin.IDevicePolicyManager: void setTrustAgentConfiguration(android.content.ComponentName,java.lang.String,android.content.ComponentName,android.os.PersistableBundle,boolean)>
<android.app.admin.IDevicePolicyManager: void clearCrossProfileIntentFilters(android.content.ComponentName,java.lang.String)>
<android.app.admin.IDevicePolicyManager: void reportSuccessfulBiometricAttempt(int)>
<android.app.admin.IDevicePolicyManager: boolean installCaCert(android.content.ComponentName,java.lang.String,byte[])>
<android.app.admin.IDevicePolicyManager: java.lang.String getActualDeviceOwnerMDM()>
<android.app.admin.IDevicePolicyManager: void setUserRestrictionGlobally(java.lang.String,java.lang.String)>
<android.app.admin.IDevicePolicyManager: int getPasswordMinimumUpperCase(android.content.ComponentName,int,boolean)>
<android.app.admin.IDevicePolicyManager: void setCrossProfilePackages(android.content.ComponentName,java.util.List)>
<android.app.admin.IDevicePolicyManager: java.util.List listPolicyExemptApps()>
<android.app.admin.IDevicePolicyManager: boolean isComplianceAcknowledgementRequired()>
<android.app.admin.IDevicePolicyManager: void clearCrossProfileIntentFiltersMDM(android.content.ComponentName,int)>
<android.app.admin.IDevicePolicyManager: java.util.List retrieveNetworkLogs(android.content.ComponentName,java.lang.String,long)>
<android.app.admin.IDevicePolicyManager: int getPermissionPolicy(android.content.ComponentName)>
<android.app.admin.IDevicePolicyManager: int getGlobalPrivateDnsMode(android.content.ComponentName)>
<android.app.admin.IDevicePolicyManager: int enableSystemAppWithIntent(android.content.ComponentName,java.lang.String,android.content.Intent)>
<android.app.admin.IDevicePolicyManager: void enforceCanManageCaCerts(android.content.ComponentName,java.lang.String)>
<android.app.admin.IDevicePolicyManager: java.util.List setMeteredDataDisabledPackages(android.content.ComponentName,java.util.List)>
<android.app.admin.IDevicePolicyManager: boolean semGetAllowDesktopSync(android.content.ComponentName,int)>
<android.app.admin.IDevicePolicyManager: void setAutoTimeEnabled(android.content.ComponentName,java.lang.String,boolean)>
<android.app.admin.IDevicePolicyManager: java.lang.CharSequence getEndUserSessionMessage(android.content.ComponentName)>
<android.app.admin.IDevicePolicyManager: android.os.Bundle getUserRestrictionsGlobally(java.lang.String)>
<android.app.admin.IDevicePolicyManager: void setPasswordQualityMDM(android.content.ComponentName,int,int)>
<android.app.admin.IDevicePolicyManager: void setCommonCriteriaModeEnabled(android.content.ComponentName,java.lang.String,boolean)>
<android.app.admin.IDevicePolicyManager: void setApplicationExemptions(java.lang.String,java.lang.String,int[])>
<android.app.admin.IDevicePolicyManager: void setStrings(java.util.List)>
<android.app.admin.IDevicePolicyManager: void finalizeWorkProfileProvisioning(android.os.UserHandle,android.accounts.Account)>
<android.app.admin.IDevicePolicyManager: boolean isSupervisionComponent(android.content.ComponentName)>
<android.app.admin.IDevicePolicyManager: void setPasswordMinimumLettersMDM(android.content.ComponentName,int,int)>
<android.app.admin.IDevicePolicyManager: void setPreferentialNetworkServiceConfigs(java.util.List)>
<android.app.admin.IDevicePolicyManager: void calculateHasIncompatibleAccounts()>
<android.app.admin.IDevicePolicyManager: java.util.List getCrossProfileCalendarPackages(android.content.ComponentName)>
<android.app.admin.IDevicePolicyManager: void setSecondaryLockscreenEnabled(android.content.ComponentName,boolean)>
<android.app.admin.IDevicePolicyManager: boolean setResetPasswordTokenMDM(android.content.ComponentName,byte[],int)>
<android.app.admin.IDevicePolicyManager: boolean isActivePasswordSufficientForDeviceRequirement()>
<android.app.admin.IDevicePolicyManager: int startUserInBackground(android.content.ComponentName,android.os.UserHandle)>
<android.app.admin.IDevicePolicyManager: boolean getBluetoothContactSharingDisabledForUser(int)>
<android.app.admin.IDevicePolicyManager: boolean getBluetoothContactSharingDisabled(android.content.ComponentName)>
<android.app.admin.IDevicePolicyManager: void resetStrings(java.util.List)>
<android.app.admin.IDevicePolicyManager: java.util.List getPermittedCrossProfileNotificationListeners(android.content.ComponentName)>
<android.app.admin.IDevicePolicyManager: android.app.admin.DevicePolicyState getDevicePolicyState()>
<android.app.admin.IDevicePolicyManager: android.app.admin.PackagePolicy getManagedProfileCallerIdAccessPolicy()>
<android.app.admin.IDevicePolicyManager: void lockNow(int,java.lang.String,boolean)>
<android.app.admin.IDevicePolicyManager: void semSetPasswordMinimumNonLetter(android.content.ComponentName,int)>
<android.app.admin.IDevicePolicyManager: void startManagedQuickContact(java.lang.String,long,boolean,long,android.content.Intent)>
<android.app.admin.IDevicePolicyManager: int getMaximumFailedPasswordsForWipe(android.content.ComponentName,int,boolean)>
<android.app.admin.IDevicePolicyManager: boolean getCrossProfileCallerIdDisabled(android.content.ComponentName)>
<android.app.admin.IDevicePolicyManager: int getCurrentFailedBiometricAttempts(int)>
<android.app.admin.IDevicePolicyManager: boolean isDeviceFinanced(java.lang.String)>
<android.app.admin.IDevicePolicyManager: boolean setProfileOwner(android.content.ComponentName,int)>
<android.app.admin.IDevicePolicyManager: void sendLostModeLocationUpdate(com.android.internal.infra.AndroidFuture)>
<android.app.admin.IDevicePolicyManager: boolean canAdminGrantSensorsPermissions()>
<android.app.admin.IDevicePolicyManager: java.util.List listForegroundAffiliatedUsers()>
<android.app.admin.IDevicePolicyManager: android.content.pm.ParceledListSlice retrievePreRebootSecurityLogs(android.content.ComponentName,java.lang.String)>
<android.app.admin.IDevicePolicyManager: void semSetPasswordMinimumUpperCase(android.content.ComponentName,int)>
<android.app.admin.IDevicePolicyManager: java.util.List getUserControlDisabledPackages(android.content.ComponentName,java.lang.String)>
<android.app.admin.IDevicePolicyManager: void setKeyguardDisabledFeatures(android.content.ComponentName,java.lang.String,int,boolean)>
<android.app.admin.IDevicePolicyManager: int logoutUser(android.content.ComponentName)>
<android.app.admin.IDevicePolicyManager: void semSetChangeNotificationEnabled(android.content.ComponentName,boolean)>
<android.app.admin.IDevicePolicyManager: boolean isSecondaryLockscreenEnabled(android.os.UserHandle)>
<android.app.admin.IDevicePolicyManager: void semSetAllowPopImapEmail(android.content.ComponentName,boolean)>
<android.app.admin.IDevicePolicyManager: boolean getCameraDisabled(android.content.ComponentName,java.lang.String,int,boolean)>
<android.app.admin.IDevicePolicyManager: void semSetPasswordMinimumNumeric(android.content.ComponentName,int)>
<android.app.admin.IDevicePolicyManager: int getPermissionGrantState(android.content.ComponentName,java.lang.String,java.lang.String,java.lang.String)>
<android.app.admin.IDevicePolicyManager: java.util.List getPolicyManagedProfiles(android.os.UserHandle)>
<android.app.admin.IDevicePolicyManager: android.app.admin.SystemUpdateInfo getPendingSystemUpdate(android.content.ComponentName)>
<android.app.admin.IDevicePolicyManager: java.util.List getActiveAdmins(int)>
<android.app.admin.IDevicePolicyManager: void setMaximumTimeToLock(android.content.ComponentName,java.lang.String,long,boolean)>
<android.app.admin.IDevicePolicyManager: void setUserRestrictionForKnox(android.content.ComponentName,java.lang.String,boolean,int)>
<android.app.admin.IDevicePolicyManager: void setSystemUpdatePolicy(android.content.ComponentName,java.lang.String,android.app.admin.SystemUpdatePolicy)>
<android.app.admin.IDevicePolicyManager: long getLastNetworkLogRetrievalTime()>
<android.app.admin.IDevicePolicyManager: boolean setApplicationRestrictionsManagingPackage(android.content.ComponentName,java.lang.String)>
<android.app.admin.IDevicePolicyManager: void addCrossProfileIntentFilterMDM(android.content.ComponentName,android.content.IntentFilter,int,int)>
<android.app.admin.IDevicePolicyManager: int getPasswordMinimumLetters(android.content.ComponentName,int,boolean)>
<android.app.admin.IDevicePolicyManager: void setForceEphemeralUsers(android.content.ComponentName,boolean)>
<android.app.admin.IDevicePolicyManager: boolean addCrossProfileWidgetProvider(android.content.ComponentName,java.lang.String,java.lang.String)>
<android.app.admin.IDevicePolicyManager: void setMaximumTimeToLockMDM(android.content.ComponentName,long,int)>
<android.app.admin.IDevicePolicyManager: long forceSecurityLogs()>
<android.app.admin.IDevicePolicyManager: android.app.admin.ParcelableResource getString(java.lang.String)>
<android.app.admin.IDevicePolicyManager: boolean setAlwaysOnVpnPackage(android.content.ComponentName,java.lang.String,boolean,java.util.List)>
<android.app.admin.IDevicePolicyManager: android.app.admin.PasswordMetrics getPasswordMinimumMetrics(int,boolean)>
<android.app.admin.IDevicePolicyManager: boolean isMasterVolumeMuted(android.content.ComponentName)>
<android.app.admin.IDevicePolicyManager: void notifyLockTaskModeChanged(boolean,java.lang.String,int)>
<android.app.admin.IDevicePolicyManager: void setMasterVolumeMuted(android.content.ComponentName,boolean)>
<android.app.admin.IDevicePolicyManager: void setDrawables(java.util.List)>
<android.app.admin.IDevicePolicyManager: void setLogoutEnabled(android.content.ComponentName,boolean)>
<android.app.admin.IDevicePolicyManager: void setPasswordExpirationTimeout(android.content.ComponentName,java.lang.String,long,boolean)>
<android.app.admin.IDevicePolicyManager: android.content.ComponentName getProfileOwnerOrDeviceOwnerSupervisionComponent(android.os.UserHandle)>
<android.app.admin.IDevicePolicyManager: java.util.List getPermittedAccessibilityServices(android.content.ComponentName)>
<android.app.admin.IDevicePolicyManager: void provisionFullyManagedDevice(android.app.admin.FullyManagedDeviceProvisioningParams,java.lang.String)>
<android.app.admin.IDevicePolicyManager: android.os.UserHandle createAndProvisionManagedProfile(android.app.admin.ManagedProfileProvisioningParams,java.lang.String)>
<android.app.admin.IDevicePolicyManager: android.os.Bundle getApplicationRestrictionsMDM(android.content.ComponentName,java.lang.String,int)>
<android.app.admin.IDevicePolicyManager: boolean packageHasActiveAdmins(java.lang.String,int)>
<android.app.admin.IDevicePolicyManager: void setRestrictionsProvider(android.content.ComponentName,android.content.ComponentName)>
<android.app.admin.IDevicePolicyManager: boolean getForceEphemeralUsers(android.content.ComponentName)>
<android.app.admin.IDevicePolicyManager: void setDeviceOwnerLockScreenInfo(android.content.ComponentName,java.lang.CharSequence)>
<android.app.admin.IDevicePolicyManager: void setRequiredStrongAuthTimeout(android.content.ComponentName,java.lang.String,long,boolean)>
<android.app.admin.IDevicePolicyManager: java.util.List getCrossProfilePackages(android.content.ComponentName)>
<android.app.admin.IDevicePolicyManager: boolean isPasswordSufficientAfterProfileUnification(int,int)>
<android.app.admin.IDevicePolicyManager: boolean hasLockdownAdminConfiguredNetworks(android.content.ComponentName)>
<android.app.admin.IDevicePolicyManager: boolean setTimeZone(android.content.ComponentName,java.lang.String,java.lang.String)>
<android.app.admin.IDevicePolicyManager: boolean hasManagedProfileContactsAccess(int,java.lang.String)>
<android.app.admin.IDevicePolicyManager: void notifyPendingSystemUpdate(android.app.admin.SystemUpdateInfo)>
<android.app.admin.IDevicePolicyManager: void setPasswordMinimumLength(android.content.ComponentName,int,boolean)>
<android.app.admin.IDevicePolicyManager: void uninstallCaCerts(android.content.ComponentName,java.lang.String,java.lang.String[])>
<android.app.admin.IDevicePolicyManager: void clearOrganizationIdForUser(int)>
<android.app.admin.IDevicePolicyManager: java.lang.CharSequence getShortSupportMessage(android.content.ComponentName,java.lang.String)>
<android.app.admin.IDevicePolicyManager: java.lang.String getWifiMacAddress(android.content.ComponentName,java.lang.String)>
<android.app.admin.IDevicePolicyManager: void setNearbyNotificationStreamingPolicy(int)>
<android.app.admin.IDevicePolicyManager: void setPasswordExpirationTimeoutMDM(android.content.ComponentName,long,int)>
<android.app.admin.IDevicePolicyManager: java.lang.CharSequence getDeviceOwnerOrganizationName()>
<android.app.admin.IDevicePolicyManager: android.app.admin.FactoryResetProtectionPolicy getFactoryResetProtectionPolicy(android.content.ComponentName)>
<android.app.admin.IDevicePolicyManager: boolean semGetRequireStorageCardEncryption(android.content.ComponentName,int,boolean)>
<android.app.admin.IDevicePolicyManager: android.content.ComponentName getGlobalProxyAdmin(int)>
<android.app.admin.IDevicePolicyManager: void setNearbyAppStreamingPolicy(int)>
<android.app.admin.IDevicePolicyManager: void setBackupServiceEnabled(android.content.ComponentName,boolean)>
<android.app.admin.IDevicePolicyManager: boolean semGetAllowBrowser(android.content.ComponentName,int)>
<android.app.admin.IDevicePolicyManager: void semSetPasswordQuality(android.content.ComponentName,int)>
<android.app.admin.IDevicePolicyManager: java.lang.String getApplicationRestrictionsManagingPackage(android.content.ComponentName)>
<android.app.admin.IDevicePolicyManager: void setPasswordHistoryLength(android.content.ComponentName,int,boolean)>
<android.app.admin.IDevicePolicyManager: void setSecureSetting(android.content.ComponentName,java.lang.String,java.lang.String)>
<android.app.admin.IDevicePolicyManager: android.os.Bundle getEnforcingAdminAndUserDetails(int,java.lang.String)>
<android.app.admin.IDevicePolicyManager: java.lang.String getAlwaysOnVpnPackage(android.content.ComponentName)>
<android.app.admin.IDevicePolicyManager: int getStorageEncryptionStatus(java.lang.String,int)>
<android.app.admin.IDevicePolicyManager: boolean isInputMethodPermittedByAdmin(android.content.ComponentName,java.lang.String,int,boolean)>
<android.app.admin.IDevicePolicyManager: void setWifiSsidPolicy(java.lang.String,android.app.admin.WifiSsidPolicy)>
<android.app.admin.IDevicePolicyManager: void setOverrideApnsEnabled(android.content.ComponentName,boolean)>
<android.app.admin.IDevicePolicyManager: void semSetAllowWifi(android.content.ComponentName,boolean)>
<android.app.admin.IDevicePolicyManager: void setFactoryResetProtectionPolicy(android.content.ComponentName,java.lang.String,android.app.admin.FactoryResetProtectionPolicy)>
<android.app.admin.IDevicePolicyManager: void semSetPasswordExpirationTimeout(android.content.ComponentName,long)>
<android.app.admin.IDevicePolicyManager: void setApplicationRestrictionsMDM(android.content.ComponentName,java.lang.String,android.os.Bundle,int)>
<android.app.admin.IDevicePolicyManager: boolean switchUser(android.content.ComponentName,android.os.UserHandle)>
<android.app.admin.IDevicePolicyManager: boolean setKeyGrantToWifiAuth(java.lang.String,java.lang.String,boolean)>
<android.app.admin.IDevicePolicyManager: boolean isPackageSuspended(android.content.ComponentName,java.lang.String,java.lang.String)>
<android.app.admin.IDevicePolicyManager: boolean hasUserSetupCompleted()>
<android.app.admin.IDevicePolicyManager: void setKeepUninstalledPackages(android.content.ComponentName,java.lang.String,java.util.List)>
<android.app.admin.IDevicePolicyManager: void setBluetoothContactSharingDisabled(android.content.ComponentName,boolean)>
<android.app.admin.IDevicePolicyManager: int getProfileWithMinimumFailedPasswordsForWipe(int,boolean)>
<android.app.admin.IDevicePolicyManager: void resetDrawables(java.util.List)>
<android.app.admin.IDevicePolicyManager: boolean setKeyPairCertificate(android.content.ComponentName,java.lang.String,java.lang.String,byte[],byte[],boolean)>
<android.app.admin.IDevicePolicyManager: void setCameraDisabled(android.content.ComponentName,java.lang.String,boolean,boolean)>
<android.app.admin.IDevicePolicyManager: void setConfiguredNetworksLockdownState(android.content.ComponentName,java.lang.String,boolean)>
<android.app.admin.IDevicePolicyManager: boolean isEphemeralUser(android.content.ComponentName)>
<android.app.admin.IDevicePolicyManager: void setUserIcon(android.content.ComponentName,android.graphics.Bitmap)>
<android.app.admin.IDevicePolicyManager: java.lang.CharSequence getDeviceOwnerLockScreenInfo()>
<android.app.admin.IDevicePolicyManager: void setKeyguardDisabledFeaturesMDM(android.content.ComponentName,int,int)>
<android.app.admin.IDevicePolicyManager: long getPasswordExpiration(android.content.ComponentName,int,boolean)>
<android.app.admin.IDevicePolicyManager: int getPasswordComplexity(boolean)>
<android.app.admin.IDevicePolicyManager: android.content.ComponentName getDeviceOwnerComponent(boolean)>
<android.app.admin.IDevicePolicyManager: void setTrustAgentConfigurationMDM(int,android.content.ComponentName,android.content.ComponentName,android.os.PersistableBundle)>
<android.app.admin.IDevicePolicyManager: void setRecommendedGlobalProxy(android.content.ComponentName,android.net.ProxyInfo)>
<android.app.admin.IDevicePolicyManager: void setUninstallBlocked(android.content.ComponentName,java.lang.String,java.lang.String,boolean)>
<android.app.admin.IDevicePolicyManager: boolean isUsingUnifiedPassword(android.content.ComponentName)>
<android.app.admin.IDevicePolicyManager: void reportKeyguardDismissed(int)>
<android.app.admin.IDevicePolicyManager: int getNearbyAppStreamingPolicy(int)>
<android.app.admin.IDevicePolicyManager: void setOrganizationColor(android.content.ComponentName,int)>
<android.app.admin.IDevicePolicyManager: boolean isNetworkLoggingEnabled(android.content.ComponentName,java.lang.String)>
<android.app.admin.IDevicePolicyManager: java.util.List getDisallowedSystemApps(android.content.ComponentName,int,java.lang.String)>
<android.app.admin.IDevicePolicyManager: java.lang.CharSequence getOrganizationName(android.content.ComponentName,java.lang.String)>
<android.app.admin.IDevicePolicyManager: boolean isResetPasswordTokenActiveMDM(android.content.ComponentName,int)>
<android.app.admin.IDevicePolicyManager: java.util.List getAffiliationIds(android.content.ComponentName)>
<android.app.admin.IDevicePolicyManager: java.util.List getDelegatedScopes(android.content.ComponentName,java.lang.String)>
<android.app.admin.IDevicePolicyManager: java.lang.String getGlobalPrivateDnsHost(android.content.ComponentName)>
<android.app.admin.IDevicePolicyManager: boolean isAlwaysOnVpnLockdownEnabledForUser(int)>
<android.app.admin.IDevicePolicyManager: android.os.PersistableBundle getTransferOwnershipBundle()>
<android.app.admin.IDevicePolicyManager: void setMinimumRequiredWifiSecurityLevel(java.lang.String,int)>
<android.app.admin.IDevicePolicyManager: java.util.List getPermittedInputMethodsAsUser(int)>
<android.app.admin.IDevicePolicyManager: void wipeDataWithReason(java.lang.String,int,java.lang.String,boolean,boolean)>
<android.app.admin.IDevicePolicyManager: void reportFailedPasswordAttempt(int,boolean)>
<android.app.admin.IDevicePolicyManager: void setOrganizationIdForUser(java.lang.String,java.lang.String,int)>
<android.app.admin.IDevicePolicyManager: java.util.List getPermittedInputMethods(android.content.ComponentName,java.lang.String,boolean)>
<android.app.admin.IDevicePolicyManager: void setPersonalAppsSuspended(android.content.ComponentName,boolean)>
<android.app.admin.IDevicePolicyManager: boolean isProfileOwnerOfOrganizationOwnedDeviceMDM(int)>
<android.app.admin.IDevicePolicyManager: void setStartUserSessionMessage(android.content.ComponentName,java.lang.CharSequence)>
<android.app.admin.IDevicePolicyManager: android.app.admin.PackagePolicy getCredentialManagerPolicy(int)>
<android.app.admin.IDevicePolicyManager: android.app.admin.ParcelableResource getDrawable(java.lang.String,java.lang.String,java.lang.String)>
<android.app.admin.IDevicePolicyManager: boolean isDeviceProvisioned()>
<android.app.admin.IDevicePolicyManager: android.content.pm.StringParceledListSlice getOwnerInstalledCaCerts(android.os.UserHandle)>
<android.app.admin.IDevicePolicyManager: boolean installKeyPair(android.content.ComponentName,java.lang.String,byte[],byte[],byte[],java.lang.String,boolean,boolean)>
<android.app.admin.IDevicePolicyManager: boolean rebootMDM(java.lang.String)>
<android.app.admin.IDevicePolicyManager: void semSetKeyguardDisabledFeatures(android.content.ComponentName,int)>
<android.app.admin.IDevicePolicyManager: void setCredentialManagerPolicy(android.app.admin.PackagePolicy)>
<android.app.admin.IDevicePolicyManager: boolean isUninstallBlocked(java.lang.String)>
<android.app.admin.IDevicePolicyManager: boolean isNotificationListenerServicePermitted(java.lang.String,int)>
<android.app.admin.IDevicePolicyManager: void semSetPasswordMinimumLetters(android.content.ComponentName,int)>
<android.app.admin.IDevicePolicyManager: boolean semGetAllowInternetSharing(android.content.ComponentName,int)>
<android.app.admin.IDevicePolicyManager: java.lang.CharSequence getOrganizationNameForUser(int)>
<android.app.admin.IDevicePolicyManager: void setSystemSetting(android.content.ComponentName,java.lang.String,java.lang.String)>
<android.app.admin.IDevicePolicyManager: boolean setPermittedAccessibilityServices(android.content.ComponentName,java.util.List)>
<android.app.admin.IDevicePolicyManager: boolean isManagedKiosk()>
<android.app.admin.IDevicePolicyManager: boolean requestBugreport(android.content.ComponentName)>
<android.app.admin.IDevicePolicyManager: void setOrganizationName(android.content.ComponentName,java.lang.String,java.lang.CharSequence)>
<android.app.admin.IDevicePolicyManager: java.lang.String[] getLockTaskPackages(android.content.ComponentName,java.lang.String)>
<android.app.admin.IDevicePolicyManager: void reportKeyguardSecured(int)>
<android.app.admin.IDevicePolicyManager: java.util.List getOverrideApns(android.content.ComponentName)>
<android.app.admin.IDevicePolicyManager: boolean semGetAllowTextMessaging(android.content.ComponentName,int)>
<android.app.admin.IDevicePolicyManager: int getUserProvisioningState(int)>
<android.app.admin.IDevicePolicyManager: void transferOwnership(android.content.ComponentName,android.content.ComponentName,android.os.PersistableBundle)>
<android.app.admin.IDevicePolicyManager: void setProfileEnabled(android.content.ComponentName)>
<android.app.admin.IDevicePolicyManager: void addPersistentPreferredActivity(android.content.ComponentName,java.lang.String,android.content.IntentFilter,android.content.ComponentName)>
<android.app.admin.IDevicePolicyManager: boolean isDpcDownloaded()>
<android.app.admin.IDevicePolicyManager: long getMaximumTimeToLock(android.content.ComponentName,int,boolean)>
<android.app.admin.IDevicePolicyManager: int getPasswordHistoryLength(android.content.ComponentName,int,boolean)>
<android.app.admin.IDevicePolicyManager: void setOrganizationColorForUser(int,int)>
<android.app.admin.IDevicePolicyManager: int getRequiredPasswordComplexity(java.lang.String,boolean)>
<android.app.admin.IDevicePolicyManager: boolean getScreenCaptureDisabled(android.content.ComponentName,int,boolean)>
<android.app.admin.IDevicePolicyManager: long getManagedProfileMaximumTimeOff(android.content.ComponentName)>
<android.app.admin.IDevicePolicyManager: void acknowledgeDeviceCompliant()>
<android.app.admin.IDevicePolicyManager: boolean isSecurityLoggingEnabled(android.content.ComponentName,java.lang.String)>
<android.app.admin.IDevicePolicyManager: void semSetRequireStorageCardEncryption(android.content.ComponentName,boolean,boolean)>
<android.app.admin.IDevicePolicyManager: void setPasswordMinimumNonLetter(android.content.ComponentName,int,boolean)>
<android.app.admin.IDevicePolicyManager: void semSetSimplePasswordEnabled(android.content.ComponentName,boolean)>
<android.app.admin.IDevicePolicyManager: android.content.ComponentName getProfileOwnerAsUser(int)>
<android.app.admin.IDevicePolicyManager: int setStorageEncryption(android.content.ComponentName,boolean)>
<android.app.admin.IDevicePolicyManager: android.app.admin.PackagePolicy getManagedProfileContactsAccessPolicy()>
<android.app.admin.IDevicePolicyManager: void setMtePolicy(int,java.lang.String)>
<android.app.admin.IDevicePolicyManager: boolean isUsbDataSignalingEnabled(java.lang.String)>
<android.app.admin.IDevicePolicyManager: boolean setApplicationHidden(android.content.ComponentName,java.lang.String,java.lang.String,boolean,boolean)>
<android.app.admin.IDevicePolicyManager: void setPasswordMinimumNonLetterMDM(android.content.ComponentName,int,int)>
<android.app.admin.IDevicePolicyManager: void setAccountManagementDisabled(android.content.ComponentName,java.lang.String,java.lang.String,boolean,boolean)>
<android.app.admin.IDevicePolicyManager: boolean installExistingPackage(android.content.ComponentName,java.lang.String,java.lang.String)>
<android.app.admin.IDevicePolicyManager: void semSetCameraDisabled(android.content.ComponentName,boolean)>
<android.app.admin.IDevicePolicyManager: int checkProvisioningPrecondition(java.lang.String,java.lang.String)>
<android.app.admin.IDevicePolicyManager: long getLastBugReportRequestTime()>
<android.app.admin.IDevicePolicyManager: boolean clearResetPasswordToken(android.content.ComponentName,java.lang.String)>
<android.app.admin.IDevicePolicyManager: void setDeviceProvisioningConfigApplied()>
<android.app.admin.IDevicePolicyManager: void setMaximumFailedPasswordsForWipe(android.content.ComponentName,java.lang.String,int,boolean)>
<android.app.admin.IDevicePolicyManager: boolean hasDeviceOwner()>
<android.app.admin.IDevicePolicyManager: int getCurrentFailedPasswordAttempts(java.lang.String,int,boolean)>
<android.app.admin.IDevicePolicyManager: void semSetAllowBrowser(android.content.ComponentName,boolean)>
<android.app.admin.IDevicePolicyManager: void installUpdateFromFile(android.content.ComponentName,java.lang.String,android.os.ParcelFileDescriptor,android.app.admin.StartInstallingUpdateCallback)>
<android.app.admin.IDevicePolicyManager: void setApplicationRestrictions(android.content.ComponentName,java.lang.String,java.lang.String,android.os.Bundle)>
<android.app.admin.IDevicePolicyManager: void clearPackagePersistentPreferredActivities(android.content.ComponentName,java.lang.String,java.lang.String)>
<android.app.admin.IDevicePolicyManager: boolean semGetAllowPopImapEmail(android.content.ComponentName,int)>
<android.app.admin.IDevicePolicyManager: int getDeviceOwnerUserId()>
<android.app.admin.IDevicePolicyManager: java.lang.String[] setPackagesSuspended(android.content.ComponentName,java.lang.String,java.lang.String[],boolean)>
<android.app.admin.IDevicePolicyManager: void setProfileOwnerOnOrganizationOwnedDevice(android.content.ComponentName,int,boolean)>
<android.app.admin.IDevicePolicyManager: void clearDeviceOwner(java.lang.String)>
<android.app.admin.IDevicePolicyManager: boolean canUsbDataSignalingBeDisabled()>
<android.app.admin.IDevicePolicyManager: boolean approveCaCert(java.lang.String,int,boolean)>
<android.app.admin.IDevicePolicyManager: boolean startViewCalendarEventInManagedProfile(java.lang.String,long,long,long,boolean,int)>
<android.app.admin.IDevicePolicyManager: void setRequiredPasswordComplexity(java.lang.String,int,boolean)>
<android.app.admin.IDevicePolicyManager: void setUserProvisioningState(int,int)>
<android.app.admin.IDevicePolicyManager: void setOverrideKeepProfilesRunning(boolean)>
<com.android.internal.app.IVoiceInteractionSessionListener: void onVoiceSessionHidden()>
<com.android.internal.app.IVoiceInteractionSessionListener: void onSetUiHints(android.os.Bundle)>
<com.android.internal.app.IVoiceInteractionSessionListener: void onVoiceSessionShown()>
<com.android.internal.app.IVoiceInteractionSessionListener: void onVoiceSessionWindowVisibilityChanged(boolean)>
<com.android.ims.internal.IImsService: void setUiTTYMode(int,int,android.os.Message)>
<com.android.ims.internal.IImsService: int open(int,int,android.app.PendingIntent,com.android.ims.internal.IImsRegistrationListener)>
<com.android.ims.internal.IImsService: void setSmsListener(int,android.telephony.ims.aidl.IImsSmsListener)>
<com.android.ims.internal.IImsService: android.telephony.ims.ImsCallProfile createCallProfile(int,int,int)>
<com.android.ims.internal.IImsService: void close(int)>
<com.android.ims.internal.IImsService: void setTtyMode(int,int)>
<com.android.ims.internal.IImsService: int stopLocalRingBackTone()>
<com.android.ims.internal.IImsService: com.android.ims.internal.IImsCallSession getPendingCallSession(int,java.lang.String)>
<com.android.ims.internal.IImsService: void acknowledgeSmsReport(int,int,int,int)>
<com.android.ims.internal.IImsService: void acknowledgeSmsWithPdu(int,int,int,byte[])>
<com.android.ims.internal.IImsService: java.lang.String getTrn(java.lang.String,java.lang.String)>
<com.android.ims.internal.IImsService: com.android.ims.internal.IImsUt getUtInterface(int)>
<com.android.ims.internal.IImsService: boolean isCmcEmergencyCallSupported(int)>
<com.android.ims.internal.IImsService: void setSmsc(int,java.lang.String)>
<com.android.ims.internal.IImsService: com.android.ims.internal.IImsEcbm getEcbmInterface(int)>
<com.android.ims.internal.IImsService: int getE911CallCount(int)>
<com.android.ims.internal.IImsService: void removeImsFeature(int,int)>
<com.android.ims.internal.IImsService: void sendSms(int,int,int,java.lang.String,java.lang.String,boolean,byte[])>
<com.android.ims.internal.IImsService: void addRegistrationListener(int,int,com.android.ims.internal.IImsRegistrationListener)>
<com.android.ims.internal.IImsService: boolean isConnected(int,int,int)>
<com.android.ims.internal.IImsService: void setVideoCrtAudio(int,boolean)>
<com.android.ims.internal.IImsService: android.telephony.ims.aidl.IImsConfig getConfig(int)>
<com.android.ims.internal.IImsService: android.telephony.ims.aidl.IImsRcsFeature createRcsFeature(int)>
<com.android.ims.internal.IImsService: void onSmsReady(int)>
<com.android.ims.internal.IImsService: boolean queryCapabilityConfiguration(int,int,int)>
<com.android.ims.internal.IImsService: void turnOnIms(int)>
<com.android.ims.internal.IImsService: android.telephony.ims.aidl.ISipTransport getSipTransport(int)>
<com.android.ims.internal.IImsService: void setRetryCount(int,int,int)>
<com.android.ims.internal.IImsService: java.lang.String getSmsFormat(int)>
<com.android.ims.internal.IImsService: void triggerAutoConfigurationForApp(int)>
<com.android.ims.internal.IImsService: void onMemoryAvailable(int,int)>
<com.android.ims.internal.IImsService: void sendDtmfEvent(int,java.lang.String)>
<com.android.ims.internal.IImsService: void sendPublishDialog(int,com.android.internal.telephony.PublishDialog)>
<com.android.ims.internal.IImsService: boolean isOpened(int)>
<com.android.ims.internal.IImsService: void acknowledgeSms(int,int,int,int)>
<com.android.ims.internal.IImsService: void notifyEpsFallbackResult(int,int)>
<com.android.ims.internal.IImsService: com.android.ims.internal.IImsMultiEndpoint getMultiEndpointInterface(int)>
<com.android.ims.internal.IImsService: void changeAudioPath(int,int)>
<com.android.ims.internal.IImsService: com.android.ims.internal.IImsCallSession createCallSession(int,android.telephony.ims.ImsCallProfile,com.android.ims.internal.IImsCallSessionListener)>
<com.android.ims.internal.IImsService: int startLocalRingBackTone(int,int,int)>
<com.android.ims.internal.IImsService: android.telephony.ims.aidl.IImsRegistration getRegistration(int)>
<com.android.ims.internal.IImsService: void setRegistrationListener(int,com.android.ims.internal.IImsRegistrationListener)>
<com.android.ims.internal.IImsService: void setSecImsMmTelEventListener(int,com.android.ims.internal.ISecImsMmTelEventListener)>
<com.android.ims.internal.IImsService: void turnOffIms(int)>
<com.android.internal.textservice.ITextServicesSessionListener: void onServiceConnected(com.android.internal.textservice.ISpellCheckerSession)>
<android.app.IUiModeManagerCallback: void notifyContrastChanged(float)>
<android.companion.ICompanionDeviceManager: void unregisterDevicePresenceListenerService(java.lang.String,java.lang.String,int)>
<android.companion.ICompanionDeviceManager: void removeOnMessageReceivedListener(int,android.companion.IOnMessageReceivedListener)>
<android.companion.ICompanionDeviceManager: boolean hasNotificationAccess(android.content.ComponentName)>
<android.companion.ICompanionDeviceManager: void detachSystemDataTransport(java.lang.String,int,int)>
<android.companion.ICompanionDeviceManager: void registerDevicePresenceListenerService(java.lang.String,java.lang.String,int)>
<android.companion.ICompanionDeviceManager: android.app.PendingIntent buildPermissionTransferUserConsentIntent(java.lang.String,int,int)>
<android.companion.ICompanionDeviceManager: android.app.PendingIntent requestNotificationAccess(android.content.ComponentName,int)>
<android.companion.ICompanionDeviceManager: void associate(android.companion.AssociationRequest,android.companion.IAssociationRequestCallback,java.lang.String,int)>
<android.companion.ICompanionDeviceManager: void attachSystemDataTransport(java.lang.String,int,int,android.os.ParcelFileDescriptor)>
<android.companion.ICompanionDeviceManager: boolean canPairWithoutPrompt(java.lang.String,java.lang.String,int)>
<android.companion.ICompanionDeviceManager: boolean isDeviceAssociatedForWifiConnection(java.lang.String,java.lang.String,int)>
<android.companion.ICompanionDeviceManager: void disableSystemDataSync(int,int)>
<android.companion.ICompanionDeviceManager: void addOnTransportsChangedListener(android.companion.IOnTransportsChangedListener)>
<android.companion.ICompanionDeviceManager: java.util.List getAllAssociationsForUser(int)>
<android.companion.ICompanionDeviceManager: java.util.List getAssociations(java.lang.String,int)>
<android.companion.ICompanionDeviceManager: void createAssociation(java.lang.String,java.lang.String,int,byte[])>
<android.companion.ICompanionDeviceManager: void sendMessage(int,byte[],int[])>
<android.companion.ICompanionDeviceManager: android.app.PendingIntent buildAssociationCancellationIntent(java.lang.String,int)>
<android.companion.ICompanionDeviceManager: void startSystemDataTransfer(java.lang.String,int,int,android.companion.ISystemDataTransferCallback)>
<android.companion.ICompanionDeviceManager: void legacyDisassociate(java.lang.String,java.lang.String,int)>
<android.companion.ICompanionDeviceManager: void addOnAssociationsChangedListener(android.companion.IOnAssociationsChangedListener,int)>
<android.companion.ICompanionDeviceManager: void notifyDeviceDisappeared(int)>
<android.companion.ICompanionDeviceManager: boolean isCompanionApplicationBound(java.lang.String,int)>
<android.companion.ICompanionDeviceManager: void addOnMessageReceivedListener(int,android.companion.IOnMessageReceivedListener)>
<android.companion.ICompanionDeviceManager: void enableSecureTransport(boolean)>
<android.companion.ICompanionDeviceManager: void notifyDeviceAppeared(int)>
<android.companion.ICompanionDeviceManager: void enableSystemDataSync(int,int)>
<android.companion.ICompanionDeviceManager: void removeOnTransportsChangedListener(android.companion.IOnTransportsChangedListener)>
<android.companion.ICompanionDeviceManager: void disassociate(int)>
<android.companion.ICompanionDeviceManager: void removeOnAssociationsChangedListener(android.companion.IOnAssociationsChangedListener,int)>
<com.samsung.android.knox.SemIRCPCallback: void onFail(java.lang.String,int,int)>
<com.samsung.android.knox.SemIRCPCallback: void onProgress(java.lang.String,int,int)>
<com.samsung.android.knox.SemIRCPCallback: void onDone(java.lang.String,int)>
<com.samsung.android.knox.SemIRCPCallback: void onComplete(java.util.List,int,int)>
<com.samsung.android.continuity.ISemContinuityManager: void registerContinuityCopyListener(com.samsung.android.continuity.ISemContinuitySimpleListener,int)>
<com.samsung.android.continuity.ISemContinuityManager: void cancelDownload(java.lang.String,int)>
<com.samsung.android.continuity.ISemContinuityManager: void clearLocalClip(int)>
<com.samsung.android.continuity.ISemContinuityManager: boolean requestDownload(java.lang.String,com.samsung.android.continuity.ISemContinuitySimpleListener,int)>
<com.samsung.android.continuity.ISemContinuityManager: void setLocalClip(android.os.Bundle,int)>
<com.samsung.android.continuity.ISemContinuityManager: void unregisterContinuityCopyListener(int)>
<com.samsung.android.continuity.ISemContinuityManager: int getNearbyDeviceCount(int,int)>
<android.app.backup.IMemorySaverBackupRestoreObserver: void onTimeout()>
<android.app.backup.IMemorySaverBackupRestoreObserver: void onRestoreCompleted(java.lang.String,boolean)>
<android.app.backup.IMemorySaverBackupRestoreObserver: void onRestoreStart(java.lang.String)>
<android.app.backup.IMemorySaverBackupRestoreObserver: void onStartBackup(java.lang.String)>
<android.app.backup.IMemorySaverBackupRestoreObserver: void onBackupCompleted(java.lang.String,boolean)>
<com.android.internal.telephony.IMms: android.net.Uri importTextMessage(java.lang.String,java.lang.String,int,java.lang.String,long,boolean,boolean)>
<com.android.internal.telephony.IMms: boolean getAutoPersisting()>
<com.android.internal.telephony.IMms: boolean deleteStoredMessage(java.lang.String,android.net.Uri)>
<com.android.internal.telephony.IMms: void setAutoPersisting(java.lang.String,boolean)>
<com.android.internal.telephony.IMms: void downloadMessage(int,java.lang.String,java.lang.String,android.net.Uri,android.os.Bundle,android.app.PendingIntent,long,java.lang.String)>
<com.android.internal.telephony.IMms: android.net.Uri importMultimediaMessage(java.lang.String,android.net.Uri,java.lang.String,long,boolean,boolean)>
<com.android.internal.telephony.IMms: boolean updateStoredMessageStatus(java.lang.String,android.net.Uri,android.content.ContentValues)>
<com.android.internal.telephony.IMms: boolean archiveStoredConversation(java.lang.String,long,boolean)>
<com.android.internal.telephony.IMms: android.net.Uri addTextMessageDraft(java.lang.String,java.lang.String,java.lang.String)>
<com.android.internal.telephony.IMms: android.net.Uri addMultimediaMessageDraft(java.lang.String,android.net.Uri)>
<com.android.internal.telephony.IMms: void sendMessage(int,java.lang.String,android.net.Uri,java.lang.String,android.os.Bundle,android.app.PendingIntent,long,java.lang.String)>
<com.android.internal.telephony.IMms: void sendStoredMessage(int,java.lang.String,android.net.Uri,android.os.Bundle,android.app.PendingIntent)>
<com.android.internal.telephony.IMms: boolean deleteStoredConversation(java.lang.String,long)>
<android.security.rkp.IRemoteProvisioning: void getRegistration(java.lang.String,android.security.rkp.IGetRegistrationCallback)>
<android.hardware.hdmi.IHdmiSystemAudioModeChangeListener: void onStatusChanged(boolean)>
<android.hardware.camera2.extension.IPreviewExtenderImpl: void onDeInit(android.os.IBinder)>
<android.hardware.camera2.extension.IPreviewExtenderImpl: android.hardware.camera2.extension.IPreviewImageProcessorImpl getPreviewImageProcessor()>
<android.hardware.camera2.extension.IPreviewExtenderImpl: int getSessionType()>
<android.hardware.camera2.extension.IPreviewExtenderImpl: void onInit(android.os.IBinder,java.lang.String,android.hardware.camera2.impl.CameraMetadataNative)>
<android.hardware.camera2.extension.IPreviewExtenderImpl: int getProcessorType()>
<android.hardware.camera2.extension.IPreviewExtenderImpl: android.hardware.camera2.extension.IRequestUpdateProcessorImpl getRequestUpdateProcessor()>
<android.hardware.camera2.extension.IPreviewExtenderImpl: android.hardware.camera2.extension.CaptureStageImpl getCaptureStage()>
<android.hardware.camera2.extension.IPreviewExtenderImpl: void init(java.lang.String,android.hardware.camera2.impl.CameraMetadataNative)>
<android.hardware.camera2.extension.IPreviewExtenderImpl: java.util.List getSupportedResolutions()>
<android.hardware.camera2.extension.IPreviewExtenderImpl: android.hardware.camera2.extension.CaptureStageImpl onEnableSession()>
<android.hardware.camera2.extension.IPreviewExtenderImpl: android.hardware.camera2.extension.CaptureStageImpl onPresetSession()>
<android.hardware.camera2.extension.IPreviewExtenderImpl: boolean isExtensionAvailable(java.lang.String,android.hardware.camera2.impl.CameraMetadataNative)>
<android.hardware.camera2.extension.IPreviewExtenderImpl: android.hardware.camera2.extension.CaptureStageImpl onDisableSession()>
<android.app.ITaskStackListener: void onTaskMovedToFront(android.app.ActivityManager$RunningTaskInfo)>
<android.app.ITaskStackListener: void onTaskCreated(int,android.content.ComponentName)>
<android.app.ITaskStackListener: void onActivityLaunchOnSecondaryDisplayRerouted(android.app.ActivityManager$RunningTaskInfo,int)>
<android.app.ITaskStackListener: void onActivityPinned(java.lang.String,int,int,int)>
<android.app.ITaskStackListener: void onActivityDismissingDockedTask()>
<android.app.ITaskStackListener: void onTaskWindowingModeChanged(int)>
<android.app.ITaskStackListener: void onTaskDescriptionChanged(android.app.ActivityManager$RunningTaskInfo)>
<android.app.ITaskStackListener: void onActivityDismissingSplitTask(java.lang.String)>
<android.app.ITaskStackListener: void onActivityUnpinned()>
<android.app.ITaskStackListener: void onActivityRestartAttempt(android.app.ActivityManager$RunningTaskInfo,boolean,boolean,boolean)>
<android.app.ITaskStackListener: void onBackPressedOnTaskRoot(android.app.ActivityManager$RunningTaskInfo)>
<android.app.ITaskStackListener: void onTaskProfileLocked(android.app.ActivityManager$RunningTaskInfo,int)>
<android.app.ITaskStackListener: void onTaskStackChanged()>
<android.app.ITaskStackListener: void onTaskFocusChanged(int,boolean)>
<android.app.ITaskStackListener: void onTaskSnapshotChanged(int,android.window.TaskSnapshot)>
<android.app.ITaskStackListener: void onRecentTaskListFrozenChanged(boolean)>
<android.app.ITaskStackListener: void onTaskRemovalStarted(android.app.ActivityManager$RunningTaskInfo)>
<android.app.ITaskStackListener: void onRecentTaskListUpdated()>
<android.app.ITaskStackListener: void onTaskMovedToBack(android.app.ActivityManager$RunningTaskInfo)>
<android.app.ITaskStackListener: void onActivityLaunchOnSecondaryDisplayFailed(android.app.ActivityManager$RunningTaskInfo,int)>
<android.app.ITaskStackListener: void onActivityForcedResizable(java.lang.String,int,int)>
<android.app.ITaskStackListener: void onTaskRemoved(int)>
<android.app.ITaskStackListener: void onOccludeChangeNotice(android.content.ComponentName,boolean)>
<android.app.ITaskStackListener: void onActivityRequestedOrientationChanged(int,int)>
<android.app.ITaskStackListener: void onActivityRotation(int)>
<android.app.ITaskStackListener: void onTaskDisplayChanged(int,int)>
<android.app.ITaskStackListener: void onLockTaskModeChanged(int)>
<android.app.ITaskStackListener: void onTaskRequestedOrientationChanged(int,int)>
<android.media.musicrecognition.IMusicRecognitionServiceCallback: void onRecognitionFailed(int)>
<android.media.musicrecognition.IMusicRecognitionServiceCallback: void onRecognitionSucceeded(android.media.MediaMetadata,android.os.Bundle)>
<android.security.attestationverification.IAttestationVerificationManagerService: void verifyToken(android.security.attestationverification.VerificationToken,android.os.ParcelDuration,com.android.internal.infra.AndroidFuture)>
<android.security.attestationverification.IAttestationVerificationManagerService: void verifyAttestation(android.security.attestationverification.AttestationProfile,int,android.os.Bundle,byte[],com.android.internal.infra.AndroidFuture)>
<android.telephony.mbms.vendor.IMbmsGroupCallService: int startGroupCall(int,long,java.util.List,java.util.List,android.telephony.mbms.IGroupCallCallback)>
<android.telephony.mbms.vendor.IMbmsGroupCallService: void dispose(int)>
<android.telephony.mbms.vendor.IMbmsGroupCallService: void updateGroupCall(int,long,java.util.List,java.util.List)>
<android.telephony.mbms.vendor.IMbmsGroupCallService: int initialize(android.telephony.mbms.IMbmsGroupCallSessionCallback,int)>
<android.telephony.mbms.vendor.IMbmsGroupCallService: void stopGroupCall(int,long)>
<android.app.IParcelFileDescriptorRetriever: android.os.ParcelFileDescriptor getPfd()>
<android.credentials.IGetCredentialCallback: void onResponse(android.credentials.GetCredentialResponse)>
<android.credentials.IGetCredentialCallback: void onError(java.lang.String,java.lang.String)>
<android.credentials.IGetCredentialCallback: void onPendingIntent(android.app.PendingIntent)>
<android.os.IDeviceIdleController: java.lang.String[] getSystemPowerWhitelistExceptIdle()>
<android.os.IDeviceIdleController: void addPowerSaveTempWhitelistApp(java.lang.String,long,int,int,java.lang.String)>
<android.os.IDeviceIdleController: long addPowerSaveTempWhitelistAppForMms(java.lang.String,int,int,java.lang.String)>
<android.os.IDeviceIdleController: int[] getAppIdWhitelistExceptIdle()>
<android.os.IDeviceIdleController: int[] getAppIdTempWhitelist()>
<android.os.IDeviceIdleController: int[] getAppIdWhitelist()>
<android.os.IDeviceIdleController: void exitIdle(java.lang.String)>
<android.os.IDeviceIdleController: int[] getAppIdUserWhitelist()>
<android.os.IDeviceIdleController: java.lang.String[] getRemovedSystemPowerWhitelistApps()>
<android.os.IDeviceIdleController: void removeSystemPowerWhitelistApp(java.lang.String)>
<android.os.IDeviceIdleController: java.lang.String[] getFullPowerWhitelistExceptIdle()>
<android.os.IDeviceIdleController: long addPowerSaveTempWhitelistAppForSms(java.lang.String,int,int,java.lang.String)>
<android.os.IDeviceIdleController: void resetPreIdleTimeoutMode()>
<android.os.IDeviceIdleController: boolean isPowerSaveWhitelistExceptIdleApp(java.lang.String)>
<android.os.IDeviceIdleController: void restoreSystemPowerWhitelistApp(java.lang.String)>
<android.os.IDeviceIdleController: int setPreIdleTimeoutMode(int)>
<android.os.IDeviceIdleController: java.lang.String[] getUserPowerWhitelist()>
<android.os.IDeviceIdleController: long whitelistAppTemporarily(java.lang.String,int,int,java.lang.String)>
<android.os.IDeviceIdleController: java.lang.String[] getSystemPowerWhitelist()>
<android.os.IDeviceIdleController: void removePowerSaveWhitelistApp(java.lang.String)>
<android.os.IDeviceIdleController: void addPowerSaveWhitelistApp(java.lang.String)>
<android.os.IDeviceIdleController: int addPowerSaveWhitelistApps(java.util.List)>
<android.os.IDeviceIdleController: boolean isPowerSaveWhitelistApp(java.lang.String)>
<android.os.IDeviceIdleController: java.lang.String[] getFullPowerWhitelist()>
<com.samsung.android.knox.dar.ddar.proxy.IProxyService: boolean registerAgentByAction(java.lang.String,int,java.lang.String,java.lang.String)>
<com.samsung.android.knox.dar.ddar.proxy.IProxyService: boolean registerAgentByMetadata(java.lang.String,int,java.lang.String,java.lang.String)>
<com.samsung.android.knox.dar.ddar.proxy.IProxyService: android.os.Bundle relay(java.lang.String,java.lang.String,java.lang.String,android.os.Bundle)>
<com.samsung.android.knox.dar.ddar.proxy.IProxyService: android.os.Bundle relayAsync(java.lang.String,java.lang.String,java.lang.String,android.os.Bundle)>
<com.samsung.android.knox.dar.ddar.proxy.IProxyService: void deregisterAgent(java.lang.String)>
<android.service.media.IMediaBrowserService: void disconnect(android.service.media.IMediaBrowserServiceCallbacks)>
<android.service.media.IMediaBrowserService: void addSubscriptionDeprecated(java.lang.String,android.service.media.IMediaBrowserServiceCallbacks)>
<android.service.media.IMediaBrowserService: void removeSubscription(java.lang.String,android.os.IBinder,android.service.media.IMediaBrowserServiceCallbacks)>
<android.service.media.IMediaBrowserService: void connect(java.lang.String,android.os.Bundle,android.service.media.IMediaBrowserServiceCallbacks)>
<android.service.media.IMediaBrowserService: void addSubscription(java.lang.String,android.os.IBinder,android.os.Bundle,android.service.media.IMediaBrowserServiceCallbacks)>
<android.service.media.IMediaBrowserService: void getMediaItem(java.lang.String,android.os.ResultReceiver,android.service.media.IMediaBrowserServiceCallbacks)>
<android.service.media.IMediaBrowserService: void removeSubscriptionDeprecated(java.lang.String,android.service.media.IMediaBrowserServiceCallbacks)>
<android.hardware.radio.messaging.IRadioMessagingResponse: void setGsmBroadcastActivationResponse(android.hardware.radio.RadioResponseInfo)>
<android.hardware.radio.messaging.IRadioMessagingResponse: void setSmscAddressResponse(android.hardware.radio.RadioResponseInfo)>
<android.hardware.radio.messaging.IRadioMessagingResponse: void reportSmsMemoryStatusResponse(android.hardware.radio.RadioResponseInfo)>
<android.hardware.radio.messaging.IRadioMessagingResponse: void getGsmBroadcastConfigResponse(android.hardware.radio.RadioResponseInfo,android.hardware.radio.messaging.GsmBroadcastSmsConfigInfo[])>
<android.hardware.radio.messaging.IRadioMessagingResponse: void acknowledgeIncomingGsmSmsWithPduResponse(android.hardware.radio.RadioResponseInfo)>
<android.hardware.radio.messaging.IRadioMessagingResponse: void acknowledgeRequest(int)>
<android.hardware.radio.messaging.IRadioMessagingResponse: java.lang.String getInterfaceHash()>
<android.hardware.radio.messaging.IRadioMessagingResponse: void sendCdmaSmsResponse(android.hardware.radio.RadioResponseInfo,android.hardware.radio.messaging.SendSmsResult)>
<android.hardware.radio.messaging.IRadioMessagingResponse: void sendSmsResponse(android.hardware.radio.RadioResponseInfo,android.hardware.radio.messaging.SendSmsResult)>
<android.hardware.radio.messaging.IRadioMessagingResponse: void sendCdmaSmsExpectMoreResponse(android.hardware.radio.RadioResponseInfo,android.hardware.radio.messaging.SendSmsResult)>
<android.hardware.radio.messaging.IRadioMessagingResponse: void writeSmsToSimResponse(android.hardware.radio.RadioResponseInfo,int)>
<android.hardware.radio.messaging.IRadioMessagingResponse: void deleteSmsOnSimResponse(android.hardware.radio.RadioResponseInfo)>
<android.hardware.radio.messaging.IRadioMessagingResponse: void acknowledgeLastIncomingCdmaSmsResponse(android.hardware.radio.RadioResponseInfo)>
<android.hardware.radio.messaging.IRadioMessagingResponse: void acknowledgeLastIncomingGsmSmsResponse(android.hardware.radio.RadioResponseInfo)>
<android.hardware.radio.messaging.IRadioMessagingResponse: void getCdmaBroadcastConfigResponse(android.hardware.radio.RadioResponseInfo,android.hardware.radio.messaging.CdmaBroadcastSmsConfigInfo[])>
<android.hardware.radio.messaging.IRadioMessagingResponse: void sendImsSmsResponse(android.hardware.radio.RadioResponseInfo,android.hardware.radio.messaging.SendSmsResult)>
<android.hardware.radio.messaging.IRadioMessagingResponse: void setCdmaBroadcastConfigResponse(android.hardware.radio.RadioResponseInfo)>
<android.hardware.radio.messaging.IRadioMessagingResponse: void setGsmBroadcastConfigResponse(android.hardware.radio.RadioResponseInfo)>
<android.hardware.radio.messaging.IRadioMessagingResponse: void sendSmsExpectMoreResponse(android.hardware.radio.RadioResponseInfo,android.hardware.radio.messaging.SendSmsResult)>
<android.hardware.radio.messaging.IRadioMessagingResponse: int getInterfaceVersion()>
<android.hardware.radio.messaging.IRadioMessagingResponse: void setCdmaBroadcastActivationResponse(android.hardware.radio.RadioResponseInfo)>
<android.hardware.radio.messaging.IRadioMessagingResponse: void getSmscAddressResponse(android.hardware.radio.RadioResponseInfo,java.lang.String)>
<android.hardware.radio.messaging.IRadioMessagingResponse: void writeSmsToRuimResponse(android.hardware.radio.RadioResponseInfo,int)>
<android.hardware.radio.messaging.IRadioMessagingResponse: void deleteSmsOnRuimResponse(android.hardware.radio.RadioResponseInfo)>
<com.android.internal.app.IVoiceInteractionSoundTriggerSession: android.hardware.soundtrigger.SoundTrigger$ModuleProperties getDspModuleProperties()>
<com.android.internal.app.IVoiceInteractionSoundTriggerSession: int setParameter(int,int,int)>
<com.android.internal.app.IVoiceInteractionSoundTriggerSession: int getParameter(int,int)>
<com.android.internal.app.IVoiceInteractionSoundTriggerSession: int startRecognition(int,java.lang.String,com.android.internal.app.IHotwordRecognitionStatusCallback,android.hardware.soundtrigger.SoundTrigger$RecognitionConfig,boolean)>
<com.android.internal.app.IVoiceInteractionSoundTriggerSession: android.hardware.soundtrigger.SoundTrigger$ModelParamRange queryParameter(int,int)>
<com.android.internal.app.IVoiceInteractionSoundTriggerSession: int stopRecognition(int,com.android.internal.app.IHotwordRecognitionStatusCallback)>
<com.android.internal.app.IVoiceInteractionSoundTriggerSession: void detach()>
<android.content.pm.IPackageInstallerSessionFileSystemConnector: void writeData(java.lang.String,long,long,android.os.ParcelFileDescriptor)>
<android.app.job.IJobService: void startJob(android.app.job.JobParameters)>
<android.app.job.IJobService: void getTransferredDownloadBytes(android.app.job.JobParameters,android.app.job.JobWorkItem)>
<android.app.job.IJobService: void getTransferredUploadBytes(android.app.job.JobParameters,android.app.job.JobWorkItem)>
<android.app.job.IJobService: void onNetworkChanged(android.app.job.JobParameters)>
<android.app.job.IJobService: void stopJob(android.app.job.JobParameters)>
<android.content.IClipboard: android.content.ClipDescription getPrimaryClipDescription(java.lang.String,java.lang.String,int,int)>
<android.content.IClipboard: void setPrimaryClip(android.content.ClipData,java.lang.String,java.lang.String,int,int)>
<android.content.IClipboard: void addPrimaryClipChangedListener(android.content.IOnPrimaryClipChangedListener,java.lang.String,java.lang.String,int,int)>
<android.content.IClipboard: void setClipboardAccessNotificationsEnabledForUser(boolean,int)>
<android.content.IClipboard: boolean areClipboardAccessNotificationsEnabledForUser(int)>
<android.content.IClipboard: boolean hasClipboardText(java.lang.String,java.lang.String,int,int)>
<android.content.IClipboard: void setPrimaryClipAsPackage(android.content.ClipData,java.lang.String,java.lang.String,int,int,java.lang.String)>
<android.content.IClipboard: android.content.ClipData getPrimaryClip(java.lang.String,java.lang.String,int,int)>
<android.content.IClipboard: boolean hasPrimaryClip(java.lang.String,java.lang.String,int,int)>
<android.content.IClipboard: void clearPrimaryClip(java.lang.String,java.lang.String,int,int)>
<android.content.IClipboard: void removePrimaryClipChangedListener(android.content.IOnPrimaryClipChangedListener,java.lang.String,java.lang.String,int,int)>
<android.content.IClipboard: java.lang.String getPrimaryClipSource(java.lang.String,java.lang.String,int,int)>
<android.content.res.IResourcesManager: boolean dumpResources(java.lang.String,android.os.ParcelFileDescriptor,android.os.RemoteCallback)>
<android.app.backup.IBackupObserver: void onUpdate(java.lang.String,android.app.backup.BackupProgress)>
<android.app.backup.IBackupObserver: void backupFinished(int)>
<android.app.backup.IBackupObserver: void onResult(java.lang.String,int)>
<com.android.internal.widget.IRemoteLockMonitorCallback: int checkRemoteLockPassword(byte[])>
<com.android.internal.widget.IRemoteLockMonitorCallback: void changeRemoteLockState(com.android.internal.widget.RemoteLockInfo)>
<android.app.admin.StartInstallingUpdateCallback: void onStartInstallingUpdateError(int,java.lang.String)>
<com.android.ims.internal.uce.options.IOptionsService: com.android.ims.internal.uce.common.StatusCode removeListener(int,com.android.ims.internal.uce.common.UceLong)>
<com.android.ims.internal.uce.options.IOptionsService: com.android.ims.internal.uce.common.StatusCode setMyInfo(int,com.android.ims.internal.uce.common.CapInfo,int)>
<com.android.ims.internal.uce.options.IOptionsService: com.android.ims.internal.uce.common.StatusCode addListener(int,com.android.ims.internal.uce.options.IOptionsListener,com.android.ims.internal.uce.common.UceLong)>
<com.android.ims.internal.uce.options.IOptionsService: com.android.ims.internal.uce.common.StatusCode responseIncomingOptions(int,int,int,java.lang.String,com.android.ims.internal.uce.options.OptionsCapInfo,boolean)>
<com.android.ims.internal.uce.options.IOptionsService: com.android.ims.internal.uce.common.StatusCode getVersion(int)>
<com.android.ims.internal.uce.options.IOptionsService: com.android.ims.internal.uce.common.StatusCode getContactListCap(int,java.lang.String[],int)>
<com.android.ims.internal.uce.options.IOptionsService: com.android.ims.internal.uce.common.StatusCode getMyInfo(int,int)>
<com.android.ims.internal.uce.options.IOptionsService: com.android.ims.internal.uce.common.StatusCode getContactCap(int,java.lang.String,int)>
<android.credentials.IClearCredentialStateCallback: void onSuccess()>
<android.credentials.IClearCredentialStateCallback: void onError(java.lang.String,java.lang.String)>
<android.security.identity.ICredentialStoreFactory: android.security.identity.ICredentialStore getCredentialStore(int)>
<com.samsung.android.remoteappmode.IRotationChangeListener: void onRotationChanged(int,int)>
<android.view.IWallpaperVisibilityListener: void onWallpaperVisibilityChanged(boolean,int)>
<android.hardware.fingerprint.IFingerprintAuthenticatorsRegisteredCallback: void onAllAuthenticatorsRegistered(java.util.List)>
<android.content.IIntentSender: void send(int,android.content.Intent,java.lang.String,android.os.IBinder,android.content.IIntentReceiver,java.lang.String,android.os.Bundle)>
<com.android.internal.inputmethod.IRemoteInputConnection: void getSelectedText(com.android.internal.inputmethod.InputConnectionCommandHeader,int,com.android.internal.infra.AndroidFuture)>
<com.android.internal.inputmethod.IRemoteInputConnection: void endBatchEdit(com.android.internal.inputmethod.InputConnectionCommandHeader)>
<com.android.internal.inputmethod.IRemoteInputConnection: void deleteSurroundingTextInCodePoints(com.android.internal.inputmethod.InputConnectionCommandHeader,int,int)>
<com.android.internal.inputmethod.IRemoteInputConnection: void performSpellCheck(com.android.internal.inputmethod.InputConnectionCommandHeader)>
<com.android.internal.inputmethod.IRemoteInputConnection: void commitTextWithTextAttribute(com.android.internal.inputmethod.InputConnectionCommandHeader,java.lang.CharSequence,int,android.view.inputmethod.TextAttribute)>
<com.android.internal.inputmethod.IRemoteInputConnection: void getExtractedText(com.android.internal.inputmethod.InputConnectionCommandHeader,android.view.inputmethod.ExtractedTextRequest,int,com.android.internal.infra.AndroidFuture)>
<com.android.internal.inputmethod.IRemoteInputConnection: void commitContent(com.android.internal.inputmethod.InputConnectionCommandHeader,android.view.inputmethod.InputContentInfo,int,android.os.Bundle,com.android.internal.infra.AndroidFuture)>
<com.android.internal.inputmethod.IRemoteInputConnection: void commitCompletion(com.android.internal.inputmethod.InputConnectionCommandHeader,android.view.inputmethod.CompletionInfo)>
<com.android.internal.inputmethod.IRemoteInputConnection: void setImeConsumesInput(com.android.internal.inputmethod.InputConnectionCommandHeader,boolean)>
<com.android.internal.inputmethod.IRemoteInputConnection: void performPrivateCommand(com.android.internal.inputmethod.InputConnectionCommandHeader,java.lang.String,android.os.Bundle)>
<com.android.internal.inputmethod.IRemoteInputConnection: void commitCorrection(com.android.internal.inputmethod.InputConnectionCommandHeader,android.view.inputmethod.CorrectionInfo)>
<com.android.internal.inputmethod.IRemoteInputConnection: void forgetCancellationSignal(android.os.IBinder)>
<com.android.internal.inputmethod.IRemoteInputConnection: void requestCursorUpdatesWithFilter(com.android.internal.inputmethod.InputConnectionCommandHeader,int,int,int,com.android.internal.infra.AndroidFuture)>
<com.android.internal.inputmethod.IRemoteInputConnection: void replaceText(com.android.internal.inputmethod.InputConnectionCommandHeader,int,int,java.lang.CharSequence,int,android.view.inputmethod.TextAttribute)>
<com.android.internal.inputmethod.IRemoteInputConnection: void previewHandwritingGesture(com.android.internal.inputmethod.InputConnectionCommandHeader,android.view.inputmethod.ParcelableHandwritingGesture,android.os.IBinder)>
<com.android.internal.inputmethod.IRemoteInputConnection: void finishComposingText(com.android.internal.inputmethod.InputConnectionCommandHeader)>
<com.android.internal.inputmethod.IRemoteInputConnection: void getTextBeforeCursor(com.android.internal.inputmethod.InputConnectionCommandHeader,int,int,com.android.internal.infra.AndroidFuture)>
<com.android.internal.inputmethod.IRemoteInputConnection: void beginBatchEdit(com.android.internal.inputmethod.InputConnectionCommandHeader)>
<com.android.internal.inputmethod.IRemoteInputConnection: void performContextMenuAction(com.android.internal.inputmethod.InputConnectionCommandHeader,int)>
<com.android.internal.inputmethod.IRemoteInputConnection: void deleteSurroundingText(com.android.internal.inputmethod.InputConnectionCommandHeader,int,int)>
<com.android.internal.inputmethod.IRemoteInputConnection: void getCursorCapsMode(com.android.internal.inputmethod.InputConnectionCommandHeader,int,com.android.internal.infra.AndroidFuture)>
<com.android.internal.inputmethod.IRemoteInputConnection: void setComposingTextWithTextAttribute(com.android.internal.inputmethod.InputConnectionCommandHeader,java.lang.CharSequence,int,android.view.inputmethod.TextAttribute)>
<com.android.internal.inputmethod.IRemoteInputConnection: void setSelection(com.android.internal.inputmethod.InputConnectionCommandHeader,int,int)>
<com.android.internal.inputmethod.IRemoteInputConnection: void getSurroundingText(com.android.internal.inputmethod.InputConnectionCommandHeader,int,int,int,com.android.internal.infra.AndroidFuture)>
<com.android.internal.inputmethod.IRemoteInputConnection: void requestTextBoundsInfo(com.android.internal.inputmethod.InputConnectionCommandHeader,android.graphics.RectF,android.os.ResultReceiver)>
<com.android.internal.inputmethod.IRemoteInputConnection: void performHandwritingGesture(com.android.internal.inputmethod.InputConnectionCommandHeader,android.view.inputmethod.ParcelableHandwritingGesture,android.os.ResultReceiver)>
<com.android.internal.inputmethod.IRemoteInputConnection: void getTextAfterCursor(com.android.internal.inputmethod.InputConnectionCommandHeader,int,int,com.android.internal.infra.AndroidFuture)>
<com.android.internal.inputmethod.IRemoteInputConnection: void sendKeyEvent(com.android.internal.inputmethod.InputConnectionCommandHeader,android.view.KeyEvent)>
<com.android.internal.inputmethod.IRemoteInputConnection: void setComposingRegionWithTextAttribute(com.android.internal.inputmethod.InputConnectionCommandHeader,int,int,android.view.inputmethod.TextAttribute)>
<com.android.internal.inputmethod.IRemoteInputConnection: void setComposingText(com.android.internal.inputmethod.InputConnectionCommandHeader,java.lang.CharSequence,int)>
<com.android.internal.inputmethod.IRemoteInputConnection: void cancelCancellationSignal(android.os.IBinder)>
<com.android.internal.inputmethod.IRemoteInputConnection: void commitText(com.android.internal.inputmethod.InputConnectionCommandHeader,java.lang.CharSequence,int)>
<com.android.internal.inputmethod.IRemoteInputConnection: void performEditorAction(com.android.internal.inputmethod.InputConnectionCommandHeader,int)>
<com.android.internal.inputmethod.IRemoteInputConnection: void requestCursorUpdates(com.android.internal.inputmethod.InputConnectionCommandHeader,int,int,com.android.internal.infra.AndroidFuture)>
<com.android.internal.inputmethod.IRemoteInputConnection: void clearMetaKeyStates(com.android.internal.inputmethod.InputConnectionCommandHeader,int)>
<com.android.internal.inputmethod.IRemoteInputConnection: void setComposingRegion(com.android.internal.inputmethod.InputConnectionCommandHeader,int,int)>
<android.media.IAudioPolicyService: java.lang.String getAudioPolicyConfig(java.lang.String)>
<android.media.IAudioPolicyService: void setDevicesRoleForCapturePreset(int,int,android.media.audio.common.AudioDevice[])>
<android.media.IAudioPolicyService: void removeUserIdDeviceAffinities(int)>
<android.media.IAudioPolicyService: int getVolumeGroupFromAudioAttributes(android.media.AudioAttributesInternal,boolean)>
<android.media.IAudioPolicyService: void stopAudioSource(int)>
<android.media.IAudioPolicyService: android.media.AudioMixerAttributesInternal getPreferredMixerAttributes(android.media.AudioAttributesInternal,int)>
<android.media.IAudioPolicyService: void setAudioVolumeGroupCallbacksEnabled(boolean)>
<android.media.IAudioPolicyService: void setStreamVolumeIndex(int,android.media.audio.common.AudioDeviceDescription,int)>
<android.media.IAudioPolicyService: int getDeviceConnectionState(android.media.audio.common.AudioDevice)>
<android.media.IAudioPolicyService: void setVolumeIndexForAttributes(android.media.AudioAttributesInternal,android.media.audio.common.AudioDeviceDescription,int)>
<android.media.IAudioPolicyService: void releaseOutput(int)>
<android.media.IAudioPolicyService: void initStreamVolume(int,int,int)>
<android.media.IAudioPolicyService: android.media.AudioMixerAttributesInternal[] getSupportedMixerAttributes(int)>
<android.media.IAudioPolicyService: int listAudioPorts(int,int,android.media.audio.common.Int,android.media.AudioPortFw[])>
<android.media.IAudioPolicyService: android.media.AudioProductStrategy[] listAudioProductStrategies()>
<android.media.IAudioPolicyService: android.media.audio.common.AudioDevice[] getDevicesForRoleAndCapturePreset(int,int)>
<android.media.IAudioPolicyService: void removeSourceDefaultEffect(int)>
<android.media.IAudioPolicyService: void clearDevicesRoleForCapturePreset(int,int)>
<android.media.IAudioPolicyService: android.media.audio.common.AudioProfile[] getDirectProfilesForAttributes(android.media.AudioAttributesInternal)>
<android.media.IAudioPolicyService: void setRttEnabled(boolean)>
<android.media.IAudioPolicyService: void setAllowedCapturePolicy(int,int)>
<android.media.IAudioPolicyService: void setPreferredMixerAttributes(android.media.AudioAttributesInternal,int,int,android.media.AudioMixerAttributesInternal)>
<android.media.IAudioPolicyService: void removeDevicesRoleForCapturePreset(int,int,android.media.audio.common.AudioDevice[])>
<android.media.IAudioPolicyService: void removeStreamDefaultEffect(int)>
<android.media.IAudioPolicyService: android.media.audio.common.AudioFormatDescription[] getHwOffloadFormatsSupportedForBluetoothMedia(android.media.audio.common.AudioDeviceDescription)>
<android.media.IAudioPolicyService: int getOffloadSupport(android.media.audio.common.AudioOffloadInfo)>
<android.media.IAudioPolicyService: void setForceUse(int,int)>
<android.media.IAudioPolicyService: int getOutputForEffect(android.media.EffectDescriptor)>
<android.media.IAudioPolicyService: int getForceUse(int)>
<android.media.IAudioPolicyService: int getDirectPlaybackSupport(android.media.AudioAttributesInternal,android.media.audio.common.AudioConfig)>
<android.media.IAudioPolicyService: void clearDevicesRoleForStrategy(int,int)>
<android.media.IAudioPolicyService: int getProductStrategyFromAudioAttributes(android.media.AudioAttributesInternal,boolean)>
<android.media.IAudioPolicyService: boolean getMasterMono()>
<android.media.IAudioPolicyService: int getMinVolumeIndexForAttributes(android.media.AudioAttributesInternal)>
<android.media.IAudioPolicyService: void startOutput(int)>
<android.media.IAudioPolicyService: int addStreamDefaultEffect(android.media.audio.common.AudioUuid,java.lang.String,android.media.audio.common.AudioUuid,int,int)>
<android.media.IAudioPolicyService: void getReportedSurroundFormats(android.media.audio.common.Int,android.media.audio.common.AudioFormatDescription[])>
<android.media.IAudioPolicyService: android.media.GetSpatializerResponse getSpatializer(android.media.INativeSpatializerCallback)>
<android.media.IAudioPolicyService: void clearPreferredMixerAttributes(android.media.AudioAttributesInternal,int,int)>
<android.media.IAudioPolicyService: void unregisterEffect(int)>
<android.media.IAudioPolicyService: void setPhoneState(int,int)>
<android.media.IAudioPolicyService: int getPhoneState()>
<android.media.IAudioPolicyService: void setDevicesRoleForStrategy(int,int,android.media.audio.common.AudioDevice[])>
<android.media.IAudioPolicyService: void onNewAudioModulesAvailable()>
<android.media.IAudioPolicyService: boolean isStreamActiveRemotely(int,int)>
<android.media.IAudioPolicyService: boolean canBeSpatialized(android.media.AudioAttributesInternal,android.media.audio.common.AudioConfig,android.media.audio.common.AudioDevice[])>
<android.media.IAudioPolicyService: boolean isUltrasoundSupported()>
<android.media.IAudioPolicyService: void setCurrentImeUid(int)>
<android.media.IAudioPolicyService: android.media.AudioPortFw getAudioPort(int)>
<android.media.IAudioPolicyService: void setSurroundFormatEnabled(android.media.audio.common.AudioFormatDescription,boolean)>
<android.media.IAudioPolicyService: void getSurroundFormats(android.media.audio.common.Int,android.media.audio.common.AudioFormatDescription[],boolean[])>
<android.media.IAudioPolicyService: android.media.GetInputForAttrResponse getInputForAttr(android.media.AudioAttributesInternal,int,int,int,android.content.AttributionSourceState,android.media.audio.common.AudioConfigBase,int,int)>
<android.media.IAudioPolicyService: int addSourceDefaultEffect(android.media.audio.common.AudioUuid,java.lang.String,android.media.audio.common.AudioUuid,int,int)>
<android.media.IAudioPolicyService: int createAudioPatch(android.media.AudioPatchFw,int)>
<android.media.IAudioPolicyService: void removeUidDeviceAffinities(int)>
<android.media.IAudioPolicyService: int getStrategyForStream(int)>
<android.media.IAudioPolicyService: void registerEffect(android.media.EffectDescriptor,int,int,int,int)>
<android.media.IAudioPolicyService: void setAudioPortCallbacksEnabled(boolean)>
<android.media.IAudioPolicyService: int getMaxVolumeIndexForAttributes(android.media.AudioAttributesInternal)>
<android.media.IAudioPolicyService: void setAudioPortConfig(android.media.AudioPortConfigFw)>
<android.media.IAudioPolicyService: void releaseSoundTriggerSession(int)>
<android.media.IAudioPolicyService: android.media.AudioPortFw[] listDeclaredDevicePorts(int)>
<android.media.IAudioPolicyService: void removeDevicesRoleForStrategy(int,int,android.media.audio.common.AudioDevice[])>
<android.media.IAudioPolicyService: void setAssistantServicesUids(int[])>
<android.media.IAudioPolicyService: void setUidDeviceAffinities(int,android.media.audio.common.AudioDevice[])>
<android.media.IAudioPolicyService: void handleDeviceConfigChange(android.media.audio.common.AudioDevice,java.lang.String,android.media.audio.common.AudioFormatDescription)>
<android.media.IAudioPolicyService: boolean isHotwordStreamSupported(boolean)>
<android.media.IAudioPolicyService: void registerPolicyMixes(android.media.AudioMix[],boolean)>
<android.media.IAudioPolicyService: void releaseAudioPatch(int)>
<android.media.IAudioPolicyService: int startAudioSource(android.media.AudioPortConfigFw,android.media.AudioAttributesInternal)>
<android.media.IAudioPolicyService: int getOutput(int)>
<android.media.IAudioPolicyService: boolean isDirectOutputSupported(android.media.audio.common.AudioConfigBase,android.media.AudioAttributesInternal)>
<android.media.IAudioPolicyService: int getVolumeIndexForAttributes(android.media.AudioAttributesInternal,android.media.audio.common.AudioDeviceDescription)>
<android.media.IAudioPolicyService: void setMasterMono(boolean)>
<android.media.IAudioPolicyService: boolean registerSoundTriggerCaptureStateListener(android.media.ICaptureStateListener)>
<android.media.IAudioPolicyService: void addDevicesRoleForCapturePreset(int,int,android.media.audio.common.AudioDevice[])>
<android.media.IAudioPolicyService: android.media.EffectDescriptor[] queryDefaultPreProcessing(int,android.media.audio.common.Int)>
<android.media.IAudioPolicyService: android.media.GetOutputForAttrResponse getOutputForAttr(android.media.AudioAttributesInternal,int,android.content.AttributionSourceState,android.media.audio.common.AudioConfig,int,int)>
<android.media.IAudioPolicyService: boolean isHapticPlaybackSupported()>
<android.media.IAudioPolicyService: void setUserIdDeviceAffinities(int,android.media.audio.common.AudioDevice[])>
<android.media.IAudioPolicyService: void stopOutput(int)>
<android.media.IAudioPolicyService: boolean isStreamActive(int,int)>
<android.media.IAudioPolicyService: void registerClient(android.media.IAudioPolicyServiceClient)>
<android.media.IAudioPolicyService: android.media.SoundTriggerSession acquireSoundTriggerSession()>
<android.media.IAudioPolicyService: android.media.audio.common.AudioDevice[] getDevicesForAttributes(android.media.AudioAttributesInternal,boolean)>
<android.media.IAudioPolicyService: void setA11yServicesUids(int[])>
<android.media.IAudioPolicyService: void stopInput(int)>
<android.media.IAudioPolicyService: void releaseInput(int)>
<android.media.IAudioPolicyService: int listAudioPatches(android.media.audio.common.Int,android.media.AudioPatchFw[])>
<android.media.IAudioPolicyService: android.media.AudioVolumeGroup[] listAudioVolumeGroups()>
<android.media.IAudioPolicyService: void startInput(int)>
<android.media.IAudioPolicyService: boolean isCallScreenModeSupported()>
<android.media.IAudioPolicyService: void setActiveAssistantServicesUids(int[])>
<android.media.IAudioPolicyService: void setDeviceConnectionState(int,android.media.audio.common.AudioPort,android.media.audio.common.AudioFormatDescription)>
<android.media.IAudioPolicyService: void setEffectEnabled(int,boolean)>
<android.media.IAudioPolicyService: void setSupportedSystemUsages(int[])>
<android.media.IAudioPolicyService: void setAudioPolicyConfig(java.lang.String)>
<android.media.IAudioPolicyService: int getStreamVolumeIndex(int,android.media.audio.common.AudioDeviceDescription)>
<android.media.IAudioPolicyService: float getStreamVolumeDB(int,int,android.media.audio.common.AudioDeviceDescription)>
<android.media.IAudioPolicyService: boolean isSourceActive(int)>
<android.media.IAudioPolicyService: void moveEffectsToIo(int[],int)>
<android.media.IAudioPolicyService: android.media.audio.common.AudioDevice[] getDevicesForRoleAndStrategy(int,int)>
<android.app.job.IJobScheduler: android.app.job.JobInfo getPendingJob(java.lang.String,int)>
<android.app.job.IJobScheduler: void unregisterUserVisibleJobObserver(android.app.job.IUserVisibleJobObserver)>
<android.app.job.IJobScheduler: boolean hasRunUserInitiatedJobsPermission(java.lang.String,int)>
<android.app.job.IJobScheduler: boolean canRunUserInitiatedJobs(java.lang.String)>
<android.app.job.IJobScheduler: int getPendingJobReason(java.lang.String,int)>
<android.app.job.IJobScheduler: java.util.List getStartedJobs()>
<android.app.job.IJobScheduler: int schedule(java.lang.String,android.app.job.JobInfo)>
<android.app.job.IJobScheduler: int scheduleAsPackage(java.lang.String,android.app.job.JobInfo,java.lang.String,int,java.lang.String)>
<android.app.job.IJobScheduler: java.util.Map getAllPendingJobs()>
<android.app.job.IJobScheduler: void notePendingUserRequestedAppStop(java.lang.String,int,java.lang.String)>
<android.app.job.IJobScheduler: android.content.pm.ParceledListSlice getAllJobSnapshots()>
<android.app.job.IJobScheduler: void registerUserVisibleJobObserver(android.app.job.IUserVisibleJobObserver)>
<android.app.job.IJobScheduler: void cancelAllInNamespace(java.lang.String)>
<android.app.job.IJobScheduler: void cancel(java.lang.String,int)>
<android.app.job.IJobScheduler: void cancelAll()>
<android.app.job.IJobScheduler: int enqueue(java.lang.String,android.app.job.JobInfo,android.app.job.JobWorkItem)>
<android.app.job.IJobScheduler: android.content.pm.ParceledListSlice getAllPendingJobsInNamespace(java.lang.String)>
<android.media.audiopolicy.IAudioPolicyCallback: void notifyAudioFocusGrant(android.media.AudioFocusInfo,int)>
<android.media.audiopolicy.IAudioPolicyCallback: void notifyAudioFocusRequest(android.media.AudioFocusInfo,int)>
<android.media.audiopolicy.IAudioPolicyCallback: void notifyUnregistration()>
<android.media.audiopolicy.IAudioPolicyCallback: void notifyVolumeAdjust(int)>
<android.media.audiopolicy.IAudioPolicyCallback: void notifyAudioFocusAbandon(android.media.AudioFocusInfo)>
<android.media.audiopolicy.IAudioPolicyCallback: void notifyMixStateUpdate(java.lang.String,int)>
<android.media.audiopolicy.IAudioPolicyCallback: void notifyAudioFocusLoss(android.media.AudioFocusInfo,boolean)>
<android.telephony.ICellInfoCallback: void onError(int,java.lang.String,java.lang.String)>
<android.telephony.ICellInfoCallback: void onCellInfo(java.util.List)>
<android.media.soundtrigger_middleware.IAcknowledgeEvent: void eventReceived()>
<android.hardware.camera2.ICameraDeviceUser: android.hardware.camera2.utils.SubmitInfo submitRequestList(android.hardware.camera2.CaptureRequest[],boolean)>
<android.hardware.camera2.ICameraDeviceUser: void deleteStream(int)>
<android.hardware.camera2.ICameraDeviceUser: void tearDown(int)>
<android.hardware.camera2.ICameraDeviceUser: void disconnect()>
<android.hardware.camera2.ICameraDeviceUser: int getGlobalAudioRestriction()>
<android.hardware.camera2.ICameraDeviceUser: android.hardware.camera2.impl.CameraMetadataNative createDefaultRequest(int)>
<android.hardware.camera2.ICameraDeviceUser: void prepare2(int,int)>
<android.hardware.camera2.ICameraDeviceUser: int createStream(android.hardware.camera2.params.OutputConfiguration)>
<android.hardware.camera2.ICameraDeviceUser: android.view.Surface getInputSurface()>
<android.hardware.camera2.ICameraDeviceUser: boolean isSessionConfigurationSupported(android.hardware.camera2.params.SessionConfiguration)>
<android.hardware.camera2.ICameraDeviceUser: android.hardware.camera2.impl.CameraMetadataNative getCameraInfo()>
<android.hardware.camera2.ICameraDeviceUser: void waitUntilIdle()>
<android.hardware.camera2.ICameraDeviceUser: int createInputStream(int,int,int,boolean)>
<android.hardware.camera2.ICameraDeviceUser: void beginConfigure()>
<android.hardware.camera2.ICameraDeviceUser: long cancelRequest(int)>
<android.hardware.camera2.ICameraDeviceUser: void setCameraAudioRestriction(int)>
<android.hardware.camera2.ICameraDeviceUser: void setParameters(java.lang.String)>
<android.hardware.camera2.ICameraDeviceUser: void finalizeOutputConfigurations(int,android.hardware.camera2.params.OutputConfiguration)>
<android.hardware.camera2.ICameraDeviceUser: android.hardware.camera2.utils.SubmitInfo submitRequest(android.hardware.camera2.CaptureRequest,boolean)>
<android.hardware.camera2.ICameraDeviceUser: android.hardware.camera2.ICameraOfflineSession switchToOffline(android.hardware.camera2.ICameraDeviceCallbacks,int[])>
<android.hardware.camera2.ICameraDeviceUser: void updateOutputConfiguration(int,android.hardware.camera2.params.OutputConfiguration)>
<android.hardware.camera2.ICameraDeviceUser: int[] endConfigure(int,android.hardware.camera2.impl.CameraMetadataNative,long)>
<android.hardware.camera2.ICameraDeviceUser: void prepare(int)>
<android.hardware.camera2.ICameraDeviceUser: long flush()>
<android.service.notification.IConditionListener: void onConditionsReceived(android.service.notification.Condition[])>
<android.media.IMediaScannerService: void requestScanFile(java.lang.String,java.lang.String,android.media.IMediaScannerListener)>
<android.media.IMediaScannerService: void scanFile(java.lang.String,java.lang.String)>
<android.sec.enterprise.proxy.IProxyCredentialsCallback: void onAuthenticationResult(int)>
<com.samsung.android.core.pm.containerservice.IContainerService: java.lang.String copyPackageToContainer(java.lang.String,java.lang.String,java.lang.String,boolean,java.lang.String)>
<com.samsung.android.core.pm.containerservice.IContainerService: void doForceGC()>
<android.service.ambientcontext.IAmbientContextDetectionService: void stopDetection(java.lang.String)>
<android.service.ambientcontext.IAmbientContextDetectionService: void startDetection(android.app.ambientcontext.AmbientContextEventRequest,java.lang.String,android.os.RemoteCallback,android.os.RemoteCallback)>
<android.service.ambientcontext.IAmbientContextDetectionService: void queryServiceStatus(int[],java.lang.String,android.os.RemoteCallback)>
<com.samsung.android.knox.zt.devicetrust.IEndpointMonitorListener: void onEventGeneralized(int,java.lang.String)>
<com.samsung.android.knox.zt.devicetrust.IEndpointMonitorListener: void onEventSimplified(int,java.lang.String)>
<com.samsung.android.knox.zt.devicetrust.IEndpointMonitorListener: void onEvent(int,android.os.Bundle)>
<android.sec.clipboard.IClipboardDataPasteEvent: void onPaste(com.samsung.android.content.clipboard.data.SemClipData)>
<android.content.pm.IPackageDeleteObserver: void packageDeleted(java.lang.String,int)>
<com.android.internal.telephony.euicc.IResetMemoryCallback: void onComplete(int)>
<com.android.internal.telecom.ICallRedirectionService: void notifyTimeout()>
<com.android.internal.telecom.ICallRedirectionService: void placeCall(com.android.internal.telecom.ICallRedirectionAdapter,android.net.Uri,android.telecom.PhoneAccountHandle,boolean)>
<android.net.INetworkPolicyManager: void addUidPolicy(int,int)>
<android.net.INetworkPolicyManager: int[] getAllFirewallRuleMobileData()>
<android.net.INetworkPolicyManager: java.lang.String getSubscriptionPlansOwner(int)>
<android.net.INetworkPolicyManager: void setDeviceIdleMode(boolean)>
<android.net.INetworkPolicyManager: boolean isUidRestrictedOnMeteredNetworks(int)>
<android.net.INetworkPolicyManager: void setFirewallRuleWifi(int,boolean)>
<android.net.INetworkPolicyManager: void registerListener(android.net.INetworkPolicyListener)>
<android.net.INetworkPolicyManager: android.telephony.SubscriptionPlan[] getSubscriptionPlans(int,java.lang.String)>
<android.net.INetworkPolicyManager: int getUidPolicy(int)>
<android.net.INetworkPolicyManager: boolean isUidNetworkingBlocked(int,boolean)>
<android.net.INetworkPolicyManager: void setFirewallRuleMobileDataMap(java.util.Map)>
<android.net.INetworkPolicyManager: android.net.NetworkPolicy[] getNetworkPolicies(java.lang.String)>
<android.net.INetworkPolicyManager: boolean getFirewallRuleWifi(int)>
<android.net.INetworkPolicyManager: void setUidPolicy(int,int)>
<android.net.INetworkPolicyManager: void setNetworkPolicies(android.net.NetworkPolicy[])>
<android.net.INetworkPolicyManager: boolean getRestrictBackground()>
<android.net.INetworkPolicyManager: int getMultipathPreference(android.net.Network)>
<android.net.INetworkPolicyManager: void setSubscriptionOverride(int,int,int,int[],long,java.lang.String)>
<android.net.INetworkPolicyManager: void setWifiMeteredOverride(java.lang.String,int)>
<android.net.INetworkPolicyManager: int getRestrictBackgroundByCaller()>
<android.net.INetworkPolicyManager: int[] getUidsWithPolicy(int)>
<android.net.INetworkPolicyManager: void removeUidPolicy(int,int)>
<android.net.INetworkPolicyManager: void unregisterListener(android.net.INetworkPolicyListener)>
<android.net.INetworkPolicyManager: void setRestrictBackground(boolean)>
<android.net.INetworkPolicyManager: android.telephony.SubscriptionPlan getSubscriptionPlan(android.net.NetworkTemplate)>
<android.net.INetworkPolicyManager: void setFirewallRuleMobileData(int,boolean)>
<android.net.INetworkPolicyManager: void factoryReset(java.lang.String)>
<android.net.INetworkPolicyManager: boolean getFirewallRuleMobileData(int)>
<android.net.INetworkPolicyManager: void notifyStatsProviderWarningOrLimitReached()>
<android.net.INetworkPolicyManager: void setSubscriptionPlans(int,android.telephony.SubscriptionPlan[],long,java.lang.String)>
<android.net.INetworkPolicyManager: void snoozeLimit(android.net.NetworkTemplate)>
<android.net.INetworkPolicyManager: int getRestrictBackgroundStatus(int)>
<android.net.INetworkPolicyManager: void setFirewallRuleWifiMap(java.util.Map)>
<android.location.ICountryListener: void onCountryDetected(android.location.Country)>
<android.service.timezone.ITimeZoneProvider: void stopUpdates()>
<android.service.timezone.ITimeZoneProvider: void startUpdates(android.service.timezone.ITimeZoneProviderManager,long,long)>
<android.media.musicrecognition.IMusicRecognitionAttributionTagCallback: void onAttributionTag(java.lang.String)>
<android.security.identity.ICredentialStore: android.security.identity.SecurityHardwareInfoParcel getSecurityHardwareInfo()>
<android.security.identity.ICredentialStore: android.security.identity.IWritableCredential createCredential(java.lang.String,java.lang.String)>
<android.security.identity.ICredentialStore: android.security.identity.ISession createPresentationSession(int)>
<android.security.identity.ICredentialStore: android.security.identity.ICredential getCredentialByName(java.lang.String,int)>
<android.service.autofill.IAutoFillService: void onFillRequest(android.service.autofill.FillRequest,android.service.autofill.IFillCallback)>
<android.service.autofill.IAutoFillService: void onConnectedStateChanged(boolean)>
<android.service.autofill.IAutoFillService: void onSaveRequest(android.service.autofill.SaveRequest,android.service.autofill.ISaveCallback)>
<android.service.autofill.IAutoFillService: void onSavedPasswordCountRequest(com.android.internal.os.IResultReceiver)>
<android.os.IMessenger: void send(android.os.Message)>
<android.hardware.input.ISwitchEventChangedListener: void onSwitchEventChanged(int,int,int,int)>
<android.app.IActivityController: boolean activityResuming(java.lang.String)>
<android.app.IActivityController: int appEarlyNotResponding(java.lang.String,int,java.lang.String)>
<android.app.IActivityController: int systemNotResponding(java.lang.String)>
<android.app.IActivityController: int appNotResponding(java.lang.String,int,java.lang.String)>
<android.app.IActivityController: boolean appCrashed(java.lang.String,int,java.lang.String,java.lang.String,long,java.lang.String)>
<android.app.IActivityController: boolean activityStarting(android.content.Intent,java.lang.String)>
<android.hardware.fingerprint.IUdfpsOverlayController: void onEnrollmentProgress(int,int)>
<android.hardware.fingerprint.IUdfpsOverlayController: void setDebugMessage(int,java.lang.String)>
<android.hardware.fingerprint.IUdfpsOverlayController: void showUdfpsOverlay(long,int,int,android.hardware.fingerprint.IUdfpsOverlayControllerCallback)>
<android.hardware.fingerprint.IUdfpsOverlayController: void onEnrollmentHelp(int)>
<android.hardware.fingerprint.IUdfpsOverlayController: void onAcquired(int,int)>
<android.hardware.fingerprint.IUdfpsOverlayController: void hideUdfpsOverlay(int)>
<android.telephony.mbms.IDownloadStatusListener: void onStatusUpdated(android.telephony.mbms.DownloadRequest,android.telephony.mbms.FileInfo,int)>
<android.hardware.tv.tuner.IDemux: long getAvSyncTime(int)>
<android.hardware.tv.tuner.IDemux: android.hardware.tv.tuner.IFilter openFilter(android.hardware.tv.tuner.DemuxFilterType,int,android.hardware.tv.tuner.IFilterCallback)>
<android.hardware.tv.tuner.IDemux: void close()>
<android.hardware.tv.tuner.IDemux: void connectCiCam(int)>
<android.hardware.tv.tuner.IDemux: void disconnectCiCam()>
<android.hardware.tv.tuner.IDemux: android.hardware.tv.tuner.IDvr openDvr(byte,int,android.hardware.tv.tuner.IDvrCallback)>
<android.hardware.tv.tuner.IDemux: void setFrontendDataSource(int)>
<android.hardware.tv.tuner.IDemux: java.lang.String getInterfaceHash()>
<android.hardware.tv.tuner.IDemux: android.hardware.tv.tuner.ITimeFilter openTimeFilter()>
<android.hardware.tv.tuner.IDemux: int getAvSyncHwId(android.hardware.tv.tuner.IFilter)>
<android.hardware.tv.tuner.IDemux: int getInterfaceVersion()>
<android.service.autofill.IAutofillFieldClassificationService: void calculateScores(android.os.RemoteCallback,java.util.List,java.lang.String[],java.lang.String[],java.lang.String,android.os.Bundle,java.util.Map,java.util.Map)>
<com.samsung.android.camera.iris.IIrisServiceLockoutResetCallback: void onLockoutReset(long)>
<android.media.tv.tunerresourcemanager.ITunerResourceManager: int getConfigPriority(int,boolean)>
<android.media.tv.tunerresourcemanager.ITunerResourceManager: void shareFrontend(int,int)>
<android.media.tv.tunerresourcemanager.ITunerResourceManager: boolean requestDemux(android.media.tv.tunerresourcemanager.TunerDemuxRequest,int[])>
<android.media.tv.tunerresourcemanager.ITunerResourceManager: void unregisterClientProfile(int)>
<android.media.tv.tunerresourcemanager.ITunerResourceManager: boolean requestDescrambler(android.media.tv.tunerresourcemanager.TunerDescramblerRequest,int[])>
<android.media.tv.tunerresourcemanager.ITunerResourceManager: boolean isHigherPriority(android.media.tv.tunerresourcemanager.ResourceClientProfile,android.media.tv.tunerresourcemanager.ResourceClientProfile)>
<android.media.tv.tunerresourcemanager.ITunerResourceManager: void releaseDemux(int,int)>
<android.media.tv.tunerresourcemanager.ITunerResourceManager: boolean acquireLock(int,long)>
<android.media.tv.tunerresourcemanager.ITunerResourceManager: void releaseDescrambler(int,int)>
<android.media.tv.tunerresourcemanager.ITunerResourceManager: void storeResourceMap(int)>
<android.media.tv.tunerresourcemanager.ITunerResourceManager: boolean requestCasSession(android.media.tv.tunerresourcemanager.CasSessionRequest,int[])>
<android.media.tv.tunerresourcemanager.ITunerResourceManager: void releaseCasSession(int,int)>
<android.media.tv.tunerresourcemanager.ITunerResourceManager: boolean transferOwner(int,int,int)>
<android.media.tv.tunerresourcemanager.ITunerResourceManager: void releaseCiCam(int,int)>
<android.media.tv.tunerresourcemanager.ITunerResourceManager: void restoreResourceMap(int)>
<android.media.tv.tunerresourcemanager.ITunerResourceManager: void registerClientProfile(android.media.tv.tunerresourcemanager.ResourceClientProfile,android.media.tv.tunerresourcemanager.IResourcesReclaimListener,int[])>
<android.media.tv.tunerresourcemanager.ITunerResourceManager: void updateCasInfo(int,int)>
<android.media.tv.tunerresourcemanager.ITunerResourceManager: boolean isLowestPriority(int,int)>
<android.media.tv.tunerresourcemanager.ITunerResourceManager: void setFrontendInfoList(android.media.tv.tunerresourcemanager.TunerFrontendInfo[])>
<android.media.tv.tunerresourcemanager.ITunerResourceManager: boolean requestFrontend(android.media.tv.tunerresourcemanager.TunerFrontendRequest,int[])>
<android.media.tv.tunerresourcemanager.ITunerResourceManager: void releaseLnb(int,int)>
<android.media.tv.tunerresourcemanager.ITunerResourceManager: boolean updateClientPriority(int,int,int)>
<android.media.tv.tunerresourcemanager.ITunerResourceManager: void releaseFrontend(int,int)>
<android.media.tv.tunerresourcemanager.ITunerResourceManager: void setDemuxInfoList(android.media.tv.tunerresourcemanager.TunerDemuxInfo[])>
<android.media.tv.tunerresourcemanager.ITunerResourceManager: int getMaxNumberOfFrontends(int)>
<android.media.tv.tunerresourcemanager.ITunerResourceManager: int getClientPriority(int,int)>
<android.media.tv.tunerresourcemanager.ITunerResourceManager: boolean releaseLock(int)>
<android.media.tv.tunerresourcemanager.ITunerResourceManager: boolean requestLnb(android.media.tv.tunerresourcemanager.TunerLnbRequest,int[])>
<android.media.tv.tunerresourcemanager.ITunerResourceManager: boolean hasUnusedFrontend(int)>
<android.media.tv.tunerresourcemanager.ITunerResourceManager: void setLnbInfoList(int[])>
<android.media.tv.tunerresourcemanager.ITunerResourceManager: boolean requestCiCam(android.media.tv.tunerresourcemanager.TunerCiCamRequest,int[])>
<android.media.tv.tunerresourcemanager.ITunerResourceManager: boolean setMaxNumberOfFrontends(int,int)>
<android.media.tv.tunerresourcemanager.ITunerResourceManager: void clearResourceMap(int)>
<android.os.storage.IStorageManager: void format(java.lang.String)>
<android.os.storage.IStorageManager: long getUsedF2fsFileNode()>
<android.os.storage.IStorageManager: void destroyUserStorage(java.lang.String,int,int)>
<android.os.storage.IStorageManager: int semGetExternalSdCardHealthState()>
<android.os.storage.IStorageManager: long getCacheQuotaBytes(java.lang.String,int)>
<android.os.storage.IStorageManager: boolean supportsCheckpoint()>
<android.os.storage.IStorageManager: boolean isSecureContainerMounted(java.lang.String)>
<android.os.storage.IStorageManager: boolean mvFileAtData(java.lang.String,java.lang.String)>
<android.os.storage.IStorageManager: void setVolumeNickname(java.lang.String,java.lang.String)>
<android.os.storage.IStorageManager: int encryptExternalStorage(boolean)>
<android.os.storage.IStorageManager: void forgetVolume(java.lang.String)>
<android.os.storage.IStorageManager: int finalizeSecureContainer(java.lang.String)>
<android.os.storage.IStorageManager: android.os.storage.VolumeRecord[] getVolumeRecords(int)>
<android.os.storage.IStorageManager: android.os.storage.DiskInfo[] getDisks()>
<android.os.storage.IStorageManager: java.lang.String getVolumeState(java.lang.String)>
<android.os.storage.IStorageManager: boolean isUserKeyUnlocked(int)>
<android.os.storage.IStorageManager: android.app.PendingIntent getManageSpaceActivityIntent(java.lang.String,int)>
<android.os.storage.IStorageManager: void disableAppDataIsolation(java.lang.String,int,int)>
<android.os.storage.IStorageManager: boolean setSdpPolicyToPathCmd(int,java.lang.String)>
<android.os.storage.IStorageManager: long getAllocatableBytes(java.lang.String,int,java.lang.String)>
<android.os.storage.IStorageManager: long lastMaintenance()>
<android.os.storage.IStorageManager: void finishMediaUpdate()>
<android.os.storage.IStorageManager: android.os.ParcelFileDescriptor openProxyFileDescriptor(int,int,int)>
<android.os.storage.IStorageManager: void runMaintenance()>
<android.os.storage.IStorageManager: void abortChanges(java.lang.String,boolean)>
<android.os.storage.IStorageManager: int resizeSecureContainer(java.lang.String,int,java.lang.String)>
<android.os.storage.IStorageManager: java.lang.String getSecureContainerFilesystemPath(java.lang.String)>
<android.os.storage.IStorageManager: void mountObb(java.lang.String,java.lang.String,android.os.storage.IObbActionListener,int,android.content.res.ObbInfo)>
<android.os.storage.IStorageManager: void benchmark(java.lang.String,android.os.IVoldTaskListener)>
<android.os.storage.IStorageManager: boolean needsCheckpoint()>
<android.os.storage.IStorageManager: void setUserKeyProtection(int,byte[])>
<android.os.storage.IStorageManager: int renameSecureContainer(java.lang.String,java.lang.String)>
<android.os.storage.IStorageManager: void createUserKey(int,int,boolean)>
<android.os.storage.IStorageManager: int getExternalStorageMountMode(int,java.lang.String)>
<android.os.storage.IStorageManager: void unregisterListener(android.os.storage.IStorageEventListener)>
<android.os.storage.IStorageManager: java.lang.String getSecureContainerPath(java.lang.String)>
<android.os.storage.IStorageManager: void notifyAppIoBlocked(java.lang.String,int,int,int)>
<android.os.storage.IStorageManager: java.lang.String[] getSecureContainerList()>
<android.os.storage.IStorageManager: void waitForAsecScan()>
<android.os.storage.IStorageManager: java.lang.String getCloudMediaProvider()>
<android.os.storage.IStorageManager: android.os.storage.StorageVolume[] getVolumeList(int,java.lang.String,int)>
<android.os.storage.IStorageManager: void partitionPublic(java.lang.String)>
<android.os.storage.IStorageManager: void unmountObb(java.lang.String,boolean,android.os.storage.IObbActionListener,int)>
<android.os.storage.IStorageManager: void abortIdleMaintenance()>
<android.os.storage.IStorageManager: int createSecureContainer(java.lang.String,int,java.lang.String,java.lang.String,int,boolean)>
<android.os.storage.IStorageManager: void prepareUserStorage(java.lang.String,int,int,int)>
<android.os.storage.IStorageManager: void partitionMixed(java.lang.String,int)>
<android.os.storage.IStorageManager: void commitChanges()>
<android.os.storage.IStorageManager: void setDebugFlags(int,int)>
<android.os.storage.IStorageManager: long getCacheSizeBytes(java.lang.String,int)>
<android.os.storage.IStorageManager: int unmountSecureContainer(java.lang.String,boolean)>
<android.os.storage.IStorageManager: android.os.storage.VolumeInfo[] getVolumes(int)>
<android.os.storage.IStorageManager: void mount(java.lang.String)>
<android.os.storage.IStorageManager: void unmountBySecApp(java.lang.String,java.lang.String)>
<android.os.storage.IStorageManager: void notifyAppIoResumed(java.lang.String,int,int,int)>
<android.os.storage.IStorageManager: void forgetAllVolumes()>
<android.os.storage.IStorageManager: boolean isAppIoBlocked(java.lang.String,int,int,int)>
<android.os.storage.IStorageManager: java.lang.String getMountedObbPath(java.lang.String)>
<android.os.storage.IStorageManager: void unmount(java.lang.String)>
<android.os.storage.IStorageManager: boolean cpFileAtData(java.lang.String,java.lang.String)>
<android.os.storage.IStorageManager: boolean isSensitive(java.lang.String)>
<android.os.storage.IStorageManager: void fstrim(int,android.os.IVoldTaskListener)>
<android.os.storage.IStorageManager: void setPrimaryStorageUuid(java.lang.String,android.content.pm.IPackageMoveObserver)>
<android.os.storage.IStorageManager: boolean setSdpPolicyCmd(int)>
<android.os.storage.IStorageManager: void setVolumeUserFlags(java.lang.String,int,int)>
<android.os.storage.IStorageManager: com.android.internal.os.AppFuseMount mountProxyFileDescriptorBridge()>
<android.os.storage.IStorageManager: void destroyUserKey(int)>
<android.os.storage.IStorageManager: java.lang.String getPrimaryStorageUuid()>
<android.os.storage.IStorageManager: void startCheckpoint(int)>
<android.os.storage.IStorageManager: void runIdleMaintenance()>
<android.os.storage.IStorageManager: void lockUserKey(int)>
<android.os.storage.IStorageManager: java.lang.String semGetExternalSdCardId()>
<android.os.storage.IStorageManager: int mountSecureContainer(java.lang.String,java.lang.String,int,boolean)>
<android.os.storage.IStorageManager: boolean setSensitive(int,java.lang.String)>
<android.os.storage.IStorageManager: void unlockUserKey(int,int,byte[],byte[])>
<android.os.storage.IStorageManager: int destroySecureContainer(java.lang.String,boolean)>
<android.os.storage.IStorageManager: boolean isObbMounted(java.lang.String)>
<android.os.storage.IStorageManager: int fixPermissionsSecureContainer(java.lang.String,int,java.lang.String)>
<android.os.storage.IStorageManager: void fixupAppDir(java.lang.String)>
<android.os.storage.IStorageManager: void formatBySecApp(java.lang.String,java.lang.String)>
<android.os.storage.IStorageManager: boolean mountSdpMediaStorageCmd(int)>
<android.os.storage.IStorageManager: void mkdirs(java.lang.String,java.lang.String)>
<android.os.storage.IStorageManager: void setCloudMediaProvider(java.lang.String)>
<android.os.storage.IStorageManager: void shutdown(android.os.storage.IStorageShutdownObserver)>
<android.os.storage.IStorageManager: int mountVolume(java.lang.String)>
<android.os.storage.IStorageManager: void partitionPrivate(java.lang.String)>
<android.os.storage.IStorageManager: int trimSecureContainer(java.lang.String,int,java.lang.String)>
<android.os.storage.IStorageManager: void registerListener(android.os.storage.IStorageEventListener)>
<android.os.storage.IStorageManager: void unmountVolume(java.lang.String,boolean,boolean)>
<android.os.storage.IStorageManager: void allocateBytes(java.lang.String,long,int,java.lang.String)>
<android.os.storage.IStorageManager: int getUsedSpaceSecureContainer(java.lang.String)>
<android.os.storage.IStorageManager: void mountBySecApp(java.lang.String,java.lang.String)>
<android.os.storage.IStorageManager: boolean setDualDARPolicyCmd(int,int)>
<android.service.trust.ITrustAgentService: void onDeviceLocked()>
<android.service.trust.ITrustAgentService: void onUserMayRequestUnlock()>
<android.service.trust.ITrustAgentService: void onTrustTimeout()>
<android.service.trust.ITrustAgentService: void setCallback(android.service.trust.ITrustAgentServiceCallback)>
<android.service.trust.ITrustAgentService: void onUnlockAttempt(boolean)>
<android.service.trust.ITrustAgentService: void onConfigure(java.util.List,android.os.IBinder)>
<android.service.trust.ITrustAgentService: void onDeviceUnlocked()>
<android.service.trust.ITrustAgentService: void onTokenStateReceived(long,int)>
<android.service.trust.ITrustAgentService: void onEscrowTokenAdded(byte[],long,android.os.UserHandle)>
<android.service.trust.ITrustAgentService: void onEscrowTokenRemoved(long,boolean)>
<android.service.trust.ITrustAgentService: void onUnlockLockout(int)>
<android.service.trust.ITrustAgentService: void onUserRequestedUnlock(boolean)>
<android.window.ITransitionPlayer: void transitionAborted(android.os.IBinder)>
<android.window.ITransitionPlayer: void requestStartTransition(android.os.IBinder,android.window.TransitionRequestInfo)>
<android.window.ITransitionPlayer: void onTransitionReady(android.os.IBinder,android.window.TransitionInfo,android.view.SurfaceControl$Transaction,android.view.SurfaceControl$Transaction)>
<android.view.IWindowId: void unregisterFocusObserver(android.view.IWindowFocusObserver)>
<android.view.IWindowId: boolean isFocused()>
<android.view.IWindowId: void registerFocusObserver(android.view.IWindowFocusObserver)>
<android.security.keymaster.IKeyAttestationApplicationIdProvider: android.security.keymaster.KeyAttestationApplicationId getKeyAttestationApplicationId(int)>
<android.app.trust.ITrustManager: boolean isActiveUnlockRunning(int)>
<android.app.trust.ITrustManager: void unlockedByBiometricForUser(int,android.hardware.biometrics.BiometricSourceType)>
<android.app.trust.ITrustManager: boolean isTrustUsuallyManaged(int)>
<android.app.trust.ITrustManager: void registerTrustListener(android.app.trust.ITrustListener)>
<android.app.trust.ITrustManager: boolean isDeviceLocked(int,int)>
<android.app.trust.ITrustManager: void reportUnlockLockout(int,int)>
<android.app.trust.ITrustManager: void clearAllBiometricRecognized(android.hardware.biometrics.BiometricSourceType,int)>
<android.app.trust.ITrustManager: void reportUnlockAttempt(boolean,int)>
<android.app.trust.ITrustManager: void reportUserRequestedUnlock(int,boolean)>
<android.app.trust.ITrustManager: void setDeviceLockedForUser(int,boolean)>
<android.app.trust.ITrustManager: void unregisterTrustListener(android.app.trust.ITrustListener)>
<android.app.trust.ITrustManager: boolean isDeviceSecure(int,int)>
<android.app.trust.ITrustManager: void reportKeyguardShowingChanged()>
<android.app.trust.ITrustManager: void reportEnabledTrustAgentsChanged(int)>
<android.app.trust.ITrustManager: void reportUserMayRequestUnlock(int)>
<vendor.samsung.hardware.radio.data.ISehRadioData: void setDataAllowed(int,boolean,vendor.samsung.hardware.radio.data.SehAllowDataParam)>
<vendor.samsung.hardware.radio.data.ISehRadioData: void setMobileDataSetting(int,boolean,boolean)>
<vendor.samsung.hardware.radio.data.ISehRadioData: int getInterfaceVersion()>
<vendor.samsung.hardware.radio.data.ISehRadioData: java.lang.String getInterfaceHash()>
<vendor.samsung.hardware.radio.data.ISehRadioData: void setResponseFunctions(vendor.samsung.hardware.radio.data.ISehRadioDataResponse,vendor.samsung.hardware.radio.data.ISehRadioDataIndication)>
<com.android.internal.graphics.fonts.IFontManager: android.text.FontConfig getFontConfig()>
<com.android.internal.graphics.fonts.IFontManager: int updateFontFamily(java.util.List,int)>
<com.android.internal.telephony.euicc.IGetSmdsAddressCallback: void onComplete(int,java.lang.String)>
<android.hardware.tv.tuner.ILnb: void close()>
<android.hardware.tv.tuner.ILnb: void sendDiseqcMessage(byte[])>
<android.hardware.tv.tuner.ILnb: void setVoltage(int)>
<android.hardware.tv.tuner.ILnb: java.lang.String getInterfaceHash()>
<android.hardware.tv.tuner.ILnb: void setCallback(android.hardware.tv.tuner.ILnbCallback)>
<android.hardware.tv.tuner.ILnb: void setTone(int)>
<android.hardware.tv.tuner.ILnb: int getInterfaceVersion()>
<android.hardware.tv.tuner.ILnb: void setSatellitePosition(int)>
<com.samsung.android.wifi.ISemWifiDiagnosticsClient: void runDiagnosis(java.lang.String,java.lang.String)>
<com.samsung.android.wifi.ISemWifiDiagnosticsClient: java.util.List setupDelegation(java.lang.String)>
<com.samsung.android.wifi.ISemWifiDiagnosticsClient: void clearHistory()>
<com.samsung.android.wifi.ISemWifiDiagnosticsClient: java.util.List getDiagnosisResults()>
<android.os.IDumpstate: void preDumpUiData(java.lang.String)>
<android.os.IDumpstate: void retrieveBugreport(int,java.lang.String,java.io.FileDescriptor,java.lang.String,android.os.IDumpstateListener)>
<android.os.IDumpstate: void startBugreport(int,java.lang.String,java.io.FileDescriptor,java.io.FileDescriptor,int,int,android.os.IDumpstateListener,boolean)>
<android.os.IDumpstate: void cancelBugreport(int,java.lang.String)>
<android.app.admin.IKeyguardClient: void onCreateKeyguardSurface(android.os.IBinder,android.app.admin.IKeyguardCallback)>
<android.hardware.gnss.IGnssNavigationMessageCallback: int getInterfaceVersion()>
<android.hardware.gnss.IGnssNavigationMessageCallback: java.lang.String getInterfaceHash()>
<android.hardware.gnss.IGnssNavigationMessageCallback: void gnssNavigationMessageCb(android.hardware.gnss.IGnssNavigationMessageCallback$GnssNavigationMessage)>
<android.hardware.ISerialManager: android.os.ParcelFileDescriptor openSerialPort(java.lang.String)>
<android.hardware.ISerialManager: java.lang.String[] getSerialPorts()>
<android.hardware.camera2.extension.ICameraExtensionsProxyService: android.hardware.camera2.extension.IPreviewExtenderImpl initializePreviewExtension(int)>
<android.hardware.camera2.extension.ICameraExtensionsProxyService: void unregisterClient(android.os.IBinder)>
<android.hardware.camera2.extension.ICameraExtensionsProxyService: void initializeSession(android.hardware.camera2.extension.IInitializeSessionCallback)>
<android.hardware.camera2.extension.ICameraExtensionsProxyService: void releaseSession()>
<android.hardware.camera2.extension.ICameraExtensionsProxyService: boolean advancedExtensionsSupported()>
<android.hardware.camera2.extension.ICameraExtensionsProxyService: android.hardware.camera2.extension.IImageCaptureExtenderImpl initializeImageExtension(int)>
<android.hardware.camera2.extension.ICameraExtensionsProxyService: android.hardware.camera2.extension.IAdvancedExtenderImpl initializeAdvancedExtension(int)>
<android.hardware.camera2.extension.ICameraExtensionsProxyService: boolean registerClient(android.os.IBinder)>
<android.hardware.soundtrigger.IRecognitionStatusCallback: void onKeyphraseDetected(android.hardware.soundtrigger.SoundTrigger$KeyphraseRecognitionEvent)>
<android.hardware.soundtrigger.IRecognitionStatusCallback: void onResumeFailed(int)>
<android.hardware.soundtrigger.IRecognitionStatusCallback: void onRecognitionResumed()>
<android.hardware.soundtrigger.IRecognitionStatusCallback: void onRecognitionPaused()>
<android.hardware.soundtrigger.IRecognitionStatusCallback: void onModuleDied()>
<android.hardware.soundtrigger.IRecognitionStatusCallback: void onPauseFailed(int)>
<android.hardware.soundtrigger.IRecognitionStatusCallback: void onGenericSoundTriggerDetected(android.hardware.soundtrigger.SoundTrigger$GenericRecognitionEvent)>
<android.hardware.soundtrigger.IRecognitionStatusCallback: void onPreempted()>
<android.app.ISearchManager: java.util.List getGlobalSearchActivities()>
<android.app.ISearchManager: android.content.ComponentName getGlobalSearchActivity()>
<android.app.ISearchManager: java.util.List getSearchablesInInsightSearch(boolean)>
<android.app.ISearchManager: java.util.List getSearchablesInGlobalSearch()>
<android.app.ISearchManager: void launchAssist(int,android.os.Bundle)>
<android.app.ISearchManager: android.app.SearchableInfo getSearchableInfo(android.content.ComponentName)>
<android.app.ISearchManager: android.content.ComponentName getWebSearchActivity()>
<android.window.IBackAnimationFinishedCallback: void onAnimationFinished(boolean)>
<android.media.tv.ITvInputServiceCallback: void addHdmiInput(int,android.media.tv.TvInputInfo)>
<android.media.tv.ITvInputServiceCallback: void addHardwareInput(int,android.media.tv.TvInputInfo)>
<android.media.tv.ITvInputServiceCallback: void removeHardwareInput(java.lang.String)>
<android.os.IPermissionController: boolean isRuntimePermission(java.lang.String)>
<android.os.IPermissionController: int getPackageUid(java.lang.String,int)>
<android.os.IPermissionController: java.lang.String[] getPackagesForUid(int)>
<android.os.IPermissionController: boolean checkPermission(java.lang.String,int,int)>
<android.os.IPermissionController: int noteOp(java.lang.String,int,java.lang.String)>
<android.hardware.gnss.IAGnssRil: java.lang.String getInterfaceHash()>
<android.hardware.gnss.IAGnssRil: void setRefLocation(android.hardware.gnss.IAGnssRil$AGnssRefLocation)>
<android.hardware.gnss.IAGnssRil: int getInterfaceVersion()>
<android.hardware.gnss.IAGnssRil: void updateNetworkState(android.hardware.gnss.IAGnssRil$NetworkAttributes)>
<android.hardware.gnss.IAGnssRil: void setSetId(int,java.lang.String)>
<android.hardware.gnss.IAGnssRil: void setCallback(android.hardware.gnss.IAGnssRilCallback)>
<android.service.euicc.IGetOtaStatusCallback: void onSuccess(int)>
<com.android.internal.inputmethod.IInputContentUriToken: void release()>
<com.android.internal.inputmethod.IInputContentUriToken: void take()>
<android.media.IMediaHTTPConnection: java.lang.String getUri()>
<android.media.IMediaHTTPConnection: void disconnect()>
<android.media.IMediaHTTPConnection: android.os.IBinder connect(java.lang.String,java.lang.String)>
<android.media.IMediaHTTPConnection: java.lang.String getMIMEType()>
<android.media.IMediaHTTPConnection: long getSize()>
<android.media.IMediaHTTPConnection: int readAt(long,int)>
<android.hardware.location.IActivityRecognitionHardwareClient: void onAvailabilityChanged(boolean,android.hardware.location.IActivityRecognitionHardware)>
<android.nfc.INfcDta: void disableDta()>
<android.nfc.INfcDta: boolean enableServer(java.lang.String,int,int,int,int)>
<android.nfc.INfcDta: void disableServer()>
<android.nfc.INfcDta: boolean registerMessageService(java.lang.String)>
<android.nfc.INfcDta: void disableClient()>
<android.nfc.INfcDta: void enableDta()>
<android.nfc.INfcDta: boolean enableClient(java.lang.String,int,int,int)>
<android.net.wifi.nl80211.ISendMgmtFrameEvent: void OnAck(int)>
<android.net.wifi.nl80211.ISendMgmtFrameEvent: void OnFailure(int)>
<android.telephony.mbms.IStreamingServiceCallback: void onStreamMethodUpdated(int)>
<android.telephony.mbms.IStreamingServiceCallback: void onMediaDescriptionUpdated()>
<android.telephony.mbms.IStreamingServiceCallback: void onBroadcastSignalStrengthUpdated(int)>
<android.telephony.mbms.IStreamingServiceCallback: void onError(int,java.lang.String)>
<android.telephony.mbms.IStreamingServiceCallback: void onStreamStateUpdated(int,int)>
<com.android.internal.telephony.ISub: void setSubscriptionProperty(int,java.lang.String,java.lang.String)>
<com.android.internal.telephony.ISub: java.util.List getSubscriptionInfoListAssociatedWithUser(android.os.UserHandle)>
<com.android.internal.telephony.ISub: boolean isSubscriptionEnabled(int)>
<com.android.internal.telephony.ISub: int setDataRoaming(int,int)>
<com.android.internal.telephony.ISub: int setUsageSetting(int,int,java.lang.String)>
<com.android.internal.telephony.ISub: java.lang.String getPhoneNumberFromFirstAvailableSource(int,java.lang.String,java.lang.String)>
<com.android.internal.telephony.ISub: void setUiccApplicationsEnabled(boolean,int)>
<com.android.internal.telephony.ISub: int setDisplayNameUsingSrc(java.lang.String,int,int)>
<com.android.internal.telephony.ISub: int getPreferredDataSubscriptionId()>
<com.android.internal.telephony.ISub: void setDefaultDataSubId(int)>
<com.android.internal.telephony.ISub: java.util.List getOpportunisticSubscriptions(java.lang.String,java.lang.String)>
<com.android.internal.telephony.ISub: void setPreferredDataSubscriptionId(int,boolean,com.android.internal.telephony.ISetOpportunisticDataCallback)>
<com.android.internal.telephony.ISub: int getActiveSubInfoCountMax()>
<com.android.internal.telephony.ISub: android.telephony.SubscriptionInfo getActiveSubscriptionInfo(int,java.lang.String,java.lang.String)>
<com.android.internal.telephony.ISub: java.lang.String getPhoneNumber(int,int,java.lang.String,java.lang.String)>
<com.android.internal.telephony.ISub: android.telephony.SubscriptionInfo getActiveSubscriptionInfoForIccId(java.lang.String,java.lang.String,java.lang.String)>
<com.android.internal.telephony.ISub: java.util.List getAvailableSubscriptionInfoList(java.lang.String,java.lang.String)>
<com.android.internal.telephony.ISub: int setIconTint(int,int)>
<com.android.internal.telephony.ISub: void removeSubscriptionsFromGroup(int[],android.os.ParcelUuid,java.lang.String)>
<com.android.internal.telephony.ISub: android.os.ParcelUuid createSubscriptionGroup(int[],java.lang.String)>
<com.android.internal.telephony.ISub: android.os.UserHandle getSubscriptionUserHandle(int)>
<com.android.internal.telephony.ISub: int setDeviceToDeviceStatusSharing(int,int)>
<com.android.internal.telephony.ISub: int setSubscriptionUserHandle(android.os.UserHandle,int)>
<com.android.internal.telephony.ISub: void restoreAllSimSpecificSettingsFromBackup(byte[])>
<com.android.internal.telephony.ISub: int getDefaultSmsSubId()>
<com.android.internal.telephony.ISub: void requestEmbeddedSubscriptionInfoListRefresh(int)>
<com.android.internal.telephony.ISub: java.lang.String getSubscriptionProperty(int,java.lang.String,java.lang.String,java.lang.String)>
<com.android.internal.telephony.ISub: java.util.List getAccessibleSubscriptionInfoList(java.lang.String)>
<com.android.internal.telephony.ISub: boolean isActiveSubId(int,java.lang.String,java.lang.String)>
<com.android.internal.telephony.ISub: void setDefaultVoiceSubId(int)>
<com.android.internal.telephony.ISub: android.telephony.SubscriptionInfo getActiveSubscriptionInfoForSimSlotIndex(int,java.lang.String,java.lang.String)>
<com.android.internal.telephony.ISub: java.util.List getAllSubInfoList(java.lang.String,java.lang.String)>
<com.android.internal.telephony.ISub: java.util.List getSubscriptionsInGroup(android.os.ParcelUuid,java.lang.String,java.lang.String)>
<com.android.internal.telephony.ISub: int getDefaultVoiceSubId()>
<com.android.internal.telephony.ISub: int getActiveSubInfoCount(java.lang.String,java.lang.String)>
<com.android.internal.telephony.ISub: int getSlotIndex(int)>
<com.android.internal.telephony.ISub: int getDefaultSubId()>
<com.android.internal.telephony.ISub: int getEnabledSubscriptionId(int)>
<com.android.internal.telephony.ISub: int setDeviceToDeviceStatusSharingContacts(java.lang.String,int)>
<com.android.internal.telephony.ISub: int setDisplayNumber(java.lang.String,int)>
<com.android.internal.telephony.ISub: boolean canDisablePhysicalSubscription()>
<com.android.internal.telephony.ISub: int addSubInfo(java.lang.String,java.lang.String,int,int)>
<com.android.internal.telephony.ISub: int getDefaultDataSubId()>
<com.android.internal.telephony.ISub: boolean removeSubInfo(java.lang.String,int)>
<com.android.internal.telephony.ISub: boolean isSubscriptionAssociatedWithUser(int,android.os.UserHandle)>
<com.android.internal.telephony.ISub: void setPhoneNumber(int,int,java.lang.String,java.lang.String,java.lang.String)>
<com.android.internal.telephony.ISub: java.util.List getActiveSubscriptionInfoList(java.lang.String,java.lang.String)>
<com.android.internal.telephony.ISub: int getActiveDataSubscriptionId()>
<com.android.internal.telephony.ISub: void setDefaultSmsSubId(int)>
<com.android.internal.telephony.ISub: int setOpportunistic(boolean,int,java.lang.String)>
<com.android.internal.telephony.ISub: void addSubscriptionsIntoGroup(int[],android.os.ParcelUuid,java.lang.String)>
<com.android.internal.telephony.ISub: int[] getActiveSubIdList(boolean)>
<com.android.internal.telephony.ISub: int getSubId(int)>
<com.android.internal.telephony.ISub: int getPhoneId(int)>
<android.app.IActivityManager: void killBackgroundProcesses(java.lang.String,int)>
<android.app.IActivityManager: void suppressResizeConfigChanges(boolean)>
<android.app.IActivityManager: void requestWifiBugReport(java.lang.String,java.lang.String)>
<android.app.IActivityManager: boolean isIntentSenderAnActivity(android.content.IIntentSender)>
<android.app.IActivityManager: int sendIntentSender(android.app.IApplicationThread,android.content.IIntentSender,android.os.IBinder,int,android.content.Intent,java.lang.String,android.content.IIntentReceiver,java.lang.String,android.os.Bundle)>
<android.app.IActivityManager: android.os.Bundle getOptionsForIntentSender(android.content.IIntentSender)>
<android.app.IActivityManager: boolean isScaledAppByPackageName(java.lang.String)>
<android.app.IActivityManager: void waitForBroadcastBarrier()>
<android.app.IActivityManager: int stopUser(int,boolean,android.app.IStopUserCallback)>
<android.app.IActivityManager: void setActivityLocusContext(android.content.ComponentName,android.content.LocusId,android.os.IBinder)>
<android.app.IActivityManager: void updatePersistentConfiguration(android.content.res.Configuration)>
<android.app.IActivityManager: void noteAlarmStart(android.content.IIntentSender,android.os.WorkSource,int,java.lang.String)>
<android.app.IActivityManager: void grantUriPermission(android.app.IApplicationThread,java.lang.String,android.net.Uri,int,int)>
<android.app.IActivityManager: boolean shutdown(int)>
<android.app.IActivityManager: java.lang.String getSwitchingFromUserMessage()>
<android.app.IActivityManager: void dumpHeapFinished(java.lang.String)>
<android.app.IActivityManager: void unregisterReceiver(android.content.IIntentReceiver)>
<android.app.IActivityManager: void setTaskResizeable(int,int)>
<android.app.IActivityManager: void cancelTaskWindowTransition(int)>
<android.app.IActivityManager: int checkPermission(java.lang.String,int,int)>
<android.app.IActivityManager: android.content.pm.ParceledListSlice getRecentTasks(int,int,int)>
<android.app.IActivityManager: java.util.List getRunningAppProcesses()>
<android.app.IActivityManager: boolean profileControl(java.lang.String,int,boolean,android.app.ProfilerInfo,int)>
<android.app.IActivityManager: void addPackageData(java.lang.String,float)>
<android.app.IActivityManager: boolean stopProfile(int)>
<android.app.IActivityManager: boolean stopServiceToken(android.content.ComponentName,android.os.IBinder,int)>
<android.app.IActivityManager: void registerStrictModeCallback(android.os.IBinder)>
<android.app.IActivityManager: void requestSystemServerHeapDump()>
<android.app.IActivityManager: void removeContentProviderExternal(java.lang.String,android.os.IBinder)>
<android.app.IActivityManager: int restartUserInBackground(int,int)>
<android.app.IActivityManager: android.app.ActivityManager$PendingIntentInfo getInfoForIntentSender(android.content.IIntentSender)>
<android.app.IActivityManager: void handleApplicationCrash(android.os.IBinder,android.app.ApplicationErrorReport$ParcelableCrashInfo)>
<android.app.IActivityManager: boolean startUserInBackground(int)>
<android.app.IActivityManager: void forceStopPackageByAdmin(java.lang.String,int)>
<android.app.IActivityManager: java.util.List getRestrictableList(int)>
<android.app.IActivityManager: boolean isFreezableUid(int)>
<android.app.IActivityManager: boolean removeTask(int)>
<android.app.IActivityManager: void unregisterProcessObserver(android.app.IProcessObserver)>
<android.app.IActivityManager: boolean unlockUser(int,byte[],byte[],android.os.IProgressListener)>
<android.app.IActivityManager: int getCurrentUserId()>
<android.app.IActivityManager: void setDebugApp(java.lang.String,boolean,boolean)>
<android.app.IActivityManager: int[] getRunningUserIds()>
<android.app.IActivityManager: java.util.List getServices(int,int)>
<android.app.IActivityManager: java.util.List getRunningExternalApplications()>
<android.app.IActivityManager: android.graphics.Rect getTaskBounds(int)>
<android.app.IActivityManager: void killPackageDependents(java.lang.String,int)>
<android.app.IActivityManager: void signalPersistentProcesses(int)>
<android.app.IActivityManager: void logFgsApiEnd(int,int,int)>
<android.app.IActivityManager: java.lang.String getLaunchedFromPackage(android.os.IBinder)>
<android.app.IActivityManager: void setActivityController(android.app.IActivityController,boolean)>
<android.app.IActivityManager: void appNotRespondingViaProvider(android.os.IBinder)>
<android.app.IActivityManager: int[] getUidFrozenState(int[])>
<android.app.IActivityManager: void startSystemLockTaskMode(int)>
<android.app.IActivityManager: void scheduleApplicationInfoChanged(java.util.List,int)>
<android.app.IActivityManager: boolean moveTaskToBack(int,boolean)>
<android.app.IActivityManager: void unbroadcastIntent(android.app.IApplicationThread,android.content.Intent,int)>
<android.app.IActivityManager: boolean bindBackupAgent(java.lang.String,int,int,int)>
<android.app.IActivityManager: void setPersistentVrThread(int)>
<android.app.IActivityManager: void killAllBackgroundProcesses()>
<android.app.IActivityManager: void registerUidObserver(android.app.IUidObserver,int,int,java.lang.String)>
<android.app.IActivityManager: void setAgentApp(java.lang.String,java.lang.String)>
<android.app.IActivityManager: android.os.IBinder peekService(android.content.Intent,java.lang.String,java.lang.String)>
<android.app.IActivityManager: void requestBugReportWithDescription(java.lang.String,java.lang.String,int)>
<android.app.IActivityManager: void makePackageIdle(java.lang.String,int)>
<android.app.IActivityManager: android.os.IBinder registerUidObserverForUids(android.app.IUidObserver,int,int,java.lang.String,int[])>
<android.app.IActivityManager: android.os.Debug$MemoryInfo[] getProcessMemoryInfo(int[])>
<android.app.IActivityManager: boolean isProcessFrozen(int)>
<android.app.IActivityManager: void enterSafeMode()>
<android.app.IActivityManager: boolean registerForegroundServiceObserver(android.app.IForegroundServiceObserver)>
<android.app.IActivityManager: boolean setFGSFilter(int,boolean)>
<android.app.IActivityManager: void removeApplicationStartInfoCompleteListener(int)>
<android.app.IActivityManager: void addUidToObserver(android.os.IBinder,java.lang.String,int)>
<android.app.IActivityManager: void attachApplication(android.app.IApplicationThread,long)>
<android.app.IActivityManager: boolean shouldServiceTimeOut(android.content.ComponentName,android.os.IBinder)>
<android.app.IActivityManager: android.os.ParcelFileDescriptor getLifeMonitor()>
<android.app.IActivityManager: void removeUidFromObserver(android.os.IBinder,java.lang.String,int)>
<android.app.IActivityManager: void revokeUriPermission(android.app.IApplicationThread,java.lang.String,android.net.Uri,int,int)>
<android.app.IActivityManager: boolean isScaledApp(int)>
<android.app.IActivityManager: void removeContentProvider(android.os.IBinder,boolean)>
<android.app.IActivityManager: boolean canRestrict(int,java.lang.String,int)>
<android.app.IActivityManager: boolean launchBugReportHandlerApp()>
<android.app.IActivityManager: android.content.res.Configuration getGlobalConfiguration()>
<android.app.IActivityManager: void closeSystemDialogsInDisplay(java.lang.String,int)>
<android.app.IActivityManager: boolean setProcessSlowdown(int,boolean)>
<android.app.IActivityManager: boolean updateMccMncConfiguration(java.lang.String,java.lang.String)>
<android.app.IActivityManager: void forceStopPackageEvenWhenStopping(java.lang.String,int)>
<android.app.IActivityManager: boolean unlockUser2(int,android.os.IProgressListener)>
<android.app.IActivityManager: android.app.ActivityTaskManager$RootTaskInfo getFocusedRootTaskInfo()>
<android.app.IActivityManager: boolean updateRestrictionInfo(com.samsung.android.sdhms.SemAppRestrictionManager$RestrictionInfo,java.util.List)>
<android.app.IActivityManager: void unregisterUserSwitchObserver(android.app.IUserSwitchObserver)>
<android.app.IActivityManager: void backupAgentCreated(java.lang.String,android.os.IBinder,int)>
<android.app.IActivityManager: void killUidForPermissionChange(int,int,java.lang.String)>
<android.app.IActivityManager: void setTTSPkgInfo(int)>
<android.app.IActivityManager: int stopService(android.app.IApplicationThread,android.content.Intent,java.lang.String,int)>
<android.app.IActivityManager: boolean stopBinderTrackingAndDump(android.os.ParcelFileDescriptor)>
<android.app.IActivityManager: void sendIdleJobTrigger()>
<android.app.IActivityManager: void setFocusedRootTask(int)>
<android.app.IActivityManager: boolean enableFgsNotificationRateLimit(boolean)>
<android.app.IActivityManager: com.samsung.android.sdhms.SemAppRestrictionManager$RestrictionInfo getRestrictionInfo(int,java.lang.String,int)>
<android.app.IActivityManager: void setProcessLimit(int)>
<android.app.IActivityManager: void updateServiceGroup(android.app.IServiceConnection,int,int)>
<android.app.IActivityManager: java.lang.String getPackageFromAppProcesses(int)>
<android.app.IActivityManager: void notifyLockedProfile(int)>
<android.app.IActivityManager: int getBackgroundRestrictionExemptionReason(int)>
<android.app.IActivityManager: boolean isUidActive(int,java.lang.String)>
<android.app.IActivityManager: void startDelegateShellPermissionIdentity(int,java.lang.String[])>
<android.app.IActivityManager: void updateFlingerFlag(int,java.lang.String)>
<android.app.IActivityManager: void bootAnimationComplete()>
<android.app.IActivityManager: void handleApplicationStrictModeViolation(android.os.IBinder,int,android.os.StrictMode$ViolationInfo)>
<android.app.IActivityManager: void setRenderThread(int)>
<android.app.IActivityManager: boolean getAutoRemoveRecents(int)>
<android.app.IActivityManager: java.util.List getLongLiveProcessesForUser(int)>
<android.app.IActivityManager: void unbindFinished(android.os.IBinder,android.content.Intent,boolean)>
<android.app.IActivityManager: void checkProfileForADCP(int,java.lang.String)>
<android.app.IActivityManager: int getMemoryTrimLevel()>
<android.app.IActivityManager: void getMyMemoryState(android.app.ActivityManager$RunningAppProcessInfo)>
<android.app.IActivityManager: void showWaitingForDebugger(android.app.IApplicationThread,boolean)>
<android.app.IActivityManager: void waitForNetworkStateUpdate(long)>
<android.app.IActivityManager: int getForegroundServiceType(android.content.ComponentName,android.os.IBinder)>
<android.app.IActivityManager: int getLockTaskModeState()>
<android.app.IActivityManager: boolean isBackgroundRestricted(java.lang.String)>
<android.app.IActivityManager: boolean isUserAMonkey()>
<android.app.IActivityManager: void resumeAppSwitches()>
<android.app.IActivityManager: void setServiceForeground(android.content.ComponentName,android.os.IBinder,int,android.app.Notification,int,int)>
<android.app.IActivityManager: float getScalingFactor(java.lang.String)>
<android.app.IActivityManager: int checkUriPermission(android.net.Uri,int,int,int,int,android.os.IBinder)>
<android.app.IActivityManager: void killApplicationProcess(java.lang.String,int)>
<android.app.IActivityManager: void setStopUserOnSwitch(int)>
<android.app.IActivityManager: android.content.pm.ParceledListSlice getHistoricalProcessStartReasons(java.lang.String,int,int)>
<android.app.IActivityManager: int stopUserWithDelayedLocking(int,boolean,android.app.IStopUserCallback)>
<android.app.IActivityManager: int broadcastIntentWithFeature(android.app.IApplicationThread,java.lang.String,android.content.Intent,java.lang.String,android.content.IIntentReceiver,int,java.lang.String,android.os.Bundle,java.lang.String[],java.lang.String[],java.lang.String[],int,android.os.Bundle,boolean,boolean,int)>
<android.app.IActivityManager: boolean enableAppFreezer(boolean)>
<android.app.IActivityManager: boolean clearRestrictionInfo(java.util.List)>
<android.app.IActivityManager: void finishReceiver(android.os.IBinder,int,java.lang.String,android.os.Bundle,boolean,int)>
<android.app.IActivityManager: java.util.List getBugreportWhitelistedPackages()>
<android.app.IActivityManager: void setUserIsMonkey(boolean)>
<android.app.IActivityManager: void requestBugReport(int)>
<android.app.IActivityManager: boolean refContentProvider(android.os.IBinder,int,int)>
<android.app.IActivityManager: boolean startProfile(int)>
<android.app.IActivityManager: void hang(android.os.IBinder,boolean)>
<android.app.IActivityManager: boolean restrict(int,int,boolean,java.lang.String,int)>
<android.app.IActivityManager: void moveTaskToRootTask(int,int,boolean)>
<android.app.IActivityManager: void unstableProviderDied(android.os.IBinder)>
<android.app.IActivityManager: void addPackageDependency(java.lang.String)>
<android.app.IActivityManager: void unbindBackupAgent(android.content.pm.ApplicationInfo)>
<android.app.IActivityManager: int startActivityAsUser(android.app.IApplicationThread,java.lang.String,android.content.Intent,java.lang.String,android.os.IBinder,java.lang.String,int,int,android.app.ProfilerInfo,android.os.Bundle,int)>
<android.app.IActivityManager: int startActivity(android.app.IApplicationThread,java.lang.String,android.content.Intent,java.lang.String,android.os.IBinder,java.lang.String,int,int,android.app.ProfilerInfo,android.os.Bundle)>
<android.app.IActivityManager: void requestRemoteBugReport(long)>
<android.app.IActivityManager: void restart()>
<android.app.IActivityManager: void setHasTopUi(boolean)>
<android.app.IActivityManager: android.content.Intent registerReceiverWithFeature(android.app.IApplicationThread,java.lang.String,java.lang.String,java.lang.String,android.content.IIntentReceiver,android.content.IntentFilter,java.lang.String,int,int)>
<android.app.IActivityManager: void registerProcessObserver(android.app.IProcessObserver)>
<android.app.IActivityManager: java.util.List getDelegatedShellPermissions()>
<android.app.IActivityManager: void killApplication(java.lang.String,int,int,java.lang.String,int)>
<android.app.IActivityManager: void startConfirmDeviceCredentialIntent(android.content.Intent,android.os.Bundle)>
<android.app.IActivityManager: void registerTaskStackListener(android.app.ITaskStackListener)>
<android.app.IActivityManager: void setDumpHeapDebugLimit(java.lang.String,int,long,java.lang.String)>
<android.app.IActivityManager: boolean isTopOfTask(android.os.IBinder)>
<android.app.IActivityManager: boolean startInstrumentation(android.content.ComponentName,java.lang.String,int,android.os.Bundle,android.app.IInstrumentationWatcher,android.app.IUiAutomationConnection,int,java.lang.String)>
<android.app.IActivityManager: void updateLockTaskPackages(int,java.lang.String[])>
<android.app.IActivityManager: void registerUidFrozenStateChangedCallback(android.app.IUidFrozenStateChangedCallback)>
<android.app.IActivityManager: java.lang.String getLongLiveApp()>
<android.app.IActivityManager: int getUidProcessState(int,java.lang.String)>
<android.app.IActivityManager: boolean handleApplicationWtf(android.os.IBinder,java.lang.String,boolean,android.app.ApplicationErrorReport$ParcelableCrashInfo,int)>
<android.app.IActivityManager: void requestTelephonyBugReport(java.lang.String,java.lang.String)>
<android.app.IActivityManager: boolean dumpHeap(java.lang.String,int,boolean,boolean,boolean,java.lang.String,android.os.ParcelFileDescriptor,android.os.RemoteCallback)>
<android.app.IActivityManager: int getProcessLimit()>
<android.app.IActivityManager: boolean isAppFreezerSupported()>
<android.app.IActivityManager: void resizeTask(int,android.graphics.Rect,int)>
<android.app.IActivityManager: void resetAbnormalList()>
<android.app.IActivityManager: int bindServiceInstance(android.app.IApplicationThread,android.os.IBinder,android.content.Intent,java.lang.String,android.app.IServiceConnection,long,java.lang.String,java.lang.String,int)>
<android.app.IActivityManager: void unregisterTaskStackListener(android.app.ITaskStackListener)>
<android.app.IActivityManager: java.util.List getRestrictedList(int)>
<android.app.IActivityManager: int getTaskForActivity(android.os.IBinder,boolean)>
<android.app.IActivityManager: boolean setLongLiveApp(java.lang.String)>
<android.app.IActivityManager: int getLaunchedFromUid(android.os.IBinder)>
<android.app.IActivityManager: void setAlwaysFinish(boolean)>
<android.app.IActivityManager: void publishService(android.os.IBinder,android.content.Intent,android.os.IBinder)>
<android.app.IActivityManager: void performIdleMaintenance()>
<android.app.IActivityManager: android.content.Intent registerReceiver(android.app.IApplicationThread,java.lang.String,android.content.IIntentReceiver,android.content.IntentFilter,java.lang.String,int,int)>
<android.app.IActivityManager: java.util.List getAllRestrictedList()>
<android.app.IActivityManager: void preloadBoosterAppsFromIpm(java.util.List,int)>
<android.app.IActivityManager: void setProcessStateSummary(byte[])>
<android.app.IActivityManager: java.lang.String[] queryRegisteredReceiverPackages(android.content.Intent,java.lang.String,int)>
<android.app.IActivityManager: void setDeterministicUidIdle(boolean)>
<android.app.IActivityManager: void stopAppSwitches()>
<android.app.IActivityManager: void unregisterUidObserver(android.app.IUidObserver)>
<android.app.IActivityManager: void requestInteractiveBugReport()>
<android.app.IActivityManager: long[] getProcessPss(int[])>
<android.app.IActivityManager: void logFgsApiStateChanged(int,int,int,int)>
<android.app.IActivityManager: void getMemoryInfo(android.app.ActivityManager$MemoryInfo)>
<android.app.IActivityManager: void forceDelayBroadcastDelivery(java.lang.String,long)>
<android.app.IActivityManager: void setApplicationStartInfoCompleteListener(android.app.IApplicationStartInfoCompleteListener,int)>
<android.app.IActivityManager: void updatePersistentConfigurationWithAttribution(android.content.res.Configuration,java.lang.String,java.lang.String)>
<android.app.IActivityManager: java.util.List getLongLiveApps()>
<android.app.IActivityManager: android.content.pm.ParceledListSlice getHistoricalProcessExitReasons(java.lang.String,int,int,int)>
<android.app.IActivityManager: void dismissUserSwitchingDialog(int)>
<android.app.IActivityManager: java.util.List getLongLiveTaskIdsForUser(int)>
<android.app.IActivityManager: int startActivityFromRecents(int,android.os.Bundle)>
<android.app.IActivityManager: boolean startUserInBackgroundWithListener(int,android.os.IProgressListener)>
<android.app.IActivityManager: boolean isModernBroadcastQueueEnabled()>
<android.app.IActivityManager: void registerDedicatedCallback(android.os.RemoteCallback,int)>
<android.app.IActivityManager: android.app.ContentProviderHolder getContentProvider(android.app.IApplicationThread,java.lang.String,java.lang.String,int,boolean)>
<android.app.IActivityManager: void showBootMessage(java.lang.CharSequence,boolean)>
<android.app.IActivityManager: int startActivityAsUserWithFeature(android.app.IApplicationThread,java.lang.String,java.lang.String,android.content.Intent,java.lang.String,android.os.IBinder,java.lang.String,int,int,android.app.ProfilerInfo,android.os.Bundle,int)>
<android.app.IActivityManager: android.content.ComponentName startService(android.app.IApplicationThread,android.content.Intent,java.lang.String,boolean,java.lang.String,java.lang.String,int)>
<android.app.IActivityManager: int[] getDisplayIdsForStartingVisibleBackgroundUsers()>
<android.app.IActivityManager: void setRequestedOrientation(android.os.IBinder,int)>
<android.app.IActivityManager: int broadcastIntent(android.app.IApplicationThread,android.content.Intent,java.lang.String,android.content.IIntentReceiver,int,java.lang.String,android.os.Bundle,java.lang.String[],int,android.os.Bundle,boolean,boolean,int)>
<android.app.IActivityManager: boolean startBinderTracking()>
<android.app.IActivityManager: void backgroundAllowlistUid(int)>
<android.app.IActivityManager: void holdLock(android.os.IBinder,int)>
<android.app.IActivityManager: int getPackageProcessState(java.lang.String,java.lang.String)>
<android.app.IActivityManager: int getMaxLongLiveApps()>
<android.app.IActivityManager: android.os.ParcelFileDescriptor openContentUri(java.lang.String)>
<android.app.IActivityManager: void moveTaskToFront(android.app.IApplicationThread,java.lang.String,int,int,android.os.Bundle)>
<android.app.IActivityManager: boolean addLongLiveApp(java.lang.String)>
<android.app.IActivityManager: int[] checkUriPermissions(java.util.List,int,int,int,int,android.os.IBinder)>
<android.app.IActivityManager: void unregisterIntentSenderCancelListener(android.content.IIntentSender,com.android.internal.os.IResultReceiver)>
<android.app.IActivityManager: android.app.PendingIntent getRunningServiceControlPanel(android.content.ComponentName)>
<android.app.IActivityManager: void showAllDSSInfo()>
<android.app.IActivityManager: void requestFullBugReport()>
<android.app.IActivityManager: android.content.Intent getIntentForIntentSender(android.content.IIntentSender)>
<android.app.IActivityManager: void killProcessesWhenImperceptible(int[],java.lang.String)>
<android.app.IActivityManager: void publishContentProviders(android.app.IApplicationThread,java.util.List)>
<android.app.IActivityManager: android.content.pm.UserInfo getCurrentUser()>
<android.app.IActivityManager: boolean setLongLiveTask(int)>
<android.app.IActivityManager: boolean isAppFreezerEnabled()>
<android.app.IActivityManager: boolean switchUser(int)>
<android.app.IActivityManager: boolean clearLongLiveTask(int)>
<android.app.IActivityManager: android.content.IIntentSender getIntentSender(int,java.lang.String,android.os.IBinder,java.lang.String,int,android.content.Intent[],java.lang.String[],int,android.os.Bundle,int)>
<android.app.IActivityManager: void setPackageScreenCompatMode(java.lang.String,int)>
<android.app.IActivityManager: boolean startProfileWithListener(int,android.os.IProgressListener)>
<android.app.IActivityManager: void logFgsApiBegin(int,int,int)>
<android.app.IActivityManager: boolean startUserInBackgroundVisibleOnDisplay(int,int,android.os.IProgressListener)>
<android.app.IActivityManager: void finishHeavyWeightApp()>
<android.app.IActivityManager: void crashApplicationWithType(int,int,java.lang.String,int,java.lang.String,boolean,int)>
<android.app.IActivityManager: boolean isVrModePackageEnabled(android.content.ComponentName)>
<android.app.IActivityManager: void noteAlarmFinish(android.content.IIntentSender,android.os.WorkSource,int,java.lang.String)>
<android.app.IActivityManager: void registerUserSwitchObserver(android.app.IUserSwitchObserver,java.lang.String)>
<android.app.IActivityManager: void appNotResponding(java.lang.String)>
<android.app.IActivityManager: void notifyCleartextNetwork(int,byte[])>
<android.app.IActivityManager: void requestInteractiveBugReportWithDescription(java.lang.String,java.lang.String)>
<android.app.IActivityManager: void serviceDoneExecuting(android.os.IBinder,int,int,int)>
<android.app.IActivityManager: void forceStopPackage(java.lang.String,int)>
<android.app.IActivityManager: void clearTTSPkgInfo()>
<android.app.IActivityManager: void setDssForPackage(java.lang.String,float)>
<android.app.IActivityManager: boolean moveTaskToBackWithBundle(int,boolean,android.os.Bundle)>
<android.app.IActivityManager: android.content.res.Configuration getConfiguration()>
<android.app.IActivityManager: boolean setProcessMemoryTrimLevel(java.lang.String,int,int)>
<android.app.IActivityManager: void getMimeTypeFilterAsync(android.net.Uri,int,android.os.RemoteCallback)>
<android.app.IActivityManager: void unregisterUidFrozenStateChangedCallback(android.app.IUidFrozenStateChangedCallback)>
<android.app.IActivityManager: void finishAttachApplication(long)>
<android.app.IActivityManager: android.content.pm.ParceledListSlice queryIntentComponentsForIntentSender(android.content.IIntentSender,int)>
<android.app.IActivityManager: void addInstrumentationResults(android.app.IApplicationThread,android.os.Bundle)>
<android.app.IActivityManager: boolean killProcessesBelowForeground(java.lang.String)>
<android.app.IActivityManager: boolean isIntentSenderTargetedToPackage(android.content.IIntentSender)>
<android.app.IActivityManager: void stopAppForUser(java.lang.String,int)>
<android.app.IActivityManager: void removeContentProviderExternalAsUser(java.lang.String,android.os.IBinder,int)>
<android.app.IActivityManager: void waitForBroadcastIdle()>
<android.app.IActivityManager: boolean moveActivityTaskToBack(android.os.IBinder,boolean)>
<android.app.IActivityManager: int getUidProcessCapabilities(int,java.lang.String)>
<android.app.IActivityManager: java.lang.String getTagForIntentSender(android.content.IIntentSender,java.lang.String)>
<android.app.IActivityManager: boolean registerIntentSenderCancelListenerEx(android.content.IIntentSender,com.android.internal.os.IResultReceiver)>
<android.app.IActivityManager: void setProcessImportant(android.os.IBinder,int,boolean,java.lang.String)>
<android.app.IActivityManager: void updatePersistentConfigurationAndLocaleOverlays(android.content.res.Configuration,java.lang.String,java.lang.String,android.os.LocaleList)>
<android.app.IActivityManager: void crashApplicationWithTypeWithExtras(int,int,java.lang.String,int,java.lang.String,boolean,int,android.os.Bundle)>
<android.app.IActivityManager: void stopDelegateShellPermissionIdentity()>
<android.app.IActivityManager: java.util.List getLongLiveProcesses()>
<android.app.IActivityManager: boolean unbindService(android.app.IServiceConnection)>
<android.app.IActivityManager: android.content.IIntentSender getIntentSenderWithFeature(int,java.lang.String,java.lang.String,android.os.IBinder,java.lang.String,int,android.content.Intent[],java.lang.String[],int,android.os.Bundle,int)>
<android.app.IActivityManager: boolean clearApplicationUserData(java.lang.String,boolean,android.content.pm.IPackageDataObserver,int)>
<android.app.IActivityManager: void noteWakeupAlarm(android.content.IIntentSender,android.os.WorkSource,int,java.lang.String,java.lang.String)>
<android.app.IActivityManager: void closeSystemDialogs(java.lang.String)>
<android.app.IActivityManager: boolean finishActivity(android.os.IBinder,int,android.content.Intent,int)>
<android.app.IActivityManager: boolean removeLongLiveApp(java.lang.String)>
<android.app.IActivityManager: java.util.List getTasks(int)>
<android.app.IActivityManager: int startActivityWithFeature(android.app.IApplicationThread,java.lang.String,java.lang.String,android.content.Intent,java.lang.String,android.os.IBinder,java.lang.String,int,int,android.app.ProfilerInfo,android.os.Bundle)>
<android.app.IActivityManager: int handleIncomingUser(int,int,int,boolean,boolean,java.lang.String,java.lang.String)>
<android.app.IActivityManager: void killUid(int,int,java.lang.String)>
<android.app.IActivityManager: int[] getIsolatedProcessList()>
<android.app.IActivityManager: boolean killPids(int[],java.lang.String,boolean)>
<android.app.IActivityManager: boolean isUserRunning(int,int)>
<android.app.IActivityManager: void resetAppErrors()>
<android.app.IActivityManager: void cancelIntentSender(android.content.IIntentSender)>
<android.app.IActivityManager: java.lang.String getSwitchingToUserMessage()>
<android.app.IActivityManager: void unhandledBack()>
<android.app.IActivityManager: int bindService(android.app.IApplicationThread,android.os.IBinder,android.content.Intent,java.lang.String,android.app.IServiceConnection,long,java.lang.String,int)>
<android.app.IActivityManager: void finishInstrumentation(android.app.IApplicationThread,int,android.os.Bundle)>
<android.app.IActivityManager: boolean updateConfiguration(android.content.res.Configuration)>
<android.app.IActivityManager: boolean isInLockTaskMode()>
<android.app.IActivityManager: java.util.List getAllRootTaskInfos()>
<android.app.IActivityManager: boolean isTopActivityImmersive()>
<android.app.IActivityManager: void reportAbnormalUsage(int,int)>
<android.app.IActivityManager: java.util.List getProcessesInErrorState()>
<android.app.IActivityManager: boolean startUserInForegroundWithListener(int,android.os.IProgressListener)>
<android.app.IActivityManager: android.app.ContentProviderHolder getContentProviderExternal(java.lang.String,int,android.os.IBinder,java.lang.String)>
<com.samsung.android.location.ISLocationBatchingListener: void onLocationAvailable(android.location.Location[],boolean)>
<android.service.controls.IControlsSubscription: void cancel()>
<android.service.controls.IControlsSubscription: void request(long)>
<com.android.internal.telephony.IPhoneStateListener: void onMessageWaitingIndicatorChanged(boolean)>
<com.android.internal.telephony.IPhoneStateListener: void onCallDisconnectCauseChanged(int,int)>
<com.android.internal.telephony.IPhoneStateListener: void onDataConnectionRealTimeInfoChanged(android.telephony.DataConnectionRealTimeInfo)>
<com.android.internal.telephony.IPhoneStateListener: void onImsCallDisconnectCauseChanged(android.telephony.ims.ImsReasonInfo)>
<com.android.internal.telephony.IPhoneStateListener: void onActiveDataSubIdChanged(int)>
<com.android.internal.telephony.IPhoneStateListener: void onOutgoingEmergencyCall(android.telephony.emergency.EmergencyNumber,int)>
<com.android.internal.telephony.IPhoneStateListener: void onPhoneCapabilityChanged(android.telephony.PhoneCapability)>
<com.android.internal.telephony.IPhoneStateListener: void onCellLocationChanged(android.telephony.CellIdentity)>
<com.android.internal.telephony.IPhoneStateListener: void onMediaQualityStatusChanged(android.telephony.ims.MediaQualityStatus)>
<com.android.internal.telephony.IPhoneStateListener: void onBarringInfoChanged(android.telephony.BarringInfo)>
<com.android.internal.telephony.IPhoneStateListener: void onOemHookRawEvent(byte[])>
<com.android.internal.telephony.IPhoneStateListener: void onRegistrationFailed(android.telephony.CellIdentity,java.lang.String,int,int,int)>
<com.android.internal.telephony.IPhoneStateListener: void onCarrierNetworkChange(boolean)>
<com.android.internal.telephony.IPhoneStateListener: void onCallStatesChanged(java.util.List)>
<com.android.internal.telephony.IPhoneStateListener: void onServiceStateChanged(android.telephony.ServiceState)>
<com.android.internal.telephony.IPhoneStateListener: void onPhysicalChannelConfigChanged(java.util.List)>
<com.android.internal.telephony.IPhoneStateListener: void onUserMobileDataStateChanged(boolean)>
<com.android.internal.telephony.IPhoneStateListener: void onDataActivationStateChanged(int)>
<com.android.internal.telephony.IPhoneStateListener: void onLegacyCallStateChanged(int,java.lang.String)>
<com.android.internal.telephony.IPhoneStateListener: void onCallStateChanged(int)>
<com.android.internal.telephony.IPhoneStateListener: void onCallForwardingIndicatorChanged(boolean)>
<com.android.internal.telephony.IPhoneStateListener: void onPreciseCallStateChanged(android.telephony.PreciseCallState)>
<com.android.internal.telephony.IPhoneStateListener: void onDataConnectionStateChanged(int,int)>
<com.android.internal.telephony.IPhoneStateListener: void onSrvccStateChanged(int)>
<com.android.internal.telephony.IPhoneStateListener: void onDataActivity(int)>
<com.android.internal.telephony.IPhoneStateListener: void onDisplayInfoChanged(android.telephony.TelephonyDisplayInfo)>
<com.android.internal.telephony.IPhoneStateListener: void onDataEnabledChanged(boolean,int)>
<com.android.internal.telephony.IPhoneStateListener: void onPreciseDataConnectionStateChanged(android.telephony.PreciseDataConnectionState)>
<com.android.internal.telephony.IPhoneStateListener: void onCallBackModeStopped(int,int)>
<com.android.internal.telephony.IPhoneStateListener: void onAllowedNetworkTypesChanged(int,long)>
<com.android.internal.telephony.IPhoneStateListener: void onCallBackModeStarted(int)>
<com.android.internal.telephony.IPhoneStateListener: void onEmergencyNumberListChanged(java.util.Map)>
<com.android.internal.telephony.IPhoneStateListener: void onVoiceActivationStateChanged(int)>
<com.android.internal.telephony.IPhoneStateListener: void onSignalStrengthsChanged(android.telephony.SignalStrength)>
<com.android.internal.telephony.IPhoneStateListener: void onRadioPowerStateChanged(int)>
<com.android.internal.telephony.IPhoneStateListener: void onLinkCapacityEstimateChanged(java.util.List)>
<com.android.internal.telephony.IPhoneStateListener: void onSignalStrengthChanged(int)>
<com.android.internal.telephony.IPhoneStateListener: void onCellInfoChanged(java.util.List)>
<com.android.internal.telephony.IPhoneStateListener: void onOutgoingEmergencySms(android.telephony.emergency.EmergencyNumber,int)>
<android.service.selectiontoolbar.ISelectionToolbarRenderServiceCallback: void transferTouch(android.os.IBinder,android.os.IBinder)>
<com.samsung.android.infoextraction.IKerykeion: void training(java.lang.String)>
<com.samsung.android.infoextraction.IKerykeion: void dismiss()>
<com.samsung.android.infoextraction.IKerykeion: void setInfoExtractionListener(int,android.os.IBinder)>
<com.samsung.android.infoextraction.IKerykeion: void addResultRule(int,java.lang.String)>
<com.samsung.android.infoextraction.IKerykeion: void show(java.lang.String,android.graphics.Rect)>
<com.samsung.android.infoextraction.IKerykeion: void start(int,com.samsung.android.infoextraction.KerykeionRequest,android.graphics.Rect)>
<com.samsung.android.infoextraction.IKerykeion: void restart()>
<com.samsung.android.infoextraction.IKerykeion: void stop(int)>
<com.android.internal.telephony.euicc.IAuthenticateServerCallback: void onComplete(int,byte[])>
<android.media.ISpatializerHeadTrackerAvailableCallback: void dispatchSpatializerHeadTrackerAvailable(boolean)>
<com.android.ims.internal.IImsCallSessionListener: void callSessionMultipartyStateChanged(com.android.ims.internal.IImsCallSession,boolean)>
<com.android.ims.internal.IImsCallSessionListener: void callSessionHandoverFailed(com.android.ims.internal.IImsCallSession,int,int,android.telephony.ims.ImsReasonInfo)>
<com.android.ims.internal.IImsCallSessionListener: void callSessionConferenceExtendFailed(com.android.ims.internal.IImsCallSession,android.telephony.ims.ImsReasonInfo)>
<com.android.ims.internal.IImsCallSessionListener: void callSessionConferenceStateUpdated(com.android.ims.internal.IImsCallSession,android.telephony.ims.ImsConferenceState)>
<com.android.ims.internal.IImsCallSessionListener: void callSessionTerminated(com.android.ims.internal.IImsCallSession,android.telephony.ims.ImsReasonInfo)>
<com.android.ims.internal.IImsCallSessionListener: void callSessionHeld(com.android.ims.internal.IImsCallSession,android.telephony.ims.ImsCallProfile)>
<com.android.ims.internal.IImsCallSessionListener: void callSessionRttModifyResponseReceived(int)>
<com.android.ims.internal.IImsCallSessionListener: void callSessionMergeComplete(com.android.ims.internal.IImsCallSession)>
<com.android.ims.internal.IImsCallSessionListener: void callSessionRemoveParticipantsRequestDelivered(com.android.ims.internal.IImsCallSession)>
<com.android.ims.internal.IImsCallSessionListener: void callSessionInviteParticipantsRequestFailed(com.android.ims.internal.IImsCallSession,android.telephony.ims.ImsReasonInfo)>
<com.android.ims.internal.IImsCallSessionListener: void callSessionResumeReceived(com.android.ims.internal.IImsCallSession,android.telephony.ims.ImsCallProfile)>
<com.android.ims.internal.IImsCallSessionListener: void callQualityChanged(android.telephony.CallQuality)>
<com.android.ims.internal.IImsCallSessionListener: void callSessionRemoveParticipantsRequestFailed(com.android.ims.internal.IImsCallSession,android.telephony.ims.ImsReasonInfo)>
<com.android.ims.internal.IImsCallSessionListener: void callSessionMayHandover(com.android.ims.internal.IImsCallSession,int,int)>
<com.android.ims.internal.IImsCallSessionListener: void callSessionUpdated(com.android.ims.internal.IImsCallSession,android.telephony.ims.ImsCallProfile)>
<com.android.ims.internal.IImsCallSessionListener: void callSessionTtyModeReceived(com.android.ims.internal.IImsCallSession,int)>
<com.android.ims.internal.IImsCallSessionListener: void callSessionProgressing(com.android.ims.internal.IImsCallSession,android.telephony.ims.ImsStreamMediaProfile)>
<com.android.ims.internal.IImsCallSessionListener: void callSessionResumed(com.android.ims.internal.IImsCallSession,android.telephony.ims.ImsCallProfile)>
<com.android.ims.internal.IImsCallSessionListener: void callSessionSendAnbrQuery(int,int,int)>
<com.android.ims.internal.IImsCallSessionListener: void callSessionHoldReceived(com.android.ims.internal.IImsCallSession,android.telephony.ims.ImsCallProfile)>
<com.android.ims.internal.IImsCallSessionListener: void callSessionTransferred()>
<com.android.ims.internal.IImsCallSessionListener: void callSessionUpdateReceived(com.android.ims.internal.IImsCallSession,android.telephony.ims.ImsCallProfile)>
<com.android.ims.internal.IImsCallSessionListener: void callSessionHoldFailed(com.android.ims.internal.IImsCallSession,android.telephony.ims.ImsReasonInfo)>
<com.android.ims.internal.IImsCallSessionListener: void callSessionRttModifyRequestReceived(com.android.ims.internal.IImsCallSession,android.telephony.ims.ImsCallProfile)>
<com.android.ims.internal.IImsCallSessionListener: void callSessionHandover(com.android.ims.internal.IImsCallSession,int,int,android.telephony.ims.ImsReasonInfo)>
<com.android.ims.internal.IImsCallSessionListener: void callSessionResumeFailed(com.android.ims.internal.IImsCallSession,android.telephony.ims.ImsReasonInfo)>
<com.android.ims.internal.IImsCallSessionListener: void callSessionConferenceExtended(com.android.ims.internal.IImsCallSession,com.android.ims.internal.IImsCallSession,android.telephony.ims.ImsCallProfile)>
<com.android.ims.internal.IImsCallSessionListener: void callSessionUssdMessageReceived(com.android.ims.internal.IImsCallSession,int,java.lang.String)>
<com.android.ims.internal.IImsCallSessionListener: void callSessionStarted(com.android.ims.internal.IImsCallSession,android.telephony.ims.ImsCallProfile)>
<com.android.ims.internal.IImsCallSessionListener: void callSessionSuppServiceReceived(com.android.ims.internal.IImsCallSession,android.telephony.ims.ImsSuppServiceNotification)>
<com.android.ims.internal.IImsCallSessionListener: void callSessionStartFailed(com.android.ims.internal.IImsCallSession,android.telephony.ims.ImsReasonInfo)>
<com.android.ims.internal.IImsCallSessionListener: void callSessionTransferFailed(android.telephony.ims.ImsReasonInfo)>
<com.android.ims.internal.IImsCallSessionListener: void callSessionConferenceExtendReceived(com.android.ims.internal.IImsCallSession,com.android.ims.internal.IImsCallSession,android.telephony.ims.ImsCallProfile)>
<com.android.ims.internal.IImsCallSessionListener: void callSessionRttAudioIndicatorChanged(android.telephony.ims.ImsStreamMediaProfile)>
<com.android.ims.internal.IImsCallSessionListener: void callSessionUpdateFailed(com.android.ims.internal.IImsCallSession,android.telephony.ims.ImsReasonInfo)>
<com.android.ims.internal.IImsCallSessionListener: void callSessionRttMessageReceived(java.lang.String)>
<com.android.ims.internal.IImsCallSessionListener: void callSessionInviteParticipantsRequestDelivered(com.android.ims.internal.IImsCallSession)>
<com.android.ims.internal.IImsCallSessionListener: void callSessionMergeFailed(com.android.ims.internal.IImsCallSession,android.telephony.ims.ImsReasonInfo)>
<com.android.ims.internal.IImsCallSessionListener: void callSessionMergeStarted(com.android.ims.internal.IImsCallSession,com.android.ims.internal.IImsCallSession,android.telephony.ims.ImsCallProfile)>
<android.debug.IAdbCallback: void onDebuggingChanged(boolean,byte)>
<android.printservice.recommendation.IRecommendationService: void registerCallbacks(android.printservice.recommendation.IRecommendationServiceCallbacks)>
<android.service.games.IGameService: void disconnected()>
<android.service.games.IGameService: void connected(android.service.games.IGameServiceController)>
<android.service.games.IGameService: void gameStarted(android.service.games.GameStartedEvent)>
<com.android.internal.telephony.euicc.IListNotificationsCallback: void onComplete(int,android.telephony.euicc.EuiccNotification[])>
<android.service.rotationresolver.IRotationResolverService: void resolveRotation(android.service.rotationresolver.IRotationResolverCallback,android.service.rotationresolver.RotationResolutionRequest)>
<android.os.IVoldMountCallback: boolean onVolumeChecking(java.io.FileDescriptor,java.lang.String,java.lang.String)>
<android.service.quicksettings.IQSTileService: void semSetToggleButtonChecked(boolean)>
<android.service.quicksettings.IQSTileService: boolean semIsToggleButtonChecked()>
<android.service.quicksettings.IQSTileService: android.widget.RemoteViews semGetDetailView()>
<android.service.quicksettings.IQSTileService: java.lang.CharSequence semGetDetailViewTitle()>
<android.service.quicksettings.IQSTileService: void onClick(android.os.IBinder)>
<android.service.quicksettings.IQSTileService: boolean semIsToggleButtonExists()>
<android.service.quicksettings.IQSTileService: void onStartListening()>
<android.service.quicksettings.IQSTileService: void onTileRemoved()>
<android.service.quicksettings.IQSTileService: void onUnlockComplete()>
<android.service.quicksettings.IQSTileService: android.content.Intent semGetSettingsIntent()>
<android.service.quicksettings.IQSTileService: void onTileAdded()>
<android.service.quicksettings.IQSTileService: void onStopListening()>
<android.service.quicksettings.IQSTileService: java.lang.CharSequence semGetDetailViewSettingButtonName()>
<com.android.ims.internal.IImsCallSession: int getState()>
<com.android.ims.internal.IImsCallSession: void notifyReadyToHandleImsCallbacks()>
<com.android.ims.internal.IImsCallSession: void sendDtmf(char,android.os.Message)>
<com.android.ims.internal.IImsCallSession: void sendUssd(java.lang.String)>
<com.android.ims.internal.IImsCallSession: void close()>
<com.android.ims.internal.IImsCallSession: java.lang.String getProperty(java.lang.String)>
<com.android.ims.internal.IImsCallSession: com.android.ims.internal.IImsVideoCallProvider getVideoCallProvider()>
<com.android.ims.internal.IImsCallSession: void transfer(java.lang.String,boolean)>
<com.android.ims.internal.IImsCallSession: void inviteParticipants(java.lang.String[])>
<com.android.ims.internal.IImsCallSession: void sendImsCallEvent(java.lang.String,android.os.Bundle)>
<com.android.ims.internal.IImsCallSession: void callSessionNotifyAnbr(int,int,int)>
<com.android.ims.internal.IImsCallSession: void consultativeTransfer(com.android.ims.internal.IImsCallSession)>
<com.android.ims.internal.IImsCallSession: android.telephony.ims.ImsCallProfile getRemoteCallProfile()>
<com.android.ims.internal.IImsCallSession: void sendRttModifyResponse(boolean)>
<com.android.ims.internal.IImsCallSession: java.lang.String getCallId()>
<com.android.ims.internal.IImsCallSession: void sendRtpHeaderExtensions(java.util.List)>
<com.android.ims.internal.IImsCallSession: void update(int,android.telephony.ims.ImsStreamMediaProfile)>
<com.android.ims.internal.IImsCallSession: void sendRttMessage(java.lang.String)>
<com.android.ims.internal.IImsCallSession: void extendToConference(java.lang.String[])>
<com.android.ims.internal.IImsCallSession: void merge()>
<com.android.ims.internal.IImsCallSession: void startConference(java.lang.String[],android.telephony.ims.ImsCallProfile)>
<com.android.ims.internal.IImsCallSession: void reject(int)>
<com.android.ims.internal.IImsCallSession: void accept(int,android.telephony.ims.ImsStreamMediaProfile)>
<com.android.ims.internal.IImsCallSession: void resume(android.telephony.ims.ImsStreamMediaProfile)>
<com.android.ims.internal.IImsCallSession: void sendRttModifyRequest(android.telephony.ims.ImsCallProfile)>
<com.android.ims.internal.IImsCallSession: boolean isMultiparty()>
<com.android.ims.internal.IImsCallSession: void stopDtmf()>
<com.android.ims.internal.IImsCallSession: void start(java.lang.String,android.telephony.ims.ImsCallProfile)>
<com.android.ims.internal.IImsCallSession: void cancelTransferCall()>
<com.android.ims.internal.IImsCallSession: android.telephony.ims.ImsCallProfile getCallProfile()>
<com.android.ims.internal.IImsCallSession: android.telephony.ims.ImsCallProfile getLocalCallProfile()>
<com.android.ims.internal.IImsCallSession: void removeParticipants(java.lang.String[])>
<com.android.ims.internal.IImsCallSession: void hold(android.telephony.ims.ImsStreamMediaProfile)>
<com.android.ims.internal.IImsCallSession: void setListener(android.telephony.ims.aidl.IImsCallSessionListener)>
<com.android.ims.internal.IImsCallSession: boolean isInCall()>
<com.android.ims.internal.IImsCallSession: void startDtmf(char)>
<com.android.ims.internal.IImsCallSession: void terminate(int)>
<com.android.ims.internal.IImsCallSession: void setMute(boolean)>
<com.android.ims.internal.IImsCallSession: void deflect(java.lang.String)>
<android.permission.IOnPermissionsChangeListener: void onPermissionsChanged(int)>
<com.android.internal.telecom.IVideoProvider: void requestCameraCapabilities()>
<com.android.internal.telecom.IVideoProvider: void sendSessionModifyRequest(android.telecom.VideoProfile,android.telecom.VideoProfile)>
<com.android.internal.telecom.IVideoProvider: void setPauseImage(android.net.Uri)>
<com.android.internal.telecom.IVideoProvider: void removeVideoCallback(android.os.IBinder)>
<com.android.internal.telecom.IVideoProvider: void setDeviceOrientation(int)>
<com.android.internal.telecom.IVideoProvider: void addVideoCallback(android.os.IBinder)>
<com.android.internal.telecom.IVideoProvider: void requestCallDataUsage()>
<com.android.internal.telecom.IVideoProvider: void setCamera(java.lang.String,java.lang.String,int)>
<com.android.internal.telecom.IVideoProvider: void setZoom(float)>
<com.android.internal.telecom.IVideoProvider: void sendSessionModifyResponse(android.telecom.VideoProfile)>
<com.android.internal.telecom.IVideoProvider: void setDisplaySurface(android.view.Surface)>
<com.android.internal.telecom.IVideoProvider: void setPreviewSurface(android.view.Surface)>
<android.telephony.ims.aidl.IOptionsResponseCallback: void onCommandError(int)>
<android.telephony.ims.aidl.IOptionsResponseCallback: void onNetworkResponse(int,java.lang.String,java.util.List)>
<android.content.IIntentReceiver: void performReceive(android.content.Intent,int,java.lang.String,android.os.Bundle,boolean,boolean,int)>
<android.webkit.IWebViewUpdateService: java.lang.String changeProviderAndSetting(java.lang.String)>
<android.webkit.IWebViewUpdateService: android.webkit.WebViewProviderInfo[] getAllWebViewPackages()>
<android.webkit.IWebViewUpdateService: android.content.pm.PackageInfo getCurrentWebViewPackage()>
<android.webkit.IWebViewUpdateService: android.webkit.WebViewProviderInfo[] getValidWebViewPackages()>
<android.webkit.IWebViewUpdateService: java.lang.String getCurrentWebViewPackageName()>
<android.webkit.IWebViewUpdateService: boolean isMultiProcessEnabled()>
<android.webkit.IWebViewUpdateService: void notifyRelroCreationCompleted()>
<android.webkit.IWebViewUpdateService: android.webkit.WebViewProviderResponse waitForAndGetProvider()>
<android.webkit.IWebViewUpdateService: void enableMultiProcess(boolean)>
<android.print.IPrintDocumentAdapterObserver: void onDestroy()>
<android.app.time.ITimeZoneDetectorListener: void onChange()>
<android.hardware.soundtrigger3.ISoundTriggerHw: int loadPhraseSoundModel(android.media.soundtrigger.PhraseSoundModel,android.hardware.soundtrigger3.ISoundTriggerHwCallback)>
<android.hardware.soundtrigger3.ISoundTriggerHw: void registerGlobalCallback(android.hardware.soundtrigger3.ISoundTriggerHwGlobalCallback)>
<android.hardware.soundtrigger3.ISoundTriggerHw: void forceRecognitionEvent(int)>
<android.hardware.soundtrigger3.ISoundTriggerHw: int loadSoundModel(android.media.soundtrigger.SoundModel,android.hardware.soundtrigger3.ISoundTriggerHwCallback)>
<android.hardware.soundtrigger3.ISoundTriggerHw: int getParameter(int,int)>
<android.hardware.soundtrigger3.ISoundTriggerHw: void startRecognition(int,int,int,android.media.soundtrigger.RecognitionConfig)>
<android.hardware.soundtrigger3.ISoundTriggerHw: java.lang.String getInterfaceHash()>
<android.hardware.soundtrigger3.ISoundTriggerHw: void unloadSoundModel(int)>
<android.hardware.soundtrigger3.ISoundTriggerHw: int getInterfaceVersion()>
<android.hardware.soundtrigger3.ISoundTriggerHw: void stopRecognition(int)>
<android.hardware.soundtrigger3.ISoundTriggerHw: android.media.soundtrigger.Properties getProperties()>
<android.hardware.soundtrigger3.ISoundTriggerHw: android.media.soundtrigger.ModelParameterRange queryParameter(int,int)>
<android.hardware.soundtrigger3.ISoundTriggerHw: void setParameter(int,int,int)>
<android.service.contentcapture.IDataShareReadAdapter: void start(android.os.ParcelFileDescriptor)>
<android.service.contentcapture.IDataShareReadAdapter: void finish()>
<android.service.contentcapture.IDataShareReadAdapter: void error(int)>
<android.media.midi.IMidiDeviceServer: android.media.midi.MidiDeviceInfo getDeviceInfo()>
<android.media.midi.IMidiDeviceServer: java.io.FileDescriptor openInputPort(android.os.IBinder,int)>
<android.media.midi.IMidiDeviceServer: void closePort(android.os.IBinder)>
<android.media.midi.IMidiDeviceServer: java.io.FileDescriptor openOutputPort(android.os.IBinder,int)>
<android.media.midi.IMidiDeviceServer: void closeDevice()>
<android.media.midi.IMidiDeviceServer: void setDeviceInfo(android.media.midi.MidiDeviceInfo)>
<android.media.midi.IMidiDeviceServer: int connectPorts(android.os.IBinder,java.io.FileDescriptor,int)>
<com.sec.android.iaft.IIAFTManagerService: void stopTrace()>
<com.sec.android.iaft.IIAFTManagerService: void startAtraceAndAnalyze(int,java.lang.String,int)>
<com.sec.android.iaft.IIAFTManagerService: void registerCallback(com.sec.android.iaft.callback.IIAFTCallback)>
<com.sec.android.iaft.IIAFTManagerService: void startAtrace()>
<android.media.tv.ITvInputService: void notifyHardwareAdded(android.media.tv.TvInputHardwareInfo)>
<android.media.tv.ITvInputService: void notifyHdmiDeviceRemoved(android.hardware.hdmi.HdmiDeviceInfo)>
<android.media.tv.ITvInputService: void notifyHardwareRemoved(android.media.tv.TvInputHardwareInfo)>
<android.media.tv.ITvInputService: void notifyHdmiDeviceAdded(android.hardware.hdmi.HdmiDeviceInfo)>
<android.media.tv.ITvInputService: android.os.IBinder getExtensionInterface(java.lang.String)>
<android.media.tv.ITvInputService: java.lang.String getExtensionInterfacePermission(java.lang.String)>
<android.media.tv.ITvInputService: void notifyHdmiDeviceUpdated(android.hardware.hdmi.HdmiDeviceInfo)>
<android.media.tv.ITvInputService: void registerCallback(android.media.tv.ITvInputServiceCallback)>
<android.media.tv.ITvInputService: void createRecordingSession(android.media.tv.ITvInputSessionCallback,java.lang.String,java.lang.String)>
<android.media.tv.ITvInputService: java.util.List getAvailableExtensionInterfaceNames()>
<android.media.tv.ITvInputService: void createSession(android.view.InputChannel,android.media.tv.ITvInputSessionCallback,java.lang.String,java.lang.String,android.content.AttributionSource)>
<android.media.tv.ITvInputService: void unregisterCallback(android.media.tv.ITvInputServiceCallback)>
<android.service.games.IGameSessionService: void create(android.service.games.IGameSessionController,android.service.games.CreateGameSessionRequest,android.service.games.GameSessionViewHostConfiguration,com.android.internal.infra.AndroidFuture)>
<com.android.internal.telecom.ICallRedirectionAdapter: void redirectCall(android.net.Uri,android.telecom.PhoneAccountHandle,boolean)>
<com.android.internal.telecom.ICallRedirectionAdapter: void cancelCall()>
<com.android.internal.telecom.ICallRedirectionAdapter: void placeCallUnmodified()>
<android.hardware.radio.voice.IRadioVoiceResponse: void getCallWaitingResponse(android.hardware.radio.RadioResponseInfo,boolean,int)>
<android.hardware.radio.voice.IRadioVoiceResponse: void switchWaitingOrHoldingAndActiveResponse(android.hardware.radio.RadioResponseInfo)>
<android.hardware.radio.voice.IRadioVoiceResponse: void stopDtmfResponse(android.hardware.radio.RadioResponseInfo)>
<android.hardware.radio.voice.IRadioVoiceResponse: void setVoNrEnabledResponse(android.hardware.radio.RadioResponseInfo)>
<android.hardware.radio.voice.IRadioVoiceResponse: void sendCdmaFeatureCodeResponse(android.hardware.radio.RadioResponseInfo)>
<android.hardware.radio.voice.IRadioVoiceResponse: void cancelPendingUssdResponse(android.hardware.radio.RadioResponseInfo)>
<android.hardware.radio.voice.IRadioVoiceResponse: void sendBurstDtmfResponse(android.hardware.radio.RadioResponseInfo)>
<android.hardware.radio.voice.IRadioVoiceResponse: void acknowledgeRequest(int)>
<android.hardware.radio.voice.IRadioVoiceResponse: void setPreferredVoicePrivacyResponse(android.hardware.radio.RadioResponseInfo)>
<android.hardware.radio.voice.IRadioVoiceResponse: int getInterfaceVersion()>
<android.hardware.radio.voice.IRadioVoiceResponse: void exitEmergencyCallbackModeResponse(android.hardware.radio.RadioResponseInfo)>
<android.hardware.radio.voice.IRadioVoiceResponse: void setMuteResponse(android.hardware.radio.RadioResponseInfo)>
<android.hardware.radio.voice.IRadioVoiceResponse: void explicitCallTransferResponse(android.hardware.radio.RadioResponseInfo)>
<android.hardware.radio.voice.IRadioVoiceResponse: void emergencyDialResponse(android.hardware.radio.RadioResponseInfo)>
<android.hardware.radio.voice.IRadioVoiceResponse: void getPreferredVoicePrivacyResponse(android.hardware.radio.RadioResponseInfo,boolean)>
<android.hardware.radio.voice.IRadioVoiceResponse: void getClirResponse(android.hardware.radio.RadioResponseInfo,int,int)>
<android.hardware.radio.voice.IRadioVoiceResponse: void getCallForwardStatusResponse(android.hardware.radio.RadioResponseInfo,android.hardware.radio.voice.CallForwardInfo[])>
<android.hardware.radio.voice.IRadioVoiceResponse: void hangupForegroundResumeBackgroundResponse(android.hardware.radio.RadioResponseInfo)>
<android.hardware.radio.voice.IRadioVoiceResponse: void setTtyModeResponse(android.hardware.radio.RadioResponseInfo)>
<android.hardware.radio.voice.IRadioVoiceResponse: void dialResponse(android.hardware.radio.RadioResponseInfo)>
<android.hardware.radio.voice.IRadioVoiceResponse: java.lang.String getInterfaceHash()>
<android.hardware.radio.voice.IRadioVoiceResponse: void handleStkCallSetupRequestFromSimResponse(android.hardware.radio.RadioResponseInfo)>
<android.hardware.radio.voice.IRadioVoiceResponse: void rejectCallResponse(android.hardware.radio.RadioResponseInfo)>
<android.hardware.radio.voice.IRadioVoiceResponse: void getLastCallFailCauseResponse(android.hardware.radio.RadioResponseInfo,android.hardware.radio.voice.LastCallFailCauseInfo)>
<android.hardware.radio.voice.IRadioVoiceResponse: void hangupConnectionResponse(android.hardware.radio.RadioResponseInfo)>
<android.hardware.radio.voice.IRadioVoiceResponse: void getMuteResponse(android.hardware.radio.RadioResponseInfo,boolean)>
<android.hardware.radio.voice.IRadioVoiceResponse: void isVoNrEnabledResponse(android.hardware.radio.RadioResponseInfo,boolean)>
<android.hardware.radio.voice.IRadioVoiceResponse: void getTtyModeResponse(android.hardware.radio.RadioResponseInfo,int)>
<android.hardware.radio.voice.IRadioVoiceResponse: void getCurrentCallsResponse(android.hardware.radio.RadioResponseInfo,android.hardware.radio.voice.Call[])>
<android.hardware.radio.voice.IRadioVoiceResponse: void hangupWaitingOrBackgroundResponse(android.hardware.radio.RadioResponseInfo)>
<android.hardware.radio.voice.IRadioVoiceResponse: void setCallForwardResponse(android.hardware.radio.RadioResponseInfo)>
<android.hardware.radio.voice.IRadioVoiceResponse: void sendUssdResponse(android.hardware.radio.RadioResponseInfo)>
<android.hardware.radio.voice.IRadioVoiceResponse: void setClirResponse(android.hardware.radio.RadioResponseInfo)>
<android.hardware.radio.voice.IRadioVoiceResponse: void separateConnectionResponse(android.hardware.radio.RadioResponseInfo)>
<android.hardware.radio.voice.IRadioVoiceResponse: void startDtmfResponse(android.hardware.radio.RadioResponseInfo)>
<android.hardware.radio.voice.IRadioVoiceResponse: void getClipResponse(android.hardware.radio.RadioResponseInfo,int)>
<android.hardware.radio.voice.IRadioVoiceResponse: void acceptCallResponse(android.hardware.radio.RadioResponseInfo)>
<android.hardware.radio.voice.IRadioVoiceResponse: void conferenceResponse(android.hardware.radio.RadioResponseInfo)>
<android.hardware.radio.voice.IRadioVoiceResponse: void setCallWaitingResponse(android.hardware.radio.RadioResponseInfo)>
<android.hardware.radio.voice.IRadioVoiceResponse: void sendDtmfResponse(android.hardware.radio.RadioResponseInfo)>
<android.hardware.radio.voice.IRadioVoiceIndication: void currentEmergencyNumberList(int,android.hardware.radio.voice.EmergencyNumber[])>
<android.hardware.radio.voice.IRadioVoiceIndication: java.lang.String getInterfaceHash()>
<android.hardware.radio.voice.IRadioVoiceIndication: void indicateRingbackTone(int,boolean)>
<android.hardware.radio.voice.IRadioVoiceIndication: void stkCallControlAlphaNotify(int,java.lang.String)>
<android.hardware.radio.voice.IRadioVoiceIndication: void callRing(int,boolean,android.hardware.radio.voice.CdmaSignalInfoRecord)>
<android.hardware.radio.voice.IRadioVoiceIndication: void enterEmergencyCallbackMode(int)>
<android.hardware.radio.voice.IRadioVoiceIndication: void cdmaOtaProvisionStatus(int,int)>
<android.hardware.radio.voice.IRadioVoiceIndication: void onSupplementaryServiceIndication(int,android.hardware.radio.voice.StkCcUnsolSsResult)>
<android.hardware.radio.voice.IRadioVoiceIndication: void callStateChanged(int)>
<android.hardware.radio.voice.IRadioVoiceIndication: void stkCallSetup(int,long)>
<android.hardware.radio.voice.IRadioVoiceIndication: void cdmaCallWaiting(int,android.hardware.radio.voice.CdmaCallWaiting)>
<android.hardware.radio.voice.IRadioVoiceIndication: void exitEmergencyCallbackMode(int)>
<android.hardware.radio.voice.IRadioVoiceIndication: int getInterfaceVersion()>
<android.hardware.radio.voice.IRadioVoiceIndication: void resendIncallMute(int)>
<android.hardware.radio.voice.IRadioVoiceIndication: void srvccStateNotify(int,int)>
<android.hardware.radio.voice.IRadioVoiceIndication: void cdmaInfoRec(int,android.hardware.radio.voice.CdmaInformationRecord[])>
<android.hardware.radio.voice.IRadioVoiceIndication: void onUssd(int,int,java.lang.String)>
<com.samsung.android.wifi.ISemWifiApClientUpdateCallback: void onClientUpdated(com.samsung.android.wifi.SemWifiApClientDetails)>
<android.telephony.gba.IGbaService: void authenticationRequest(android.telephony.gba.GbaAuthRequest)>
<android.media.projection.IMediaProjectionCallback: void onCapturedContentResize(int,int)>
<android.media.projection.IMediaProjectionCallback: void onCapturedContentVisibilityChanged(boolean)>
<android.media.projection.IMediaProjectionCallback: void onStop()>
<android.se.omapi.ISecureElementListener: java.lang.String getInterfaceHash()>
<android.se.omapi.ISecureElementListener: int getInterfaceVersion()>
<android.view.IRecentsAnimationController: void finish(boolean,boolean)>
<android.view.IRecentsAnimationController: boolean removeTask(int)>
<android.view.IRecentsAnimationController: void setInputConsumerEnabled(boolean)>
<android.view.IRecentsAnimationController: void setWillFinishToHome(boolean)>
<android.view.IRecentsAnimationController: void detachNavigationBarFromApp(boolean)>
<android.view.IRecentsAnimationController: void setAnimationTargetsBehindSystemBars(boolean)>
<android.view.IRecentsAnimationController: android.window.TaskSnapshot screenshotTask(int)>
<android.view.IRecentsAnimationController: void animateNavigationBarToApp(long)>
<android.view.IRecentsAnimationController: void cleanupScreenshot()>
<android.view.IRecentsAnimationController: void setFinishTaskTransaction(int,android.window.PictureInPictureSurfaceTransaction,android.view.SurfaceControl)>
<android.view.IRecentsAnimationController: void setDeferCancelUntilNextTransition(boolean,boolean)>
<android.content.ISyncContext: void onFinished(android.content.SyncResult)>
<android.content.ISyncContext: void sendHeartbeat()>
<com.samsung.android.remoteappmode.ISecureAppChangedListener: void onSecuredAppRemoved(int,java.lang.String)>
<com.samsung.android.remoteappmode.ISecureAppChangedListener: void onSecuredAppLaunched(int,java.lang.String)>
<com.android.internal.telephony.euicc.IGetEuiccInfo2Callback: void onComplete(int,byte[])>
<com.android.internal.telephony.ISipDialogStateCallback: void onActiveSipDialogsChanged(java.util.List)>
<android.app.IGameModeListener: void onGameModeChanged(java.lang.String,int,int,int)>
<com.android.internal.textservice.ISpellCheckerSessionListener: void onGetSentenceSuggestions(android.view.textservice.SentenceSuggestionsInfo[])>
<com.android.internal.textservice.ISpellCheckerSessionListener: void onGetSuggestions(android.view.textservice.SuggestionsInfo[])>
<android.hardware.cas.IMediaCasService: int getInterfaceVersion()>
<android.hardware.cas.IMediaCasService: android.hardware.cas.ICas createPlugin(int,android.hardware.cas.ICasListener)>
<android.hardware.cas.IMediaCasService: boolean isDescramblerSupported(int)>
<android.hardware.cas.IMediaCasService: android.hardware.cas.AidlCasPluginDescriptor[] enumeratePlugins()>
<android.hardware.cas.IMediaCasService: boolean isSystemIdSupported(int)>
<android.hardware.cas.IMediaCasService: android.hardware.cas.IDescrambler createDescrambler(int)>
<android.hardware.cas.IMediaCasService: java.lang.String getInterfaceHash()>
<com.samsung.android.service.reactive.IReactiveService: int setString(java.lang.String)>
<com.samsung.android.service.reactive.IReactiveService: int getServiceSupport()>
<com.samsung.android.service.reactive.IReactiveService: int removeString()>
<com.samsung.android.service.reactive.IReactiveService: byte[] getRandom()>
<com.samsung.android.service.reactive.IReactiveService: byte[] sessionAccept(byte[])>
<com.samsung.android.service.reactive.IReactiveService: java.lang.String getString()>
<com.samsung.android.service.reactive.IReactiveService: int getFlag(int)>
<com.samsung.android.service.reactive.IReactiveService: int setFlag(int,int,java.lang.String)>
<com.samsung.android.service.reactive.IReactiveService: int getErrorCode()>
<com.samsung.android.service.reactive.IReactiveService: int sessionComplete(byte[])>
<com.samsung.android.service.reactive.IReactiveService: int verify(java.lang.String,int)>
<android.hardware.gnss.IGnssPowerIndication: void requestGnssPowerStats()>
<android.hardware.gnss.IGnssPowerIndication: java.lang.String getInterfaceHash()>
<android.hardware.gnss.IGnssPowerIndication: int getInterfaceVersion()>
<android.hardware.gnss.IGnssPowerIndication: void setCallback(android.hardware.gnss.IGnssPowerIndicationCallback)>
<android.view.autofill.IAutoFillManager: void getDefaultFieldClassificationAlgorithm(com.android.internal.os.IResultReceiver)>
<android.view.autofill.IAutoFillManager: void cancelSession(int,int)>
<android.view.autofill.IAutoFillManager: void getAutofillServiceComponentName(com.android.internal.os.IResultReceiver)>
<android.view.autofill.IAutoFillManager: void setAutofillFailure(int,java.util.List,int)>
<android.view.autofill.IAutoFillManager: void startSession(android.os.IBinder,android.os.IBinder,android.view.autofill.AutofillId,android.graphics.Rect,android.view.autofill.AutofillValue,int,boolean,int,android.content.ComponentName,boolean,com.android.internal.os.IResultReceiver)>
<android.view.autofill.IAutoFillManager: void onPendingSaveUi(int,android.os.IBinder)>
<android.view.autofill.IAutoFillManager: void setAuthenticationResult(android.os.Bundle,int,int,int)>
<android.view.autofill.IAutoFillManager: void setHasCallback(int,int,boolean)>
<android.view.autofill.IAutoFillManager: void removeClient(android.view.autofill.IAutoFillManagerClient,int)>
<android.view.autofill.IAutoFillManager: void addClient(android.view.autofill.IAutoFillManagerClient,android.content.ComponentName,int,com.android.internal.os.IResultReceiver)>
<android.view.autofill.IAutoFillManager: void getAvailableFieldClassificationAlgorithms(com.android.internal.os.IResultReceiver)>
<android.view.autofill.IAutoFillManager: void setUserData(android.service.autofill.UserData)>
<android.view.autofill.IAutoFillManager: void isServiceEnabled(int,java.lang.String,com.android.internal.os.IResultReceiver)>
<android.view.autofill.IAutoFillManager: void restoreSession(int,android.os.IBinder,android.os.IBinder,com.android.internal.os.IResultReceiver)>
<android.view.autofill.IAutoFillManager: void disableOwnedAutofillServices(int)>
<android.view.autofill.IAutoFillManager: void finishSession(int,int,int)>
<android.view.autofill.IAutoFillManager: void isServiceSupported(int,com.android.internal.os.IResultReceiver)>
<android.view.autofill.IAutoFillManager: void setAugmentedAutofillWhitelist(java.util.List,java.util.List,com.android.internal.os.IResultReceiver)>
<android.view.autofill.IAutoFillManager: void getFillEventHistory(com.android.internal.os.IResultReceiver)>
<android.view.autofill.IAutoFillManager: void getUserData(com.android.internal.os.IResultReceiver)>
<android.view.autofill.IAutoFillManager: void getUserDataId(com.android.internal.os.IResultReceiver)>
<android.view.autofill.IAutoFillManager: void updateSession(int,android.view.autofill.AutofillId,android.graphics.Rect,android.view.autofill.AutofillValue,int,int,int)>
<android.view.autofill.IAutoFillManager: void isFieldClassificationEnabled(com.android.internal.os.IResultReceiver)>
<com.samsung.android.multiwindow.IRemoteAppTransitionListener: void onWallpaperVisibilityChanged(boolean,boolean)>
<com.samsung.android.multiwindow.IRemoteAppTransitionListener: void onFinishRecentsAnimation(boolean)>
<com.samsung.android.multiwindow.IRemoteAppTransitionListener: void onStartHomeAnimation(boolean)>
<com.samsung.android.multiwindow.IRemoteAppTransitionListener: void onStartRecentsAnimation(boolean)>
<android.service.autofill.IInlineSuggestionUiCallback: void onError()>
<android.service.autofill.IInlineSuggestionUiCallback: void onTransferTouchFocusToImeWindow(android.os.IBinder,int)>
<android.service.autofill.IInlineSuggestionUiCallback: void onContent(android.service.autofill.IInlineSuggestionUi,android.view.SurfaceControlViewHost$SurfacePackage,int,int)>
<android.service.autofill.IInlineSuggestionUiCallback: void onStartIntentSender(android.content.IntentSender)>
<android.service.autofill.IInlineSuggestionUiCallback: void onClick()>
<android.service.autofill.IInlineSuggestionUiCallback: void onLongClick()>
<android.net.wifi.nl80211.IScanEvent: void OnScanResultReady()>
<android.net.wifi.nl80211.IScanEvent: void OnScanFailed()>
<android.net.wifi.nl80211.IScanEvent: void OnScanRequestFailed(int)>
<android.hardware.radio.data.IRadioDataResponse: void setupDataCallResponse(android.hardware.radio.RadioResponseInfo,android.hardware.radio.data.SetupDataCallResult)>
<android.hardware.radio.data.IRadioDataResponse: int getInterfaceVersion()>
<android.hardware.radio.data.IRadioDataResponse: void setInitialAttachApnResponse(android.hardware.radio.RadioResponseInfo)>
<android.hardware.radio.data.IRadioDataResponse: void acknowledgeRequest(int)>
<android.hardware.radio.data.IRadioDataResponse: void setDataThrottlingResponse(android.hardware.radio.RadioResponseInfo)>
<android.hardware.radio.data.IRadioDataResponse: void allocatePduSessionIdResponse(android.hardware.radio.RadioResponseInfo,int)>
<android.hardware.radio.data.IRadioDataResponse: java.lang.String getInterfaceHash()>
<android.hardware.radio.data.IRadioDataResponse: void setDataAllowedResponse(android.hardware.radio.RadioResponseInfo)>
<android.hardware.radio.data.IRadioDataResponse: void getSlicingConfigResponse(android.hardware.radio.RadioResponseInfo,android.hardware.radio.data.SlicingConfig)>
<android.hardware.radio.data.IRadioDataResponse: void startHandoverResponse(android.hardware.radio.RadioResponseInfo)>
<android.hardware.radio.data.IRadioDataResponse: void releasePduSessionIdResponse(android.hardware.radio.RadioResponseInfo)>
<android.hardware.radio.data.IRadioDataResponse: void cancelHandoverResponse(android.hardware.radio.RadioResponseInfo)>
<android.hardware.radio.data.IRadioDataResponse: void startKeepaliveResponse(android.hardware.radio.RadioResponseInfo,android.hardware.radio.data.KeepaliveStatus)>
<android.hardware.radio.data.IRadioDataResponse: void deactivateDataCallResponse(android.hardware.radio.RadioResponseInfo)>
<android.hardware.radio.data.IRadioDataResponse: void getDataCallListResponse(android.hardware.radio.RadioResponseInfo,android.hardware.radio.data.SetupDataCallResult[])>
<android.hardware.radio.data.IRadioDataResponse: void setDataProfileResponse(android.hardware.radio.RadioResponseInfo)>
<android.hardware.radio.data.IRadioDataResponse: void stopKeepaliveResponse(android.hardware.radio.RadioResponseInfo)>
<android.app.trust.ITrustListener: void onTrustError(java.lang.CharSequence)>
<android.app.trust.ITrustListener: void onIsActiveUnlockRunningChanged(boolean,int)>
<android.app.trust.ITrustListener: void onEnabledTrustAgentsChanged(int)>
<android.app.trust.ITrustListener: void onTrustChanged(boolean,boolean,int,int,java.util.List)>
<android.app.trust.ITrustListener: void onTrustManagedChanged(boolean,int)>
<android.hardware.gnss.IGnssConfiguration: void setEmergencySuplPdn(boolean)>
<android.hardware.gnss.IGnssConfiguration: void setSuplMode(int)>
<android.hardware.gnss.IGnssConfiguration: int getInterfaceVersion()>
<android.hardware.gnss.IGnssConfiguration: void setGlonassPositioningProtocol(int)>
<android.hardware.gnss.IGnssConfiguration: void setBlocklist(android.hardware.gnss.BlocklistedSource[])>
<android.hardware.gnss.IGnssConfiguration: void setSuplVersion(int)>
<android.hardware.gnss.IGnssConfiguration: java.lang.String getInterfaceHash()>
<android.hardware.gnss.IGnssConfiguration: void setEsExtensionSec(int)>
<android.hardware.gnss.IGnssConfiguration: void setLppProfile(int)>
<com.android.ims.internal.uce.presence.IPresenceListener: void listCapInfoReceived(com.android.ims.internal.uce.presence.PresRlmiInfo,com.android.ims.internal.uce.presence.PresResInfo[])>
<com.android.ims.internal.uce.presence.IPresenceListener: void cmdStatus(com.android.ims.internal.uce.presence.PresCmdStatus)>
<com.android.ims.internal.uce.presence.IPresenceListener: void publishTriggering(com.android.ims.internal.uce.presence.PresPublishTriggerType)>
<com.android.ims.internal.uce.presence.IPresenceListener: void serviceUnAvailable(com.android.ims.internal.uce.common.StatusCode)>
<com.android.ims.internal.uce.presence.IPresenceListener: void serviceAvailable(com.android.ims.internal.uce.common.StatusCode)>
<com.android.ims.internal.uce.presence.IPresenceListener: void capInfoReceived(java.lang.String,com.android.ims.internal.uce.presence.PresTupleInfo[])>
<com.android.ims.internal.uce.presence.IPresenceListener: void unpublishMessageSent()>
<com.android.ims.internal.uce.presence.IPresenceListener: void getVersionCb(java.lang.String)>
<com.android.ims.internal.uce.presence.IPresenceListener: void sipResponseReceived(com.android.ims.internal.uce.presence.PresSipResponse)>
<android.media.musicrecognition.IMusicRecognitionManager: void beginRecognition(android.media.musicrecognition.RecognitionRequest,android.os.IBinder)>
<com.samsung.android.multiwindow.IDragAndDropClient: void onDisconnected()>
<com.samsung.android.multiwindow.IDragAndDropClient: void onConnected(android.os.IBinder,int)>
<com.samsung.android.multiwindow.IDragAndDropClient: boolean getInitialDropTargetVisible()>
<com.android.internal.telephony.IUpdateAvailableNetworksCallback: void onComplete(int)>
<android.service.dreams.IDreamService: void attach(android.os.IBinder,boolean,boolean,android.os.IRemoteCallback)>
<android.service.dreams.IDreamService: void wakeUp()>
<android.service.dreams.IDreamService: void detach()>
<android.hardware.radio.network.IRadioNetworkResponse: void setNetworkSelectionModeManualResponse(android.hardware.radio.RadioResponseInfo)>
<android.hardware.radio.network.IRadioNetworkResponse: void setNullCipherAndIntegrityEnabledResponse(android.hardware.radio.RadioResponseInfo)>
<android.hardware.radio.network.IRadioNetworkResponse: void supplyNetworkDepersonalizationResponse(android.hardware.radio.RadioResponseInfo,int)>
<android.hardware.radio.network.IRadioNetworkResponse: void cancelEmergencyNetworkScanResponse(android.hardware.radio.RadioResponseInfo)>
<android.hardware.radio.network.IRadioNetworkResponse: void getCellInfoListResponse(android.hardware.radio.RadioResponseInfo,android.hardware.radio.network.CellInfo[])>
<android.hardware.radio.network.IRadioNetworkResponse: void setSystemSelectionChannelsResponse(android.hardware.radio.RadioResponseInfo)>
<android.hardware.radio.network.IRadioNetworkResponse: void getVoiceRadioTechnologyResponse(android.hardware.radio.RadioResponseInfo,int)>
<android.hardware.radio.network.IRadioNetworkResponse: void getAvailableNetworksResponse(android.hardware.radio.RadioResponseInfo,android.hardware.radio.network.OperatorInfo[])>
<android.hardware.radio.network.IRadioNetworkResponse: void getSystemSelectionChannelsResponse(android.hardware.radio.RadioResponseInfo,android.hardware.radio.network.RadioAccessSpecifier[])>
<android.hardware.radio.network.IRadioNetworkResponse: void getAllowedNetworkTypesBitmapResponse(android.hardware.radio.RadioResponseInfo,int)>
<android.hardware.radio.network.IRadioNetworkResponse: void setN1ModeEnabledResponse(android.hardware.radio.RadioResponseInfo)>
<android.hardware.radio.network.IRadioNetworkResponse: void setNetworkSelectionModeAutomaticResponse(android.hardware.radio.RadioResponseInfo)>
<android.hardware.radio.network.IRadioNetworkResponse: void isNrDualConnectivityEnabledResponse(android.hardware.radio.RadioResponseInfo,boolean)>
<android.hardware.radio.network.IRadioNetworkResponse: void stopNetworkScanResponse(android.hardware.radio.RadioResponseInfo)>
<android.hardware.radio.network.IRadioNetworkResponse: void triggerEmergencyNetworkScanResponse(android.hardware.radio.RadioResponseInfo)>
<android.hardware.radio.network.IRadioNetworkResponse: void isN1ModeEnabledResponse(android.hardware.radio.RadioResponseInfo,boolean)>
<android.hardware.radio.network.IRadioNetworkResponse: void setUsageSettingResponse(android.hardware.radio.RadioResponseInfo)>
<android.hardware.radio.network.IRadioNetworkResponse: int getInterfaceVersion()>
<android.hardware.radio.network.IRadioNetworkResponse: void getDataRegistrationStateResponse(android.hardware.radio.RadioResponseInfo,android.hardware.radio.network.RegStateResult)>
<android.hardware.radio.network.IRadioNetworkResponse: void setCdmaRoamingPreferenceResponse(android.hardware.radio.RadioResponseInfo)>
<android.hardware.radio.network.IRadioNetworkResponse: void getUsageSettingResponse(android.hardware.radio.RadioResponseInfo,int)>
<android.hardware.radio.network.IRadioNetworkResponse: void exitEmergencyModeResponse(android.hardware.radio.RadioResponseInfo)>
<android.hardware.radio.network.IRadioNetworkResponse: void getCdmaRoamingPreferenceResponse(android.hardware.radio.RadioResponseInfo,int)>
<android.hardware.radio.network.IRadioNetworkResponse: void setIndicationFilterResponse(android.hardware.radio.RadioResponseInfo)>
<android.hardware.radio.network.IRadioNetworkResponse: void setSignalStrengthReportingCriteriaResponse(android.hardware.radio.RadioResponseInfo)>
<android.hardware.radio.network.IRadioNetworkResponse: void getBarringInfoResponse(android.hardware.radio.RadioResponseInfo,android.hardware.radio.network.CellIdentity,android.hardware.radio.network.BarringInfo[])>
<android.hardware.radio.network.IRadioNetworkResponse: void setAllowedNetworkTypesBitmapResponse(android.hardware.radio.RadioResponseInfo)>
<android.hardware.radio.network.IRadioNetworkResponse: void acknowledgeRequest(int)>
<android.hardware.radio.network.IRadioNetworkResponse: void getOperatorResponse(android.hardware.radio.RadioResponseInfo,java.lang.String,java.lang.String,java.lang.String)>
<android.hardware.radio.network.IRadioNetworkResponse: void setBarringPasswordResponse(android.hardware.radio.RadioResponseInfo)>
<android.hardware.radio.network.IRadioNetworkResponse: void setEmergencyModeResponse(android.hardware.radio.RadioResponseInfo,android.hardware.radio.network.EmergencyRegResult)>
<android.hardware.radio.network.IRadioNetworkResponse: void setCellInfoListRateResponse(android.hardware.radio.RadioResponseInfo)>
<android.hardware.radio.network.IRadioNetworkResponse: void setSuppServiceNotificationsResponse(android.hardware.radio.RadioResponseInfo)>
<android.hardware.radio.network.IRadioNetworkResponse: void getImsRegistrationStateResponse(android.hardware.radio.RadioResponseInfo,boolean,int)>
<android.hardware.radio.network.IRadioNetworkResponse: java.lang.String getInterfaceHash()>
<android.hardware.radio.network.IRadioNetworkResponse: void setLinkCapacityReportingCriteriaResponse(android.hardware.radio.RadioResponseInfo)>
<android.hardware.radio.network.IRadioNetworkResponse: void isNullCipherAndIntegrityEnabledResponse(android.hardware.radio.RadioResponseInfo,boolean)>
<android.hardware.radio.network.IRadioNetworkResponse: void setBandModeResponse(android.hardware.radio.RadioResponseInfo)>
<android.hardware.radio.network.IRadioNetworkResponse: void getSignalStrengthResponse(android.hardware.radio.RadioResponseInfo,android.hardware.radio.network.SignalStrength)>
<android.hardware.radio.network.IRadioNetworkResponse: void getNetworkSelectionModeResponse(android.hardware.radio.RadioResponseInfo,boolean)>
<android.hardware.radio.network.IRadioNetworkResponse: void setLocationUpdatesResponse(android.hardware.radio.RadioResponseInfo)>
<android.hardware.radio.network.IRadioNetworkResponse: void startNetworkScanResponse(android.hardware.radio.RadioResponseInfo)>
<android.hardware.radio.network.IRadioNetworkResponse: void getAvailableBandModesResponse(android.hardware.radio.RadioResponseInfo,int[])>
<android.hardware.radio.network.IRadioNetworkResponse: void setNrDualConnectivityStateResponse(android.hardware.radio.RadioResponseInfo)>
<android.hardware.radio.network.IRadioNetworkResponse: void getVoiceRegistrationStateResponse(android.hardware.radio.RadioResponseInfo,android.hardware.radio.network.RegStateResult)>
<android.hardware.gnss.IGnssNavigationMessageInterface: java.lang.String getInterfaceHash()>
<android.hardware.gnss.IGnssNavigationMessageInterface: int getInterfaceVersion()>
<android.hardware.gnss.IGnssNavigationMessageInterface: void setCallback(android.hardware.gnss.IGnssNavigationMessageCallback)>
<android.hardware.gnss.IGnssNavigationMessageInterface: void close()>
<android.service.storage.IExternalStorageService: void freeCache(java.lang.String,java.lang.String,long,android.os.RemoteCallback)>
<android.service.storage.IExternalStorageService: void notifyVolumeStateChanged(java.lang.String,android.os.storage.StorageVolume,android.os.RemoteCallback)>
<android.service.storage.IExternalStorageService: void notifyAnrDelayStarted(java.lang.String,int,int,int)>
<android.service.storage.IExternalStorageService: void endSession(java.lang.String,android.os.RemoteCallback)>
<android.service.storage.IExternalStorageService: void startSession(java.lang.String,int,android.os.ParcelFileDescriptor,java.lang.String,java.lang.String,android.os.RemoteCallback)>
<android.view.IWindowSession: int relayout(android.view.IWindow,android.view.WindowManager$LayoutParams,int,int,int,int,int,int,android.window.ClientWindowFrames,android.util.MergedConfiguration,android.view.SurfaceControl,android.view.InsetsState,android.view.InsetsSourceControl$Array,android.os.Bundle)>
<android.view.IWindowSession: void wallpaperOffsetsComplete(android.os.IBinder)>
<android.view.IWindowSession: void pokeDrawLock(android.os.IBinder)>
<android.view.IWindowSession: void cancelDragAndDrop(android.os.IBinder,boolean)>
<android.view.IWindowSession: int addToDisplayWithoutInputChannel(android.view.IWindow,android.view.WindowManager$LayoutParams,int,int,android.view.InsetsState,android.graphics.Rect,float[])>
<android.view.IWindowSession: boolean outOfMemory(android.view.IWindow)>
<android.view.IWindowSession: void updatePointerIcon(android.view.IWindow)>
<android.view.IWindowSession: void dragRecipientExited(android.view.IWindow)>
<android.view.IWindowSession: void finishMovingTask(android.view.IWindow)>
<android.view.IWindowSession: void reportDropResult(android.view.IWindow,boolean)>
<android.view.IWindowSession: int addToDisplayAsUser(android.view.IWindow,android.view.WindowManager$LayoutParams,int,int,int,int,android.view.InputChannel,android.view.InsetsState,android.view.InsetsSourceControl$Array,android.graphics.Rect,float[])>
<android.view.IWindowSession: void finishDrawing(android.view.IWindow,android.view.SurfaceControl$Transaction,int)>
<android.view.IWindowSession: void setWallpaperDisplayOffset(android.os.IBinder,int,int)>
<android.view.IWindowSession: void setOnBackInvokedCallbackInfo(android.view.IWindow,android.window.OnBackInvokedCallbackInfo)>
<android.view.IWindowSession: void setInsets(android.view.IWindow,int,android.graphics.Rect,android.graphics.Rect,android.graphics.Region)>
<android.view.IWindowSession: boolean transferEmbeddedTouchFocusToHost(android.view.IWindow)>
<android.view.IWindowSession: void setWallpaperZoomOut(android.os.IBinder,float)>
<android.view.IWindowSession: void setShouldZoomOutWallpaper(android.os.IBinder,boolean)>
<android.view.IWindowSession: void clearTouchableRegion(android.view.IWindow)>
<android.view.IWindowSession: void updateTapExcludeRegion(android.view.IWindow,android.graphics.Region)>
<android.view.IWindowSession: void relayoutAsync(android.view.IWindow,android.view.WindowManager$LayoutParams,int,int,int,int,int,int)>
<android.view.IWindowSession: void performHapticFeedbackAsync(int,boolean)>
<android.view.IWindowSession: void setTspNoteMode(android.view.IWindow,boolean)>
<android.view.IWindowSession: void onRectangleOnScreenRequested(android.os.IBinder,android.graphics.Rect)>
<android.view.IWindowSession: void grantInputChannelWithTaskToken(int,android.view.SurfaceControl,android.view.IWindow,android.os.IBinder,int,int,int,int,android.os.IBinder,android.os.IBinder,java.lang.String,android.view.InputChannel,int,android.window.WindowContainerToken)>
<android.view.IWindowSession: void performClipDataUpdate(android.content.ClipData)>
<android.view.IWindowSession: int addToDisplay(android.view.IWindow,android.view.WindowManager$LayoutParams,int,int,int,android.view.InputChannel,android.view.InsetsState,android.view.InsetsSourceControl$Array,android.graphics.Rect,float[])>
<android.view.IWindowSession: void updateRequestedVisibleTypes(android.view.IWindow,int)>
<android.view.IWindowSession: android.os.IBinder performDrag(android.view.IWindow,int,android.view.SurfaceControl,int,float,float,float,float,android.content.ClipData)>
<android.view.IWindowSession: void setWallpaperPosition(android.os.IBinder,float,float,float,float)>
<android.view.IWindowSession: android.os.IBinder performDragWithArea(android.view.IWindow,int,android.view.SurfaceControl,int,float,float,float,float,android.content.ClipData,android.graphics.RectF,android.graphics.Point)>
<android.view.IWindowSession: void dragRecipientEntered(android.view.IWindow)>
<android.view.IWindowSession: void grantInputChannel(int,android.view.SurfaceControl,android.view.IWindow,android.os.IBinder,int,int,int,int,android.os.IBinder,android.os.IBinder,java.lang.String,android.view.InputChannel)>
<android.view.IWindowSession: void wallpaperCommandComplete(android.os.IBinder,android.os.Bundle)>
<android.view.IWindowSession: void reportSystemGestureExclusionChanged(android.view.IWindow,java.util.List)>
<android.view.IWindowSession: void updateInputChannel(android.os.IBinder,int,android.view.SurfaceControl,int,int,int,android.graphics.Region)>
<android.view.IWindowSession: void grantEmbeddedWindowFocus(android.view.IWindow,android.os.IBinder,boolean)>
<android.view.IWindowSession: android.view.IWindowId getWindowId(android.os.IBinder)>
<android.view.IWindowSession: boolean startMovingTask(android.view.IWindow,float,float)>
<android.view.IWindowSession: void reportKeepClearAreasChanged(android.view.IWindow,java.util.List,java.util.List)>
<android.view.IWindowSession: void clearTspDeadzone(android.view.IWindow)>
<android.view.IWindowSession: boolean dropForAccessibility(android.view.IWindow,int,int)>
<android.view.IWindowSession: boolean performHapticFeedback(int,boolean)>
<android.view.IWindowSession: void remove(android.view.IWindow)>
<android.view.IWindowSession: boolean cancelDraw(android.view.IWindow)>
<android.view.IWindowSession: void generateDisplayHash(android.view.IWindow,android.graphics.Rect,java.lang.String,android.os.RemoteCallback)>
<android.view.IWindowSession: android.os.Bundle sendWallpaperCommand(android.os.IBinder,java.lang.String,int,int,int,android.os.Bundle,boolean)>
<android.view.IWindowSession: void removeWithTaskToken(android.view.IWindow,android.window.WindowContainerToken)>
<android.view.IWindowSession: void setTspDeadzone(android.view.IWindow,android.os.Bundle)>
<android.os.IUserManager: boolean isUserForeground(int)>
<android.os.IUserManager: boolean hasBaseUserRestriction(java.lang.String,int)>
<android.os.IUserManager: int getRemainingCreatableUserCount(java.lang.String)>
<android.os.IUserManager: boolean isUserUnlockingOrUnlocked(int)>
<android.os.IUserManager: int getUserHandle(int)>
<android.os.IUserManager: android.content.pm.UserInfo createProfileForUserEvenWhenDisallowedWithThrow(java.lang.String,java.lang.String,int,int,java.lang.String[])>
<android.os.IUserManager: void setUserIcon(int,android.graphics.Bitmap)>
<android.os.IUserManager: int getPreviousFullUserToEnterForeground()>
<android.os.IUserManager: android.content.pm.UserInfo getUserInfo(int)>
<android.os.IUserManager: int[] getVisibleUsers()>
<android.os.IUserManager: java.util.List getUsers(boolean,boolean,boolean)>
<android.os.IUserManager: android.content.pm.UserProperties getUserPropertiesCopy(int)>
<android.os.IUserManager: void revokeUserAdmin(int)>
<android.os.IUserManager: boolean canHaveRestrictedProfile(int)>
<android.os.IUserManager: android.os.Bundle getApplicationRestrictionsForUser(java.lang.String,int)>
<android.os.IUserManager: int getBootUser()>
<android.os.IUserManager: android.content.pm.UserInfo createUserWithThrow(java.lang.String,java.lang.String,int)>
<android.os.IUserManager: android.os.UserHandle createUserWithAttributes(java.lang.String,java.lang.String,int,android.graphics.Bitmap,java.lang.String,java.lang.String,android.os.PersistableBundle)>
<android.os.IUserManager: boolean isPreCreated(int)>
<android.os.IUserManager: boolean removeUser(int)>
<android.os.IUserManager: boolean isUserTypeEnabled(java.lang.String)>
<android.os.IUserManager: android.content.pm.UserInfo createProfileForUserWithThrow(java.lang.String,java.lang.String,int,int,java.lang.String[])>
<android.os.IUserManager: boolean isDemoUser(int)>
<android.os.IUserManager: void setUserEnabled(int)>
<android.os.IUserManager: int getMainUserId()>
<android.os.IUserManager: android.content.pm.UserInfo preCreateUserWithThrow(java.lang.String)>
<android.os.IUserManager: int getUserSwitchability(int)>
<android.os.IUserManager: boolean canAddMoreUsersOfType(java.lang.String)>
<android.os.IUserManager: int[] getProfileIds(int,boolean)>
<android.os.IUserManager: boolean removeUserEvenWhenDisallowed(int)>
<android.os.IUserManager: boolean isRestricted(int)>
<android.os.IUserManager: boolean isQuietModeEnabled(int)>
<android.os.IUserManager: long getUserUnlockRealtime()>
<android.os.IUserManager: void setUserRestriction(java.lang.String,boolean,int)>
<android.os.IUserManager: void evictCredentialEncryptionKey(int)>
<android.os.IUserManager: int getUserBadgeResId(int)>
<android.os.IUserManager: java.lang.String getUserAccount(int)>
<android.os.IUserManager: long getUserCreationTime(int)>
<android.os.IUserManager: boolean isUserUnlocked(int)>
<android.os.IUserManager: boolean isSameProfileGroup(int,int)>
<android.os.IUserManager: boolean canAddMoreManagedProfiles(int,boolean)>
<android.os.IUserManager: boolean isHeadlessSystemUserMode()>
<android.os.IUserManager: boolean requestQuietModeEnabled(java.lang.String,boolean,int,android.content.IntentSender,int)>
<android.os.IUserManager: void clearSeedAccountData(int)>
<android.os.IUserManager: void setSeedAccountData(int,java.lang.String,java.lang.String,android.os.PersistableBundle,boolean)>
<android.os.IUserManager: void addUserRestrictionsListener(android.os.IUserRestrictionsListener)>
<android.os.IUserManager: int getUserBadgeLabelResId(int)>
<android.os.IUserManager: java.util.List getUserRestrictionSources(java.lang.String,int)>
<android.os.IUserManager: int getUserBadgeNoBackgroundResId(int)>
<android.os.IUserManager: boolean setUserEphemeral(int,boolean)>
<android.os.IUserManager: boolean isUserOfType(int,java.lang.String)>
<android.os.IUserManager: boolean hasRestrictedProfiles(int)>
<android.os.IUserManager: android.content.pm.UserInfo createRestrictedProfileWithThrow(java.lang.String,int)>
<android.os.IUserManager: int getUserBadgeColorResId(int)>
<android.os.IUserManager: int getUserRestrictionSource(java.lang.String,int)>
<android.os.IUserManager: void setDefaultGuestRestrictions(android.os.Bundle)>
<android.os.IUserManager: android.os.Bundle getDefaultGuestRestrictions()>
<android.os.IUserManager: android.content.pm.UserInfo getPrimaryUser()>
<android.os.IUserManager: java.lang.String getSeedAccountType(int)>
<android.os.IUserManager: int getCredentialOwnerProfile(int)>
<android.os.IUserManager: boolean isUserSwitcherEnabled(boolean,int)>
<android.os.IUserManager: java.lang.String getUserName()>
<android.os.IUserManager: boolean updateUserInfo(int,android.os.Bundle)>
<android.os.IUserManager: boolean hasUserRestriction(java.lang.String,int)>
<android.os.IUserManager: android.os.Bundle getUserRestrictions(int)>
<android.os.IUserManager: boolean hasUserRestrictionOnAnyUser(java.lang.String)>
<android.os.IUserManager: boolean isSettingRestrictedForUser(java.lang.String,int,java.lang.String,int)>
<android.os.IUserManager: java.lang.String[] getPreInstallableSystemPackages(java.lang.String)>
<android.os.IUserManager: boolean isUserVisible(int)>
<android.os.IUserManager: android.os.PersistableBundle getSeedAccountOptions(int)>
<android.os.IUserManager: void setUserAdmin(int)>
<android.os.IUserManager: void setBootUser(int)>
<android.os.IUserManager: java.lang.String getProfileType(int)>
<android.os.IUserManager: void setUserName(int,java.lang.String)>
<android.os.IUserManager: long getUserStartRealtime()>
<android.os.IUserManager: int getProfileParentId(int)>
<android.os.IUserManager: boolean isAdminUser(int)>
<android.os.IUserManager: boolean isUserRunning(int)>
<android.os.IUserManager: int getUserBadgeDarkColorResId(int)>
<android.os.IUserManager: boolean isUserNameSet(int)>
<android.os.IUserManager: void setApplicationRestrictions(java.lang.String,android.os.Bundle,int)>
<android.os.IUserManager: java.util.List getProfiles(int,boolean)>
<android.os.IUserManager: int getUserIconBadgeResId(int)>
<android.os.IUserManager: boolean someUserHasAccount(java.lang.String,java.lang.String)>
<android.os.IUserManager: android.os.Bundle getApplicationRestrictions(java.lang.String)>
<android.os.IUserManager: boolean hasBadge(int)>
<android.os.IUserManager: java.util.List getGuestUsers()>
<android.os.IUserManager: java.lang.String getSeedAccountName(int)>
<android.os.IUserManager: boolean markGuestForDeletion(int)>
<android.os.IUserManager: android.os.ParcelFileDescriptor getUserIcon(int)>
<android.os.IUserManager: boolean someUserHasSeedAccount(java.lang.String,java.lang.String)>
<android.os.IUserManager: int getMainDisplayIdAssignedToUser()>
<android.os.IUserManager: int getUserSerialNumber(int)>
<android.os.IUserManager: int removeUserWhenPossible(int,boolean)>
<android.os.IUserManager: android.content.pm.UserInfo getProfileParent(int)>
<android.os.IUserManager: void setUserAccount(int,java.lang.String)>
<android.os.IUserManager: int getRemainingCreatableProfileCount(java.lang.String,int)>
<android.os.IUserManager: boolean canAddMoreProfilesToUser(java.lang.String,int,boolean)>
<com.android.internal.app.IBatteryStatsCallback: void notifyNetworkStatsUpdated(java.util.List)>
<android.hardware.input.IInputManager: boolean unregisterVibratorStateListener(int,android.os.IVibratorStateListener)>
<android.hardware.input.IInputManager: void registerLidStateChangedListener(android.hardware.input.ISemLidStateChangedListener)>
<android.hardware.input.IInputManager: void setDisplayIdForPointerIcon(int)>
<android.hardware.input.IInputManager: void registerWirelessKeyboardShareChangedListener(android.hardware.input.IWirelessKeyboardShareChangedListener)>
<android.hardware.input.IInputManager: java.util.List getLights(int)>
<android.hardware.input.IInputManager: int getDisplayIdForPointerIcon()>
<android.hardware.input.IInputManager: boolean injectInputEvent(android.view.InputEvent,int)>
<android.hardware.input.IInputManager: java.lang.String getKeyboardLayoutForInputDevice(android.hardware.input.InputDeviceIdentifier,int,android.view.inputmethod.InputMethodInfo,android.view.inputmethod.InputMethodSubtype)>
<android.hardware.input.IInputManager: void clearAllModifierKeyRemappings()>
<android.hardware.input.IInputManager: void disableInputDevice(int)>
<android.hardware.input.IInputManager: android.hardware.input.InputSensorInfo[] getSensorList(int)>
<android.hardware.input.IInputManager: void vibrate(int,android.os.VibrationEffect,android.os.IBinder)>
<android.hardware.input.IInputManager: java.util.Map getModifierKeyRemapping()>
<android.hardware.input.IInputManager: void registerSwitchEventChangedListener(android.hardware.input.ISwitchEventChangedListener)>
<android.hardware.input.IInputManager: void updateWirelessKeyboardShareStatus()>
<android.hardware.input.IInputManager: boolean isDefaultPointerIconChanged()>
<android.hardware.input.IInputManager: int[] getVibratorIds(int)>
<android.hardware.input.IInputManager: void cancelVibrate(int,android.os.IBinder)>
<android.hardware.input.IInputManager: void setCustomHoverIcon(android.view.PointerIcon)>
<android.hardware.input.IInputManager: void vibrateCombined(int,android.os.CombinedVibration,android.os.IBinder)>
<android.hardware.input.IInputManager: void remapModifierKey(int,int)>
<android.hardware.input.IInputManager: android.hardware.input.HostUsiVersion getHostUsiVersionFromDisplayConfig(int)>
<android.hardware.input.IInputManager: void removeDeviceWirelessKeyboardShare(java.lang.String,int)>
<android.hardware.input.IInputManager: void forceFadeIcon(int)>
<android.hardware.input.IInputManager: android.hardware.input.TouchCalibration getTouchCalibrationForInputDevice(java.lang.String,int)>
<android.hardware.input.IInputManager: boolean supportPogoDevice()>
<android.hardware.input.IInputManager: int getKeyCodeForKeyLocation(int,int)>
<android.hardware.input.IInputManager: int getToolTypeForDefaultPointerIcon()>
<android.hardware.input.IInputManager: boolean isInputDeviceEnabled(int)>
<android.hardware.input.IInputManager: int getInboundQueueLength()>
<android.hardware.input.IInputManager: void tryPointerSpeed(int)>
<android.hardware.input.IInputManager: android.hardware.input.KeyboardLayout[] getKeyboardLayoutsForInputDevice(android.hardware.input.InputDeviceIdentifier)>
<android.hardware.input.IInputManager: int getScanCodeState(int,int,int)>
<android.hardware.input.IInputManager: void setHostRoleWirelessKeyboardShare()>
<android.hardware.input.IInputManager: android.hardware.input.IInputDeviceBatteryState getBatteryState(int)>
<android.hardware.input.IInputManager: void setDefaultPointerIcon(int,android.view.PointerIcon,boolean)>
<android.hardware.input.IInputManager: int getLidState()>
<android.hardware.input.IInputManager: void cancelCurrentTouch()>
<android.hardware.input.IInputManager: void changeDeviceWirelessKeyboardShare(java.lang.String,int)>
<android.hardware.input.IInputManager: android.hardware.input.KeyboardLayout getKeyboardLayout(java.lang.String)>
<android.hardware.input.IInputManager: android.view.PointerIcon getDefaultPointerIcon()>
<android.hardware.input.IInputManager: long getLastLidEventTimeNanos()>
<android.hardware.input.IInputManager: android.view.VerifiedInputEvent verifyInputEvent(android.view.InputEvent)>
<android.hardware.input.IInputManager: void requestPointerCapture(android.os.IBinder,boolean)>
<android.hardware.input.IInputManager: java.lang.String getInputDeviceBluetoothAddress(int)>
<android.hardware.input.IInputManager: int checkInputFeature()>
<android.hardware.input.IInputManager: void registerTabletModeChangedListener(android.hardware.input.ITabletModeChangedListener)>
<android.hardware.input.IInputManager: void setLightStates(int,int[],android.hardware.lights.LightState[],android.os.IBinder)>
<android.hardware.input.IInputManager: boolean injectInputEventToTarget(android.view.InputEvent,int,int)>
<android.hardware.input.IInputManager: void setShowAllTouches(boolean)>
<android.hardware.input.IInputManager: void registerInputDevicesChangedListener(android.hardware.input.IInputDevicesChangedListener)>
<android.hardware.input.IInputManager: void unregisterBatteryListener(int,android.hardware.input.IInputDeviceBatteryListener)>
<android.hardware.input.IInputManager: android.view.InputDevice getInputDevice(int)>
<android.hardware.input.IInputManager: void addKeyboardLayoutForInputDevice(android.hardware.input.InputDeviceIdentifier,java.lang.String)>
<android.hardware.input.IInputManager: android.view.InputChannel monitorInputForBinder(java.lang.String,int,int)>
<android.hardware.input.IInputManager: int isInTabletMode()>
<android.hardware.input.IInputManager: int getGlobalMetaState(int)>
<android.hardware.input.IInputManager: void addPortAssociation(java.lang.String,int)>
<android.hardware.input.IInputManager: boolean isUidTouched(int)>
<android.hardware.input.IInputManager: void setWakeKeyDynamically(java.lang.String,boolean,java.lang.String)>
<android.hardware.input.IInputManager: boolean flushSensor(int,int)>
<android.hardware.input.IInputManager: boolean setTspEnabled(int,boolean)>
<android.hardware.input.IInputManager: android.view.InputMonitor monitorGestureInputFiltered(android.os.IBinder,java.lang.String,int,int)>
<android.hardware.input.IInputManager: void registerKeyboardBacklightListener(android.hardware.input.IKeyboardBacklightListener)>
<android.hardware.input.IInputManager: void closeLightSession(int,android.os.IBinder)>
<android.hardware.input.IInputManager: void removeKeyboardLayoutForInputDevice(android.hardware.input.InputDeviceIdentifier,java.lang.String)>
<android.hardware.input.IInputManager: java.lang.String[] getEnabledKeyboardLayoutsForInputDevice(android.hardware.input.InputDeviceIdentifier)>
<android.hardware.input.IInputManager: android.hardware.lights.LightState getLightState(int,int)>
<android.hardware.input.IInputManager: void unregisterKeyboardBacklightListener(android.hardware.input.IKeyboardBacklightListener)>
<android.hardware.input.IInputManager: java.lang.String getCurrentKeyboardLayoutForInputDevice(android.hardware.input.InputDeviceIdentifier)>
<android.hardware.input.IInputManager: void removeUniqueIdAssociation(java.lang.String)>
<android.hardware.input.IInputManager: android.view.InputMonitor monitorGestureInput(android.os.IBinder,java.lang.String,int)>
<android.hardware.input.IInputManager: void addUniqueIdAssociation(java.lang.String,java.lang.String)>
<android.hardware.input.IInputManager: void notifyQuickAccess(int,float,float)>
<android.hardware.input.IInputManager: void pilferPointers(android.os.IBinder)>
<android.hardware.input.IInputManager: boolean registerVibratorStateListener(int,android.os.IVibratorStateListener)>
<android.hardware.input.IInputManager: void setKeyboardLayoutForInputDevice(android.hardware.input.InputDeviceIdentifier,int,android.view.inputmethod.InputMethodInfo,android.view.inputmethod.InputMethodSubtype,java.lang.String)>
<android.hardware.input.IInputManager: boolean hasKeys(int,int,int[],boolean[])>
<android.hardware.input.IInputManager: boolean addDeviceWirelessKeyboardShare(int)>
<android.hardware.input.IInputManager: int isMicMuted()>
<android.hardware.input.IInputManager: void setPointerIconType(int)>
<android.hardware.input.IInputManager: void registerMultiFingerGestureListener(android.hardware.input.IMultiFingerGestureListener)>
<android.hardware.input.IInputManager: void setTouchCalibrationForInputDevice(java.lang.String,int,android.hardware.input.TouchCalibration)>
<android.hardware.input.IInputManager: boolean isVibrating(int)>
<android.hardware.input.IInputManager: void setCustomPointerIcon(android.view.PointerIcon)>
<android.hardware.input.IInputManager: java.lang.String getVelocityTrackerStrategy()>
<android.hardware.input.IInputManager: int getPointerIconType()>
<android.hardware.input.IInputManager: void openLightSession(int,java.lang.String,android.os.IBinder)>
<android.hardware.input.IInputManager: boolean enableSensor(int,int,int,int)>
<android.hardware.input.IInputManager: int getCurrentSwitchEventState(int,boolean)>
<android.hardware.input.IInputManager: android.hardware.input.KeyboardLayout[] getKeyboardLayoutListForInputDevice(android.hardware.input.InputDeviceIdentifier,int,android.view.inputmethod.InputMethodInfo,android.view.inputmethod.InputMethodSubtype)>
<android.hardware.input.IInputManager: void enableInputDevice(int)>
<android.hardware.input.IInputManager: int[] getInputDeviceIds()>
<android.hardware.input.IInputManager: boolean registerSensorListener(android.hardware.input.IInputSensorEventListener)>
<android.hardware.input.IInputManager: void setCurrentKeyboardLayoutForInputDevice(android.hardware.input.InputDeviceIdentifier,java.lang.String)>
<android.hardware.input.IInputManager: void unregisterSensorListener(android.hardware.input.IInputSensorEventListener)>
<android.hardware.input.IInputManager: void registerBatteryListener(int,android.hardware.input.IInputDeviceBatteryListener)>
<android.hardware.input.IInputManager: boolean switchDeviceWirelessKeyboardShare(java.lang.String,int)>
<android.hardware.input.IInputManager: long semGetMotionIdleTimeMillis(boolean)>
<android.hardware.input.IInputManager: void registerPointerIconChangedListener(android.hardware.input.IPointerIconChangedListener)>
<android.hardware.input.IInputManager: void connectByBtDevice(android.bluetooth.BluetoothDevice)>
<android.hardware.input.IInputManager: void setStartedShutdown(boolean)>
<android.hardware.input.IInputManager: void removePortAssociation(java.lang.String)>
<android.hardware.input.IInputManager: android.hardware.input.KeyboardLayout[] getKeyboardLayouts()>
<android.hardware.input.IInputManager: void disableSensor(int,int)>
<android.telephony.ims.aidl.IFeatureProvisioningCallback: void onFeatureProvisioningChanged(int,int,boolean)>
<android.telephony.ims.aidl.IFeatureProvisioningCallback: void onRcsFeatureProvisioningChanged(int,int,boolean)>
<android.service.quicksettings.IQSService: android.service.quicksettings.Tile getTile(android.os.IBinder)>
<android.service.quicksettings.IQSService: void onStartActivity(android.os.IBinder)>
<android.service.quicksettings.IQSService: void startActivity(android.os.IBinder,android.app.PendingIntent)>
<android.service.quicksettings.IQSService: void onDialogHidden(android.os.IBinder)>
<android.service.quicksettings.IQSService: void semUpdateDetailView(android.os.IBinder)>
<android.service.quicksettings.IQSService: void updateQsTile(android.service.quicksettings.Tile,android.os.IBinder)>
<android.service.quicksettings.IQSService: void updateStatusIcon(android.os.IBinder,android.graphics.drawable.Icon,java.lang.String)>
<android.service.quicksettings.IQSService: void startUnlockAndRun(android.os.IBinder)>
<android.service.quicksettings.IQSService: boolean isLocked()>
<android.service.quicksettings.IQSService: boolean isSecure()>
<android.service.quicksettings.IQSService: void onShowDialog(android.os.IBinder)>
<android.service.quicksettings.IQSService: void onStartSuccessful(android.os.IBinder)>
<android.service.quicksettings.IQSService: void semFireToggleStateChanged(android.os.IBinder,boolean,boolean)>
<android.service.assist.classification.IFieldClassificationCallback: void onCancellable(android.os.ICancellationSignal)>
<android.service.assist.classification.IFieldClassificationCallback: boolean isCompleted()>
<android.service.assist.classification.IFieldClassificationCallback: void onFailure()>
<android.service.assist.classification.IFieldClassificationCallback: void onSuccess(android.service.assist.classification.FieldClassificationResponse)>
<android.service.assist.classification.IFieldClassificationCallback: void cancel()>
<android.service.euicc.ISwitchToSubscriptionCallback: void onComplete(int)>
<android.view.translation.ITranslationDirectManager: void onFinishTranslationSession(int)>
<android.view.translation.ITranslationDirectManager: void onTranslationRequest(android.view.translation.TranslationRequest,int,android.os.ICancellationSignal,android.service.translation.ITranslationCallback)>
<android.security.apc.IConfirmationCallback: void onCompleted(int,byte[])>
<android.net.wifi.sharedconnectivity.service.ISharedConnectivityService: android.net.wifi.sharedconnectivity.app.KnownNetworkConnectionStatus getKnownNetworkConnectionStatus()>
<android.net.wifi.sharedconnectivity.service.ISharedConnectivityService: android.net.wifi.sharedconnectivity.app.HotspotNetworkConnectionStatus getHotspotNetworkConnectionStatus()>
<android.net.wifi.sharedconnectivity.service.ISharedConnectivityService: java.util.List getKnownNetworks()>
<android.net.wifi.sharedconnectivity.service.ISharedConnectivityService: void registerCallback(android.net.wifi.sharedconnectivity.service.ISharedConnectivityCallback)>
<android.net.wifi.sharedconnectivity.service.ISharedConnectivityService: android.net.wifi.sharedconnectivity.app.SharedConnectivitySettingsState getSettingsState()>
<android.net.wifi.sharedconnectivity.service.ISharedConnectivityService: void disconnectHotspotNetwork(android.net.wifi.sharedconnectivity.app.HotspotNetwork)>
<android.net.wifi.sharedconnectivity.service.ISharedConnectivityService: void connectHotspotNetwork(android.net.wifi.sharedconnectivity.app.HotspotNetwork)>
<android.net.wifi.sharedconnectivity.service.ISharedConnectivityService: void connectKnownNetwork(android.net.wifi.sharedconnectivity.app.KnownNetwork)>
<android.net.wifi.sharedconnectivity.service.ISharedConnectivityService: void unregisterCallback(android.net.wifi.sharedconnectivity.service.ISharedConnectivityCallback)>
<android.net.wifi.sharedconnectivity.service.ISharedConnectivityService: java.util.List getHotspotNetworks()>
<android.net.wifi.sharedconnectivity.service.ISharedConnectivityService: void forgetKnownNetwork(android.net.wifi.sharedconnectivity.app.KnownNetwork)>
<android.net.wifi.sharedconnectivity.service.ISharedConnectivityCallback: void onHotspotNetworkConnectionStatusChanged(android.net.wifi.sharedconnectivity.app.HotspotNetworkConnectionStatus)>
<android.net.wifi.sharedconnectivity.service.ISharedConnectivityCallback: void onKnownNetworkConnectionStatusChanged(android.net.wifi.sharedconnectivity.app.KnownNetworkConnectionStatus)>
<android.net.wifi.sharedconnectivity.service.ISharedConnectivityCallback: void onKnownNetworksUpdated(java.util.List)>
<android.net.wifi.sharedconnectivity.service.ISharedConnectivityCallback: void onSharedConnectivitySettingsChanged(android.net.wifi.sharedconnectivity.app.SharedConnectivitySettingsState)>
<android.net.wifi.sharedconnectivity.service.ISharedConnectivityCallback: void onHotspotNetworksUpdated(java.util.List)>
<android.hardware.tv.tuner.IFrontend: void tune(android.hardware.tv.tuner.FrontendSettings)>
<android.hardware.tv.tuner.IFrontend: void scan(android.hardware.tv.tuner.FrontendSettings,int)>
<android.hardware.tv.tuner.IFrontend: java.lang.String getInterfaceHash()>
<android.hardware.tv.tuner.IFrontend: int getInterfaceVersion()>
<android.hardware.tv.tuner.IFrontend: android.hardware.tv.tuner.FrontendStatus[] getStatus(int[])>
<android.hardware.tv.tuner.IFrontend: int[] getFrontendStatusReadiness(int[])>
<android.hardware.tv.tuner.IFrontend: int linkCiCam(int)>
<android.hardware.tv.tuner.IFrontend: void setCallback(android.hardware.tv.tuner.IFrontendCallback)>
<android.hardware.tv.tuner.IFrontend: java.lang.String getHardwareInfo()>
<android.hardware.tv.tuner.IFrontend: void stopScan()>
<android.hardware.tv.tuner.IFrontend: void close()>
<android.hardware.tv.tuner.IFrontend: void removeOutputPid(int)>
<android.hardware.tv.tuner.IFrontend: void stopTune()>
<android.hardware.tv.tuner.IFrontend: void setLnb(int)>
<android.hardware.tv.tuner.IFrontend: void unlinkCiCam(int)>
<android.app.IUiAutomationConnection: boolean setRotation(int)>
<android.app.IUiAutomationConnection: void connect(android.accessibilityservice.IAccessibilityServiceClient,int)>
<android.app.IUiAutomationConnection: void disconnect()>
<android.app.IUiAutomationConnection: android.view.WindowContentFrameStats getWindowContentFrameStats(int)>
<android.app.IUiAutomationConnection: java.util.List getAdoptedShellPermissions()>
<android.app.IUiAutomationConnection: void syncInputTransactions(boolean)>
<android.app.IUiAutomationConnection: void dropShellPermissionIdentity()>
<android.app.IUiAutomationConnection: android.graphics.Bitmap takeSurfaceControlScreenshot(android.view.SurfaceControl)>
<android.app.IUiAutomationConnection: void adoptShellPermissionIdentity(int,java.lang.String[])>
<android.app.IUiAutomationConnection: void executeShellCommandWithStderr(java.lang.String,android.os.ParcelFileDescriptor,android.os.ParcelFileDescriptor,android.os.ParcelFileDescriptor)>
<android.app.IUiAutomationConnection: boolean injectInputEvent(android.view.InputEvent,boolean,boolean)>
<android.app.IUiAutomationConnection: void injectInputEventToInputFilter(android.view.InputEvent)>
<android.app.IUiAutomationConnection: void shutdown()>
<android.app.IUiAutomationConnection: void clearWindowAnimationFrameStats()>
<android.app.IUiAutomationConnection: void revokeRuntimePermission(java.lang.String,java.lang.String,int)>
<android.app.IUiAutomationConnection: void executeShellCommand(java.lang.String,android.os.ParcelFileDescriptor,android.os.ParcelFileDescriptor)>
<android.app.IUiAutomationConnection: android.graphics.Bitmap takeScreenshot(android.graphics.Rect)>
<android.app.IUiAutomationConnection: void grantRuntimePermission(java.lang.String,java.lang.String,int)>
<android.app.IUiAutomationConnection: boolean clearWindowContentFrameStats(int)>
<android.app.IUiAutomationConnection: android.view.WindowAnimationFrameStats getWindowAnimationFrameStats()>
<com.android.internal.app.IAppOpsAsyncNotedCallback: void opNoted(android.app.AsyncNotedAppOp)>
<android.sec.enterprise.adapterlayer.ISystemUIAdapterCallback: void setPasswordLockDelay(int)>
<android.sec.enterprise.adapterlayer.ISystemUIAdapterCallback: void setSettingsChangeAllowed(boolean)>
<android.sec.enterprise.adapterlayer.ISystemUIAdapterCallback: void setWifiStateChangeAllowed(boolean)>
<android.sec.enterprise.adapterlayer.ISystemUIAdapterCallback: void setLocationProviderAllowed(java.lang.String,boolean)>
<android.sec.enterprise.adapterlayer.ISystemUIAdapterCallback: void setGPSStateChangeAllowed(boolean)>
<android.sec.enterprise.adapterlayer.ISystemUIAdapterCallback: void setFaceRecognitionEvenCameraBlockedAllowed(boolean)>
<android.sec.enterprise.adapterlayer.ISystemUIAdapterCallback: void setLockscreenWallpaper(boolean)>
<android.sec.enterprise.adapterlayer.ISystemUIAdapterCallback: void setNavigationBarHidden(boolean)>
<android.sec.enterprise.adapterlayer.ISystemUIAdapterCallback: void setRoamingAllowed(boolean)>
<android.sec.enterprise.adapterlayer.ISystemUIAdapterCallback: void setAirplaneModeAllowed(boolean)>
<android.sec.enterprise.adapterlayer.ISystemUIAdapterCallback: void setLockedIccIds(java.lang.String[])>
<android.sec.enterprise.adapterlayer.ISystemUIAdapterCallback: void setPwdChangeRequested(int)>
<android.sec.enterprise.adapterlayer.ISystemUIAdapterCallback: void setMultifactorAuthEnabled(boolean)>
<android.sec.enterprise.adapterlayer.ISystemUIAdapterCallback: void setCellularDataAllowed(boolean)>
<android.sec.enterprise.adapterlayer.ISystemUIAdapterCallback: void setStatusBarExpansionAllowed(boolean)>
<android.sec.enterprise.adapterlayer.ISystemUIAdapterCallback: void setWifiTetheringAllowed(boolean)>
<android.sec.enterprise.adapterlayer.ISystemUIAdapterCallback: void setMaximumFailedPasswordsForProfileDisable(int)>
<android.sec.enterprise.adapterlayer.ISystemUIAdapterCallback: void setNFCStateChangeAllowed(boolean)>
<android.sec.enterprise.adapterlayer.ISystemUIAdapterCallback: void setMaximumFailedPasswordsForDisable(int,java.lang.String)>
<android.sec.enterprise.adapterlayer.ISystemUIAdapterCallback: void setStatusBarHidden(boolean)>
<android.sec.enterprise.adapterlayer.ISystemUIAdapterCallback: void excludeExternalStorageForFailedPasswordsWipe(boolean)>
<android.sec.enterprise.adapterlayer.ISystemUIAdapterCallback: void setCameraAllowed(boolean)>
<android.sec.enterprise.adapterlayer.ISystemUIAdapterCallback: void setAdminLock(boolean,boolean)>
<android.sec.enterprise.adapterlayer.ISystemUIAdapterCallback: void setApplicationNameControlEnabled(boolean)>
<android.sec.enterprise.adapterlayer.ISystemUIAdapterCallback: void setBluetoothAllowed(boolean)>
<android.sec.enterprise.adapterlayer.ISystemUIAdapterCallback: void setPasswordVisibilityEnabled(boolean)>
<android.sec.enterprise.adapterlayer.ISystemUIAdapterCallback: void setLockscreenInvisibleOverlay(boolean)>
<android.sec.enterprise.adapterlayer.ISystemUIAdapterCallback: void setKioskModeEnabled(boolean)>
<android.sec.enterprise.adapterlayer.ISystemUIAdapterCallback: void setWifiAllowed(boolean)>
<com.samsung.android.desktopmode.IDesktopModeUiService: void removeNavBarIcon(int)>
<com.samsung.android.desktopmode.IDesktopModeUiService: boolean isActivityShowing(int)>
<com.samsung.android.desktopmode.IDesktopModeUiService: void finishActivity(int)>
<com.samsung.android.desktopmode.IDesktopModeUiService: void removeNotification(int)>
<com.samsung.android.desktopmode.IDesktopModeUiService: int getCurrentOverlayType(int)>
<com.samsung.android.desktopmode.IDesktopModeUiService: boolean hasUiElement()>
<com.samsung.android.desktopmode.IDesktopModeUiService: void showNavBarIcon(int)>
<com.samsung.android.desktopmode.IDesktopModeUiService: void dismissOverlay(int,int)>
<com.samsung.android.desktopmode.IDesktopModeUiService: void showDialog(int,int,com.samsung.android.desktopmode.IDesktopModeUiServiceCallback)>
<com.samsung.android.desktopmode.IDesktopModeUiService: int getCurrentDialogType()>
<com.samsung.android.desktopmode.IDesktopModeUiService: void showNotification(int)>
<com.samsung.android.desktopmode.IDesktopModeUiService: void showOverlay(int,int,com.samsung.android.desktopmode.IDesktopModeUiServiceCallback)>
<com.samsung.android.desktopmode.IDesktopModeUiService: void dismissDialog(int,int)>
<com.samsung.android.desktopmode.IDesktopModeUiService: void startActivity(int,int,com.samsung.android.desktopmode.IDesktopModeUiServiceCallback)>
<com.samsung.android.desktopmode.IDesktopModeUiService: boolean hasOverlay(int,int)>
<android.telephony.ims.aidl.IImsCapabilityCallback: void onQueryCapabilityConfiguration(int,int,boolean)>
<android.telephony.ims.aidl.IImsCapabilityCallback: void onChangeCapabilityConfigurationError(int,int,int)>
<android.telephony.ims.aidl.IImsCapabilityCallback: void onCapabilitiesStatusChanged(int)>
<com.android.internal.telephony.euicc.IGetDefaultSmdpAddressCallback: void onComplete(int,java.lang.String)>
<com.android.internal.telephony.ISms: android.os.Bundle getCarrierConfigValuesForSubscriber(int)>
<com.android.internal.telephony.ISms: boolean enableCellBroadcastRangeForSubscriber(int,int,int,int)>
<com.android.internal.telephony.ISms: int getPreferredSmsSubscription()>
<com.android.internal.telephony.ISms: boolean resetAllCellBroadcastRanges(int)>
<com.android.internal.telephony.ISms: boolean isSmsSimPickActivityNeeded(int)>
<com.android.internal.telephony.ISms: void sendTextwithOptionsForSubscriber(int,java.lang.String,java.lang.String,java.lang.String,java.lang.String,android.app.PendingIntent,android.app.PendingIntent,boolean,int,int,int)>
<com.android.internal.telephony.ISms: void setStorageMonitorMemoryStatusOverride(int,boolean)>
<com.android.internal.telephony.ISms: boolean getSmsSettingForSubscriber(int,java.lang.String)>
<com.android.internal.telephony.ISms: boolean disableCellBroadcastForSubscriber(int,int,int)>
<com.android.internal.telephony.ISms: boolean getSMSPAvailableForSubscriber(int)>
<com.android.internal.telephony.ISms: void sendTextwithOptionsReadconfirmForSubscriber(int,java.lang.String,java.lang.String,java.lang.String,java.lang.String,android.app.PendingIntent,android.app.PendingIntent,boolean,int,int,int,int)>
<com.android.internal.telephony.ISms: void sendStoredMultipartText(int,java.lang.String,java.lang.String,android.net.Uri,java.lang.String,java.util.List,java.util.List)>
<com.android.internal.telephony.ISms: void sendMultipartTextwithOptionsForSubscriber(int,java.lang.String,java.lang.String,java.lang.String,java.util.List,java.util.List,java.util.List,boolean,int,int,int)>
<com.android.internal.telephony.ISms: void sendTextwithCBPForSubscriber(int,java.lang.String,java.lang.String,java.lang.String,java.lang.String,android.app.PendingIntent,android.app.PendingIntent,java.lang.String,int)>
<com.android.internal.telephony.ISms: void setPremiumSmsPermissionForSubscriber(int,java.lang.String,int)>
<com.android.internal.telephony.ISms: java.util.List getAllMessagesFromIccEfForSubscriber(int,java.lang.String)>
<com.android.internal.telephony.ISms: void sendTextAutoLoginForSubscriber(int,java.lang.String,java.lang.String,java.lang.String,java.lang.String,android.app.PendingIntent,android.app.PendingIntent,boolean)>
<com.android.internal.telephony.ISms: boolean isSMSPromptEnabled()>
<com.android.internal.telephony.ISms: void sendTextForSubscriberWithOptions(int,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,android.app.PendingIntent,android.app.PendingIntent,boolean,int,boolean,int)>
<com.android.internal.telephony.ISms: int getPremiumSmsPermissionForSubscriber(int,java.lang.String)>
<com.android.internal.telephony.ISms: void clearStorageMonitorMemoryStatusOverride(int)>
<com.android.internal.telephony.ISms: boolean isImsSmsSupportedForSubscriber(int)>
<com.android.internal.telephony.ISms: java.lang.String createAppSpecificSmsToken(int,java.lang.String,android.app.PendingIntent)>
<com.android.internal.telephony.ISms: void sendMultipartTextForSubscriber(int,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.util.List,java.util.List,java.util.List,boolean,long)>
<com.android.internal.telephony.ISms: void sendTextNSRIForSubscriber(int,java.lang.String,java.lang.String,java.lang.String,byte[],android.app.PendingIntent,android.app.PendingIntent,int,int)>
<com.android.internal.telephony.ISms: byte[] getCbSettingsForSubscriber(int)>
<com.android.internal.telephony.ISms: int checkSmsShortCodeDestination(int,java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
<com.android.internal.telephony.ISms: boolean disableCellBroadcastRangeForSubscriber(int,int,int,int)>
<com.android.internal.telephony.ISms: void sendMultipartTextwithCBPForSubscriber(int,java.lang.String,java.lang.String,java.lang.String,java.util.List,java.util.List,java.util.List,java.lang.String,int)>
<com.android.internal.telephony.ISms: void sendMultipartTextForSubscriberWithOptions(int,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.util.List,java.util.List,java.util.List,boolean,int,boolean,int)>
<com.android.internal.telephony.ISms: void resetSimFullStatusForSubscriber(int)>
<com.android.internal.telephony.ISms: void sendDatawithOrigPortForSubscriber(int,java.lang.String,java.lang.String,java.lang.String,int,int,byte[],android.app.PendingIntent,android.app.PendingIntent)>
<com.android.internal.telephony.ISms: void injectSmsPduForSubscriber(int,byte[],java.lang.String,android.app.PendingIntent)>
<com.android.internal.telephony.ISms: boolean updateMessageOnIccEfForSubscriber(int,java.lang.String,int,int,byte[])>
<com.android.internal.telephony.ISms: boolean copyMessageToIccEfForSubscriber(int,java.lang.String,int,byte[],byte[])>
<com.android.internal.telephony.ISms: boolean enableCellBroadcastForSubscriber(int,int,int)>
<com.android.internal.telephony.ISms: java.lang.String getImsSmsFormatForSubscriber(int)>
<com.android.internal.telephony.ISms: java.lang.String createAppSpecificSmsTokenWithPackageInfo(int,java.lang.String,java.lang.String,android.app.PendingIntent)>
<com.android.internal.telephony.ISms: java.lang.String getSmscAddressFromIccEfForSubscriber(int,java.lang.String)>
<com.android.internal.telephony.ISms: int getPremiumSmsPermission(java.lang.String)>
<com.android.internal.telephony.ISms: java.lang.String getMnoNameForSubscriber(int)>
<com.android.internal.telephony.ISms: void sendTextForSubscriber(int,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,android.app.PendingIntent,android.app.PendingIntent,boolean,long)>
<com.android.internal.telephony.ISms: void sendDataForSubscriber(int,java.lang.String,java.lang.String,java.lang.String,java.lang.String,int,byte[],android.app.PendingIntent,android.app.PendingIntent)>
<com.android.internal.telephony.ISms: void sendOTADomesticForSubscriber(int,java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
<com.android.internal.telephony.ISms: void sendStoredText(int,java.lang.String,java.lang.String,android.net.Uri,java.lang.String,android.app.PendingIntent,android.app.PendingIntent)>
<com.android.internal.telephony.ISms: void setPremiumSmsPermission(java.lang.String,int)>
<com.android.internal.telephony.ISms: int getSmsCapacityOnIccForSubscriber(int)>
<com.android.internal.telephony.ISms: boolean setSmscAddressOnIccEfForSubscriber(java.lang.String,int,java.lang.String)>
<android.hardware.biometrics.IAuthService: void cancelAuthentication(android.os.IBinder,java.lang.String,long)>
<android.hardware.biometrics.IAuthService: int canAuthenticate(java.lang.String,int,int)>
<android.hardware.biometrics.IAuthService: void resetLockout(int,byte[])>
<android.hardware.biometrics.IAuthService: void resetLockoutTimeBound(android.os.IBinder,java.lang.String,int,int,byte[])>
<android.hardware.biometrics.IAuthService: java.lang.CharSequence getSettingName(int,java.lang.String,int)>
<android.hardware.biometrics.IAuthService: java.lang.String getUiPackage()>
<android.hardware.biometrics.IAuthService: java.util.List getSensorProperties(java.lang.String)>
<android.hardware.biometrics.IAuthService: java.lang.CharSequence getPromptMessage(int,java.lang.String,int)>
<android.hardware.biometrics.IAuthService: void invalidateAuthenticatorIds(int,int,android.hardware.biometrics.IInvalidationCallback)>
<android.hardware.biometrics.IAuthService: java.lang.CharSequence getButtonLabel(int,java.lang.String,int)>
<android.hardware.biometrics.IAuthService: long authenticate(android.os.IBinder,long,int,android.hardware.biometrics.IBiometricServiceReceiver,java.lang.String,android.hardware.biometrics.PromptInfo)>
<android.hardware.biometrics.IAuthService: boolean hasEnrolledBiometrics(int,java.lang.String)>
<android.hardware.biometrics.IAuthService: long[] getAuthenticatorIds(int)>
<android.hardware.biometrics.IAuthService: android.hardware.biometrics.ITestSession createTestSession(int,android.hardware.biometrics.ITestSessionCallback,java.lang.String)>
<android.hardware.biometrics.IAuthService: void registerEnabledOnKeyguardCallback(android.hardware.biometrics.IBiometricEnabledOnKeyguardCallback)>
<android.view.IAppTransitionAnimationSpecsFuture: android.view.AppTransitionAnimationSpec[] get()>
<android.media.tv.ITvInputClient: void onTimeShiftStatusChanged(int,int)>
<android.media.tv.ITvInputClient: void onAdResponse(android.media.tv.AdResponse,int)>
<android.media.tv.ITvInputClient: void onAudioPresentationSelected(int,int,int)>
<android.media.tv.ITvInputClient: void onBroadcastInfoResponse(android.media.tv.BroadcastInfoResponse,int)>
<android.media.tv.ITvInputClient: void onTimeShiftMode(int,int)>
<android.media.tv.ITvInputClient: void onTuned(android.net.Uri,int)>
<android.media.tv.ITvInputClient: void onTimeShiftStartPositionChanged(long,int)>
<android.media.tv.ITvInputClient: void onVideoAvailable(int)>
<android.media.tv.ITvInputClient: void onAitInfoUpdated(android.media.tv.AitInfo,int)>
<android.media.tv.ITvInputClient: void onCueingMessageAvailability(boolean,int)>
<android.media.tv.ITvInputClient: void onTrackSelected(int,java.lang.String,int)>
<android.media.tv.ITvInputClient: void onTracksChanged(java.util.List,int)>
<android.media.tv.ITvInputClient: void onContentBlocked(java.lang.String,int)>
<android.media.tv.ITvInputClient: void onAdBufferConsumed(android.media.tv.AdBuffer,int)>
<android.media.tv.ITvInputClient: void onAudioPresentationsChanged(java.util.List,int)>
<android.media.tv.ITvInputClient: void onLayoutSurface(int,int,int,int,int)>
<android.media.tv.ITvInputClient: void onSessionEvent(java.lang.String,android.os.Bundle,int)>
<android.media.tv.ITvInputClient: void onVideoUnavailable(int,int)>
<android.media.tv.ITvInputClient: void onTimeShiftCurrentPositionChanged(long,int)>
<android.media.tv.ITvInputClient: void onContentAllowed(int)>
<android.media.tv.ITvInputClient: void onRecordingStopped(android.net.Uri,int)>
<android.media.tv.ITvInputClient: void onTvMessage(int,android.os.Bundle,int)>
<android.media.tv.ITvInputClient: void onSignalStrength(int,int)>
<android.media.tv.ITvInputClient: void onError(int,int)>
<android.media.tv.ITvInputClient: void onSessionReleased(int)>
<android.media.tv.ITvInputClient: void onSessionCreated(java.lang.String,android.os.IBinder,android.view.InputChannel,int)>
<android.media.tv.ITvInputClient: void onChannelRetuned(android.net.Uri,int)>
<android.media.tv.ITvInputClient: void onAvailableSpeeds(float[],int)>
<com.samsung.android.multiwindow.IDexSnappingCallback: void onWindowSnappingChanged(int,android.graphics.Rect)>
<com.android.internal.inputmethod.IImeTracker: void onHidden(android.view.inputmethod.ImeTracker$Token)>
<com.android.internal.inputmethod.IImeTracker: android.view.inputmethod.ImeTracker$Token onRequestHide(java.lang.String,int,int,int)>
<com.android.internal.inputmethod.IImeTracker: void onCancelled(android.view.inputmethod.ImeTracker$Token,int)>
<com.android.internal.inputmethod.IImeTracker: android.view.inputmethod.ImeTracker$Token onRequestShow(java.lang.String,int,int,int)>
<com.android.internal.inputmethod.IImeTracker: void onShown(android.view.inputmethod.ImeTracker$Token)>
<com.android.internal.inputmethod.IImeTracker: boolean hasPendingImeVisibilityRequests()>
<com.android.internal.inputmethod.IImeTracker: void onProgress(android.os.IBinder,int)>
<com.android.internal.inputmethod.IImeTracker: void onFailed(android.view.inputmethod.ImeTracker$Token,int)>
<com.android.internal.compat.IPlatformCompat: com.android.internal.compat.CompatibilityChangeInfo[] listAllChanges()>
<com.android.internal.compat.IPlatformCompat: void setOverridesForTest(com.android.internal.compat.CompatibilityChangeConfig,java.lang.String)>
<com.android.internal.compat.IPlatformCompat: void clearOverridesForTest(java.lang.String)>
<com.android.internal.compat.IPlatformCompat: com.android.internal.compat.CompatibilityChangeConfig getAppConfig(android.content.pm.ApplicationInfo)>
<com.android.internal.compat.IPlatformCompat: void reportChangeByPackageName(long,java.lang.String,int)>
<com.android.internal.compat.IPlatformCompat: void reportChangeByUid(long,int)>
<com.android.internal.compat.IPlatformCompat: void putAllOverridesOnReleaseBuilds(com.android.internal.compat.CompatibilityOverridesByPackageConfig)>
<com.android.internal.compat.IPlatformCompat: void setOverrides(com.android.internal.compat.CompatibilityChangeConfig,java.lang.String)>
<com.android.internal.compat.IPlatformCompat: com.android.internal.compat.CompatibilityChangeInfo[] listUIChanges()>
<com.android.internal.compat.IPlatformCompat: void clearOverrides(java.lang.String)>
<com.android.internal.compat.IPlatformCompat: boolean clearOverrideForTest(long,java.lang.String)>
<com.android.internal.compat.IPlatformCompat: boolean isChangeEnabled(long,android.content.pm.ApplicationInfo)>
<com.android.internal.compat.IPlatformCompat: int disableTargetSdkChanges(java.lang.String,int)>
<com.android.internal.compat.IPlatformCompat: void removeAllOverridesOnReleaseBuilds(com.android.internal.compat.CompatibilityOverridesToRemoveByPackageConfig)>
<com.android.internal.compat.IPlatformCompat: void reportChange(long,android.content.pm.ApplicationInfo)>
<com.android.internal.compat.IPlatformCompat: boolean isChangeEnabledByPackageName(long,java.lang.String,int)>
<com.android.internal.compat.IPlatformCompat: boolean isChangeEnabledByUid(long,int)>
<com.android.internal.compat.IPlatformCompat: boolean clearOverride(long,java.lang.String)>
<com.android.internal.compat.IPlatformCompat: int enableTargetSdkChanges(java.lang.String,int)>
<com.android.internal.compat.IPlatformCompat: void putOverridesOnReleaseBuilds(com.android.internal.compat.CompatibilityOverrideConfig,java.lang.String)>
<com.android.internal.compat.IPlatformCompat: void removeOverridesOnReleaseBuilds(com.android.internal.compat.CompatibilityOverridesToRemoveConfig,java.lang.String)>
<com.android.internal.compat.IPlatformCompat: com.android.internal.compat.IOverrideValidator getOverrideValidator()>
<android.service.wallpapereffectsgeneration.IWallpaperEffectsGenerationService: void onGenerateCinematicEffect(android.app.wallpapereffectsgeneration.CinematicEffectRequest)>
<android.companion.virtual.IVirtualDevice: void registerIntentInterceptor(android.companion.virtual.IVirtualDeviceIntentInterceptor,android.content.IntentFilter)>
<android.companion.virtual.IVirtualDevice: void unregisterInputDevice(android.os.IBinder)>
<android.companion.virtual.IVirtualDevice: void unregisterIntentInterceptor(android.companion.virtual.IVirtualDeviceIntentInterceptor)>
<android.companion.virtual.IVirtualDevice: int getInputDeviceId(android.os.IBinder)>
<android.companion.virtual.IVirtualDevice: void setShowPointerIcon(boolean)>
<android.companion.virtual.IVirtualDevice: boolean sendSensorEvent(android.os.IBinder,android.companion.virtual.sensor.VirtualSensorEvent)>
<android.companion.virtual.IVirtualDevice: void onAudioSessionEnded()>
<android.companion.virtual.IVirtualDevice: void onAudioSessionStarting(int,android.companion.virtual.audio.IAudioRoutingCallback,android.companion.virtual.audio.IAudioConfigChangedCallback)>
<android.companion.virtual.IVirtualDevice: void createVirtualKeyboard(android.hardware.input.VirtualKeyboardConfig,android.os.IBinder)>
<android.companion.virtual.IVirtualDevice: boolean sendScrollEvent(android.os.IBinder,android.hardware.input.VirtualMouseScrollEvent)>
<android.companion.virtual.IVirtualDevice: void createVirtualMouse(android.hardware.input.VirtualMouseConfig,android.os.IBinder)>
<android.companion.virtual.IVirtualDevice: android.graphics.PointF getCursorPosition(android.os.IBinder)>
<android.companion.virtual.IVirtualDevice: void createVirtualTouchscreen(android.hardware.input.VirtualTouchscreenConfig,android.os.IBinder)>
<android.companion.virtual.IVirtualDevice: java.util.List getVirtualSensorList()>
<android.companion.virtual.IVirtualDevice: void launchPendingIntent(int,android.app.PendingIntent,android.os.ResultReceiver)>
<android.companion.virtual.IVirtualDevice: boolean sendRelativeEvent(android.os.IBinder,android.hardware.input.VirtualMouseRelativeEvent)>
<android.companion.virtual.IVirtualDevice: void createVirtualNavigationTouchpad(android.hardware.input.VirtualNavigationTouchpadConfig,android.os.IBinder)>
<android.companion.virtual.IVirtualDevice: int getAssociationId()>
<android.companion.virtual.IVirtualDevice: boolean sendTouchEvent(android.os.IBinder,android.hardware.input.VirtualTouchEvent)>
<android.companion.virtual.IVirtualDevice: boolean sendKeyEvent(android.os.IBinder,android.hardware.input.VirtualKeyEvent)>
<android.companion.virtual.IVirtualDevice: int getDeviceId()>
<android.companion.virtual.IVirtualDevice: void close()>
<android.companion.virtual.IVirtualDevice: boolean sendDpadKeyEvent(android.os.IBinder,android.hardware.input.VirtualKeyEvent)>
<android.companion.virtual.IVirtualDevice: void createVirtualDpad(android.hardware.input.VirtualDpadConfig,android.os.IBinder)>
<android.companion.virtual.IVirtualDevice: boolean sendButtonEvent(android.os.IBinder,android.hardware.input.VirtualMouseButtonEvent)>
<com.samsung.android.content.smartclip.ISpenGestureService: android.os.Bundle getScrollableAreaInfo(android.graphics.Rect,android.os.IBinder)>
<com.samsung.android.content.smartclip.ISpenGestureService: java.lang.String getBleSpenAddress()>
<com.samsung.android.content.smartclip.ISpenGestureService: void setSpenPdctLowSensitivityEnable()>
<com.samsung.android.content.smartclip.ISpenGestureService: int getCurrentMissingMethodFlags()>
<com.samsung.android.content.smartclip.ISpenGestureService: android.graphics.Bitmap screenshot(int,int,boolean,android.graphics.Rect,int,int,boolean)>
<com.samsung.android.content.smartclip.ISpenGestureService: void resetPenDetachSound(java.lang.String)>
<com.samsung.android.content.smartclip.ISpenGestureService: void setPenHoverIcon(java.lang.String,java.io.FileDescriptor,float,float)>
<com.samsung.android.content.smartclip.ISpenGestureService: int getScreenOffReason()>
<com.samsung.android.content.smartclip.ISpenGestureService: void notifyBleSpenChargeLockState(boolean)>
<com.samsung.android.content.smartclip.ISpenGestureService: void setPenDetachSound(java.lang.String,java.io.FileDescriptor)>
<com.samsung.android.content.smartclip.ISpenGestureService: com.android.internal.inputmethod.IRemoteInputConnection getCurrentInputContext()>
<com.samsung.android.content.smartclip.ISpenGestureService: void resetPenAttachSound(java.lang.String)>
<com.samsung.android.content.smartclip.ISpenGestureService: void setSpenPowerSavingModeEnabled(boolean)>
<com.samsung.android.content.smartclip.ISpenGestureService: void setHoverStayDetectEnabled(boolean)>
<com.samsung.android.content.smartclip.ISpenGestureService: void setBleSpenCmfCode(java.lang.String)>
<com.samsung.android.content.smartclip.ISpenGestureService: void notifyKeyboardClosed()>
<com.samsung.android.content.smartclip.ISpenGestureService: android.view.inputmethod.EditorInfo getCurrentEditorInfo()>
<com.samsung.android.content.smartclip.ISpenGestureService: void registerBleSpenChargeLockStateChangedListener(com.samsung.android.content.smartclip.IBleSpenChargeLockStateChangedListener)>
<com.samsung.android.content.smartclip.ISpenGestureService: void injectInputEvent(int,int,android.view.InputEvent[],boolean,android.os.IBinder)>
<com.samsung.android.content.smartclip.ISpenGestureService: void resetPenHoverIcon(java.lang.String)>
<com.samsung.android.content.smartclip.ISpenGestureService: com.samsung.android.content.smartclip.SemSmartClipDataRepository getSmartClipDataByScreenRect(android.graphics.Rect,android.os.IBinder,int,int)>
<com.samsung.android.content.smartclip.ISpenGestureService: void setBleSpenAddress(java.lang.String)>
<com.samsung.android.content.smartclip.ISpenGestureService: void setSpenInsertionState(boolean)>
<com.samsung.android.content.smartclip.ISpenGestureService: void registerAirGestureListener(com.samsung.android.content.smartclip.IAirGestureListener)>
<com.samsung.android.content.smartclip.ISpenGestureService: void registerInputMethodInfoChangeListener(com.samsung.android.content.smartclip.IInputMethodInfoChangeListener)>
<com.samsung.android.content.smartclip.ISpenGestureService: void setCurrentInputInfo(com.android.internal.inputmethod.IRemoteInputConnection,android.view.inputmethod.EditorInfo,int)>
<com.samsung.android.content.smartclip.ISpenGestureService: void writeBleSpenCommand(java.lang.String)>
<com.samsung.android.content.smartclip.ISpenGestureService: void setScreenOffReason(int)>
<com.samsung.android.content.smartclip.ISpenGestureService: boolean isSupportBleSpen()>
<com.samsung.android.content.smartclip.ISpenGestureService: void unregisterInputMethodInfoChangeListener(com.samsung.android.content.smartclip.IInputMethodInfoChangeListener)>
<com.samsung.android.content.smartclip.ISpenGestureService: android.os.Bundle getScrollableViewInfo(android.graphics.Rect,int,android.os.IBinder)>
<com.samsung.android.content.smartclip.ISpenGestureService: void setHoverStayValues(int,int,int)>
<com.samsung.android.content.smartclip.ISpenGestureService: void unregisterHoverListener(com.samsung.android.content.smartclip.ISpenGestureHoverListener)>
<com.samsung.android.content.smartclip.ISpenGestureService: void saveBleSpenLogFile(byte[])>
<com.samsung.android.content.smartclip.ISpenGestureService: java.lang.String getBleSpenCmfCode()>
<com.samsung.android.content.smartclip.ISpenGestureService: void showTouchPointer(boolean)>
<com.samsung.android.content.smartclip.ISpenGestureService: boolean isSpenInserted()>
<com.samsung.android.content.smartclip.ISpenGestureService: void unregisterBleSpenChargeLockStateChangedListener(com.samsung.android.content.smartclip.IBleSpenChargeLockStateChangedListener)>
<com.samsung.android.content.smartclip.ISpenGestureService: void registerHoverListener(com.samsung.android.content.smartclip.ISpenGestureHoverListener)>
<com.samsung.android.content.smartclip.ISpenGestureService: void unregisterAirGestureListener(com.samsung.android.content.smartclip.IAirGestureListener)>
<com.samsung.android.content.smartclip.ISpenGestureService: void sendSmartClipRemoteRequestResult(com.samsung.android.content.smartclip.SmartClipRemoteRequestResult)>
<com.samsung.android.content.smartclip.ISpenGestureService: void notifyAirGesture(java.lang.String)>
<com.samsung.android.content.smartclip.ISpenGestureService: void setPenAttachSound(java.lang.String,java.io.FileDescriptor)>
<com.android.ims.internal.IImsEcbm: void exitEmergencyCallbackMode()>
<com.android.ims.internal.IImsEcbm: void setListener(com.android.ims.internal.IImsEcbmListener)>
<android.hardware.camera2.ICameraInjectionCallback: void onInjectionError(int)>
<android.service.dreams.IDreamOverlayClientCallback: void onDreamOverlayClient(android.service.dreams.IDreamOverlayClient)>
<android.hardware.tv.tuner.IDvrCallback: java.lang.String getInterfaceHash()>
<android.hardware.tv.tuner.IDvrCallback: void onRecordStatus(byte)>
<android.hardware.tv.tuner.IDvrCallback: int getInterfaceVersion()>
<android.hardware.tv.tuner.IDvrCallback: void onPlaybackStatus(int)>
<android.service.voice.IVoiceInteractionSessionService: void newSession(android.os.IBinder,android.os.Bundle,int)>
<android.service.controls.IControlsSubscriber: void onComplete(android.os.IBinder)>
<android.service.controls.IControlsSubscriber: void onNext(android.os.IBinder,android.service.controls.Control)>
<android.service.controls.IControlsSubscriber: void onSubscribe(android.os.IBinder,android.service.controls.IControlsSubscription)>
<android.service.controls.IControlsSubscriber: void onError(android.os.IBinder,java.lang.String)>
<com.samsung.android.ims.cmc.ISemCmcRecordingListener: void onError(int,int)>
<com.samsung.android.ims.cmc.ISemCmcRecordingListener: void onInfo(int,int)>
<com.android.internal.app.IVoiceInteractor: void setKillCallback(android.os.ICancellationSignal)>
<com.android.internal.app.IVoiceInteractor: com.android.internal.app.IVoiceInteractorRequest startCompleteVoice(java.lang.String,com.android.internal.app.IVoiceInteractorCallback,android.app.VoiceInteractor$Prompt,android.os.Bundle)>
<com.android.internal.app.IVoiceInteractor: com.android.internal.app.IVoiceInteractorRequest startPickOption(java.lang.String,com.android.internal.app.IVoiceInteractorCallback,android.app.VoiceInteractor$Prompt,android.app.VoiceInteractor$PickOptionRequest$Option[],android.os.Bundle)>
<com.android.internal.app.IVoiceInteractor: boolean[] supportsCommands(java.lang.String,java.lang.String[])>
<com.android.internal.app.IVoiceInteractor: com.android.internal.app.IVoiceInteractorRequest startConfirmation(java.lang.String,com.android.internal.app.IVoiceInteractorCallback,android.app.VoiceInteractor$Prompt,android.os.Bundle)>
<com.android.internal.app.IVoiceInteractor: void notifyDirectActionsChanged(int,android.os.IBinder)>
<com.android.internal.app.IVoiceInteractor: com.android.internal.app.IVoiceInteractorRequest startCommand(java.lang.String,com.android.internal.app.IVoiceInteractorCallback,java.lang.String,android.os.Bundle)>
<com.android.internal.app.IVoiceInteractor: com.android.internal.app.IVoiceInteractorRequest startAbortVoice(java.lang.String,com.android.internal.app.IVoiceInteractorCallback,android.app.VoiceInteractor$Prompt,android.os.Bundle)>
<android.print.ILayoutResultCallback: void onLayoutStarted(android.os.ICancellationSignal,int)>
<android.print.ILayoutResultCallback: void onLayoutFinished(android.print.PrintDocumentInfo,boolean,int)>
<android.print.ILayoutResultCallback: void onLayoutFailed(java.lang.CharSequence,int)>
<android.print.ILayoutResultCallback: void onLayoutCanceled(int)>
<com.android.internal.telecom.ICallDiagnosticService: void callQualityChanged(java.lang.String,android.telephony.CallQuality)>
<com.android.internal.telecom.ICallDiagnosticService: void updateCallAudioState(android.telecom.CallAudioState)>
<com.android.internal.telecom.ICallDiagnosticService: void initializeDiagnosticCall(android.telecom.ParcelableCall)>
<com.android.internal.telecom.ICallDiagnosticService: void setAdapter(com.android.internal.telecom.ICallDiagnosticServiceAdapter)>
<com.android.internal.telecom.ICallDiagnosticService: void updateCall(android.telecom.ParcelableCall)>
<com.android.internal.telecom.ICallDiagnosticService: void notifyCallDisconnected(java.lang.String,android.telecom.DisconnectCause)>
<com.android.internal.telecom.ICallDiagnosticService: void receiveDeviceToDeviceMessage(java.lang.String,int,int)>
<com.android.internal.telecom.ICallDiagnosticService: void receiveBluetoothCallQualityReport(android.telecom.BluetoothCallQualityReport)>
<com.android.internal.telecom.ICallDiagnosticService: void removeDiagnosticCall(java.lang.String)>
<android.hardware.location.IGeofenceHardwareMonitorCallback: void onMonitoringSystemChange(android.hardware.location.GeofenceHardwareMonitorEvent)>
<com.samsung.android.dsms.aidl.IDsmsInfoService: boolean isCommercializedDevice()>
<com.samsung.android.wifi.ISemWifiApClientListUpdateCallback: void onOverallDataLimitChanged(long)>
<com.samsung.android.wifi.ISemWifiApClientListUpdateCallback: void onClientListUpdated(java.util.List,long)>
<android.hardware.soundtrigger3.ISoundTriggerHwCallback: int getInterfaceVersion()>
<android.hardware.soundtrigger3.ISoundTriggerHwCallback: void phraseRecognitionCallback(int,android.media.soundtrigger.PhraseRecognitionEvent)>
<android.hardware.soundtrigger3.ISoundTriggerHwCallback: void recognitionCallback(int,android.media.soundtrigger.RecognitionEvent)>
<android.hardware.soundtrigger3.ISoundTriggerHwCallback: java.lang.String getInterfaceHash()>
<android.hardware.soundtrigger3.ISoundTriggerHwCallback: void modelUnloaded(int)>
<vendor.samsung.hardware.thermal.ISehThermal: int getScenarioHint()>
<vendor.samsung.hardware.thermal.ISehThermal: void unregisterThermalChangedCallback(vendor.samsung.hardware.thermal.ISehThermalChangedCallback)>
<vendor.samsung.hardware.thermal.ISehThermal: java.lang.String getInterfaceHash()>
<vendor.samsung.hardware.thermal.ISehThermal: vendor.samsung.hardware.thermal.SehTemperature[] getTemperatures()>
<vendor.samsung.hardware.thermal.ISehThermal: void registerThermalChangedCallback(vendor.samsung.hardware.thermal.ISehThermalChangedCallback)>
<vendor.samsung.hardware.thermal.ISehThermal: void setScenarioHint(int)>
<vendor.samsung.hardware.thermal.ISehThermal: int getInterfaceVersion()>
<vendor.samsung.hardware.thermal.ISehThermal: vendor.samsung.hardware.thermal.SehTemperature[] getTemperaturesWithType(int)>
<android.service.notification.INotificationListener: void onNotificationSnoozedUntilContext(android.service.notification.IStatusBarNotificationHolder,java.lang.String)>
<android.service.notification.INotificationListener: void onStatusBarIconsBehaviorChanged(boolean)>
<android.service.notification.INotificationListener: void onActionClicked(java.lang.String,android.app.Notification$Action,int)>
<android.service.notification.INotificationListener: void onPanelRevealed(int)>
<android.service.notification.INotificationListener: void onNotificationChannelGroupModification(java.lang.String,android.os.UserHandle,android.app.NotificationChannelGroup,int)>
<android.service.notification.INotificationListener: void onSuggestedReplySent(java.lang.String,java.lang.CharSequence,int)>
<android.service.notification.INotificationListener: void onNotificationFeedbackReceived(java.lang.String,android.service.notification.NotificationRankingUpdate,android.os.Bundle)>
<android.service.notification.INotificationListener: void onNotificationEnqueuedWithChannel(android.service.notification.IStatusBarNotificationHolder,android.app.NotificationChannel,android.service.notification.NotificationRankingUpdate)>
<android.service.notification.INotificationListener: void onInterruptionFilterChanged(int)>
<android.service.notification.INotificationListener: void onNotificationExpansionChanged(java.lang.String,boolean,boolean)>
<android.service.notification.INotificationListener: void onNotificationClicked(java.lang.String)>
<android.service.notification.INotificationListener: void onAllowedAdjustmentsChanged()>
<android.service.notification.INotificationListener: void onPanelHidden()>
<android.service.notification.INotificationListener: void onNotificationRankingUpdate(android.service.notification.NotificationRankingUpdate)>
<android.service.notification.INotificationListener: void onEdgeNotificationPosted(java.lang.String,int,android.os.Bundle)>
<android.service.notification.INotificationListener: void onEdgeNotificationRemoved(java.lang.String,int,android.os.Bundle)>
<android.service.notification.INotificationListener: void onListenerConnected(android.service.notification.NotificationRankingUpdate)>
<android.service.notification.INotificationListener: void onNotificationDirectReply(java.lang.String)>
<android.service.notification.INotificationListener: void onNotificationVisibilityChanged(java.lang.String,boolean)>
<android.service.notification.INotificationListener: void onNotificationChannelModification(java.lang.String,android.os.UserHandle,android.app.NotificationChannel,int)>
<android.service.notification.INotificationListener: void onNotificationRemoved(android.service.notification.IStatusBarNotificationHolder,android.service.notification.NotificationRankingUpdate,android.service.notification.NotificationStats,int)>
<android.service.notification.INotificationListener: void onListenerHintsChanged(int)>
<android.service.notification.INotificationListener: void onNotificationPosted(android.service.notification.IStatusBarNotificationHolder,android.service.notification.NotificationRankingUpdate)>
<android.service.notification.INotificationListener: void onNotificationsSeen(java.util.List)>
<android.content.pm.IStagedApexObserver: void onApexStaged(android.content.pm.ApexStagedEvent)>
<android.hardware.camera2.extension.ICaptureCallback: void onCaptureSequenceCompleted(int)>
<android.hardware.camera2.extension.ICaptureCallback: void onCaptureCompleted(long,int,android.hardware.camera2.impl.CameraMetadataNative)>
<android.hardware.camera2.extension.ICaptureCallback: void onCaptureProcessProgressed(int)>
<android.hardware.camera2.extension.ICaptureCallback: void onCaptureFailed(int)>
<android.hardware.camera2.extension.ICaptureCallback: void onCaptureStarted(int,long)>
<android.hardware.camera2.extension.ICaptureCallback: void onCaptureProcessStarted(int)>
<android.hardware.camera2.extension.ICaptureCallback: void onCaptureSequenceAborted(int)>
<android.content.IOnPrimaryClipChangedListener: void dispatchPrimaryClipChanged()>
<vendor.samsung.hardware.radio.channel.ISehRadioChannel: void setCallback(vendor.samsung.hardware.radio.channel.ISehRadioChannelCallback)>
<vendor.samsung.hardware.radio.channel.ISehRadioChannel: int getInterfaceVersion()>
<vendor.samsung.hardware.radio.channel.ISehRadioChannel: java.lang.String getInterfaceHash()>
<vendor.samsung.hardware.radio.channel.ISehRadioChannel: void send(byte[])>
<android.net.wifi.nl80211.IApInterface: boolean registerCallback(android.net.wifi.nl80211.IApInterfaceEventCallback)>
<android.net.wifi.nl80211.IApInterface: java.lang.String getInterfaceName()>
<com.android.internal.telephony.euicc.IGetRulesAuthTableCallback: void onComplete(int,android.telephony.euicc.EuiccRulesAuthTable)>
<android.content.pm.IDexModuleRegisterCallback: void onDexModuleRegistered(java.lang.String,boolean,java.lang.String)>
<com.android.internal.telephony.IPhoneSubInfo: java.lang.String getSubscriberIdForUiccAppType(int,int,java.lang.String)>
<com.android.internal.telephony.IPhoneSubInfo: java.lang.String getImsPrivateUserIdentity(int,java.lang.String,java.lang.String)>
<com.android.internal.telephony.IPhoneSubInfo: java.lang.String[] getHomePlmns(int)>
<com.android.internal.telephony.IPhoneSubInfo: java.lang.String[] getIsimImpu(int)>
<com.android.internal.telephony.IPhoneSubInfo: java.lang.String getKeyLifetime(int)>
<com.android.internal.telephony.IPhoneSubInfo: void clearMwiNotificationAndVoicemailCount(int,java.lang.String)>
<com.android.internal.telephony.IPhoneSubInfo: byte[] getPsismsc(java.lang.String)>
<com.android.internal.telephony.IPhoneSubInfo: java.lang.String getDeviceIdWithFeature(java.lang.String,java.lang.String)>
<com.android.internal.telephony.IPhoneSubInfo: java.lang.String getVoiceMailNumber(java.lang.String,java.lang.String)>
<com.android.internal.telephony.IPhoneSubInfo: java.lang.String getDeviceSvn(java.lang.String,java.lang.String)>
<com.android.internal.telephony.IPhoneSubInfo: java.lang.String getDeviceId(java.lang.String)>
<com.android.internal.telephony.IPhoneSubInfo: java.lang.String getBtid(int)>
<com.android.internal.telephony.IPhoneSubInfo: java.lang.String getVoiceMailNumberForSubscriber(int,java.lang.String,java.lang.String)>
<com.android.internal.telephony.IPhoneSubInfo: java.lang.String getGroupIdLevel2ForSubscriber(int,java.lang.String,java.lang.String)>
<com.android.internal.telephony.IPhoneSubInfo: java.lang.String getDeviceSvnUsingSubId(int,java.lang.String,java.lang.String)>
<com.android.internal.telephony.IPhoneSubInfo: java.lang.String getSimServiceTable(int,int)>
<com.android.internal.telephony.IPhoneSubInfo: java.lang.String getVoiceMailAlphaTag(java.lang.String,java.lang.String)>
<com.android.internal.telephony.IPhoneSubInfo: java.lang.String getIccSimChallengeResponse(int,int,int,java.lang.String,java.lang.String,java.lang.String)>
<com.android.internal.telephony.IPhoneSubInfo: java.lang.String getIccSerialNumber(java.lang.String)>
<com.android.internal.telephony.IPhoneSubInfo: java.lang.String getLine1NumberForSubscriber(int,java.lang.String,java.lang.String)>
<com.android.internal.telephony.IPhoneSubInfo: java.util.List getImsPublicUserIdentities(int,java.lang.String,java.lang.String)>
<com.android.internal.telephony.IPhoneSubInfo: java.lang.String getIccSerialNumberForSubscriber(int,java.lang.String,java.lang.String)>
<com.android.internal.telephony.IPhoneSubInfo: android.net.Uri getSmscIdentity(int,int)>
<com.android.internal.telephony.IPhoneSubInfo: java.lang.String getLine1AlphaTag(java.lang.String,java.lang.String)>
<com.android.internal.telephony.IPhoneSubInfo: java.lang.String getIccSerialNumberWithFeature(java.lang.String,java.lang.String)>
<com.android.internal.telephony.IPhoneSubInfo: java.lang.String getSubscriberIdForSubscriber(int,java.lang.String,java.lang.String)>
<com.android.internal.telephony.IPhoneSubInfo: java.lang.String[] getIsimPcscf(int)>
<com.android.internal.telephony.IPhoneSubInfo: void resetCarrierKeysForImsiEncryption(int,java.lang.String)>
<com.android.internal.telephony.IPhoneSubInfo: java.lang.String getMsisdnForSubscriber(int,java.lang.String,java.lang.String)>
<com.android.internal.telephony.IPhoneSubInfo: boolean isGbaSupported()>
<com.android.internal.telephony.IPhoneSubInfo: java.lang.String getLine1Number(java.lang.String,java.lang.String)>
<com.android.internal.telephony.IPhoneSubInfo: java.lang.String getNaiForSubscriber(int,java.lang.String,java.lang.String)>
<com.android.internal.telephony.IPhoneSubInfo: java.lang.String getSubscriberId(java.lang.String)>
<com.android.internal.telephony.IPhoneSubInfo: byte[] getRand(int)>
<com.android.internal.telephony.IPhoneSubInfo: void setCarrierInfoForImsiEncryption(int,java.lang.String,android.telephony.ImsiEncryptionInfo)>
<com.android.internal.telephony.IPhoneSubInfo: java.lang.String getIsimDomain(int)>
<com.android.internal.telephony.IPhoneSubInfo: java.lang.String getIsimImpi(int)>
<com.android.internal.telephony.IPhoneSubInfo: byte[] getPsismscWithPhoneId(int,java.lang.String)>
<com.android.internal.telephony.IPhoneSubInfo: java.lang.String getIsimIst(int)>
<com.android.internal.telephony.IPhoneSubInfo: java.lang.String getImeiForSubscriber(int,java.lang.String,java.lang.String)>
<com.android.internal.telephony.IPhoneSubInfo: void setPcoValue(int,int,java.lang.String)>
<com.android.internal.telephony.IPhoneSubInfo: java.lang.String getGroupIdLevel1ForSubscriber(int,java.lang.String,java.lang.String)>
<com.android.internal.telephony.IPhoneSubInfo: boolean isGbaSupportedForSubscriber(int)>
<com.android.internal.telephony.IPhoneSubInfo: android.telephony.ImsiEncryptionInfo getCarrierInfoForImsiEncryption(int,int,java.lang.String)>
<com.android.internal.telephony.IPhoneSubInfo: java.lang.String getLine1AlphaTagForSubscriber(int,java.lang.String,java.lang.String)>
<com.android.internal.telephony.IPhoneSubInfo: java.lang.String getSubscriberIdWithFeature(java.lang.String,java.lang.String)>
<com.android.internal.telephony.IPhoneSubInfo: java.lang.String getVoiceMailAlphaTagForSubscriber(int,java.lang.String,java.lang.String)>
<com.android.internal.telephony.IPhoneSubInfo: java.lang.String getDeviceIdForPhone(int,java.lang.String,java.lang.String)>
<com.android.internal.telephony.IPhoneSubInfo: java.lang.String getMsisdn(java.lang.String,java.lang.String)>
<android.service.watchdog.IExplicitHealthCheckService: void request(java.lang.String)>
<android.service.watchdog.IExplicitHealthCheckService: void getRequestedPackages(android.os.RemoteCallback)>
<android.service.watchdog.IExplicitHealthCheckService: void getSupportedPackages(android.os.RemoteCallback)>
<android.service.watchdog.IExplicitHealthCheckService: void setCallback(android.os.RemoteCallback)>
<android.service.watchdog.IExplicitHealthCheckService: void cancel(java.lang.String)>
<com.android.ims.internal.IImsEcbmListener: void enteredECBM()>
<com.android.ims.internal.IImsEcbmListener: void exitedECBM()>
<android.media.ICaptureStateListener: void setCaptureState(boolean)>
<android.hardware.contexthub.IContextHub: void onSettingChanged(byte,boolean)>
<android.hardware.contexthub.IContextHub: void unloadNanoapp(int,long,int)>
<android.hardware.contexthub.IContextHub: void queryNanoapps(int)>
<android.hardware.contexthub.IContextHub: void enableNanoapp(int,long,int)>
<android.hardware.contexthub.IContextHub: long[] getPreloadedNanoappIds(int)>
<android.hardware.contexthub.IContextHub: void onNanSessionStateChanged(android.hardware.contexthub.NanSessionStateUpdate)>
<android.hardware.contexthub.IContextHub: void sendMessageToHub(int,android.hardware.contexthub.ContextHubMessage)>
<android.hardware.contexthub.IContextHub: void onHostEndpointDisconnected(char)>
<android.hardware.contexthub.IContextHub: void loadNanoapp(int,android.hardware.contexthub.NanoappBinary,int)>
<android.hardware.contexthub.IContextHub: java.lang.String getInterfaceHash()>
<android.hardware.contexthub.IContextHub: void setTestMode(boolean)>
<android.hardware.contexthub.IContextHub: java.util.List getContextHubs()>
<android.hardware.contexthub.IContextHub: void disableNanoapp(int,long,int)>
<android.hardware.contexthub.IContextHub: void registerCallback(int,android.hardware.contexthub.IContextHubCallback)>
<android.hardware.contexthub.IContextHub: void onHostEndpointConnected(android.hardware.contexthub.HostEndpointInfo)>
<android.hardware.contexthub.IContextHub: int getInterfaceVersion()>
<android.app.backup.IBackupCallback: void operationComplete(long)>
<android.app.IRequestFinishCallback: void requestFinish()>
<android.hardware.usb.gadget.IUsbGadget: void getUsbSpeed(android.hardware.usb.gadget.IUsbGadgetCallback,long)>
<android.hardware.usb.gadget.IUsbGadget: int getInterfaceVersion()>
<android.hardware.usb.gadget.IUsbGadget: void reset(android.hardware.usb.gadget.IUsbGadgetCallback,long)>
<android.hardware.usb.gadget.IUsbGadget: void setCurrentUsbFunctions(long,android.hardware.usb.gadget.IUsbGadgetCallback,long,long)>
<android.hardware.usb.gadget.IUsbGadget: java.lang.String getInterfaceHash()>
<android.hardware.usb.gadget.IUsbGadget: void getCurrentUsbFunctions(android.hardware.usb.gadget.IUsbGadgetCallback,long)>
<android.app.IGameManagerService: int getGameMode(java.lang.String,int)>
<android.app.IGameManagerService: boolean isAngleEnabled(java.lang.String,int)>
<android.app.IGameManagerService: int[] getAvailableGameModes(java.lang.String,int)>
<android.app.IGameManagerService: android.app.GameModeInfo getGameModeInfo(java.lang.String,int)>
<android.app.IGameManagerService: void updateResolutionScalingFactor(java.lang.String,int,float,int)>
<android.app.IGameManagerService: void updateCustomGameModeConfiguration(java.lang.String,android.app.GameModeConfiguration,int)>
<android.app.IGameManagerService: float getResolutionScalingFactor(java.lang.String,int,int)>
<android.app.IGameManagerService: void setGameServiceProvider(java.lang.String)>
<android.app.IGameManagerService: void addGameModeListener(android.app.IGameModeListener)>
<android.app.IGameManagerService: void notifyGraphicsEnvironmentSetup(java.lang.String,int)>
<android.app.IGameManagerService: void removeGameModeListener(android.app.IGameModeListener)>
<android.app.IGameManagerService: void setGameMode(java.lang.String,int,int)>
<android.app.IGameManagerService: void setGameState(java.lang.String,android.app.GameState,int)>
<android.hardware.input.IMultiFingerGestureListener: void onMultiFingerGesture(int,int)>
<com.android.internal.app.IVoiceInteractionSessionShowCallback: void onFailed()>
<com.android.internal.app.IVoiceInteractionSessionShowCallback: void onShown()>
<android.service.wallpaper.IWallpaperConnection: void onWallpaperColorsChanged(android.app.WallpaperColors,int)>
<android.service.wallpaper.IWallpaperConnection: void engineShown(android.service.wallpaper.IWallpaperEngine)>
<android.service.wallpaper.IWallpaperConnection: android.os.ParcelFileDescriptor setWallpaper(java.lang.String)>
<android.service.wallpaper.IWallpaperConnection: void onLocalWallpaperColorsChanged(android.graphics.RectF,android.app.WallpaperColors,int)>
<android.service.wallpaper.IWallpaperConnection: void attachEngine(android.service.wallpaper.IWallpaperEngine,int)>
<android.content.pm.IOnAppsChangedListener: void onPackageLoadingProgressChanged(android.os.UserHandle,java.lang.String,float)>
<android.content.pm.IOnAppsChangedListener: void onShortcutChanged(android.os.UserHandle,java.lang.String,android.content.pm.ParceledListSlice)>
<android.content.pm.IOnAppsChangedListener: void onPackagesSuspended(android.os.UserHandle,java.lang.String[],android.os.Bundle)>
<android.content.pm.IOnAppsChangedListener: void onPackagesUnsuspended(android.os.UserHandle,java.lang.String[])>
<android.content.pm.IOnAppsChangedListener: void onPackageRemoved(android.os.UserHandle,java.lang.String)>
<android.content.pm.IOnAppsChangedListener: void onPackagesUnavailable(android.os.UserHandle,java.lang.String[],boolean)>
<android.content.pm.IOnAppsChangedListener: void onPackagesAvailable(android.os.UserHandle,java.lang.String[],boolean)>
<android.content.pm.IOnAppsChangedListener: void onPackageAdded(android.os.UserHandle,java.lang.String)>
<android.content.pm.IOnAppsChangedListener: void onPackageChanged(android.os.UserHandle,java.lang.String)>
<android.media.IRemoteSessionCallback: void onSessionChanged(android.media.session.MediaSession$Token)>
<android.media.IRemoteSessionCallback: void onVolumeChanged(android.media.session.MediaSession$Token,int)>
<android.print.IPrintSpoolerClient: void onPrintJobStateChanged(android.print.PrintJobInfo)>
<android.print.IPrintSpoolerClient: void onPrintJobQueued(android.print.PrintJobInfo)>
<android.print.IPrintSpoolerClient: void onAllPrintJobsForServiceHandled(android.content.ComponentName)>
<android.print.IPrintSpoolerClient: void onAllPrintJobsHandled()>
<com.android.internal.widget.IWeakEscrowTokenRemovedListener: void onWeakEscrowTokenRemoved(long,int)>
<android.printservice.IPrintService: void requestCustomPrinterIcon(android.print.PrinterId)>
<android.printservice.IPrintService: void createPrinterDiscoverySession()>
<android.printservice.IPrintService: void startPrinterStateTracking(android.print.PrinterId)>
<android.printservice.IPrintService: void destroyPrinterDiscoverySession()>
<android.printservice.IPrintService: void validatePrinters(java.util.List)>
<android.printservice.IPrintService: void stopPrinterDiscovery()>
<android.printservice.IPrintService: void stopPrinterStateTracking(android.print.PrinterId)>
<android.printservice.IPrintService: void onPrintJobQueued(android.print.PrintJobInfo)>
<android.printservice.IPrintService: void requestCancelPrintJob(android.print.PrintJobInfo)>
<android.printservice.IPrintService: void startPrinterDiscovery(java.util.List)>
<android.printservice.IPrintService: void setClient(android.printservice.IPrintServiceClient)>
<com.samsung.android.wifi.ISemMobileWipsService: void onScanResults(java.util.List)>
<com.samsung.android.wifi.ISemMobileWipsService: void sendMessage(android.os.Message)>
<com.samsung.android.wifi.ISemMobileWipsService: boolean checkMWIPS(java.lang.String,int)>
<com.samsung.android.wifi.ISemMobileWipsService: boolean setCurrentBss(java.lang.String,java.lang.String,java.lang.String,int,byte[])>
<com.samsung.android.wifi.ISemMobileWipsService: boolean registerCallback(com.samsung.android.wifi.ISemMobileWipsFramework)>
<com.samsung.android.wifi.ISemMobileWipsService: boolean registerPacketSender(com.samsung.android.wifi.ISemMobileWipsPacketSender)>
<com.samsung.android.wifi.ISemMobileWipsService: void broadcastBcnEventAbort(java.lang.String,int)>
<com.samsung.android.wifi.ISemMobileWipsService: boolean unregisterPacketSender(com.samsung.android.wifi.ISemMobileWipsPacketSender)>
<com.samsung.android.wifi.ISemMobileWipsService: void onDnsResponses(java.util.List,java.lang.String)>
<com.samsung.android.wifi.ISemMobileWipsService: void updateWifiChipInfo(java.lang.String,java.lang.String)>
<com.samsung.android.wifi.ISemMobileWipsService: void broadcastBcnIntervalEvent(java.lang.String,java.lang.String,java.lang.String,int,int,long,long)>
<com.samsung.android.wifi.ISemMobileWipsService: boolean unregisterCallback(com.samsung.android.wifi.ISemMobileWipsFramework)>
<android.telephony.ims.aidl.IImsSmsListener: void onSmsReceived(int,java.lang.String,byte[])>
<android.telephony.ims.aidl.IImsSmsListener: void onSendSmsResponse(int,int,int,int,int,int)>
<android.telephony.ims.aidl.IImsSmsListener: void onMemoryAvailableResult(int,int,int)>
<android.telephony.ims.aidl.IImsSmsListener: void onSmsStatusReportReceived(int,java.lang.String,byte[])>
<android.telephony.ims.aidl.IImsSmsListener: void onReceiveSmsDeliveryReportAck(int,int)>
<android.telephony.ims.aidl.IImsSmsListener: void onSendSmsResult(int,int,int,int,int)>
<android.service.vr.IVrListener: void focusedActivityChanged(android.content.ComponentName,boolean,int)>
<android.hardware.gnss.IGnssGeofenceCallback: void gnssGeofencePauseCb(int,int)>
<android.hardware.gnss.IGnssGeofenceCallback: int getInterfaceVersion()>
<android.hardware.gnss.IGnssGeofenceCallback: void gnssGeofenceStatusCb(int,android.hardware.gnss.GnssLocation)>
<android.hardware.gnss.IGnssGeofenceCallback: void gnssGeofenceRemoveCb(int,int)>
<android.hardware.gnss.IGnssGeofenceCallback: void gnssGeofenceTransitionCb(int,android.hardware.gnss.GnssLocation,int,long)>
<android.hardware.gnss.IGnssGeofenceCallback: java.lang.String getInterfaceHash()>
<android.hardware.gnss.IGnssGeofenceCallback: void gnssGeofenceResumeCb(int,int)>
<android.hardware.gnss.IGnssGeofenceCallback: void gnssGeofenceAddCb(int,int)>
<android.app.IWallpaperManagerCallback: void onSemWallpaperChanged(int,int)>
<android.app.IWallpaperManagerCallback: void onSemMultipackApplied(int)>
<android.app.IWallpaperManagerCallback: void onWallpaperColorsChanged(android.app.WallpaperColors,int,int)>
<android.app.IWallpaperManagerCallback: void onSemWallpaperColorsAnalysisRequested(int,int)>
<android.app.IWallpaperManagerCallback: void onSemWallpaperColorsChanged(android.app.SemWallpaperColors,int,int)>
<android.app.IWallpaperManagerCallback: void onWallpaperChanged()>
<android.app.IWallpaperManagerCallback: void onSemBackupStatusChanged(int,int,int)>
<com.samsung.android.ims.ISemEpdgListener: void onEpdgAvailable(int,boolean,int)>
<com.samsung.android.ims.ISemEpdgListener: void onEpdgShowPopup(int,int)>
<com.samsung.android.ims.ISemEpdgListener: void onIpsecConnection(int,java.lang.String,int,int)>
<com.samsung.android.ims.ISemEpdgListener: void onHandoverResult(int,int,int,java.lang.String)>
<com.samsung.android.ims.ISemEpdgListener: void onIpsecDisconnection(int,java.lang.String)>
<android.security.attestationverification.IAttestationVerificationService: void onVerifyAttestation(android.os.Bundle,byte[],com.android.internal.infra.AndroidFuture)>
<android.hardware.biometrics.fingerprint.IFingerprint: int getInterfaceVersion()>
<android.hardware.biometrics.fingerprint.IFingerprint: android.hardware.biometrics.fingerprint.SensorProps[] getSensorProps()>
<android.hardware.biometrics.fingerprint.IFingerprint: java.lang.String getInterfaceHash()>
<android.hardware.biometrics.fingerprint.IFingerprint: android.hardware.biometrics.fingerprint.ISession createSession(int,int,android.hardware.biometrics.fingerprint.ISessionCallback)>
<com.android.internal.textservice.ISpellCheckerServiceCallback: void onSessionCreated(com.android.internal.textservice.ISpellCheckerSession)>
<android.os.epic.IEpicManager: android.os.epic.IEpicObject Creates(int[])>
<android.os.epic.IEpicManager: android.os.epic.IEpicObject Create(int)>
<android.os.IVoldTaskListener: void onStatus(int,android.os.PersistableBundle)>
<android.os.IVoldTaskListener: void onFinished(int,android.os.PersistableBundle)>
<com.samsung.android.infoextraction.IKerykeionCallBack: void onCompleted(java.util.List)>
<android.hardware.face.IFaceService: byte[] dumpSensorServiceStateProto(int,boolean)>
<android.hardware.face.IFaceService: void prepareForAuthentication(boolean,android.os.IBinder,long,android.hardware.biometrics.IBiometricSensorReceiver,android.hardware.face.FaceAuthenticateOptions,long,int,boolean)>
<android.hardware.face.IFaceService: void addLockoutResetCallback(android.hardware.biometrics.IBiometricServiceLockoutResetCallback,java.lang.String)>
<android.hardware.face.IFaceService: void registerAuthenticators(java.util.List)>
<android.hardware.face.IFaceService: long authenticate(android.os.IBinder,long,android.hardware.face.IFaceServiceReceiver,android.hardware.face.FaceAuthenticateOptions)>
<android.hardware.face.IFaceService: int getLockoutModeForUser(int,int)>
<android.hardware.face.IFaceService: void cancelFaceDetect(android.os.IBinder,java.lang.String,long)>
<android.hardware.face.IFaceService: boolean hasEnrolledFaces(int,int,java.lang.String)>
<android.hardware.face.IFaceService: boolean semIsEnrollSession()>
<android.hardware.face.IFaceService: void semResumeEnroll()>
<android.hardware.face.IFaceService: void cancelAuthenticationFromService(int,android.os.IBinder,java.lang.String,long)>
<android.hardware.face.IFaceService: java.lang.String semGetInfo(int)>
<android.hardware.face.IFaceService: long enrollRemotely(int,android.os.IBinder,byte[],android.hardware.face.IFaceServiceReceiver,java.lang.String,int[])>
<android.hardware.face.IFaceService: long semAuthenticate(android.os.IBinder,long,android.hardware.face.IFaceServiceReceiver,android.hardware.face.FaceAuthenticateOptions,android.os.Bundle,byte[])>
<android.hardware.face.IFaceService: int semGetRemainingLockoutTime(int)>
<android.hardware.face.IFaceService: long detectFace(android.os.IBinder,android.hardware.face.IFaceServiceReceiver,android.hardware.face.FaceAuthenticateOptions)>
<android.hardware.face.IFaceService: long getAuthenticatorId(int,int)>
<android.hardware.face.IFaceService: boolean semIsSessionClose()>
<android.hardware.face.IFaceService: void semSessionOpen()>
<android.hardware.face.IFaceService: void cancelAuthentication(android.os.IBinder,java.lang.String,long)>
<android.hardware.face.IFaceService: void getFeature(android.os.IBinder,int,int,android.hardware.face.IFaceServiceReceiver,java.lang.String)>
<android.hardware.face.IFaceService: void revokeChallenge(android.os.IBinder,int,int,java.lang.String,long)>
<android.hardware.face.IFaceService: boolean semShouldRemoveTemplate()>
<android.hardware.face.IFaceService: void setFeature(android.os.IBinder,int,int,boolean,byte[],android.hardware.face.IFaceServiceReceiver,java.lang.String)>
<android.hardware.face.IFaceService: boolean isHardwareDetected(int,java.lang.String)>
<android.hardware.face.IFaceService: void semPauseEnroll()>
<android.hardware.face.IFaceService: boolean semResetAuthenticationTimeout()>
<android.hardware.face.IFaceService: void generateChallenge(android.os.IBinder,int,int,android.hardware.face.IFaceServiceReceiver,java.lang.String)>
<android.hardware.face.IFaceService: void startPreparedClient(int,int)>
<android.hardware.face.IFaceService: void invalidateAuthenticatorId(int,int,android.hardware.biometrics.IInvalidationCallback)>
<android.hardware.face.IFaceService: void scheduleWatchdog()>
<android.hardware.face.IFaceService: void semSessionClose()>
<android.hardware.face.IFaceService: android.hardware.biometrics.ITestSession createTestSession(int,android.hardware.biometrics.ITestSessionCallback,java.lang.String)>
<android.hardware.face.IFaceService: long semAuthenticateExt(android.os.IBinder,long,android.hardware.face.IFaceServiceReceiver,android.hardware.face.FaceAuthenticateOptions,android.view.Surface,byte[])>
<android.hardware.face.IFaceService: void cancelEnrollment(android.os.IBinder,long)>
<android.hardware.face.IFaceService: java.util.List getSensorPropertiesInternal(java.lang.String)>
<android.hardware.face.IFaceService: void addAuthenticatorsRegisteredCallback(android.hardware.face.IFaceAuthenticatorsRegisteredCallback)>
<android.hardware.face.IFaceService: void semPauseAuth()>
<android.hardware.face.IFaceService: long enroll(int,android.os.IBinder,byte[],android.hardware.face.IFaceServiceReceiver,java.lang.String,int[],android.view.Surface,boolean)>
<android.hardware.face.IFaceService: boolean semIsFrameworkHandleLockout()>
<android.hardware.face.IFaceService: android.hardware.face.FaceSensorPropertiesInternal getSensorProperties(int,java.lang.String)>
<android.hardware.face.IFaceService: void semResumeAuth()>
<android.hardware.face.IFaceService: void remove(android.os.IBinder,int,int,android.hardware.face.IFaceServiceReceiver,java.lang.String)>
<android.hardware.face.IFaceService: int semGetSecurityLevel(boolean)>
<android.hardware.face.IFaceService: void registerBiometricStateListener(android.hardware.biometrics.IBiometricStateListener)>
<android.hardware.face.IFaceService: void resetLockout(android.os.IBinder,int,int,byte[],java.lang.String)>
<android.hardware.face.IFaceService: java.util.List getEnrolledFaces(int,int,java.lang.String)>
<android.hardware.face.IFaceService: void removeAll(android.os.IBinder,int,android.hardware.face.IFaceServiceReceiver,java.lang.String)>
<com.samsung.android.sepunion.IGoodCatchManager: void registerListener(java.lang.String,java.lang.String[],com.samsung.android.sepunion.IGoodCatchDispatcher,android.os.IBinder)>
<com.samsung.android.sepunion.IGoodCatchManager: void update(java.lang.String[])>
<com.samsung.android.sepunion.IGoodCatchManager: java.util.List getSelectedSettingKey()>
<com.samsung.android.hardware.secinputdev.ISemInputDeviceRemoteServiceCallback: void deliveryLastData(int[],float)>
<com.samsung.android.hardware.secinputdev.ISemInputDeviceRemoteServiceCallback: void deliveryRawdata(int[])>
<android.hardware.fingerprint.ISidefpsController: void show(int,int)>
<android.hardware.fingerprint.ISidefpsController: void hide(int)>
<android.hardware.biometrics.IBiometricSensorReceiver: void onSemAuthenticationSucceeded(int,byte[],android.os.Bundle)>
<android.hardware.biometrics.IBiometricSensorReceiver: void onAuthenticationFailed(int)>
<android.hardware.biometrics.IBiometricSensorReceiver: void onAuthenticationSucceeded(int,byte[])>
<android.hardware.biometrics.IBiometricSensorReceiver: void onError(int,int,int,int)>
<android.hardware.biometrics.IBiometricSensorReceiver: void onAcquired(int,int,int)>
<com.android.internal.backup.ITransportStatusCallback: void onOperationComplete()>
<com.android.internal.backup.ITransportStatusCallback: void onOperationCompleteWithStatus(int)>
<com.samsung.android.sepunion.IDeviceInfoManager: int getNumPendingIntentAsUser(int,java.lang.String,int)>
<com.samsung.android.sepunion.IDeviceInfoManager: void registerPendingIntentForIntentForAllUsers(android.content.IntentFilter,android.app.PendingIntent,java.lang.String,int)>
<com.samsung.android.sepunion.IDeviceInfoManager: void unregisterPendingIntentForIntentAsUser(android.content.IntentFilter,android.app.PendingIntent,java.lang.String,int)>
<com.samsung.android.sepunion.IDeviceInfoManager: void registerPendingIntentForUriAsUser(android.net.Uri,android.app.PendingIntent,java.lang.String,int)>
<com.samsung.android.sepunion.IDeviceInfoManager: void unregisterPendingIntentForUriAsUser(android.net.Uri,android.app.PendingIntent,java.lang.String,int)>
<com.samsung.android.sepunion.IDeviceInfoManager: void clearPendingIntentAsUser(java.lang.String,int)>
<com.samsung.android.sepunion.IDeviceInfoManager: void registerPendingIntentForIntentAsUser(android.content.IntentFilter,android.app.PendingIntent,java.lang.String,int)>
<com.samsung.android.sepunion.IDeviceInfoManager: void registerPendingIntentForCustomEventAsUser(java.lang.String,android.app.PendingIntent,android.os.Bundle,java.lang.String,int)>
<com.samsung.android.sepunion.IDeviceInfoManager: void registerPendingIntent(android.content.IntentFilter,android.app.PendingIntent,int,java.util.List,java.lang.String,int)>
<com.samsung.android.sepunion.IDeviceInfoManager: void unregisterPendingIntentForCustomEventAsUser(java.lang.String,android.app.PendingIntent,android.os.Bundle,java.lang.String,int)>
<com.samsung.android.sepunion.IDeviceInfoManager: void unregisterPendingIntent(android.content.IntentFilter,android.app.PendingIntent,java.lang.String,int)>
<android.hardware.camera2.extension.IOutputSurfaceConfiguration: android.hardware.camera2.extension.OutputSurface getImageAnalysisOutputSurface()>
<android.hardware.camera2.extension.IOutputSurfaceConfiguration: android.hardware.camera2.extension.OutputSurface getImageCaptureOutputSurface()>
<android.hardware.camera2.extension.IOutputSurfaceConfiguration: android.hardware.camera2.extension.OutputSurface getPreviewOutputSurface()>
<android.hardware.camera2.extension.IOutputSurfaceConfiguration: android.hardware.camera2.extension.OutputSurface getPostviewOutputSurface()>
<com.samsung.android.cover.ISViewCoverBaseService: void onSViewCoverHide()>
<com.samsung.android.cover.ISViewCoverBaseService: boolean isCoverViewShowing()>
<com.samsung.android.cover.ISViewCoverBaseService: void onSViewCoverShow()>
<com.samsung.android.cover.ISViewCoverBaseService: void updateCoverState(com.samsung.android.cover.CoverState)>
<com.samsung.android.cover.ISViewCoverBaseService: int onCoverAppCovered(boolean)>
<com.samsung.android.cover.ISViewCoverBaseService: void onSystemReady()>
<android.app.IActivityClientController: void activityDestroyed(android.os.IBinder)>
<android.app.IActivityClientController: boolean isTopOfTask(android.os.IBinder)>
<android.app.IActivityClientController: void activityTopResumedStateLost()>
<android.app.IActivityClientController: boolean isImmersive(android.os.IBinder)>
<android.app.IActivityClientController: boolean navigateUpTo(android.os.IBinder,android.content.Intent,java.lang.String,int,android.content.Intent)>
<android.app.IActivityClientController: void activityStopped(android.os.IBinder,android.os.Bundle,android.os.PersistableBundle,java.lang.CharSequence)>
<android.app.IActivityClientController: android.os.IBinder getActivityTokenBelow(android.os.IBinder)>
<android.app.IActivityClientController: boolean isRootVoiceInteraction(android.os.IBinder)>
<android.app.IActivityClientController: boolean convertToTranslucent(android.os.IBinder,android.os.Bundle)>
<android.app.IActivityClientController: void activityRelaunched(android.os.IBinder)>
<android.app.IActivityClientController: boolean finishActivity(android.os.IBinder,int,android.content.Intent,int)>
<android.app.IActivityClientController: java.lang.String getLaunchedFromPackage(android.os.IBinder)>
<android.app.IActivityClientController: void setImmersive(android.os.IBinder,boolean)>
<android.app.IActivityClientController: void overrideActivityTransition(android.os.IBinder,boolean,int,int,int)>
<android.app.IActivityClientController: void stopLockTaskModeByToken(android.os.IBinder)>
<android.app.IActivityClientController: void unregisterRemoteAnimations(android.os.IBinder)>
<android.app.IActivityClientController: void invalidateHomeTaskSnapshot(android.os.IBinder)>
<android.app.IActivityClientController: int getDisplayId(android.os.IBinder)>
<android.app.IActivityClientController: boolean finishActivityAffinity(android.os.IBinder)>
<android.app.IActivityClientController: void stopLocalVoiceInteraction(android.os.IBinder)>
<android.app.IActivityClientController: android.content.ComponentName getCallingActivity(android.os.IBinder)>
<android.app.IActivityClientController: boolean convertFromTranslucent(android.os.IBinder)>
<android.app.IActivityClientController: void onBackPressed(android.os.IBinder,android.app.IRequestFinishCallback)>
<android.app.IActivityClientController: void clearOverrideActivityTransition(android.os.IBinder,boolean)>
<android.app.IActivityClientController: boolean isRequestedToLaunchInTaskFragment(android.os.IBinder,android.os.IBinder)>
<android.app.IActivityClientController: void setForceSendResultForMediaProjection(android.os.IBinder)>
<android.app.IActivityClientController: void setInheritShowWhenLocked(android.os.IBinder,boolean)>
<android.app.IActivityClientController: void requestCompatCameraControl(android.os.IBinder,boolean,boolean,android.app.ICompatCameraControlCallback)>
<android.app.IActivityClientController: boolean enterPictureInPictureMode(android.os.IBinder,android.app.PictureInPictureParams)>
<android.app.IActivityClientController: void setTurnScreenOn(android.os.IBinder,boolean)>
<android.app.IActivityClientController: int getLaunchedFromUid(android.os.IBinder)>
<android.app.IActivityClientController: void dismissKeyguard(android.os.IBinder,com.android.internal.policy.IKeyguardDismissCallback,java.lang.CharSequence)>
<android.app.IActivityClientController: boolean moveActivityTaskToBack(android.os.IBinder,boolean)>
<android.app.IActivityClientController: void overridePendingTaskTransition(android.os.IBinder,java.lang.String,int,int)>
<android.app.IActivityClientController: void registerRemoteAnimations(android.os.IBinder,android.view.RemoteAnimationDefinition)>
<android.app.IActivityClientController: void setAllowCrossUidActivitySwitchFromBelow(android.os.IBinder,boolean)>
<android.app.IActivityClientController: boolean releaseActivityInstance(android.os.IBinder)>
<android.app.IActivityClientController: void activityRefreshed(android.os.IBinder)>
<android.app.IActivityClientController: void toggleFreeformWindowingMode(android.os.IBinder)>
<android.app.IActivityClientController: void setPictureInPictureParams(android.os.IBinder,android.app.PictureInPictureParams)>
<android.app.IActivityClientController: void activityLocalRelaunch(android.os.IBinder)>
<android.app.IActivityClientController: boolean convertFromTranslucentOp(android.os.IBinder,boolean)>
<android.app.IActivityClientController: void reportSizeConfigurations(android.os.IBinder,android.window.SizeConfigurationBuckets)>
<android.app.IActivityClientController: android.content.res.Configuration getTaskConfiguration(android.os.IBinder)>
<android.app.IActivityClientController: void setShowWhenLocked(android.os.IBinder,boolean)>
<android.app.IActivityClientController: void startLockTaskModeByToken(android.os.IBinder)>
<android.app.IActivityClientController: boolean willActivityBeVisible(android.os.IBinder)>
<android.app.IActivityClientController: void setRequestedOrientation(android.os.IBinder,int)>
<android.app.IActivityClientController: void requestMultiwindowFullscreen(android.os.IBinder,int,android.os.IRemoteCallback)>
<android.app.IActivityClientController: void showLockTaskEscapeMessage(android.os.IBinder)>
<android.app.IActivityClientController: void activityIdle(android.os.IBinder,android.content.res.Configuration,boolean)>
<android.app.IActivityClientController: int setVrMode(android.os.IBinder,boolean,android.content.ComponentName)>
<android.app.IActivityClientController: boolean shouldUpRecreateTask(android.os.IBinder,java.lang.String)>
<android.app.IActivityClientController: void splashScreenAttached(android.os.IBinder)>
<android.app.IActivityClientController: void setTaskDescription(android.os.IBinder,android.app.ActivityManager$TaskDescription)>
<android.app.IActivityClientController: void finishSubActivity(android.os.IBinder,java.lang.String,int)>
<android.app.IActivityClientController: void activityResumed(android.os.IBinder,boolean)>
<android.app.IActivityClientController: void reportActivityFullyDrawn(android.os.IBinder,boolean)>
<android.app.IActivityClientController: void activityPaused(android.os.IBinder)>
<android.app.IActivityClientController: void overridePendingTransition(android.os.IBinder,java.lang.String,int,int,int)>
<android.app.IActivityClientController: int getRequestedOrientation(android.os.IBinder)>
<android.app.IActivityClientController: boolean showAssistFromActivity(android.os.IBinder,android.os.Bundle)>
<android.app.IActivityClientController: java.lang.String getCallingPackage(android.os.IBinder)>
<android.app.IActivityClientController: int getTaskForActivity(android.os.IBinder,boolean)>
<android.app.IActivityClientController: void adjustPopOverOptions(android.os.IBinder,int[],int[],android.graphics.Point[],int[])>
<android.app.IActivityClientController: void enableTaskLocaleOverride(android.os.IBinder)>
<android.app.IActivityClientController: void setRecentsScreenshotEnabled(android.os.IBinder,boolean)>
<android.app.IActivityClientController: void startLocalVoiceInteraction(android.os.IBinder,android.os.Bundle)>
<android.app.IActivityClientController: void setShouldDockBigOverlays(android.os.IBinder,boolean)>
<android.service.autofill.ISurfacePackageResultCallback: void onResult(android.view.SurfaceControlViewHost$SurfacePackage)>
<android.telephony.ICellBroadcastService: java.lang.CharSequence getCellBroadcastAreaInfo(int)>
<android.telephony.ICellBroadcastService: void handleCdmaCellBroadcastSms(int,byte[],int)>
<android.telephony.ICellBroadcastService: void handleCdmaScpMessage(int,java.util.List,java.lang.String,android.os.RemoteCallback)>
<android.telephony.ICellBroadcastService: void handleGsmCellBroadcastSms(int,byte[])>
<android.companion.IOnMessageReceivedListener: void onMessageReceived(int,byte[])>
<android.security.metrics.IKeystoreMetrics: android.security.metrics.KeystoreAtom[] pullMetrics(int)>
<vendor.samsung.hardware.radio.messaging.ISehRadioMessagingResponse: void sendCdmaSmsResponse(vendor.samsung.hardware.radio.SehRadioResponseInfo,vendor.samsung.hardware.radio.messaging.SehSendSmsResult)>
<vendor.samsung.hardware.radio.messaging.ISehRadioMessagingResponse: void getStoredMsgCountFromSimResponse(vendor.samsung.hardware.radio.SehRadioResponseInfo,vendor.samsung.hardware.radio.messaging.SehStoredMsgCount)>
<vendor.samsung.hardware.radio.messaging.ISehRadioMessagingResponse: void sendSMSExpectMoreResponse(vendor.samsung.hardware.radio.SehRadioResponseInfo,vendor.samsung.hardware.radio.messaging.SehSendSmsResult)>
<vendor.samsung.hardware.radio.messaging.ISehRadioMessagingResponse: void sendCdmaSmsExpectMoreResponse(vendor.samsung.hardware.radio.SehRadioResponseInfo,vendor.samsung.hardware.radio.messaging.SehSendSmsResult)>
<vendor.samsung.hardware.radio.messaging.ISehRadioMessagingResponse: void writeSmsToSimResponse(vendor.samsung.hardware.radio.SehRadioResponseInfo,int)>
<vendor.samsung.hardware.radio.messaging.ISehRadioMessagingResponse: void readSmsFromSimResponse(vendor.samsung.hardware.radio.SehRadioResponseInfo,vendor.samsung.hardware.radio.messaging.SehSimMsgArgs)>
<vendor.samsung.hardware.radio.messaging.ISehRadioMessagingResponse: void getCellBroadcastConfigResponse(vendor.samsung.hardware.radio.SehRadioResponseInfo,vendor.samsung.hardware.radio.messaging.SehCbConfigArgs)>
<vendor.samsung.hardware.radio.messaging.ISehRadioMessagingResponse: void getImsRegistrationStateResponse(vendor.samsung.hardware.radio.SehRadioResponseInfo,int[])>
<vendor.samsung.hardware.radio.messaging.ISehRadioMessagingResponse: java.lang.String getInterfaceHash()>
<vendor.samsung.hardware.radio.messaging.ISehRadioMessagingResponse: int getInterfaceVersion()>
<vendor.samsung.hardware.radio.messaging.ISehRadioMessagingResponse: void sendSmsResponse(vendor.samsung.hardware.radio.SehRadioResponseInfo,vendor.samsung.hardware.radio.messaging.SehSendSmsResult)>
<com.android.ims.internal.IImsServiceController: void removeImsFeature(int,int)>
<com.android.ims.internal.IImsServiceController: void addFeatureStatusCallback(int,int,com.android.ims.internal.IImsFeatureStatusCallback)>
<com.android.ims.internal.IImsServiceController: com.android.ims.internal.IImsMMTelFeature createEmergencyMMTelFeature(int)>
<com.android.ims.internal.IImsServiceController: com.android.ims.internal.IImsMMTelFeature createMMTelFeature(int)>
<com.android.ims.internal.IImsServiceController: void removeFeatureStatusCallback(int,int,com.android.ims.internal.IImsFeatureStatusCallback)>
<com.android.ims.internal.IImsServiceController: com.android.ims.internal.IImsRcsFeature createRcsFeature(int)>
<android.os.IInstalld: boolean setDualDARPolicyDir(int,int,java.lang.String)>
<android.os.IInstalld: byte[] hashSecondaryDexFile(java.lang.String,java.lang.String,int,java.lang.String,int)>
<android.os.IInstalld: void destroyAppData(java.lang.String,java.lang.String,int,int,long)>
<android.os.IInstalld: boolean dexopt(java.lang.String,int,java.lang.String,java.lang.String,int,java.lang.String,int,java.lang.String,java.lang.String,java.lang.String,java.lang.String,boolean,int,java.lang.String,java.lang.String,java.lang.String)>
<android.os.IInstalld: boolean prepareAppProfile(java.lang.String,int,int,java.lang.String,java.lang.String,java.lang.String)>
<android.os.IInstalld: void freeCache(java.lang.String,long,int)>
<android.os.IInstalld: boolean getKnoxScanDir(java.lang.String,long,java.util.List)>
<android.os.IInstalld: boolean getCompressedStats(java.lang.String,long[])>
<android.os.IInstalld: void destroyProfileSnapshot(java.lang.String,java.lang.String)>
<android.os.IInstalld: boolean copyKnoxAppData(java.lang.String,int,java.lang.String,int,int)>
<android.os.IInstalld: long[] getUserSize(java.lang.String,int,int,int[])>
<android.os.IInstalld: boolean copyKnoxCancel(java.lang.String,long)>
<android.os.IInstalld: void destroyAppProfiles(java.lang.String)>
<android.os.IInstalld: void clearAppProfiles(java.lang.String,java.lang.String)>
<android.os.IInstalld: void createOatDir(java.lang.String,java.lang.String,java.lang.String)>
<android.os.IInstalld: boolean hasDualDARPolicyRecursively(java.lang.String,java.util.List)>
<android.os.IInstalld: android.os.storage.CrateMetadata[] getAppCrates(java.lang.String,java.lang.String[],int)>
<android.os.IInstalld: void destroyUserData(java.lang.String,int,int)>
<android.os.IInstalld: boolean setDualDARPolicyDirRecursively(int,int,java.lang.String)>
<android.os.IInstalld: void migrateAppData(java.lang.String,java.lang.String,int,int)>
<android.os.IInstalld: boolean getDualDARLockstate()>
<android.os.IInstalld: void clearAppData(java.lang.String,java.lang.String,int,int,long)>
<android.os.IInstalld: void createUserData(java.lang.String,int,int,int)>
<android.os.IInstalld: void moveCompleteApp(java.lang.String,java.lang.String,java.lang.String,int,java.lang.String,int,java.lang.String)>
<android.os.IInstalld: void cleanupInvalidPackageDirs(java.lang.String,int,int)>
<android.os.IInstalld: int mergeProfiles(int,java.lang.String,java.lang.String)>
<android.os.IInstalld: long[] getKnoxFileInfo(java.lang.String)>
<android.os.IInstalld: boolean dumpProfiles(int,java.lang.String,java.lang.String,java.lang.String,boolean)>
<android.os.IInstalld: int getOdexVisibility(java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
<android.os.IInstalld: void setAppQuota(java.lang.String,int,int,long)>
<android.os.IInstalld: void migrateLegacyObbData()>
<android.os.IInstalld: long snapshotAppData(java.lang.String,java.lang.String,int,int,int)>
<android.os.IInstalld: void fixupAppData(java.lang.String,int)>
<android.os.IInstalld: void linkNativeLibraryDirectory(java.lang.String,java.lang.String,java.lang.String,int)>
<android.os.IInstalld: boolean reconcileSecondaryDexFile(java.lang.String,java.lang.String,int,java.lang.String[],java.lang.String,int)>
<android.os.IInstalld: void compressFile(java.lang.String,boolean)>
<android.os.IInstalld: void tryMountDataMirror(java.lang.String)>
<android.os.IInstalld: void restoreconAppData(java.lang.String,java.lang.String,int,int,int,java.lang.String)>
<android.os.IInstalld: int copyKnoxChunks(java.lang.String,int,java.lang.String,int,int,long,long,long)>
<android.os.IInstalld: void rmPackageDir(java.lang.String,java.lang.String)>
<android.os.IInstalld: long deleteOdex(java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
<android.os.IInstalld: android.os.CreateAppDataResult createAppData(android.os.CreateAppDataArgs)>
<android.os.IInstalld: boolean createEncAppData(java.lang.String,int,int,int)>
<android.os.IInstalld: void moveAb(java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
<android.os.IInstalld: android.os.storage.CrateMetadata[] getUserCrates(java.lang.String,int)>
<android.os.IInstalld: void rmdex(java.lang.String,java.lang.String)>
<android.os.IInstalld: long[] getAppSize(java.lang.String,java.lang.String[],int,int,int,long[],java.lang.String[])>
<android.os.IInstalld: void deleteReferenceProfile(java.lang.String,java.lang.String)>
<android.os.IInstalld: void linkFile(java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
<android.os.IInstalld: void destroyCeSnapshotsNotSpecified(java.lang.String,int,int[])>
<android.os.IInstalld: void controlDexOptBlocking(boolean)>
<android.os.IInstalld: void onPrivateVolumeRemoved(java.lang.String)>
<android.os.IInstalld: void scanApkStats(java.lang.String,int)>
<android.os.IInstalld: boolean removeEncUserDir(int)>
<android.os.IInstalld: void destroyAppDataSnapshot(java.lang.String,java.lang.String,int,long,int,int)>
<android.os.IInstalld: boolean copySystemProfile(java.lang.String,int,java.lang.String,java.lang.String)>
<android.os.IInstalld: boolean removeNotTargetedPreloadApksIfNeeded()>
<android.os.IInstalld: void setFirstBoot()>
<android.os.IInstalld: boolean compileLayouts(java.lang.String,java.lang.String,java.lang.String,int)>
<android.os.IInstalld: boolean hasDualDARPolicy(java.lang.String)>
<android.os.IInstalld: boolean createProfileSnapshot(int,java.lang.String,java.lang.String,java.lang.String)>
<android.os.IInstalld: boolean isQuotaSupported(java.lang.String)>
<android.os.IInstalld: android.os.CreateAppDataResult[] createAppDataBatched(android.os.CreateAppDataArgs[])>
<android.os.IInstalld: void reconcileSdkData(android.os.ReconcileSdkDataArgs)>
<android.os.IInstalld: void invalidateMounts()>
<android.os.IInstalld: void restoreAppDataSnapshot(java.lang.String,java.lang.String,int,java.lang.String,int,int,int)>
<android.os.IInstalld: boolean deleteKnoxFile(java.lang.String)>
<android.os.IInstalld: boolean setEviction(int,boolean)>
<android.os.IInstalld: boolean removeEncPkgDir(int,java.lang.String)>
<android.os.IInstalld: long[] getExternalSize(java.lang.String,int,int,int[])>
<android.os.IInstalld: boolean migrateSdpDb(java.lang.String,int)>
<android.app.IInstrumentationWatcher: void instrumentationFinished(android.content.ComponentName,int,android.os.Bundle)>
<android.app.IInstrumentationWatcher: void instrumentationStatus(android.content.ComponentName,int,android.os.Bundle)>
<android.app.IAssistDataReceiver: void onHandleAssistData(android.os.Bundle)>
<android.app.IAssistDataReceiver: void onHandleAssistScreenshot(android.graphics.Bitmap)>
<com.android.internal.policy.IKeyguardLockedStateListener: void onKeyguardLockedStateChanged(boolean)>
<android.hardware.gnss.IGnss: android.hardware.gnss.IGnssAntennaInfo getExtensionGnssAntennaInfo()>
<android.hardware.gnss.IGnss: java.lang.String getInterfaceHash()>
<android.hardware.gnss.IGnss: void close()>
<android.hardware.gnss.IGnss: void stopSvStatus()>
<android.hardware.gnss.IGnss: android.hardware.gnss.visibility_control.IGnssVisibilityControl getExtensionGnssVisibilityControl()>
<android.hardware.gnss.IGnss: android.hardware.gnss.IGnssConfiguration getExtensionGnssConfiguration()>
<android.hardware.gnss.IGnss: void injectTime(long,long,int)>
<android.hardware.gnss.IGnss: void setCallback(android.hardware.gnss.IGnssCallback)>
<android.hardware.gnss.IGnss: android.hardware.gnss.IAGnssRil getExtensionAGnssRil()>
<android.hardware.gnss.IGnss: android.hardware.gnss.IGnssBatching getExtensionGnssBatching()>
<android.hardware.gnss.IGnss: void start()>
<android.hardware.gnss.IGnss: android.hardware.gnss.IGnssMeasurementInterface getExtensionGnssMeasurement()>
<android.hardware.gnss.IGnss: void startSvStatus()>
<android.hardware.gnss.IGnss: void stop()>
<android.hardware.gnss.IGnss: void startNmea()>
<android.hardware.gnss.IGnss: android.hardware.gnss.IAGnss getExtensionAGnss()>
<android.hardware.gnss.IGnss: android.hardware.gnss.IGnssNavigationMessageInterface getExtensionGnssNavigationMessage()>
<android.hardware.gnss.IGnss: android.hardware.gnss.measurement_corrections.IMeasurementCorrectionsInterface getExtensionMeasurementCorrections()>
<android.hardware.gnss.IGnss: void stopNmea()>
<android.hardware.gnss.IGnss: android.hardware.gnss.IGnssPsds getExtensionPsds()>
<android.hardware.gnss.IGnss: android.hardware.gnss.IGnssGeofence getExtensionGnssGeofence()>
<android.hardware.gnss.IGnss: android.hardware.gnss.IGnssPowerIndication getExtensionGnssPowerIndication()>
<android.hardware.gnss.IGnss: void injectBestLocation(android.hardware.gnss.GnssLocation)>
<android.hardware.gnss.IGnss: void setPositionMode(android.hardware.gnss.IGnss$PositionModeOptions)>
<android.hardware.gnss.IGnss: void deleteAidingData(int)>
<android.hardware.gnss.IGnss: int getInterfaceVersion()>
<android.hardware.gnss.IGnss: void injectLocation(android.hardware.gnss.GnssLocation)>
<android.hardware.gnss.IGnss: android.hardware.gnss.IGnssDebug getExtensionGnssDebug()>
<android.hardware.location.IActivityRecognitionHardware: boolean enableActivityEvent(java.lang.String,int,long)>
<android.hardware.location.IActivityRecognitionHardware: boolean disableActivityEvent(java.lang.String,int)>
<android.hardware.location.IActivityRecognitionHardware: boolean flush()>
<android.hardware.location.IActivityRecognitionHardware: boolean unregisterSink(android.hardware.location.IActivityRecognitionHardwareSink)>
<android.hardware.location.IActivityRecognitionHardware: java.lang.String[] getSupportedActivities()>
<android.hardware.location.IActivityRecognitionHardware: boolean registerSink(android.hardware.location.IActivityRecognitionHardwareSink)>
<android.hardware.location.IActivityRecognitionHardware: boolean isActivitySupported(java.lang.String)>
<com.android.internal.infra.IAndroidFuture: void complete(com.android.internal.infra.AndroidFuture)>
<com.samsung.android.wifi.ISemWifiApSmartCallback: void onStateChanged(int,java.lang.String)>
<android.media.session.IOnMediaKeyEventSessionChangedListener: void onMediaKeyEventSessionChanged(java.lang.String,android.media.session.MediaSession$Token)>
<android.app.IActivityTaskManager: boolean removeTask(int)>
<android.app.IActivityTaskManager: int getOrientationControlPolicy(int,java.lang.String)>
<android.app.IActivityTaskManager: android.app.ActivityTaskManager$RootTaskInfo getFocusedRootTaskInfo()>
<android.app.IActivityTaskManager: void setCutoutPolicy(int,java.lang.String,int)>
<android.app.IActivityTaskManager: android.app.WaitResult startActivityAndWait(android.app.IApplicationThread,java.lang.String,java.lang.String,android.content.Intent,java.lang.String,android.os.IBinder,java.lang.String,int,int,android.app.ProfilerInfo,android.os.Bundle,int)>
<android.app.IActivityTaskManager: int startActivityFromGameSession(android.app.IApplicationThread,java.lang.String,java.lang.String,int,int,android.content.Intent,int,int)>
<android.app.IActivityTaskManager: int getBoundsCompatAlignment()>
<android.app.IActivityTaskManager: boolean supportsLocalVoiceInteraction()>
<android.app.IActivityTaskManager: java.util.List getCoverLauncherAvailableAppList(int)>
<android.app.IActivityTaskManager: int startVoiceActivity(java.lang.String,java.lang.String,int,int,android.content.Intent,java.lang.String,android.service.voice.IVoiceInteractionSession,com.android.internal.app.IVoiceInteractor,int,android.app.ProfilerInfo,android.os.Bundle,int)>
<android.app.IActivityTaskManager: void setOrientationControlDefault(boolean)>
<android.app.IActivityTaskManager: java.lang.String getScpmVersion()>
<android.app.IActivityTaskManager: void setCustomSplashScreenTheme(java.lang.String,java.lang.String,int)>
<android.app.IActivityTaskManager: void updateLockTaskPackages(int,java.lang.String[])>
<android.app.IActivityTaskManager: void setApplockLockedAppsPackage(java.lang.String)>
<android.app.IActivityTaskManager: void setFrontActivityScreenCompatMode(int)>
<android.app.IActivityTaskManager: void setAppLockedUnLockPackage(java.lang.String)>
<android.app.IActivityTaskManager: void stopSystemLockTaskMode()>
<android.app.IActivityTaskManager: android.graphics.Point getAppTaskThumbnailSize()>
<android.app.IActivityTaskManager: void setFocusedRootTask(int)>
<android.app.IActivityTaskManager: void setAppLockedVerifying(java.lang.String,boolean)>
<android.app.IActivityTaskManager: void suppressResizeConfigChanges(boolean)>
<android.app.IActivityTaskManager: android.content.pm.ConfigurationInfo getDeviceConfigurationInfo()>
<android.app.IActivityTaskManager: void setDisallowWhenLandscape(boolean)>
<android.app.IActivityTaskManager: void startSystemLockTaskMode(int)>
<android.app.IActivityTaskManager: java.util.Map getCoverLauncherEnabledAppListByType(int,int)>
<android.app.IActivityTaskManager: void setApplockType(int)>
<android.app.IActivityTaskManager: boolean isActivityStartAllowedOnDisplay(int,android.content.Intent,java.lang.String,int)>
<android.app.IActivityTaskManager: int startActivityIntentSender(android.app.IApplicationThread,android.content.IIntentSender,android.os.IBinder,android.content.Intent,java.lang.String,android.os.IBinder,java.lang.String,int,int,int,android.os.Bundle)>
<android.app.IActivityTaskManager: void unregisterScreenCaptureObserver(android.os.IBinder,android.app.IScreenCaptureObserver)>
<android.app.IActivityTaskManager: void setUseLetterbox(boolean)>
<android.app.IActivityTaskManager: void releaseSomeActivities(android.app.IApplicationThread)>
<android.app.IActivityTaskManager: void moveRootTaskToDisplay(int,int)>
<android.app.IActivityTaskManager: java.lang.String getAppLockedCheckAction()>
<android.app.IActivityTaskManager: boolean updateConfiguration(android.content.res.Configuration)>
<android.app.IActivityTaskManager: android.os.Bundle getAssistContextExtras(int)>
<android.app.IActivityTaskManager: boolean requestAutofillData(android.app.IAssistDataReceiver,android.os.Bundle,android.os.IBinder,int)>
<android.app.IActivityTaskManager: void cancelRecentsAnimation(boolean)>
<android.app.IActivityTaskManager: int startActivityFromRecents(int,android.os.Bundle)>
<android.app.IActivityTaskManager: void finishVoiceTask(android.service.voice.IVoiceInteractionSession)>
<android.app.IActivityTaskManager: void clearLaunchParamsForPackages(java.util.List)>
<android.app.IActivityTaskManager: java.lang.String getVoiceInteractorPackageName(android.os.IBinder)>
<android.app.IActivityTaskManager: void stopAppSwitches()>
<android.app.IActivityTaskManager: boolean startDreamActivity(android.content.Intent)>
<android.app.IActivityTaskManager: android.window.TaskSnapshot takeTaskSnapshot(int,boolean)>
<android.app.IActivityTaskManager: int getApplockType()>
<android.app.IActivityTaskManager: void setRunningRemoteTransitionDelegate(android.app.IApplicationThread)>
<android.app.IActivityTaskManager: int addAppTask(android.os.IBinder,android.content.Intent,android.app.ActivityManager$TaskDescription,android.graphics.Bitmap)>
<android.app.IActivityTaskManager: java.util.List getAppTasks(java.lang.String)>
<android.app.IActivityTaskManager: int getFrontActivityScreenCompatMode()>
<android.app.IActivityTaskManager: int getLockTaskModeState()>
<android.app.IActivityTaskManager: java.lang.String getSsecureHiddenAppsPackages()>
<android.app.IActivityTaskManager: void resetUserPackageSettings(int,int)>
<android.app.IActivityTaskManager: void setApplockEnabled(boolean)>
<android.app.IActivityTaskManager: void clearAppLockedUnLockedApp()>
<android.app.IActivityTaskManager: void moveTaskToFront(android.app.IApplicationThread,java.lang.String,int,int,android.os.Bundle)>
<android.app.IActivityTaskManager: void registerRemoteTransitionForNextActivityStart(java.lang.String,android.view.RemoteAnimationAdapter,android.os.IBinder,android.window.RemoteTransition)>
<android.app.IActivityTaskManager: void setPersistentVrThread(int)>
<android.app.IActivityTaskManager: java.util.List getAllRootTaskInfosOnDisplay(int)>
<android.app.IActivityTaskManager: void keyguardGoingAway(int)>
<android.app.IActivityTaskManager: void startActivityForCoverLauncherAsUser(android.content.Intent,java.lang.String,int)>
<android.app.IActivityTaskManager: void sendSaLoggingBroadcastForSetting(java.lang.String,java.lang.String,java.lang.String)>
<android.app.IActivityTaskManager: void unregisterTaskStackListener(android.app.ITaskStackListener)>
<android.app.IActivityTaskManager: android.content.pm.ParceledListSlice getRecentTasks(int,int,int)>
<android.app.IActivityTaskManager: android.window.IWindowOrganizerController getWindowOrganizerController()>
<android.app.IActivityTaskManager: void registerRemoteAnimationForNextActivityStart(java.lang.String,android.view.RemoteAnimationAdapter,android.os.IBinder)>
<android.app.IActivityTaskManager: int startActivity(android.app.IApplicationThread,java.lang.String,java.lang.String,android.content.Intent,java.lang.String,android.os.IBinder,java.lang.String,int,int,android.app.ProfilerInfo,android.os.Bundle)>
<android.app.IActivityTaskManager: boolean isAppLockedVerifying(java.lang.String)>
<android.app.IActivityTaskManager: void setSsecureHiddenAppsPackages(java.lang.String)>
<android.app.IActivityTaskManager: android.graphics.Bitmap getTaskDescriptionIcon(java.lang.String,int)>
<android.app.IActivityTaskManager: void setFocusedTask(int)>
<android.app.IActivityTaskManager: boolean hasWallpaperBackgroundForLetterbox(int)>
<android.app.IActivityTaskManager: void cancelTaskWindowTransition(int)>
<android.app.IActivityTaskManager: void alwaysShowUnsupportedCompileSdkWarning(android.content.ComponentName)>
<android.app.IActivityTaskManager: android.graphics.Rect getTaskBounds(int)>
<android.app.IActivityTaskManager: void registKeyEventListener(com.samsung.android.multiwindow.IKeyEventListener)>
<android.app.IActivityTaskManager: void startRecentsActivity(android.content.Intent,long,android.view.IRecentsAnimationRunner)>
<android.app.IActivityTaskManager: android.window.TaskSnapshot getTaskSnapshot(int,boolean,boolean)>
<android.app.IActivityTaskManager: void unhandledBack()>
<android.app.IActivityTaskManager: void focusTopTask(int)>
<android.app.IActivityTaskManager: void removeRootTasksInWindowingModes(int[])>
<android.app.IActivityTaskManager: boolean removeTaskWithFlags(int,int)>
<android.app.IActivityTaskManager: void removeAllVisibleRecentTasks()>
<android.app.IActivityTaskManager: android.app.ActivityTaskManager$RootTaskInfo getRootTaskInfo(int,int)>
<android.app.IActivityTaskManager: void setActivityController(android.app.IActivityController,boolean)>
<android.app.IActivityTaskManager: java.util.List getAppLockedPackageList()>
<android.app.IActivityTaskManager: int setCoverLauncherPackageDisabled(java.lang.String,int)>
<android.app.IActivityTaskManager: boolean isAssistDataAllowedOnCurrentActivity()>
<android.app.IActivityTaskManager: boolean requestAssistContextExtras(int,android.app.IAssistDataReceiver,android.os.Bundle,android.os.IBinder,boolean,boolean)>
<android.app.IActivityTaskManager: void startActivityForCoverLauncher(android.content.Intent,java.lang.String)>
<android.app.IActivityTaskManager: int startActivities(android.app.IApplicationThread,java.lang.String,java.lang.String,android.content.Intent[],java.lang.String[],android.os.IBinder,android.os.Bundle,int)>
<android.app.IActivityTaskManager: void startAppLockService(android.os.IBinder,android.content.Intent,boolean,java.lang.String)>
<android.app.IActivityTaskManager: com.samsung.android.core.IFoldStarManager getFoldStarManagerService()>
<android.app.IActivityTaskManager: void onPictureInPictureStateChanged(android.app.PictureInPictureUiState)>
<android.app.IActivityTaskManager: void startActivityForDexRestart(int)>
<android.app.IActivityTaskManager: void sendSaLoggingBroadcast(java.lang.String,java.lang.String,java.lang.String,long,java.util.Map)>
<android.app.IActivityTaskManager: boolean isAppLockedPackage(java.lang.String)>
<android.app.IActivityTaskManager: boolean isApplockEnabled()>
<android.app.IActivityTaskManager: boolean getPackageAskScreenCompat(java.lang.String)>
<android.app.IActivityTaskManager: void setOrientationControlPolicy(int,java.lang.String,int)>
<android.app.IActivityTaskManager: boolean clearRecentTasks(int)>
<android.app.IActivityTaskManager: java.lang.String getAppLockedLockType()>
<android.app.IActivityTaskManager: boolean isInLockTaskMode()>
<android.app.IActivityTaskManager: int startAssistantActivity(java.lang.String,java.lang.String,int,int,android.content.Intent,java.lang.String,android.os.Bundle,int)>
<android.app.IActivityTaskManager: void updateLockTaskFeatures(int,int)>
<android.app.IActivityTaskManager: void setVrThread(int)>
<android.app.IActivityTaskManager: int startActivityAsUser(android.app.IApplicationThread,java.lang.String,java.lang.String,android.content.Intent,java.lang.String,android.os.IBinder,java.lang.String,int,int,android.app.ProfilerInfo,android.os.Bundle,int)>
<android.app.IActivityTaskManager: void setApplockLockedAppsClass(java.lang.String)>
<android.app.IActivityTaskManager: java.lang.String getApplockLockedAppsClass()>
<android.app.IActivityTaskManager: int getCutoutPolicy(int,java.lang.String)>
<android.app.IActivityTaskManager: void moveTaskToRootTask(int,int,boolean)>
<android.app.IActivityTaskManager: void setPackageScreenCompatMode(java.lang.String,int)>
<android.app.IActivityTaskManager: int startActivityAsCaller(android.app.IApplicationThread,java.lang.String,android.content.Intent,java.lang.String,android.os.IBinder,java.lang.String,int,int,android.app.ProfilerInfo,android.os.Bundle,boolean,int)>
<android.app.IActivityTaskManager: java.util.List getTasks(int,boolean,boolean,int)>
<android.app.IActivityTaskManager: boolean startNextMatchingActivity(android.os.IBinder,android.content.Intent,android.os.Bundle)>
<android.app.IActivityTaskManager: void reportAssistContextExtras(android.os.IBinder,android.os.Bundle,android.app.assist.AssistStructure,android.app.assist.AssistContent,android.net.Uri)>
<android.app.IActivityTaskManager: boolean isTopActivityImmersive()>
<android.app.IActivityTaskManager: void requestWaitingForOccluding(int)>
<android.app.IActivityTaskManager: java.util.List getAllRootTaskInfos()>
<android.app.IActivityTaskManager: void detachNavigationBarFromApp(android.os.IBinder)>
<android.app.IActivityTaskManager: void setPackageAskScreenCompat(java.lang.String,boolean)>
<android.app.IActivityTaskManager: void registerScreenCaptureObserver(android.os.IBinder,android.app.IScreenCaptureObserver)>
<android.app.IActivityTaskManager: void removeRootTasksWithActivityTypes(int[])>
<android.app.IActivityTaskManager: void setVoiceKeepAwake(android.service.voice.IVoiceInteractionSession,boolean)>
<android.app.IActivityTaskManager: int getLastResumedActivityUserId()>
<android.app.IActivityTaskManager: android.app.ActivityTaskManager$RootTaskInfo getRootTaskInfoOnDisplay(int,int,int)>
<android.app.IActivityTaskManager: boolean isPackageEnabledForCoverLauncher(java.lang.String,int)>
<android.app.IActivityTaskManager: void setTaskResizeable(int,int)>
<android.app.IActivityTaskManager: android.app.ActivityManager$TaskDescription getTaskDescription(int)>
<android.app.IActivityTaskManager: boolean requestAssistDataForTask(android.app.IAssistDataReceiver,int,java.lang.String,java.lang.String)>
<android.app.IActivityTaskManager: void setLockScreenShown(boolean,boolean)>
<android.app.IActivityTaskManager: int getPackageScreenCompatMode(java.lang.String)>
<android.app.IActivityTaskManager: java.util.Map getCoverLauncherEnabledAppList(int)>
<android.app.IActivityTaskManager: int setCoverLauncherPackageEnabled(java.lang.String,int)>
<android.app.IActivityTaskManager: void resumeAppSwitches()>
<android.app.IActivityTaskManager: void registerTaskStackListener(android.app.ITaskStackListener)>
<android.app.IActivityTaskManager: android.window.BackNavigationInfo startBackNavigation(android.os.RemoteCallback,android.window.BackAnimationAdapter)>
<android.app.IActivityTaskManager: void resizeTask(int,android.graphics.Rect,int)>
<android.app.IActivityTaskManager: android.graphics.Bitmap getResumedTaskThumbnail(int)>
<android.app.IActivityTaskManager: android.app.IActivityClientController getActivityClientController()>
<android.app.IActivityTaskManager: int startActivityWithConfig(android.app.IApplicationThread,java.lang.String,java.lang.String,android.content.Intent,java.lang.String,android.os.IBinder,java.lang.String,int,int,android.content.res.Configuration,android.os.Bundle,int)>
<android.app.IActivityTaskManager: java.lang.String getApplockLockedAppsPackage()>
<android.app.IActivityTaskManager: com.samsung.android.multiwindow.IMultiTaskingBinder getMultiTaskingBinder()>
<android.app.IActivityTaskManager: void onSplashScreenViewCopyFinished(int,android.window.SplashScreenView$SplashScreenViewParcelable)>
<android.app.IActivityTaskManager: void registerRemoteAnimationsForDisplay(int,android.view.RemoteAnimationDefinition)>
<android.app.IActivityTaskManager: void setBoundsCompatAlignment(int)>
<android.media.IMediaRouterClient: void onRestoreRoute()>
<android.media.IMediaRouterClient: void onStateChanged()>
<android.media.IMediaRouterClient: void onGroupRouteSelected(java.lang.String)>
<com.android.internal.app.IVoiceInteractorCallback: void deliverCancel(com.android.internal.app.IVoiceInteractorRequest)>
<com.android.internal.app.IVoiceInteractorCallback: void deliverPickOptionResult(com.android.internal.app.IVoiceInteractorRequest,boolean,android.app.VoiceInteractor$PickOptionRequest$Option[],android.os.Bundle)>
<com.android.internal.app.IVoiceInteractorCallback: void deliverCompleteVoiceResult(com.android.internal.app.IVoiceInteractorRequest,android.os.Bundle)>
<com.android.internal.app.IVoiceInteractorCallback: void destroy()>
<com.android.internal.app.IVoiceInteractorCallback: void deliverAbortVoiceResult(com.android.internal.app.IVoiceInteractorRequest,android.os.Bundle)>
<com.android.internal.app.IVoiceInteractorCallback: void deliverConfirmationResult(com.android.internal.app.IVoiceInteractorRequest,boolean,android.os.Bundle)>
<com.android.internal.app.IVoiceInteractorCallback: void deliverCommandResult(com.android.internal.app.IVoiceInteractorRequest,boolean,android.os.Bundle)>
<android.hardware.location.IContextHubService: void loadNanoAppOnHub(int,android.hardware.location.IContextHubTransactionCallback,android.hardware.location.NanoAppBinary)>
<android.hardware.location.IContextHubService: int[] findNanoAppOnHub(int,android.hardware.location.NanoAppFilter)>
<android.hardware.location.IContextHubService: android.hardware.location.ContextHubInfo getContextHubInfo(int)>
<android.hardware.location.IContextHubService: int registerCallback(android.hardware.location.IContextHubCallback)>
<android.hardware.location.IContextHubService: void enableNanoApp(int,android.hardware.location.IContextHubTransactionCallback,long)>
<android.hardware.location.IContextHubService: long[] getPreloadedNanoAppIds(android.hardware.location.ContextHubInfo)>
<android.hardware.location.IContextHubService: void queryNanoApps(int,android.hardware.location.IContextHubTransactionCallback)>
<android.hardware.location.IContextHubService: boolean setTestMode(boolean)>
<android.hardware.location.IContextHubService: int sendMessage(int,int,android.hardware.location.ContextHubMessage)>
<android.hardware.location.IContextHubService: android.hardware.location.NanoAppInstanceInfo getNanoAppInstanceInfo(int)>
<android.hardware.location.IContextHubService: android.hardware.location.IContextHubClient createClient(int,android.hardware.location.IContextHubClientCallback,java.lang.String,java.lang.String)>
<android.hardware.location.IContextHubService: java.util.List getContextHubs()>
<android.hardware.location.IContextHubService: int unloadNanoApp(int)>
<android.hardware.location.IContextHubService: void disableNanoApp(int,android.hardware.location.IContextHubTransactionCallback,long)>
<android.hardware.location.IContextHubService: android.hardware.location.IContextHubClient createPendingIntentClient(int,android.app.PendingIntent,long,java.lang.String)>
<android.hardware.location.IContextHubService: int[] getContextHubHandles()>
<android.hardware.location.IContextHubService: int loadNanoApp(int,android.hardware.location.NanoApp)>
<android.hardware.location.IContextHubService: void unloadNanoAppFromHub(int,android.hardware.location.IContextHubTransactionCallback,long)>
<android.app.ambientcontext.IAmbientContextManager: void unregisterObserver(java.lang.String)>
<android.app.ambientcontext.IAmbientContextManager: void registerObserverWithCallback(android.app.ambientcontext.AmbientContextEventRequest,java.lang.String,android.app.ambientcontext.IAmbientContextObserver)>
<android.app.ambientcontext.IAmbientContextManager: void registerObserver(android.app.ambientcontext.AmbientContextEventRequest,android.app.PendingIntent,android.os.RemoteCallback)>
<android.app.ambientcontext.IAmbientContextManager: void startConsentActivity(int[],java.lang.String)>
<android.app.ambientcontext.IAmbientContextManager: void queryServiceStatus(int[],java.lang.String,android.os.RemoteCallback)>
<com.samsung.android.camera.iris.IIrisServiceReceiver: void onIRImage(long,byte[],int,int)>
<com.samsung.android.camera.iris.IIrisServiceReceiver: void onError(long,int)>
<com.samsung.android.camera.iris.IIrisServiceReceiver: void onRemoved(long,int,int)>
<com.samsung.android.camera.iris.IIrisServiceReceiver: void onAcquired(long,int)>
<com.samsung.android.camera.iris.IIrisServiceReceiver: void onAuthenticationFailed(long)>
<com.samsung.android.camera.iris.IIrisServiceReceiver: void onAuthenticationSucceeded(long,com.samsung.android.camera.iris.Iris,byte[])>
<com.samsung.android.camera.iris.IIrisServiceReceiver: void onEnrollResult(long,int,int,int)>
<com.android.internal.view.IDragAndDropPermissions: void take(android.os.IBinder)>
<com.android.internal.view.IDragAndDropPermissions: void takeTransient()>
<com.android.internal.view.IDragAndDropPermissions: int getFlags()>
<com.android.internal.view.IDragAndDropPermissions: void release()>
<com.samsung.android.cocktailbar.ICocktailBarStateCallback: void onCocktailBarStateChanged(com.samsung.android.cocktailbar.CocktailBarStateInfo)>
<android.service.vr.IVrStateCallbacks: void onVrStateChanged(boolean)>
<android.app.IUidObserver: void onUidIdle(int,boolean)>
<android.app.IUidObserver: void onUidStateChanged(int,int,long,int)>
<android.app.IUidObserver: void onUidCachedChanged(int,boolean)>
<android.app.IUidObserver: void onUidActive(int)>
<android.app.IUidObserver: void onUidProcAdjChanged(int,int)>
<android.app.IUidObserver: void onUidGone(int,boolean)>
<com.samsung.android.ims.SemSimMobStatusListener: void onSimMobilityStateChanged(boolean)>
<android.os.IThermalEventListener: void notifyThrottling(android.os.Temperature)>
<android.net.INetworkRecommendationProvider: void requestScores(android.net.NetworkKey[])>
<com.samsung.android.cocktailbar.ICocktailBarShowCallback: void onShown(android.os.IBinder)>
<android.telephony.ims.aidl.IOptionsRequestCallback: void respondToCapabilityRequest(android.telephony.ims.RcsContactUceCapability,boolean)>
<android.telephony.ims.aidl.IOptionsRequestCallback: void respondToCapabilityRequestWithError(int,java.lang.String)>
<vendor.samsung.hardware.radio.sim.ISehRadioSimIndication: void simPhonebookReadyIndication(int)>
<vendor.samsung.hardware.radio.sim.ISehRadioSimIndication: void stkCallControlResultIndication(int,java.lang.String)>
<vendor.samsung.hardware.radio.sim.ISehRadioSimIndication: void stkSmsSendResultIndication(int,int)>
<vendor.samsung.hardware.radio.sim.ISehRadioSimIndication: void releaseCompleteMessageIndication(int,vendor.samsung.hardware.radio.sim.SehSsReleaseComplete)>
<vendor.samsung.hardware.radio.sim.ISehRadioSimIndication: int getInterfaceVersion()>
<vendor.samsung.hardware.radio.sim.ISehRadioSimIndication: java.lang.String getInterfaceHash()>
<vendor.samsung.hardware.radio.sim.ISehRadioSimIndication: void phonebookInitCompleteIndication(int)>
<vendor.samsung.hardware.radio.sim.ISehRadioSimIndication: void simCountMismatchedIndication(int,int)>
<vendor.samsung.hardware.radio.sim.ISehRadioSimIndication: void simSwapStateChangedIndication(int,int)>
<vendor.samsung.hardware.radio.sim.ISehRadioSimIndication: void sapNotify(int,byte[])>
<vendor.samsung.hardware.radio.sim.ISehRadioSimIndication: void simOnOffStateChangedNotify(int,int)>
<android.net.INetworkScoreService: boolean isCallerActiveScorer(int)>
<android.net.INetworkScoreService: java.util.List getAllValidScorers()>
<android.net.INetworkScoreService: boolean requestScores(android.net.NetworkKey[])>
<android.net.INetworkScoreService: java.lang.String getActiveScorerPackage()>
<android.net.INetworkScoreService: boolean setActiveScorer(java.lang.String)>
<android.net.INetworkScoreService: boolean updateScores(android.net.ScoredNetwork[])>
<android.net.INetworkScoreService: void unregisterNetworkScoreCache(int,android.net.INetworkScoreCache)>
<android.net.INetworkScoreService: boolean clearScores()>
<android.net.INetworkScoreService: android.net.NetworkScorerAppData getActiveScorer()>
<android.net.INetworkScoreService: void disableScoring()>
<android.net.INetworkScoreService: void registerNetworkScoreCache(int,android.net.INetworkScoreCache,int)>
<android.print.IPrinterDiscoveryObserver: void onPrintersAdded(android.content.pm.ParceledListSlice)>
<android.print.IPrinterDiscoveryObserver: void onPrintersRemoved(android.content.pm.ParceledListSlice)>
<com.samsung.android.media.IResourceManagerObserverClient: void notify(int,int,int,com.samsung.android.media.MediaResourceNotifyInfoParcel)>
<com.samsung.android.knox.dar.ddar.IDualDarAuthProgressCallback: void onInnerLayerUnlocked()>
<com.samsung.android.knox.dar.ddar.IDualDarAuthProgressCallback: void onInnerLayerUnlockFailed()>
<android.app.INotificationManager: void setOnNotificationPostedTrimFromListener(android.service.notification.INotificationListener,int)>
<android.app.INotificationManager: boolean isNotificationListenerAccessGrantedForUser(android.content.ComponentName,int)>
<android.app.INotificationManager: boolean isImportanceLocked(java.lang.String,int)>
<android.app.INotificationManager: boolean isSystemConditionProviderEnabled(java.lang.String)>
<android.app.INotificationManager: void setAppBypassDnd(java.lang.String,int,boolean)>
<android.app.INotificationManager: void enqueueTextToastForDex(java.lang.String,android.os.IBinder,java.lang.CharSequence,int,boolean,int,android.app.ITransientNotificationCallback,java.lang.String,int)>
<android.app.INotificationManager: android.content.pm.ParceledListSlice getNotificationChannelGroups(java.lang.String)>
<android.app.INotificationManager: void setReminderEnabled(int,boolean,java.util.List)>
<android.app.INotificationManager: boolean areBubblesEnabled(android.os.UserHandle)>
<android.app.INotificationManager: void removeEdgeNotification(java.lang.String,int,android.os.Bundle,int)>
<android.app.INotificationManager: void requestHintsFromListener(android.service.notification.INotificationListener,int)>
<android.app.INotificationManager: void createNotificationChannels(java.lang.String,android.content.pm.ParceledListSlice)>
<android.app.INotificationManager: void requestBindProvider(android.content.ComponentName)>
<android.app.INotificationManager: boolean hasSentValidBubble(java.lang.String,int)>
<android.app.INotificationManager: void registerListener(android.service.notification.INotificationListener,android.content.ComponentName,int)>
<android.app.INotificationManager: void setNotificationPolicyAccessGrantedForUser(java.lang.String,int,boolean)>
<android.app.INotificationManager: byte[] getBackupPayload(int)>
<android.app.INotificationManager: android.content.ComponentName getDefaultNotificationAssistant()>
<android.app.INotificationManager: boolean getPrivateNotificationsAllowed()>
<android.app.INotificationManager: boolean isSubDisplayNotificationAllowed(java.lang.String,int)>
<android.app.INotificationManager: void setNotificationPolicy(java.lang.String,android.app.NotificationManager$Policy)>
<android.app.INotificationManager: void clearRequestedListenerHints(android.service.notification.INotificationListener)>
<android.app.INotificationManager: int getHintsFromListenerNoToken()>
<android.app.INotificationManager: android.app.NotificationChannel getNotificationChannel(java.lang.String,int,java.lang.String,java.lang.String)>
<android.app.INotificationManager: void setNotificationPolicyAccessGranted(java.lang.String,boolean)>
<android.app.INotificationManager: void cancelNotificationsFromListener(android.service.notification.INotificationListener,java.lang.String[])>
<android.app.INotificationManager: void updateNotificationChannelForPackage(java.lang.String,int,android.app.NotificationChannel)>
<android.app.INotificationManager: boolean removeAutomaticZenRules(java.lang.String)>
<android.app.INotificationManager: android.app.NotificationManager$Policy getConsolidatedNotificationPolicy()>
<android.app.INotificationManager: void applyAdjustmentsFromAssistant(android.service.notification.INotificationListener,java.util.List)>
<android.app.INotificationManager: boolean removeWearableAppFromList(int,java.lang.String)>
<android.app.INotificationManager: boolean canNotifyAsPackage(java.lang.String,java.lang.String,int)>
<android.app.INotificationManager: int getPackageImportance(java.lang.String)>
<android.app.INotificationManager: void requestInterruptionFilterFromListener(android.service.notification.INotificationListener,int)>
<android.app.INotificationManager: int getBlockedAppCount(int)>
<android.app.INotificationManager: void cancelNotificationByGroupKey(java.lang.String,java.lang.String,int,int,java.lang.String,java.lang.String)>
<android.app.INotificationManager: void setAutomaticZenRuleState(java.lang.String,android.service.notification.Condition)>
<android.app.INotificationManager: void unregisterEdgeLightingListener(android.os.IBinder,java.lang.String)>
<android.app.INotificationManager: void enqueueNotificationWithTag(java.lang.String,java.lang.String,java.lang.String,int,android.app.Notification,int)>
<android.app.INotificationManager: boolean isPackageEnabled(java.lang.String,int)>
<android.app.INotificationManager: void createNotificationChannelsForPackage(java.lang.String,int,android.content.pm.ParceledListSlice)>
<android.app.INotificationManager: android.content.pm.ParceledListSlice getNotificationChannels(java.lang.String,java.lang.String,int)>
<android.app.INotificationManager: void cancelNotificationByEdge(java.lang.String,java.lang.String,int,int,java.lang.String)>
<android.app.INotificationManager: int getLockScreenNotificationVisibilityForPackage(java.lang.String,int)>
<android.app.INotificationManager: void updateCancelEvent(int,java.lang.String,boolean)>
<android.app.INotificationManager: void createConversationNotificationChannelForPackage(java.lang.String,int,android.app.NotificationChannel,java.lang.String)>
<android.app.INotificationManager: void migrateNotificationFilter(android.service.notification.INotificationListener,int,java.util.List)>
<android.app.INotificationManager: void cancelToast(java.lang.String,android.os.IBinder)>
<android.app.INotificationManager: void clearData(java.lang.String,int,boolean)>
<android.app.INotificationManager: boolean canAppBypassDnd(java.lang.String,int)>
<android.app.INotificationManager: java.lang.String getNotificationDelegate(java.lang.String)>
<android.app.INotificationManager: boolean hasSentValidMsg(java.lang.String,int)>
<android.app.INotificationManager: java.util.List getNotificationHistoryDataForPackage(java.lang.String,java.lang.String,int,java.lang.String,java.lang.String,int)>
<android.app.INotificationManager: void finishToken(java.lang.String,android.os.IBinder)>
<android.app.INotificationManager: java.util.List getWearableAppList(int)>
<android.app.INotificationManager: int getDeletedChannelCount(java.lang.String,int)>
<android.app.INotificationManager: int getNumNotificationChannelsForPackage(java.lang.String,int,boolean)>
<android.app.INotificationManager: int getRuleInstanceCount(android.content.ComponentName)>
<android.app.INotificationManager: void updateEdgeLightingPolicy(java.lang.String,com.samsung.android.edge.EdgeLightingPolicy)>
<android.app.INotificationManager: void setNotificationAlertsEnabledForPackage(java.lang.String,int,boolean)>
<android.app.INotificationManager: void applyRestore(byte[],int)>
<android.app.INotificationManager: void updateNotificationChannelGroupFromPrivilegedListener(android.service.notification.INotificationListener,java.lang.String,android.os.UserHandle,android.app.NotificationChannelGroup)>
<android.app.INotificationManager: void setNotificationAssistantAccessGrantedForUser(android.content.ComponentName,int,boolean)>
<android.app.INotificationManager: android.service.notification.ZenModeConfig getZenModeConfig()>
<android.app.INotificationManager: boolean isInCall(java.lang.String,int)>
<android.app.INotificationManager: void notifyConditions(java.lang.String,android.service.notification.IConditionProvider,android.service.notification.Condition[])>
<android.app.INotificationManager: void setNotificationListenerAccessGranted(android.content.ComponentName,boolean,boolean)>
<android.app.INotificationManager: boolean dispatchDelayedWakelockAndBlocked(int,java.lang.String,java.lang.String,int)>
<android.app.INotificationManager: boolean isEdgeLightingAllowed(java.lang.String,int)>
<android.app.INotificationManager: boolean isReminderEnabled(java.lang.String,int)>
<android.app.INotificationManager: void stopEdgeLighting(java.lang.String,android.os.IBinder)>
<android.app.INotificationManager: android.service.notification.StatusBarNotification[] getHistoricalNotificationsWithAttribution(java.lang.String,java.lang.String,int,boolean)>
<android.app.INotificationManager: boolean setWearableAppList(int,java.util.List)>
<android.app.INotificationManager: void deleteNotificationHistoryItem(java.lang.String,int,long)>
<android.app.INotificationManager: boolean isEdgeLightingNotificationAllowed(java.lang.String)>
<android.app.INotificationManager: void registerNotificationListener(android.content.ComponentName,int,boolean)>
<android.app.INotificationManager: android.content.ComponentName getAllowedNotificationAssistantForUser(int)>
<android.app.INotificationManager: java.util.List getEnabledNotificationListenerPackages()>
<android.app.INotificationManager: android.app.NotificationChannel getNotificationChannelForPackage(java.lang.String,int,java.lang.String,java.lang.String,boolean)>
<android.app.INotificationManager: void requestUnbindListener(android.service.notification.INotificationListener)>
<android.app.INotificationManager: boolean areNotificationsEnabledForPackage(java.lang.String,int)>
<android.app.INotificationManager: android.app.NotificationChannel getConversationNotificationChannel(java.lang.String,int,java.lang.String,java.lang.String,boolean,java.lang.String)>
<android.app.INotificationManager: void setToastRateLimitingEnabled(boolean)>
<android.app.INotificationManager: void setZenMode(int,android.net.Uri,java.lang.String)>
<android.app.INotificationManager: void snoozeNotificationUntilFromListener(android.service.notification.INotificationListener,java.lang.String,long)>
<android.app.INotificationManager: boolean removeAutomaticZenRule(java.lang.String)>
<android.app.INotificationManager: android.content.pm.ParceledListSlice getActiveNotificationsFromListener(android.service.notification.INotificationListener,java.lang.String[],int)>
<android.app.INotificationManager: void unregisterListener(android.service.notification.INotificationListener,int)>
<android.app.INotificationManager: boolean addWearableAppToList(int,java.lang.String)>
<android.app.INotificationManager: void requestUnbindProvider(android.service.notification.IConditionProvider)>
<android.app.INotificationManager: android.app.NotificationHistory getNotificationHistoryForPackage(java.lang.String,java.lang.String,int,java.lang.String,java.lang.String,int)>
<android.app.INotificationManager: android.app.NotificationHistory getNotificationHistory(java.lang.String,java.lang.String)>
<android.app.INotificationManager: void createNotificationChannelGroups(java.lang.String,android.content.pm.ParceledListSlice)>
<android.app.INotificationManager: boolean dispatchDelayedWakeUpAndBlocked(int,java.lang.String,java.lang.String)>
<android.app.INotificationManager: void cleanUpCallersAfter(long)>
<android.app.INotificationManager: void setNotificationsEnabledForPackage(java.lang.String,int,boolean)>
<android.app.INotificationManager: void cancelNotificationWithTag(java.lang.String,java.lang.String,java.lang.String,int,int)>
<android.app.INotificationManager: boolean shouldHideSilentStatusIcons(java.lang.String)>
<android.app.INotificationManager: android.app.NotificationChannelGroup getNotificationChannelGroup(java.lang.String,java.lang.String)>
<android.app.INotificationManager: void unbindEdgeLightingService(android.os.IBinder,java.lang.String)>
<android.app.INotificationManager: void setAllowEdgeLighting(java.lang.String,int,boolean)>
<android.app.INotificationManager: android.content.pm.ParceledListSlice getConversationsForPackage(java.lang.String,int)>
<android.app.INotificationManager: boolean isAlertsAllowed(java.lang.String,int,java.lang.String,int)>
<android.app.INotificationManager: int getZenMode()>
<android.app.INotificationManager: android.content.pm.ParceledListSlice getSnoozedNotificationsFromListener(android.service.notification.INotificationListener,int)>
<android.app.INotificationManager: android.app.NotificationChannelGroup getNotificationChannelGroupForPackage(java.lang.String,java.lang.String,int)>
<android.app.INotificationManager: void setInvalidMsgAppDemoted(java.lang.String,int,boolean)>
<android.app.INotificationManager: void bindEdgeLightingService(android.os.IBinder,int,android.content.ComponentName)>
<android.app.INotificationManager: android.content.pm.ParceledListSlice getNotificationChannelsBypassingDnd(java.lang.String,int)>
<android.app.INotificationManager: int getAllNotificationListenersCount()>
<android.app.INotificationManager: void unlockNotificationChannel(java.lang.String,int,java.lang.String)>
<android.app.INotificationManager: void disable(int,java.lang.String,android.os.IBinder)>
<android.app.INotificationManager: void unsnoozeNotificationFromAssistant(android.service.notification.INotificationListener,java.lang.String)>
<android.app.INotificationManager: void registerEdgeLightingListener(android.os.IBinder,android.content.ComponentName)>
<android.app.INotificationManager: void requestBindListener(android.content.ComponentName)>
<android.app.INotificationManager: void setAllowNotificationPopUpForPackage(java.lang.String,int,boolean)>
<android.app.INotificationManager: void setInterruptionFilter(java.lang.String,int)>
<android.app.INotificationManager: void setNotificationListenerAccessGrantedForUser(android.content.ComponentName,int,boolean,boolean)>
<android.app.INotificationManager: void updateNotificationChannelFromPrivilegedListener(android.service.notification.INotificationListener,java.lang.String,android.os.UserHandle,android.app.NotificationChannel)>
<android.app.INotificationManager: int getInterruptionFilterFromListener(android.service.notification.INotificationListener)>
<android.app.INotificationManager: void setNotificationsShownFromListener(android.service.notification.INotificationListener,java.lang.String[])>
<android.app.INotificationManager: void updateNotificationChannels(java.lang.String,android.content.pm.ParceledListSlice)>
<android.app.INotificationManager: android.content.pm.ParceledListSlice getNotificationChannelGroupsForPackage(java.lang.String,int,boolean)>
<android.app.INotificationManager: java.util.List getEnabledNotificationListeners(int)>
<android.app.INotificationManager: void startEdgeLighting(java.lang.String,com.samsung.android.edge.SemEdgeLightingInfo,android.os.IBinder)>
<android.app.INotificationManager: java.lang.String addAutomaticZenRule(android.app.AutomaticZenRule,java.lang.String)>
<android.app.INotificationManager: boolean areNotificationsEnabled(java.lang.String)>
<android.app.INotificationManager: boolean onlyHasDefaultChannel(java.lang.String,int)>
<android.app.INotificationManager: void setNotificationAssistantAccessGranted(android.content.ComponentName,boolean)>
<android.app.INotificationManager: android.content.pm.ParceledListSlice getNotificationChannelsFromPrivilegedListener(android.service.notification.INotificationListener,java.lang.String,android.os.UserHandle)>
<android.app.INotificationManager: void silenceNotificationSound()>
<android.app.INotificationManager: void unsnoozeNotificationFromSystemListener(android.service.notification.INotificationListener,java.lang.String)>
<android.app.INotificationManager: boolean updateAutomaticZenRule(java.lang.String,android.app.AutomaticZenRule)>
<android.app.INotificationManager: void cancelNotificationFromListener(android.service.notification.INotificationListener,java.lang.String,java.lang.String,int)>
<android.app.INotificationManager: void enqueueEdgeNotification(java.lang.String,java.lang.String,int,android.os.Bundle,int)>
<android.app.INotificationManager: android.content.pm.ParceledListSlice getNotificationChannelsForPackage(java.lang.String,int,boolean)>
<android.app.INotificationManager: void setNASMigrationDoneAndResetDefault(int,boolean)>
<android.app.INotificationManager: void cancelAllNotifications(java.lang.String,int)>
<android.app.INotificationManager: int getEdgeLightingState()>
<android.app.INotificationManager: void applyAdjustmentFromAssistant(android.service.notification.INotificationListener,android.service.notification.Adjustment)>
<android.app.INotificationManager: void updateNotificationChannelGroupForPackage(java.lang.String,int,android.app.NotificationChannelGroup)>
<android.app.INotificationManager: boolean areChannelsBypassingDnd()>
<android.app.INotificationManager: void deleteNotificationChannel(java.lang.String,java.lang.String)>
<android.app.INotificationManager: void enqueueTextToast(java.lang.String,android.os.IBinder,java.lang.CharSequence,int,boolean,int,android.app.ITransientNotificationCallback)>
<android.app.INotificationManager: android.service.notification.NotificationListenerFilter getListenerFilter(android.content.ComponentName,int)>
<android.app.INotificationManager: void applyEnqueuedAdjustmentFromAssistant(android.service.notification.INotificationListener,android.service.notification.Adjustment)>
<android.app.INotificationManager: android.app.NotificationChannelGroup getPopulatedNotificationChannelGroupForPackage(java.lang.String,int,java.lang.String,boolean)>
<android.app.INotificationManager: void setListenerFilter(android.content.ComponentName,int,android.service.notification.NotificationListenerFilter)>
<android.app.INotificationManager: android.content.pm.ParceledListSlice getAppActiveNotifications(java.lang.String,int)>
<android.app.INotificationManager: boolean isInInvalidMsgState(java.lang.String,int)>
<android.app.INotificationManager: boolean areBubblesAllowed(java.lang.String)>
<android.app.INotificationManager: void setNotificationsEnabledWithImportanceLockForPackage(java.lang.String,int,boolean)>
<android.app.INotificationManager: java.util.List getZenRules()>
<android.app.INotificationManager: boolean getNotificationAlertsEnabledForPackage(java.lang.String,int)>
<android.app.INotificationManager: void setAllowSubDisplayNotification(java.lang.String,int,boolean)>
<android.app.INotificationManager: boolean isPackagePaused(java.lang.String)>
<android.app.INotificationManager: void setReminderEnabledForPackage(java.lang.String,int,boolean)>
<android.app.INotificationManager: boolean matchesCallFilter(android.os.Bundle)>
<android.app.INotificationManager: void setRestoreBlockListForSS(java.util.List)>
<android.app.INotificationManager: void updateEdgeLightingPackageList(java.lang.String,java.util.List)>
<android.app.INotificationManager: boolean isNotificationAssistantAccessGranted(android.content.ComponentName)>
<android.app.INotificationManager: void requestUnbindListenerComponent(android.content.ComponentName)>
<android.app.INotificationManager: void resetDefaultAllowEdgeLighting()>
<android.app.INotificationManager: android.content.ComponentName getEffectsSuppressor()>
<android.app.INotificationManager: void setPrivateNotificationsAllowed(boolean)>
<android.app.INotificationManager: boolean isNotificationListenerAccessGranted(android.content.ComponentName)>
<android.app.INotificationManager: void enqueueToast(java.lang.String,android.os.IBinder,android.app.ITransientNotification,int,boolean,int)>
<android.app.INotificationManager: int getBlockedChannelCount(java.lang.String,int)>
<android.app.INotificationManager: int getAppsBypassingDndCount(int)>
<android.app.INotificationManager: void deleteNotificationChannelGroup(java.lang.String,java.lang.String)>
<android.app.INotificationManager: void setShowBadge(java.lang.String,int,boolean)>
<android.app.INotificationManager: android.content.ComponentName getAllowedNotificationAssistant()>
<android.app.INotificationManager: android.content.pm.ParceledListSlice getNotificationChannelGroupsFromPrivilegedListener(android.service.notification.INotificationListener,java.lang.String,android.os.UserHandle)>
<android.app.INotificationManager: void snoozeNotificationUntilContextFromListener(android.service.notification.INotificationListener,java.lang.String,java.lang.String)>
<android.app.INotificationManager: int getBubblePreferenceForPackage(java.lang.String,int)>
<android.app.INotificationManager: void disableEdgeLightingNotification(java.lang.String,boolean)>
<android.app.INotificationManager: android.content.pm.ParceledListSlice getConversations(boolean)>
<android.app.INotificationManager: android.service.notification.StatusBarNotification[] getActiveNotificationsWithAttribution(java.lang.String,java.lang.String)>
<android.app.INotificationManager: boolean hasUserDemotedInvalidMsgApp(java.lang.String,int)>
<android.app.INotificationManager: java.util.List getAllowedAssistantAdjustments(java.lang.String)>
<android.app.INotificationManager: boolean isNotificationPolicyAccessGrantedForPackage(java.lang.String)>
<android.app.INotificationManager: boolean isPermissionFixed(java.lang.String,int)>
<android.app.INotificationManager: boolean canUseFullScreenIntent(android.content.AttributionSource)>
<android.app.INotificationManager: android.app.NotificationManager$Policy getNotificationPolicy(java.lang.String)>
<android.app.INotificationManager: void setLockScreenNotificationVisibilityForPackage(java.lang.String,int,int)>
<android.app.INotificationManager: int getHintsFromListener(android.service.notification.INotificationListener)>
<android.app.INotificationManager: void addReplyHistory(int,java.lang.String,java.lang.String,int,java.lang.String,java.lang.String)>
<android.app.INotificationManager: boolean requestListenerHintsForWearable(int)>
<android.app.INotificationManager: boolean canShowBadge(java.lang.String,int)>
<android.app.INotificationManager: void setHideSilentStatusIcons(boolean)>
<android.app.INotificationManager: android.service.notification.StatusBarNotification[] getHistoricalNotifications(java.lang.String,int,boolean)>
<android.app.INotificationManager: void setNotificationDelegate(java.lang.String,java.lang.String)>
<android.app.INotificationManager: void enqueueToastForDex(java.lang.String,android.os.IBinder,android.app.ITransientNotification,int,boolean,int,java.lang.String,int)>
<android.app.INotificationManager: android.service.notification.StatusBarNotification[] getActiveNotifications(java.lang.String)>
<android.app.INotificationManager: void unlockAllNotificationChannels()>
<android.app.INotificationManager: android.app.AutomaticZenRule getAutomaticZenRule(java.lang.String)>
<android.app.INotificationManager: long pullStats(long,int,boolean,java.util.List)>
<android.app.INotificationManager: boolean hasEnabledNotificationListener(java.lang.String,int)>
<android.app.INotificationManager: void setBubblesAllowed(java.lang.String,int,int)>
<android.app.INotificationManager: boolean isAllowNotificationPopUpForPackage(java.lang.String,int)>
<android.app.INotificationManager: boolean isNotificationPolicyAccessGranted(java.lang.String)>
<android.hardware.camera2.extension.IImageProcessorImpl: void onNextImageAvailable(android.hardware.camera2.extension.OutputConfigId,android.hardware.camera2.extension.ParcelImage,java.lang.String)>
<com.sec.android.sdhms.ISamsungDeviceHealthManager: int getTemperature(int)>
<com.sec.android.sdhms.ISamsungDeviceHealthManager: boolean setThermalControlFlag(int)>
<com.sec.android.sdhms.ISamsungDeviceHealthManager: int getThermalThrottlingDelta()>
<com.sec.android.sdhms.ISamsungDeviceHealthManager: boolean setThermalThrottlingDelta(int)>
<com.sec.android.sdhms.ISamsungDeviceHealthManager: int getRemainingUsageTime(int)>
<com.sec.android.sdhms.ISamsungDeviceHealthManager: void destroyGameSdkMaxlock()>
<com.sec.android.sdhms.ISamsungDeviceHealthManager: boolean addLowModeApps(java.util.List)>
<com.sec.android.sdhms.ISamsungDeviceHealthManager: void logAction(java.lang.String,int,java.util.List)>
<com.sec.android.sdhms.ISamsungDeviceHealthManager: boolean setThermalThrottlingDeltaWithPackageName(java.lang.String,int)>
<com.sec.android.sdhms.ISamsungDeviceHealthManager: java.util.List getCoolingDevices()>
<com.sec.android.sdhms.ISamsungDeviceHealthManager: boolean isDownLoadingForUid(int)>
<com.sec.android.sdhms.ISamsungDeviceHealthManager: int getRemainingUsageTimeWithSettings(int,int)>
<com.sec.android.sdhms.ISamsungDeviceHealthManager: int getSupportedThermalThrottlingDelta()>
<com.sec.android.sdhms.ISamsungDeviceHealthManager: java.util.List getProcessUsageStats(long,long)>
<com.sec.android.sdhms.ISamsungDeviceHealthManager: void logActionWithSource(java.lang.String,int,int)>
<com.sec.android.sdhms.ISamsungDeviceHealthManager: void updateGameSdkOperation(boolean,android.os.IBinder)>
<com.sec.android.sdhms.ISamsungDeviceHealthManager: int getThermalControlFlag()>
<com.sec.android.sdhms.ISamsungDeviceHealthManager: java.util.List getLowModeApps()>
<com.sec.android.sdhms.ISamsungDeviceHealthManager: java.util.List getTemperatures()>
<com.sec.android.sdhms.ISamsungDeviceHealthManager: boolean addHeavyLoadApps(java.util.List)>
<com.sec.android.sdhms.ISamsungDeviceHealthManager: java.util.List getBatteryEventHistory(long,long,int)>
<com.sec.android.sdhms.ISamsungDeviceHealthManager: int getSupportedHistoryTypes()>
<com.sec.android.sdhms.ISamsungDeviceHealthManager: void initializeSiopScenario(android.os.Bundle,android.os.IBinder)>
<com.sec.android.sdhms.ISamsungDeviceHealthManager: boolean addLowRefreshRateApps(java.util.List)>
<com.sec.android.sdhms.ISamsungDeviceHealthManager: java.lang.String getActiveSensorList()>
<com.sec.android.sdhms.ISamsungDeviceHealthManager: int getRUT(int,java.lang.String)>
<com.sec.android.sdhms.ISamsungDeviceHealthManager: java.util.List getThermalStats(long,long)>
<com.sec.android.sdhms.ISamsungDeviceHealthManager: int getSsrmStatus(int)>
<com.sec.android.sdhms.ISamsungDeviceHealthManager: java.util.List getHeavyLoadApps()>
<com.sec.android.sdhms.ISamsungDeviceHealthManager: void registerCallback(android.os.IThermalEventListener)>
<com.sec.android.sdhms.ISamsungDeviceHealthManager: void acquireSiop(java.lang.String)>
<com.sec.android.sdhms.ISamsungDeviceHealthManager: int[] getAllTemperatures(int)>
<com.sec.android.sdhms.ISamsungDeviceHealthManager: void releaseGameSdkMaxlock()>
<com.sec.android.sdhms.ISamsungDeviceHealthManager: void initGameSdkMaxlock(android.os.IBinder,android.os.IBinder)>
<com.sec.android.sdhms.ISamsungDeviceHealthManager: java.util.List getBatteryStats(int,long,long,boolean)>
<com.sec.android.sdhms.ISamsungDeviceHealthManager: java.util.List getNetworkUsageStats(long,long)>
<com.sec.android.sdhms.ISamsungDeviceHealthManager: float[] supportVRTemperaturesInformation(java.lang.String,int,int)>
<com.sec.android.sdhms.ISamsungDeviceHealthManager: boolean isGameSupportLRP()>
<com.sec.android.sdhms.ISamsungDeviceHealthManager: void logActionWithPkg(java.lang.String,int,java.lang.String,java.util.List)>
<com.sec.android.sdhms.ISamsungDeviceHealthManager: void terminateSiopScenario(java.lang.String)>
<com.sec.android.sdhms.ISamsungDeviceHealthManager: java.util.List getLowRefreshRateApps()>
<com.sec.android.sdhms.ISamsungDeviceHealthManager: void logAnomaly(android.os.Bundle)>
<com.sec.android.sdhms.ISamsungDeviceHealthManager: void acquireGameSdkMaxlock(int,int)>
<com.sec.android.sdhms.ISamsungDeviceHealthManager: void sendCommand(java.lang.String,java.lang.String)>
<com.sec.android.sdhms.ISamsungDeviceHealthManager: boolean setAnomalyConfig(android.app.PendingIntent)>
<com.sec.android.sdhms.ISamsungDeviceHealthManager: java.util.List getOverheatReason(long,long)>
<com.sec.android.sdhms.ISamsungDeviceHealthManager: void releaseSiop(java.lang.String)>
<com.sec.android.sdhms.ISamsungDeviceHealthManager: android.os.Bundle getGameSiopInfo()>
<com.sec.android.sdhms.ISamsungDeviceHealthManager: void updateSpaOperation(boolean,android.os.IBinder)>
<com.sec.android.sdhms.ISamsungDeviceHealthManager: int getLRTemperature()>
<android.media.soundtrigger_middleware.ISoundTriggerCallback: void onRecognition(int,android.media.soundtrigger_middleware.RecognitionEventSys,int)>
<android.media.soundtrigger_middleware.ISoundTriggerCallback: void onModuleDied()>
<android.media.soundtrigger_middleware.ISoundTriggerCallback: void onModelUnloaded(int)>
<android.media.soundtrigger_middleware.ISoundTriggerCallback: void onPhraseRecognition(int,android.media.soundtrigger_middleware.PhraseRecognitionEventSys,int)>
<android.media.soundtrigger_middleware.ISoundTriggerCallback: void onResourcesAvailable()>
<android.service.quickaccesswallet.IQuickAccessWalletServiceCallbacks: void onGetWalletCardsFailure(android.service.quickaccesswallet.GetWalletCardsError)>
<android.service.quickaccesswallet.IQuickAccessWalletServiceCallbacks: void onGetWalletCardsSuccess(android.service.quickaccesswallet.GetWalletCardsResponse)>
<android.service.quickaccesswallet.IQuickAccessWalletServiceCallbacks: void onTargetActivityPendingIntentReceived(android.app.PendingIntent)>
<android.service.quickaccesswallet.IQuickAccessWalletServiceCallbacks: void onWalletServiceEvent(android.service.quickaccesswallet.WalletServiceEvent)>
<android.service.attention.IAttentionCallback: void onSuccess(int,long)>
<android.service.attention.IAttentionCallback: void onFailure(int)>
<android.telephony.mbms.IMbmsDownloadSessionCallback: void onFileServicesUpdated(java.util.List)>
<android.telephony.mbms.IMbmsDownloadSessionCallback: void onError(int,java.lang.String)>
<android.telephony.mbms.IMbmsDownloadSessionCallback: void onMiddlewareReady()>
<android.app.backup.ISelectBackupTransportCallback: void onFailure(int)>
<android.app.backup.ISelectBackupTransportCallback: void onSuccess(java.lang.String)>
<android.telephony.IBootstrapAuthenticationCallback: void onAuthenticationFailure(int,int)>
<android.telephony.IBootstrapAuthenticationCallback: void onKeysAvailable(int,byte[],java.lang.String)>
<android.print.IPrintDocumentAdapter: void finish()>
<android.print.IPrintDocumentAdapter: void layout(android.print.PrintAttributes,android.print.PrintAttributes,android.print.ILayoutResultCallback,android.os.Bundle,int)>
<android.print.IPrintDocumentAdapter: void kill(java.lang.String)>
<android.print.IPrintDocumentAdapter: void start()>
<android.print.IPrintDocumentAdapter: void setObserver(android.print.IPrintDocumentAdapterObserver)>
<android.print.IPrintDocumentAdapter: void write(android.print.PageRange[],android.os.ParcelFileDescriptor,android.print.IWriteResultCallback,int)>
<com.samsung.android.cover.ICoverManagerCallback: java.lang.String getListenerInfo()>
<com.samsung.android.cover.ICoverManagerCallback: void coverCallback(com.samsung.android.cover.CoverState)>
<android.media.IRemoteDisplayCallback: void onStateChanged(android.media.RemoteDisplayState)>
<android.os.IZtdListener: void onSysDataTraced(int,int,java.lang.String[])>
<android.os.IZtdListener: void onUnauthorizedAccessDetected(int,int,int,long,int,int,java.lang.String,java.lang.String)>
<android.telephony.ims.aidl.IImsMmTelFeature: void sendDtmfEvent(int,java.lang.String)>
<android.telephony.ims.aidl.IImsMmTelFeature: void notifySrvccCanceled()>
<android.telephony.ims.aidl.IImsMmTelFeature: void acknowledgeSms(int,int,int)>
<android.telephony.ims.aidl.IImsMmTelFeature: void addCapabilityCallback(android.telephony.ims.aidl.IImsCapabilityCallback)>
<android.telephony.ims.aidl.IImsMmTelFeature: void setMediaQualityThreshold(int,android.telephony.ims.MediaThreshold)>
<android.telephony.ims.aidl.IImsMmTelFeature: void notifyEpsFallbackResult(int,int)>
<android.telephony.ims.aidl.IImsMmTelFeature: void notifySrvccStarted(android.telephony.ims.aidl.ISrvccStartedCallback)>
<android.telephony.ims.aidl.IImsMmTelFeature: void changeCapabilitiesConfiguration(android.telephony.ims.feature.CapabilityChangeRequest,android.telephony.ims.aidl.IImsCapabilityCallback)>
<android.telephony.ims.aidl.IImsMmTelFeature: android.telephony.ims.MediaQualityStatus queryMediaQualityStatus(int)>
<android.telephony.ims.aidl.IImsMmTelFeature: void setSmsListener(android.telephony.ims.aidl.IImsSmsListener)>
<android.telephony.ims.aidl.IImsMmTelFeature: void sendSms(int,int,java.lang.String,java.lang.String,boolean,byte[])>
<android.telephony.ims.aidl.IImsMmTelFeature: void triggerAutoConfigurationForApp(int)>
<android.telephony.ims.aidl.IImsMmTelFeature: com.android.ims.internal.IImsEcbm getEcbmInterface()>
<android.telephony.ims.aidl.IImsMmTelFeature: void setTerminalBasedCallWaitingStatus(boolean)>
<android.telephony.ims.aidl.IImsMmTelFeature: void setTtyMode(int)>
<android.telephony.ims.aidl.IImsMmTelFeature: boolean isCmcEmergencyCallSupported(int)>
<android.telephony.ims.aidl.IImsMmTelFeature: void setVideoCrtAudio(int,boolean)>
<android.telephony.ims.aidl.IImsMmTelFeature: int shouldProcessCall(java.lang.String[])>
<android.telephony.ims.aidl.IImsMmTelFeature: void setUiTtyMode(int,android.os.Message)>
<android.telephony.ims.aidl.IImsMmTelFeature: void onSmsReady()>
<android.telephony.ims.aidl.IImsMmTelFeature: android.telephony.ims.ImsCallProfile createCallProfile(int,int)>
<android.telephony.ims.aidl.IImsMmTelFeature: void sendPublishDialog(int,com.android.internal.telephony.PublishDialog)>
<android.telephony.ims.aidl.IImsMmTelFeature: int getFeatureState()>
<android.telephony.ims.aidl.IImsMmTelFeature: int getInitialCallNetworkType(int)>
<android.telephony.ims.aidl.IImsMmTelFeature: void notifySrvccFailed()>
<android.telephony.ims.aidl.IImsMmTelFeature: java.lang.String getSmsFormat()>
<android.telephony.ims.aidl.IImsMmTelFeature: void queryCapabilityConfiguration(int,int,android.telephony.ims.aidl.IImsCapabilityCallback)>
<android.telephony.ims.aidl.IImsMmTelFeature: void setSmsc(java.lang.String)>
<android.telephony.ims.aidl.IImsMmTelFeature: void setListener(android.telephony.ims.aidl.IImsMmTelListener)>
<android.telephony.ims.aidl.IImsMmTelFeature: com.android.ims.internal.IImsCallSession createCallSession(android.telephony.ims.ImsCallProfile)>
<android.telephony.ims.aidl.IImsMmTelFeature: void initImsSmsImplAdapter()>
<android.telephony.ims.aidl.IImsMmTelFeature: com.android.ims.internal.IImsMultiEndpoint getMultiEndpointInterface()>
<android.telephony.ims.aidl.IImsMmTelFeature: int stopLocalRingBackTone()>
<android.telephony.ims.aidl.IImsMmTelFeature: int queryCapabilityStatus()>
<android.telephony.ims.aidl.IImsMmTelFeature: void setRetryCount(int,int)>
<android.telephony.ims.aidl.IImsMmTelFeature: void changeAudioPath(int,int)>
<android.telephony.ims.aidl.IImsMmTelFeature: java.lang.String getTrn(java.lang.String,java.lang.String)>
<android.telephony.ims.aidl.IImsMmTelFeature: int startLocalRingBackTone(int,int,int)>
<android.telephony.ims.aidl.IImsMmTelFeature: void acknowledgeSmsWithPdu(int,int,int,byte[])>
<android.telephony.ims.aidl.IImsMmTelFeature: void removeCapabilityCallback(android.telephony.ims.aidl.IImsCapabilityCallback)>
<android.telephony.ims.aidl.IImsMmTelFeature: void acknowledgeSmsReport(int,int,int)>
<android.telephony.ims.aidl.IImsMmTelFeature: com.android.ims.internal.IImsUt getUtInterface()>
<android.telephony.ims.aidl.IImsMmTelFeature: void notifySrvccCompleted()>
<android.telephony.ims.aidl.IImsMmTelFeature: void changeOfferedRtpHeaderExtensionTypes(java.util.List)>
<android.telephony.ims.aidl.IImsMmTelFeature: void onMemoryAvailable(int)>
<android.media.projection.IMediaProjectionWatcherCallback: void onStart(android.media.projection.MediaProjectionInfo)>
<android.media.projection.IMediaProjectionWatcherCallback: void onStop(android.media.projection.MediaProjectionInfo)>
<android.nfc.INfcAdapterExtras: void authenticate(java.lang.String,byte[])>
<android.nfc.INfcAdapterExtras: android.os.Bundle getAtr(java.lang.String)>
<android.nfc.INfcAdapterExtras: android.os.Bundle close(java.lang.String,android.os.IBinder)>
<android.nfc.INfcAdapterExtras: java.lang.String getDriverName(java.lang.String)>
<android.nfc.INfcAdapterExtras: android.os.Bundle getAtrWithPackageName(java.lang.String,java.lang.String)>
<android.nfc.INfcAdapterExtras: android.os.Bundle transceiveWithPackageName(java.lang.String,byte[],java.lang.String)>
<android.nfc.INfcAdapterExtras: android.os.Bundle open(java.lang.String,android.os.IBinder)>
<android.nfc.INfcAdapterExtras: android.os.Bundle openWithPackageName(java.lang.String,android.os.IBinder,java.lang.String)>
<android.nfc.INfcAdapterExtras: android.os.Bundle transceive(java.lang.String,byte[])>
<android.nfc.INfcAdapterExtras: android.os.Bundle closeWithPackageName(java.lang.String,android.os.IBinder,java.lang.String)>
<android.nfc.INfcAdapterExtras: void setCardEmulationRoute(java.lang.String,int)>
<android.nfc.INfcAdapterExtras: int getCardEmulationRoute(java.lang.String)>
<android.print.IPrintServicesChangeListener: void onPrintServicesChanged()>
<android.view.IDisplayChangeWindowCallback: void continueDisplayChange(android.window.WindowContainerTransaction)>
<com.samsung.android.service.sats.ISatsService: java.lang.String executePseudoDrkAtCommnd(java.lang.String)>
<android.service.voice.IMicrophoneHotwordDetectionVoiceInteractionCallback: void onHotwordDetectionServiceFailure(android.service.voice.HotwordDetectionServiceFailure)>
<android.service.voice.IMicrophoneHotwordDetectionVoiceInteractionCallback: void onRejected(android.service.voice.HotwordRejectedResult)>
<android.service.voice.IMicrophoneHotwordDetectionVoiceInteractionCallback: void onDetected(android.service.voice.HotwordDetectedResult,android.media.AudioFormat,android.os.ParcelFileDescriptor)>
<com.samsung.android.chimera.IChimera: java.util.List getAvailableMemInfo(long,long)>
<android.gsi.IGsiServiceCallback: void onResult(int)>
<android.content.pm.IPackageDeleteObserver2: void onUserActionRequired(android.content.Intent)>
<android.content.pm.IPackageDeleteObserver2: void onPackageDeleted(java.lang.String,int,java.lang.String)>
<com.android.ims.internal.IImsUt: int updateCOLP(boolean)>
<com.android.ims.internal.IImsUt: void close()>
<com.android.ims.internal.IImsUt: void setListener(com.android.ims.internal.IImsUtListener)>
<com.android.ims.internal.IImsUt: int queryCallBarring(int)>
<com.android.ims.internal.IImsUt: int updateCallForward(int,int,java.lang.String,int,int)>
<com.android.ims.internal.IImsUt: int queryCLIR()>
<com.android.ims.internal.IImsUt: int queryCallForward(int,java.lang.String)>
<com.android.ims.internal.IImsUt: int queryCallWaiting()>
<com.android.ims.internal.IImsUt: boolean isUssdEnabled()>
<com.android.ims.internal.IImsUt: int updateCallWaiting(boolean,int)>
<com.android.ims.internal.IImsUt: int updateCLIP(boolean)>
<com.android.ims.internal.IImsUt: int transact(android.os.Bundle)>
<com.android.ims.internal.IImsUt: int updateCallBarringWithPassword(int,int,java.lang.String[],int,java.lang.String)>
<com.android.ims.internal.IImsUt: int queryCOLR()>
<com.android.ims.internal.IImsUt: int queryCLIP()>
<com.android.ims.internal.IImsUt: int queryCOLP()>
<com.android.ims.internal.IImsUt: int updateCallBarring(int,int,java.lang.String[])>
<com.android.ims.internal.IImsUt: int queryCallBarringForServiceClass(int,int)>
<com.android.ims.internal.IImsUt: int updateCLIR(int)>
<com.android.ims.internal.IImsUt: int updateCOLR(int)>
<com.android.ims.internal.IImsUt: int updateCallBarringForServiceClass(int,int,java.lang.String[],int)>
<android.system.keystore2.IKeystoreOperation: int getInterfaceVersion()>
<android.system.keystore2.IKeystoreOperation: void updateAad(byte[])>
<android.system.keystore2.IKeystoreOperation: byte[] finish(byte[],byte[])>
<android.system.keystore2.IKeystoreOperation: byte[] update(byte[])>
<android.system.keystore2.IKeystoreOperation: void abort()>
<android.system.keystore2.IKeystoreOperation: java.lang.String getInterfaceHash()>
<android.hardware.radio.voice.IRadioVoice: void separateConnection(int,int)>
<android.hardware.radio.voice.IRadioVoice: void getCallWaiting(int,int)>
<android.hardware.radio.voice.IRadioVoice: void getMute(int)>
<android.hardware.radio.voice.IRadioVoice: void setClir(int,int)>
<android.hardware.radio.voice.IRadioVoice: void stopDtmf(int)>
<android.hardware.radio.voice.IRadioVoice: void setCallForward(int,android.hardware.radio.voice.CallForwardInfo)>
<android.hardware.radio.voice.IRadioVoice: java.lang.String getInterfaceHash()>
<android.hardware.radio.voice.IRadioVoice: void setMute(int,boolean)>
<android.hardware.radio.voice.IRadioVoice: void setCallWaiting(int,boolean,int)>
<android.hardware.radio.voice.IRadioVoice: void hangup(int,int)>
<android.hardware.radio.voice.IRadioVoice: void hangupWaitingOrBackground(int)>
<android.hardware.radio.voice.IRadioVoice: void setPreferredVoicePrivacy(int,boolean)>
<android.hardware.radio.voice.IRadioVoice: void handleStkCallSetupRequestFromSim(int,boolean)>
<android.hardware.radio.voice.IRadioVoice: void getCallForwardStatus(int,android.hardware.radio.voice.CallForwardInfo)>
<android.hardware.radio.voice.IRadioVoice: void startDtmf(int,java.lang.String)>
<android.hardware.radio.voice.IRadioVoice: void dial(int,android.hardware.radio.voice.Dial)>
<android.hardware.radio.voice.IRadioVoice: int getInterfaceVersion()>
<android.hardware.radio.voice.IRadioVoice: void rejectCall(int)>
<android.hardware.radio.voice.IRadioVoice: void sendCdmaFeatureCode(int,java.lang.String)>
<android.hardware.radio.voice.IRadioVoice: void emergencyDial(int,android.hardware.radio.voice.Dial,int,java.lang.String[],int,boolean,boolean)>
<android.hardware.radio.voice.IRadioVoice: void cancelPendingUssd(int)>
<android.hardware.radio.voice.IRadioVoice: void isVoNrEnabled(int)>
<android.hardware.radio.voice.IRadioVoice: void setTtyMode(int,int)>
<android.hardware.radio.voice.IRadioVoice: void getTtyMode(int)>
<android.hardware.radio.voice.IRadioVoice: void setVoNrEnabled(int,boolean)>
<android.hardware.radio.voice.IRadioVoice: void sendDtmf(int,java.lang.String)>
<android.hardware.radio.voice.IRadioVoice: void sendUssd(int,java.lang.String)>
<android.hardware.radio.voice.IRadioVoice: void setResponseFunctions(android.hardware.radio.voice.IRadioVoiceResponse,android.hardware.radio.voice.IRadioVoiceIndication)>
<android.hardware.radio.voice.IRadioVoice: void switchWaitingOrHoldingAndActive(int)>
<android.hardware.radio.voice.IRadioVoice: void hangupForegroundResumeBackground(int)>
<android.hardware.radio.voice.IRadioVoice: void getLastCallFailCause(int)>
<android.hardware.radio.voice.IRadioVoice: void conference(int)>
<android.hardware.radio.voice.IRadioVoice: void getPreferredVoicePrivacy(int)>
<android.hardware.radio.voice.IRadioVoice: void sendBurstDtmf(int,java.lang.String,int,int)>
<android.hardware.radio.voice.IRadioVoice: void getClip(int)>
<android.hardware.radio.voice.IRadioVoice: void exitEmergencyCallbackMode(int)>
<android.hardware.radio.voice.IRadioVoice: void getClir(int)>
<android.hardware.radio.voice.IRadioVoice: void responseAcknowledgement()>
<android.hardware.radio.voice.IRadioVoice: void getCurrentCalls(int)>
<android.hardware.radio.voice.IRadioVoice: void explicitCallTransfer(int)>
<android.hardware.radio.voice.IRadioVoice: void acceptCall(int)>
<android.os.IStoraged: int getRecentPerf()>
<android.os.IStoraged: void onUserStopped(int)>
<android.os.IStoraged: void onUserStarted(int)>
<android.hardware.usb.IUsbOperationInternal: void onOperationComplete(int)>
<com.samsung.android.knox.dar.IDarManagerService: int getAvailableUserId()>
<com.samsung.android.knox.dar.IDarManagerService: int getMainUserId(int)>
<com.samsung.android.knox.dar.IDarManagerService: boolean setDualDarInfo(int,int)>
<com.samsung.android.knox.dar.IDarManagerService: java.util.List getPackageListForDualDarPolicy(java.lang.String)>
<com.samsung.android.knox.dar.IDarManagerService: int startTracing(int,int,android.os.Bundle,com.samsung.android.knox.zt.devicetrust.IEndpointMonitorListener)>
<com.samsung.android.knox.dar.IDarManagerService: int getInnerAuthUserId(int)>
<com.samsung.android.knox.dar.IDarManagerService: boolean isSensitive(java.lang.String)>
<com.samsung.android.knox.dar.IDarManagerService: boolean resetPasswordWithToken(java.lang.String,byte[],int)>
<com.samsung.android.knox.dar.IDarManagerService: int getPasswordMinimumLengthForInner()>
<com.samsung.android.knox.dar.IDarManagerService: void registerClient(int,com.samsung.android.knox.dar.sdp.ISdpListener)>
<com.samsung.android.knox.dar.IDarManagerService: boolean isDefaultPathUser(int)>
<com.samsung.android.knox.dar.IDarManagerService: double getSupportedSDKVersion()>
<com.samsung.android.knox.dar.IDarManagerService: void startMonitoringFiles(int,int[],java.util.List,java.util.List,android.os.IZtdListener)>
<com.samsung.android.knox.dar.IDarManagerService: boolean isKnoxKeyInstallable()>
<com.samsung.android.knox.dar.IDarManagerService: int isLicensed()>
<com.samsung.android.knox.dar.IDarManagerService: int exists(java.lang.String)>
<com.samsung.android.knox.dar.IDarManagerService: int unregisterListener(java.lang.String,com.samsung.android.knox.dar.sdp.ISdpListener)>
<com.samsung.android.knox.dar.IDarManagerService: void systemReady()>
<com.samsung.android.knox.dar.IDarManagerService: boolean setSensitive(int,java.lang.String)>
<com.samsung.android.knox.dar.IDarManagerService: boolean setResetPasswordToken(byte[],int)>
<com.samsung.android.knox.dar.IDarManagerService: void stopMonitoringFiles(int)>
<com.samsung.android.knox.dar.IDarManagerService: int removeEngine(java.lang.String)>
<com.samsung.android.knox.dar.IDarManagerService: int createEncPkgDir(int,java.lang.String)>
<com.samsung.android.knox.dar.IDarManagerService: int disallow(java.lang.String,java.lang.String)>
<com.samsung.android.knox.dar.IDarManagerService: boolean isInnerAuthRequired(int)>
<com.samsung.android.knox.dar.IDarManagerService: java.util.List getBlockedClearablePackages(int)>
<com.samsung.android.knox.dar.IDarManagerService: int migrate(java.lang.String)>
<com.samsung.android.knox.dar.IDarManagerService: int addEngine(com.samsung.android.knox.sdp.core.SdpCreationParam,java.lang.String,java.lang.String)>
<com.samsung.android.knox.dar.IDarManagerService: void onDeviceOwnerLocked(int)>
<com.samsung.android.knox.dar.IDarManagerService: int lock(java.lang.String)>
<com.samsung.android.knox.dar.IDarManagerService: boolean isSdpSupportedSecureFolder(int)>
<com.samsung.android.knox.dar.IDarManagerService: void onBiometricsAuthenticated(int)>
<com.samsung.android.knox.dar.IDarManagerService: void unregisterClient(int,com.samsung.android.knox.dar.sdp.ISdpListener)>
<com.samsung.android.knox.dar.IDarManagerService: int registerListener(java.lang.String,com.samsung.android.knox.dar.sdp.ISdpListener)>
<com.samsung.android.knox.dar.IDarManagerService: void setMainUserId(int,int)>
<com.samsung.android.knox.dar.IDarManagerService: int saveTokenIntoTrusted(java.lang.String,java.lang.String)>
<com.samsung.android.knox.dar.IDarManagerService: int unlockViaTrusted(java.lang.String,java.lang.String)>
<com.samsung.android.knox.dar.IDarManagerService: boolean isSdpSupported()>
<com.samsung.android.knox.dar.IDarManagerService: int deleteToeknFromTrusted(java.lang.String)>
<com.samsung.android.knox.dar.IDarManagerService: int stopTracing(int,int)>
<com.samsung.android.knox.dar.IDarManagerService: boolean isResetPasswordTokenActive(int)>
<com.samsung.android.knox.dar.IDarManagerService: boolean clearResetPasswordToken(int)>
<com.samsung.android.knox.dar.IDarManagerService: void startMonitoringDomains(int,int[],java.util.List,android.os.IZtdListener)>
<com.samsung.android.knox.dar.IDarManagerService: void setInnerAuthUserId(int,int)>
<com.samsung.android.knox.dar.IDarManagerService: int allow(java.lang.String,java.lang.String)>
<com.samsung.android.knox.dar.IDarManagerService: void addBlockedClearablePackages(int,java.lang.String)>
<com.samsung.android.knox.dar.IDarManagerService: int reserveUserIdForSystem()>
<com.samsung.android.knox.dar.IDarManagerService: com.samsung.android.knox.sdp.core.SdpEngineInfo getEngineInfo(java.lang.String)>
<com.samsung.android.knox.dar.IDarManagerService: boolean isDarSupported()>
<com.samsung.android.knox.dar.IDarManagerService: int getReservedUserIdForSystem()>
<com.samsung.android.knox.dar.IDarManagerService: boolean isSDPEnabled(int)>
<com.samsung.android.knox.dar.IDarManagerService: int resetPassword(java.lang.String,java.lang.String,java.lang.String)>
<com.samsung.android.knox.dar.IDarManagerService: int setPassword(java.lang.String,java.lang.String)>
<com.samsung.android.knox.dar.IDarManagerService: int unlock(java.lang.String,java.lang.String)>
<com.samsung.android.knox.dar.IDarManagerService: void stopMonitoringDomains(int)>
<com.samsung.android.knox.dar.IDarManagerService: boolean isDeviceRootKeyInstalled()>
<android.view.IDisplayChangeWindowController: void onDisplayChange(int,int,int,android.window.DisplayAreaInfo,android.view.IDisplayChangeWindowCallback)>
<android.app.ICompatCameraControlCallback: void applyCameraCompatTreatment()>
<android.app.ICompatCameraControlCallback: void revertCameraCompatTreatment()>
<android.media.session.ISessionManager: void setOnMediaKeyListener(android.media.session.IOnMediaKeyListener)>
<android.media.session.ISessionManager: void unregisterRemoteSessionCallback(android.media.IRemoteSessionCallback)>
<android.media.session.ISessionManager: android.media.session.MediaSession$Token getMediaKeyEventSession(java.lang.String)>
<android.media.session.ISessionManager: void setCustomMediaKeyDispatcher(java.lang.String)>
<android.media.session.ISessionManager: java.lang.String getMediaKeyEventSessionPackageName(java.lang.String)>
<android.media.session.ISessionManager: void addSession2TokensListener(android.media.session.ISession2TokensListener,int)>
<android.media.session.ISessionManager: void setOnVolumeKeyLongPressListener(android.media.session.IOnVolumeKeyLongPressListener)>
<android.media.session.ISessionManager: java.util.List getSessions(android.content.ComponentName,int)>
<android.media.session.ISessionManager: void removeSessionsListener(android.media.session.IActiveSessionsListener)>
<android.media.session.ISessionManager: void addOnMediaKeyEventDispatchedListener(android.media.session.IOnMediaKeyEventDispatchedListener)>
<android.media.session.ISessionManager: void removeOnMediaKeyEventDispatchedListener(android.media.session.IOnMediaKeyEventDispatchedListener)>
<android.media.session.ISessionManager: void addOnMediaKeyEventSessionChangedListener(android.media.session.IOnMediaKeyEventSessionChangedListener,java.lang.String)>
<android.media.session.ISessionManager: void addSessionsListener(android.media.session.IActiveSessionsListener,android.content.ComponentName,int)>
<android.media.session.ISessionManager: boolean isTrusted(java.lang.String,int,int)>
<android.media.session.ISessionManager: void dispatchVolumeKeyEvent(java.lang.String,java.lang.String,boolean,android.view.KeyEvent,int,boolean)>
<android.media.session.ISessionManager: void dispatchVolumeKeyEventToSessionAsSystemService(java.lang.String,java.lang.String,android.view.KeyEvent,android.media.session.MediaSession$Token)>
<android.media.session.ISessionManager: int getSessionPolicies(android.media.session.MediaSession$Token)>
<android.media.session.ISessionManager: void removeSession2TokensListener(android.media.session.ISession2TokensListener)>
<android.media.session.ISessionManager: boolean dispatchMediaKeyEventToSessionAsSystemService(java.lang.String,android.view.KeyEvent,android.media.session.MediaSession$Token)>
<android.media.session.ISessionManager: void dispatchMediaKeyEvent(java.lang.String,boolean,android.view.KeyEvent,boolean)>
<android.media.session.ISessionManager: boolean isGlobalPriorityActive()>
<android.media.session.ISessionManager: void registerRemoteSessionCallback(android.media.IRemoteSessionCallback)>
<android.media.session.ISessionManager: boolean hasCustomMediaSessionPolicyProvider(java.lang.String)>
<android.media.session.ISessionManager: void setSessionPolicies(android.media.session.MediaSession$Token,int)>
<android.media.session.ISessionManager: android.media.session.ISession createSession(java.lang.String,android.media.session.ISessionCallback,java.lang.String,android.os.Bundle,int)>
<android.media.session.ISessionManager: void dispatchAdjustVolume(java.lang.String,java.lang.String,int,int,int)>
<android.media.session.ISessionManager: boolean hasCustomMediaKeyDispatcher(java.lang.String)>
<android.media.session.ISessionManager: void removeOnMediaKeyEventSessionChangedListener(android.media.session.IOnMediaKeyEventSessionChangedListener)>
<android.media.session.ISessionManager: void setCustomMediaSessionPolicyProvider(java.lang.String)>
<com.android.internal.telephony.euicc.IDisableProfileCallback: void onComplete(int)>
<com.samsung.android.ims.SemAutoConfigListener: void onVerificationCodeNeeded()>
<com.samsung.android.ims.SemAutoConfigListener: void onIidTokenNeeded()>
<com.samsung.android.ims.SemAutoConfigListener: void onAutoConfigurationCompleted(boolean)>
<com.samsung.android.ims.SemAutoConfigListener: void onMsisdnNumberNeeded()>
<android.companion.virtual.IVirtualDeviceManager: int getAudioRecordingSessionId(int)>
<android.companion.virtual.IVirtualDeviceManager: android.companion.virtual.IVirtualDevice createVirtualDevice(android.os.IBinder,java.lang.String,int,android.companion.virtual.VirtualDeviceParams,android.companion.virtual.IVirtualDeviceActivityListener,android.companion.virtual.IVirtualDeviceSoundEffectListener)>
<android.companion.virtual.IVirtualDeviceManager: int getDeviceIdForDisplayId(int)>
<android.companion.virtual.IVirtualDeviceManager: int createVirtualDisplay(android.hardware.display.VirtualDisplayConfig,android.hardware.display.IVirtualDisplayCallback,android.companion.virtual.IVirtualDevice,java.lang.String)>
<android.companion.virtual.IVirtualDeviceManager: int getDevicePolicy(int,int)>
<android.companion.virtual.IVirtualDeviceManager: boolean isValidVirtualDeviceId(int)>
<android.companion.virtual.IVirtualDeviceManager: int getAudioPlaybackSessionId(int)>
<android.companion.virtual.IVirtualDeviceManager: void playSoundEffect(int,int)>
<android.companion.virtual.IVirtualDeviceManager: java.util.List getVirtualDevices()>
<android.content.pm.IShortcutService: void applyRestore(byte[],int)>
<android.content.pm.IShortcutService: void removeAllDynamicShortcuts(java.lang.String,int)>
<android.content.pm.IShortcutService: android.content.pm.ParceledListSlice getShortcuts(java.lang.String,int,int)>
<android.content.pm.IShortcutService: void removeLongLivedShortcuts(java.lang.String,java.util.List,int)>
<android.content.pm.IShortcutService: void restoreBitmapsFromBackupService(android.os.ParcelFileDescriptor,java.lang.String,java.lang.String)>
<android.content.pm.IShortcutService: int getIconMaxDimensions(java.lang.String,int)>
<android.content.pm.IShortcutService: java.lang.String[] getBitmapPathList(int)>
<android.content.pm.IShortcutService: void pushDynamicShortcut(java.lang.String,android.content.pm.ShortcutInfo,int)>
<android.content.pm.IShortcutService: boolean setDynamicShortcuts(java.lang.String,android.content.pm.ParceledListSlice,int)>
<android.content.pm.IShortcutService: void createShortcutResultIntent(java.lang.String,android.content.pm.ShortcutInfo,int,com.android.internal.infra.AndroidFuture)>
<android.content.pm.IShortcutService: byte[] getBackupPayload(int)>
<android.content.pm.IShortcutService: void handleLocaleChanged(boolean)>
<android.content.pm.IShortcutService: void resetThrottling()>
<android.content.pm.IShortcutService: boolean isRequestPinItemSupported(int,int)>
<android.content.pm.IShortcutService: void requestPinShortcutAsDisplay(java.lang.String,android.content.pm.ShortcutInfo,android.content.IntentSender,int,int,com.android.internal.infra.AndroidFuture)>
<android.content.pm.IShortcutService: boolean updateShortcuts(java.lang.String,android.content.pm.ParceledListSlice,int)>
<android.content.pm.IShortcutService: boolean hasShareTargets(java.lang.String,java.lang.String,int)>
<android.content.pm.IShortcutService: void reportShortcutUsed(java.lang.String,java.lang.String,int)>
<android.content.pm.IShortcutService: void onApplicationActive(java.lang.String,int)>
<android.content.pm.IShortcutService: void requestPinShortcut(java.lang.String,android.content.pm.ShortcutInfo,android.content.IntentSender,int,com.android.internal.infra.AndroidFuture)>
<android.content.pm.IShortcutService: android.content.pm.ParceledListSlice getShareTargets(java.lang.String,android.content.IntentFilter,int)>
<android.content.pm.IShortcutService: void disableShortcuts(java.lang.String,java.util.List,java.lang.CharSequence,int,int)>
<android.content.pm.IShortcutService: void removeDynamicShortcuts(java.lang.String,java.util.List,int)>
<android.content.pm.IShortcutService: boolean addDynamicShortcuts(java.lang.String,android.content.pm.ParceledListSlice,int)>
<android.content.pm.IShortcutService: void enableShortcuts(java.lang.String,java.util.List,int)>
<android.content.pm.IShortcutService: com.android.internal.os.IParcelFileDescriptorFactory getShortcutBitmapsFileDescriptor()>
<android.content.pm.IShortcutService: long getRateLimitResetTime(java.lang.String,int)>
<android.content.pm.IShortcutService: android.os.ParcelFileDescriptor getBackupShortcut(int)>
<android.content.pm.IShortcutService: int getRemainingCallCount(java.lang.String,int)>
<android.content.pm.IShortcutService: int applyRestoreSmartSwitch(android.os.ParcelFileDescriptor,int)>
<android.content.pm.IShortcutService: int getMaxShortcutCountPerActivity(java.lang.String,int)>
<com.android.internal.app.ILogAccessDialogCallback: void declineAccessForClient(int,java.lang.String)>
<com.android.internal.app.ILogAccessDialogCallback: void approveAccessForClient(int,java.lang.String)>
<com.samsung.android.isrb.IIsrbManager: void setFakeTime()>
<com.samsung.android.isrb.IIsrbManager: void setIsrbEnable(boolean)>
<com.samsung.android.isrb.IIsrbManager: boolean isBootCompleteState()>
<android.media.IResourceManagerClient: boolean reclaimResource()>
<android.media.IResourceManagerClient: void startWatchingMode()>
<android.media.IResourceManagerClient: void stopWatchingMode()>
<android.media.IResourceManagerClient: java.lang.String getName()>
<android.media.IResourceManagerClient: int getCodecState()>
<android.content.ISyncAdapterUnsyncableAccountCallback: void onUnsyncableAccountDone(boolean)>
<android.service.persistentdata.IPersistentDataBlockService: boolean hasFrpCredentialHandle()>
<android.service.persistentdata.IPersistentDataBlockService: boolean isEnabled()>
<android.service.persistentdata.IPersistentDataBlockService: int getDataBlockSize()>
<android.service.persistentdata.IPersistentDataBlockService: long getMaximumDataBlockSize()>
<android.service.persistentdata.IPersistentDataBlockService: void setOemUnlockEnabled(boolean)>
<android.service.persistentdata.IPersistentDataBlockService: void wipe()>
<android.service.persistentdata.IPersistentDataBlockService: byte[] read()>
<android.service.persistentdata.IPersistentDataBlockService: java.lang.String getPersistentDataPackageName()>
<android.service.persistentdata.IPersistentDataBlockService: int getFlashLockState()>
<android.service.persistentdata.IPersistentDataBlockService: int write(byte[])>
<android.service.persistentdata.IPersistentDataBlockService: boolean getOemUnlockEnabled()>
<android.telephony.satellite.ISatelliteProvisionStateCallback: void onSatelliteProvisionStateChanged(boolean)>
<android.hardware.hdmi.IHdmiControlStatusChangeListener: void onStatusChange(int,boolean)>
<android.hardware.location.IGeofenceHardwareCallback: void onGeofenceRemove(int,int)>
<android.hardware.location.IGeofenceHardwareCallback: void onGeofenceTransition(int,int,android.location.Location,long,int)>
<android.hardware.location.IGeofenceHardwareCallback: void onGeofencePause(int,int)>
<android.hardware.location.IGeofenceHardwareCallback: void onGeofenceAdd(int,int)>
<android.hardware.location.IGeofenceHardwareCallback: void onGeofenceResume(int,int)>
<android.app.usage.IStorageStatsManager: long getCacheBytes(java.lang.String,java.lang.String)>
<android.app.usage.IStorageStatsManager: long getTotalBytes(java.lang.String,java.lang.String)>
<android.app.usage.IStorageStatsManager: android.app.usage.StorageStats queryStatsForUser(java.lang.String,int,java.lang.String)>
<android.app.usage.IStorageStatsManager: android.content.pm.ParceledListSlice queryCratesForUser(java.lang.String,int,java.lang.String)>
<android.app.usage.IStorageStatsManager: android.content.pm.ParceledListSlice queryCratesForUid(java.lang.String,int,java.lang.String)>
<android.app.usage.IStorageStatsManager: long getFreeBytes(java.lang.String,java.lang.String)>
<android.app.usage.IStorageStatsManager: android.app.usage.StorageStats queryStatsForPackage(java.lang.String,java.lang.String,int,java.lang.String)>
<android.app.usage.IStorageStatsManager: android.app.usage.StorageStats queryStatsForUid(java.lang.String,int,java.lang.String)>
<android.app.usage.IStorageStatsManager: android.content.pm.ParceledListSlice queryCratesForPackage(java.lang.String,java.lang.String,int,java.lang.String)>
<android.app.usage.IStorageStatsManager: long getCacheQuotaBytes(java.lang.String,int,java.lang.String)>
<android.app.usage.IStorageStatsManager: boolean isQuotaSupported(java.lang.String,java.lang.String)>
<android.app.usage.IStorageStatsManager: android.app.usage.ExternalStorageStats queryExternalStatsForUser(java.lang.String,int,java.lang.String)>
<android.app.usage.IStorageStatsManager: boolean isReservedSupported(java.lang.String,java.lang.String)>
<com.android.internal.telephony.euicc.IGetProfileCallback: void onComplete(int,android.service.euicc.EuiccProfileInfo)>
<android.app.timezonedetector.ITimeZoneDetectorService: android.app.time.TimeZoneCapabilitiesAndConfig getCapabilitiesAndConfig()>
<android.app.timezonedetector.ITimeZoneDetectorService: void addListener(android.app.time.ITimeZoneDetectorListener)>
<android.app.timezonedetector.ITimeZoneDetectorService: void suggestTelephonyTimeZone(android.app.timezonedetector.TelephonyTimeZoneSuggestion)>
<android.app.timezonedetector.ITimeZoneDetectorService: boolean updateConfiguration(android.app.time.TimeZoneConfiguration)>
<android.app.timezonedetector.ITimeZoneDetectorService: boolean suggestManualTimeZone(android.app.timezonedetector.ManualTimeZoneSuggestion)>
<android.app.timezonedetector.ITimeZoneDetectorService: boolean setManualTimeZone(android.app.timezonedetector.ManualTimeZoneSuggestion)>
<android.app.timezonedetector.ITimeZoneDetectorService: void removeListener(android.app.time.ITimeZoneDetectorListener)>
<android.app.timezonedetector.ITimeZoneDetectorService: boolean confirmTimeZone(java.lang.String)>
<android.app.timezonedetector.ITimeZoneDetectorService: android.app.time.TimeZoneState getTimeZoneState()>
<android.media.midi.IMidiManager: void setDeviceStatus(android.media.midi.IMidiDeviceServer,android.media.midi.MidiDeviceStatus)>
<android.media.midi.IMidiManager: android.media.midi.MidiDeviceInfo[] getDevicesForTransport(int)>
<android.media.midi.IMidiManager: android.media.midi.MidiDeviceInfo getServiceDeviceInfo(java.lang.String,java.lang.String)>
<android.media.midi.IMidiManager: android.media.midi.MidiDeviceInfo[] getDevices()>
<android.media.midi.IMidiManager: android.media.midi.MidiDeviceInfo registerDeviceServer(android.media.midi.IMidiDeviceServer,int,int,java.lang.String[],java.lang.String[],android.os.Bundle,int,int)>
<android.media.midi.IMidiManager: void registerListener(android.os.IBinder,android.media.midi.IMidiDeviceListener)>
<android.media.midi.IMidiManager: void openBluetoothDevice(android.os.IBinder,android.bluetooth.BluetoothDevice,android.media.midi.IMidiDeviceOpenCallback)>
<android.media.midi.IMidiManager: void updateTotalBytes(android.media.midi.IMidiDeviceServer,int,int)>
<android.media.midi.IMidiManager: void unregisterListener(android.os.IBinder,android.media.midi.IMidiDeviceListener)>
<android.media.midi.IMidiManager: android.media.midi.MidiDeviceStatus getDeviceStatus(android.media.midi.MidiDeviceInfo)>
<android.media.midi.IMidiManager: void openDevice(android.os.IBinder,android.media.midi.MidiDeviceInfo,android.media.midi.IMidiDeviceOpenCallback)>
<android.media.midi.IMidiManager: void unregisterDeviceServer(android.media.midi.IMidiDeviceServer)>
<android.media.midi.IMidiManager: void closeDevice(android.os.IBinder,android.os.IBinder)>
<android.hardware.biometrics.ITestSession: void cleanupInternalState(int)>
<android.hardware.biometrics.ITestSession: void notifyError(int,int)>
<android.hardware.biometrics.ITestSession: void acceptAuthentication(int)>
<android.hardware.biometrics.ITestSession: void notifyAcquired(int,int)>
<android.hardware.biometrics.ITestSession: void notifyVendorError(int,int)>
<android.hardware.biometrics.ITestSession: void startEnroll(int)>
<android.hardware.biometrics.ITestSession: void rejectAuthentication(int)>
<android.hardware.biometrics.ITestSession: void notifyVendorAcquired(int,int)>
<android.hardware.biometrics.ITestSession: void finishEnroll(int)>
<android.hardware.biometrics.ITestSession: void setTestHalEnabled(boolean)>
<android.hardware.location.IContextHubClientCallback: void onNanoAppDisabled(long)>
<android.hardware.location.IContextHubClientCallback: void onNanoAppUnloaded(long)>
<android.hardware.location.IContextHubClientCallback: void onNanoAppLoaded(long)>
<android.hardware.location.IContextHubClientCallback: void onMessageFromNanoApp(android.hardware.location.NanoAppMessage)>
<android.hardware.location.IContextHubClientCallback: void onNanoAppAborted(long,int)>
<android.hardware.location.IContextHubClientCallback: void onClientAuthorizationChanged(long,int)>
<android.hardware.location.IContextHubClientCallback: void onHubReset()>
<android.hardware.location.IContextHubClientCallback: void onNanoAppEnabled(long)>
<android.service.notification.IStatusBarNotificationHolder: android.service.notification.StatusBarNotification get()>
<android.app.people.IConversationListener: void onConversationUpdate(android.app.people.ConversationChannel)>
<com.samsung.android.desktopmode.IDesktopModeListener: void onDesktopModeStateChanged(com.samsung.android.desktopmode.SemDesktopModeState)>
<android.hardware.camera2.extension.IProcessResultImpl: void onCaptureProcessProgressed(int)>
<android.hardware.camera2.extension.IProcessResultImpl: void onCaptureCompleted(long,android.hardware.camera2.impl.CameraMetadataNative)>
<android.os.incremental.IStorageLoadingProgressListener: void onStorageLoadingProgressChanged(int,float)>
<android.media.tv.interactive.ITvInteractiveAppServiceCallback: void onStateChanged(int,int,int)>
<android.permission.ILegacyPermissionManager: int checkPhoneNumberAccess(java.lang.String,java.lang.String,java.lang.String,int,int)>
<android.permission.ILegacyPermissionManager: void grantDefaultPermissionsToEnabledTelephonyDataServices(java.lang.String[],int)>
<android.permission.ILegacyPermissionManager: void grantDefaultPermissionsToEnabledCarrierApps(java.lang.String[],int)>
<android.permission.ILegacyPermissionManager: void grantDefaultPermissionsToActiveLuiApp(java.lang.String,int)>
<android.permission.ILegacyPermissionManager: void revokeDefaultPermissionsFromDisabledTelephonyDataServices(java.lang.String[],int)>
<android.permission.ILegacyPermissionManager: void revokeDefaultPermissionsFromLuiApps(java.lang.String[],int)>
<android.permission.ILegacyPermissionManager: void grantDefaultPermissionsToEnabledImsServices(java.lang.String[],int)>
<android.permission.ILegacyPermissionManager: int checkDeviceIdentifierAccess(java.lang.String,java.lang.String,java.lang.String,int,int)>
<android.permission.ILegacyPermissionManager: void grantDefaultPermissionsToCarrierServiceApp(java.lang.String,int)>
<android.media.IResourceManagerService: void overridePid(int,int)>
<android.media.IResourceManagerService: float getRemainedFrameRateFor(java.lang.String,int,int)>
<android.media.IResourceManagerService: void overrideProcessInfo(android.media.IResourceManagerClient,int,int,int)>
<android.media.IResourceManagerService: float getSupportedFrameRateFor(java.lang.String,int,int)>
<android.media.IResourceManagerService: void markClientForPendingRemoval(android.media.ClientInfoParcel)>
<android.media.IResourceManagerService: void setCodecState(int,int,long,android.media.IResourceManagerClient,int)>
<android.media.IResourceManagerService: void removeClient(android.media.ClientInfoParcel)>
<android.media.IResourceManagerService: com.samsung.android.media.IResourceManagerObserver createResourceObserver(com.samsung.android.media.IResourceManagerObserverClient)>
<android.media.IResourceManagerService: void removeResource(android.media.ClientInfoParcel,android.media.MediaResourceParcel[])>
<android.media.IResourceManagerService: void config(android.media.MediaResourcePolicyParcel[])>
<android.media.IResourceManagerService: void notifyClientStarted(android.media.ClientConfigParcel)>
<android.media.IResourceManagerService: boolean reclaimResource(android.media.ClientInfoParcel,android.media.MediaResourceParcel[])>
<android.media.IResourceManagerService: void addMediaInfo(int,int,long,android.media.IResourceManagerClient,com.samsung.android.media.MediaInfoParcel[])>
<android.media.IResourceManagerService: void notifyClientStopped(android.media.ClientConfigParcel)>
<android.media.IResourceManagerService: void reclaimResourcesFromClientsPendingRemoval(int)>
<android.media.IResourceManagerService: void addResource(android.media.ClientInfoParcel,android.media.IResourceManagerClient,android.media.MediaResourceParcel[])>
<android.media.IResourceManagerService: void sendCapacityError(int,int,long,android.media.IResourceManagerClient,com.samsung.android.media.MediaInfoParcel[])>
<android.media.IResourceManagerService: void notifyClientConfigChanged(android.media.ClientConfigParcel)>
<android.media.IResourceManagerService: void notifyClientCreated(android.media.ClientInfoParcel)>
<android.app.contentsuggestions.IContentSuggestionsManager: void setDefaultServiceEnabled(int,boolean)>
<android.app.contentsuggestions.IContentSuggestionsManager: void resetTemporaryService(int)>
<android.app.contentsuggestions.IContentSuggestionsManager: void setTemporaryService(int,java.lang.String,int)>
<android.app.contentsuggestions.IContentSuggestionsManager: void classifyContentSelections(int,android.app.contentsuggestions.ClassificationsRequest,android.app.contentsuggestions.IClassificationsCallback)>
<android.app.contentsuggestions.IContentSuggestionsManager: void isEnabled(int,com.android.internal.os.IResultReceiver)>
<android.app.contentsuggestions.IContentSuggestionsManager: void notifyInteraction(int,java.lang.String,android.os.Bundle)>
<android.app.contentsuggestions.IContentSuggestionsManager: void provideContextImage(int,int,android.os.Bundle)>
<android.app.contentsuggestions.IContentSuggestionsManager: void provideContextBitmap(int,android.graphics.Bitmap,android.os.Bundle)>
<android.app.contentsuggestions.IContentSuggestionsManager: void suggestContentSelections(int,android.app.contentsuggestions.SelectionsRequest,android.app.contentsuggestions.ISelectionsCallback)>
<android.telephony.mbms.vendor.IMbmsStreamingService: int requestUpdateStreamingServices(int,java.util.List)>
<android.telephony.mbms.vendor.IMbmsStreamingService: void stopStreaming(int,java.lang.String)>
<android.telephony.mbms.vendor.IMbmsStreamingService: int initialize(android.telephony.mbms.IMbmsStreamingSessionCallback,int)>
<android.telephony.mbms.vendor.IMbmsStreamingService: int startStreaming(int,java.lang.String,android.telephony.mbms.IStreamingServiceCallback)>
<android.telephony.mbms.vendor.IMbmsStreamingService: android.net.Uri getPlaybackUri(int,java.lang.String)>
<android.telephony.mbms.vendor.IMbmsStreamingService: void dispose(int)>
<android.telephony.ims.aidl.IImsServiceController: android.telephony.ims.aidl.IImsMmTelFeature createMmTelFeature(int,int)>
<android.telephony.ims.aidl.IImsServiceController: android.telephony.ims.aidl.ISipTransport getSipTransport(int)>
<android.telephony.ims.aidl.IImsServiceController: android.telephony.ims.aidl.IImsRcsFeature createRcsFeature(int,int)>
<android.telephony.ims.aidl.IImsServiceController: void notifyImsServiceReadyForFeatureCreation()>
<android.telephony.ims.aidl.IImsServiceController: void setListener(android.telephony.ims.aidl.IImsServiceControllerListener)>
<android.telephony.ims.aidl.IImsServiceController: void resetIms(int,int)>
<android.telephony.ims.aidl.IImsServiceController: void removeImsFeature(int,int,boolean)>
<android.telephony.ims.aidl.IImsServiceController: void addFeatureStatusCallback(int,int,com.android.ims.internal.IImsFeatureStatusCallback)>
<android.telephony.ims.aidl.IImsServiceController: android.telephony.ims.aidl.IImsRegistration getRegistration(int,int)>
<android.telephony.ims.aidl.IImsServiceController: android.telephony.ims.aidl.IImsConfig getConfig(int,int)>
<android.telephony.ims.aidl.IImsServiceController: android.telephony.ims.stub.ImsFeatureConfiguration querySupportedImsFeatures()>
<android.telephony.ims.aidl.IImsServiceController: void removeFeatureStatusCallback(int,int,com.android.ims.internal.IImsFeatureStatusCallback)>
<android.telephony.ims.aidl.IImsServiceController: android.telephony.ims.aidl.IImsMmTelFeature createEmergencyOnlyMmTelFeature(int)>
<android.telephony.ims.aidl.IImsServiceController: void disableIms(int,int)>
<android.telephony.ims.aidl.IImsServiceController: long getImsServiceCapabilities()>
<android.telephony.ims.aidl.IImsServiceController: void enableIms(int,int)>
<android.net.wifi.nl80211.IWificondEventCallback: void OnRegDomainChanged(java.lang.String)>
<android.print.IPrintManager: java.util.List getPrintServices(int,int)>
<android.print.IPrintManager: android.print.PrintJobInfo getPrintJobInfo(android.print.PrintJobId,int,int)>
<android.print.IPrintManager: void setBindInstantServiceAllowed(int,boolean)>
<android.print.IPrintManager: void stopPrinterStateTracking(android.print.PrinterId,int)>
<android.print.IPrintManager: void addPrintJobStateChangeListener(android.print.IPrintJobStateChangeListener,int,int)>
<android.print.IPrintManager: void removePrintServiceRecommendationsChangeListener(android.printservice.recommendation.IRecommendationsChangeListener,int)>
<android.print.IPrintManager: android.graphics.drawable.Icon getCustomPrinterIcon(android.print.PrinterId,int)>
<android.print.IPrintManager: void addPrintServicesChangeListener(android.print.IPrintServicesChangeListener,int)>
<android.print.IPrintManager: boolean isPrintServiceEnabled(android.content.ComponentName,int)>
<android.print.IPrintManager: void removePrintJobStateChangeListener(android.print.IPrintJobStateChangeListener,int)>
<android.print.IPrintManager: void startPrinterStateTracking(android.print.PrinterId,int)>
<android.print.IPrintManager: android.os.Bundle print(java.lang.String,android.print.IPrintDocumentAdapter,android.print.PrintAttributes,java.lang.String,int,int)>
<android.print.IPrintManager: void destroyPrinterDiscoverySession(android.print.IPrinterDiscoveryObserver,int)>
<android.print.IPrintManager: void createPrinterDiscoverySession(android.print.IPrinterDiscoveryObserver,int)>
<android.print.IPrintManager: void addPrintServiceRecommendationsChangeListener(android.printservice.recommendation.IRecommendationsChangeListener,int)>
<android.print.IPrintManager: void validatePrinters(java.util.List,int)>
<android.print.IPrintManager: boolean getBindInstantServiceAllowed(int)>
<android.print.IPrintManager: java.util.List getPrintJobInfos(int,int)>
<android.print.IPrintManager: void startPrinterDiscovery(android.print.IPrinterDiscoveryObserver,java.util.List,int)>
<android.print.IPrintManager: java.util.List getPrintServiceRecommendations(int)>
<android.print.IPrintManager: void stopPrinterDiscovery(android.print.IPrinterDiscoveryObserver,int)>
<android.print.IPrintManager: void restartPrintJob(android.print.PrintJobId,int,int)>
<android.print.IPrintManager: void cancelPrintJob(android.print.PrintJobId,int,int)>
<android.print.IPrintManager: void removePrintServicesChangeListener(android.print.IPrintServicesChangeListener,int)>
<android.print.IPrintManager: void setPrintServiceEnabled(android.content.ComponentName,boolean,int)>
<com.samsung.android.knox.zt.IZeroTrustListener: void onEventGeneralized(int,java.util.Map)>
<com.samsung.android.knox.zt.IZeroTrustListener: void onEvent(int,android.os.Bundle)>
<com.samsung.android.knox.zt.IZeroTrustListener: void onEventSimplified(int,java.lang.String)>
<com.samsung.android.gamesdk.IGameSDKService: boolean initGameSDK()>
<com.samsung.android.gamesdk.IGameSDKService: java.lang.String getVersion()>
<com.samsung.android.gamesdk.IGameSDKService: boolean setCpuBoostMode(int)>
<com.samsung.android.gamesdk.IGameSDKService: int getGPULevelMax()>
<com.samsung.android.gamesdk.IGameSDKService: int isPMModeEnable()>
<com.samsung.android.gamesdk.IGameSDKService: double getHighPrecisionSkinTempLevel()>
<com.samsung.android.gamesdk.IGameSDKService: int getGpuJTLevel()>
<com.samsung.android.gamesdk.IGameSDKService: boolean initGameSDKWithJsonData(java.lang.String,java.lang.String)>
<com.samsung.android.gamesdk.IGameSDKService: boolean setLevelWithScene(java.lang.String,int,int)>
<com.samsung.android.gamesdk.IGameSDKService: int setFreqLevels(int,int)>
<com.samsung.android.gamesdk.IGameSDKService: int getClusterInfo()>
<com.samsung.android.gamesdk.IGameSDKService: double getGpuLoad()>
<com.samsung.android.gamesdk.IGameSDKService: int getCpuLevelCurrent()>
<com.samsung.android.gamesdk.IGameSDKService: int getCurrentRefreshRate()>
<com.samsung.android.gamesdk.IGameSDKService: double getFrameworkFPS()>
<com.samsung.android.gamesdk.IGameSDKService: int getTempLevel()>
<com.samsung.android.gamesdk.IGameSDKService: int getGpuLevelCurrent()>
<com.samsung.android.gamesdk.IGameSDKService: boolean initGameSDKWithVersion(java.lang.String)>
<com.samsung.android.gamesdk.IGameSDKService: void resetRefreshRate()>
<com.samsung.android.gamesdk.IGameSDKService: void setRefreshRate(int)>
<com.samsung.android.gamesdk.IGameSDKService: boolean setGpuBoostMode(int)>
<com.samsung.android.gamesdk.IGameSDKService: int getCPULevelMax()>
<com.samsung.android.gamesdk.IGameSDKService: int getSkinTempLevel()>
<com.samsung.android.gamesdk.IGameSDKService: double getGpuFrameTime()>
<com.samsung.android.gamesdk.IGameSDKService: boolean setGameSDKStateListener(com.samsung.android.gamesdk.IGameSDKStateListener)>
<com.samsung.android.gamesdk.IGameSDKService: double getCpuLoad()>
<com.samsung.android.gamesdk.IGameSDKService: boolean isGameSDKVrrSupported()>
<com.samsung.android.gamesdk.IGameSDKService: int[] getSupportedRefreshRates()>
<com.samsung.android.gamesdk.IGameSDKService: int getCpuJTLevel()>
<com.samsung.android.gamesdk.IGameSDKService: boolean isPackageInWhiteList(java.lang.String)>
<com.samsung.android.gamesdk.IGameSDKService: boolean setGameSDKListener(com.samsung.android.gamesdk.IGameSDKListener)>
<com.samsung.android.gamesdk.IGameSDKService: boolean setDisableTMLevel(int)>
<com.samsung.android.gamesdk.IGameSDKService: void finalGameSDK(java.lang.String)>
<com.samsung.android.gamesdk.IGameSDKService: double getPrevFrameworkFPS()>
<com.samsung.android.gamesdk.IGameSDKService: boolean registerDebugBridgePid(int)>
<com.android.server.IRealTimeTokenService: int checkTokenInfoExpiry(long)>
<com.android.server.IRealTimeTokenService: int registerTokenInfo(long,long)>
<com.android.server.IRealTimeTokenService: int unregisterTokenInfo(long)>
<com.android.server.IRealTimeTokenService: int unregisterAllTokenInfo()>
<android.hardware.location.IActivityRecognitionHardwareWatcher: void onInstanceChanged(android.hardware.location.IActivityRecognitionHardware)>
<android.service.timezone.ITimeZoneProviderManager: void onTimeZoneProviderEvent(android.service.timezone.TimeZoneProviderEvent)>
<android.location.IGnssMeasurementsListener: void onGnssMeasurementsReceived(android.location.GnssMeasurementsEvent)>
<android.location.IGnssMeasurementsListener: void onStatusChanged(int)>
<android.media.IPreferredMixerAttributesDispatcher: void dispatchPrefMixerAttributesChanged(android.media.AudioAttributes,int,android.media.AudioMixerAttributes)>
<android.media.ISpatializerHeadToSoundStagePoseCallback: void dispatchPoseChanged(float[])>
<android.hardware.ICamera: void disconnect()>
<com.samsung.android.sepunion.IPluginManager: com.samsung.android.cover.CoverState getCoverState()>
<com.samsung.android.cover.ICoverManager: void registerCallback(android.os.IBinder,android.content.ComponentName)>
<com.samsung.android.cover.ICoverManager: boolean requestCoverAuthentication(android.os.IBinder,android.content.ComponentName)>
<com.samsung.android.cover.ICoverManager: void sendPowerKeyToCover()>
<com.samsung.android.cover.ICoverManager: boolean setFotaInProgress(boolean,android.os.IBinder,android.content.ComponentName)>
<com.samsung.android.cover.ICoverManager: boolean enableLcdOffByCover(android.os.IBinder,android.content.ComponentName)>
<com.samsung.android.cover.ICoverManager: void sendSystemEvent(android.os.Bundle)>
<com.samsung.android.cover.ICoverManager: void sendDataToNfcLedCover(int,byte[])>
<com.samsung.android.cover.ICoverManager: boolean unregisterNfcTouchListenerCallback(android.os.IBinder)>
<com.samsung.android.cover.ICoverManager: boolean unregisterCallbackForExternal(android.os.IBinder)>
<com.samsung.android.cover.ICoverManager: void registerListenerCallbackForExternal(android.os.IBinder,android.content.ComponentName,int)>
<com.samsung.android.cover.ICoverManager: int onCoverAppCovered(boolean)>
<com.samsung.android.cover.ICoverManager: void sendDataToCover(int,byte[])>
<com.samsung.android.cover.ICoverManager: boolean unregisterCallback(android.os.IBinder)>
<com.samsung.android.cover.ICoverManager: void addLedNotification(android.os.Bundle)>
<com.samsung.android.cover.ICoverManager: boolean disableLcdOffByCover(android.os.IBinder,android.content.ComponentName)>
<com.samsung.android.cover.ICoverManager: boolean isCoverManagerDisabled()>
<com.samsung.android.cover.ICoverManager: void registerNfcTouchListenerCallback(int,android.os.IBinder,android.content.ComponentName)>
<com.samsung.android.cover.ICoverManager: com.samsung.android.cover.CoverState getCoverStateForExternal()>
<com.samsung.android.cover.ICoverManager: void removeLedNotification(android.os.Bundle)>
<com.samsung.android.cover.ICoverManager: com.samsung.android.cover.CoverState getCoverState()>
<com.samsung.android.cover.ICoverManager: void disableCoverManager(boolean,android.os.IBinder,java.lang.String)>
<com.samsung.android.cover.ICoverManager: int getVersion()>
<com.samsung.android.cover.ICoverManager: void registerListenerCallback(android.os.IBinder,android.content.ComponentName,int)>
<com.samsung.android.cover.ICoverManager: boolean getCoverSwitchState()>
<com.samsung.android.app.usage.IUsageStatsWatcher: void noteStopComponent(android.content.ComponentName,android.content.Intent,int,int)>
<com.samsung.android.app.usage.IUsageStatsWatcher: void notePauseComponent(android.content.ComponentName,android.content.Intent,int,int)>
<com.samsung.android.app.usage.IUsageStatsWatcher: void noteResumeComponent(android.content.ComponentName,android.content.Intent,int,int)>
<android.telephony.ims.aidl.ISipDelegateConnectionStateCallback: void onDestroyed(int)>
<android.telephony.ims.aidl.ISipDelegateConnectionStateCallback: void onConfigurationChanged(android.telephony.ims.SipDelegateConfiguration)>
<android.telephony.ims.aidl.ISipDelegateConnectionStateCallback: void onFeatureTagStatusChanged(android.telephony.ims.DelegateRegistrationState,java.util.List)>
<android.telephony.ims.aidl.ISipDelegateConnectionStateCallback: void onImsConfigurationChanged(android.telephony.ims.SipDelegateImsConfiguration)>
<android.telephony.ims.aidl.ISipDelegateConnectionStateCallback: void onCreated(android.telephony.ims.aidl.ISipDelegate)>
<android.hardware.thermal.IThermalChangedCallback: int getInterfaceVersion()>
<android.hardware.thermal.IThermalChangedCallback: java.lang.String getInterfaceHash()>
<android.hardware.thermal.IThermalChangedCallback: void notifyThrottling(android.hardware.thermal.Temperature)>
<com.android.internal.widget.IUpdateVerifierCallback: void onReceiveSaGuid(java.lang.String)>
<android.telephony.mbms.IGroupCallCallback: void onGroupCallStateChanged(int,int)>
<android.telephony.mbms.IGroupCallCallback: void onBroadcastSignalStrengthUpdated(int)>
<android.telephony.mbms.IGroupCallCallback: void onError(int,java.lang.String)>
<android.app.backup.IBackupManager: void setAutoRestoreForUser(int,boolean)>
<android.app.backup.IBackupManager: void updateTransportAttributesForUser(int,android.content.ComponentName,java.lang.String,android.content.Intent,java.lang.String,android.content.Intent,java.lang.CharSequence)>
<android.app.backup.IBackupManager: void semSetAutoRestoreEnabled(boolean)>
<android.app.backup.IBackupManager: java.util.Map semBackupPackage(android.os.ParcelFileDescriptor,java.lang.String[],java.lang.String,int)>
<android.app.backup.IBackupManager: android.os.UserHandle getUserForAncestralSerialNumber(long)>
<android.app.backup.IBackupManager: android.content.ComponentName[] listAllTransportComponentsForUser(int)>
<android.app.backup.IBackupManager: void fullBackupCustomized(int,java.lang.String,boolean,boolean,boolean,boolean,boolean,boolean,boolean,java.lang.String[],boolean,java.lang.String,boolean,android.app.backup.IMemorySaverBackupRestoreObserver)>
<android.app.backup.IBackupManager: boolean isBackupEnabledForUser(int)>
<android.app.backup.IBackupManager: void backupNowForUser(int)>
<android.app.backup.IBackupManager: void semSetBackupEnabled(boolean)>
<android.app.backup.IBackupManager: void dataChangedForUser(int,java.lang.String)>
<android.app.backup.IBackupManager: void restoreAtInstallForUser(int,java.lang.String,int)>
<android.app.backup.IBackupManager: void agentConnectedForUser(int,java.lang.String,android.os.IBinder)>
<android.app.backup.IBackupManager: java.lang.String getCurrentTransport()>
<android.app.backup.IBackupManager: android.content.Intent getConfigurationIntent(java.lang.String)>
<android.app.backup.IBackupManager: android.content.ComponentName getCurrentTransportComponentForUser(int)>
<android.app.backup.IBackupManager: void fullRestoreCustomized(int,java.lang.String,boolean,java.lang.String,android.app.backup.IMemorySaverBackupRestoreObserver)>
<android.app.backup.IBackupManager: java.lang.String selectBackupTransport(java.lang.String)>
<android.app.backup.IBackupManager: void agentConnected(java.lang.String,android.os.IBinder)>
<android.app.backup.IBackupManager: int requestBackup(java.lang.String[],android.app.backup.IBackupObserver,android.app.backup.IBackupManagerMonitor,int)>
<android.app.backup.IBackupManager: boolean isSubUserSupported()>
<android.app.backup.IBackupManager: boolean semCancelBackupAndRestore()>
<android.app.backup.IBackupManager: boolean semIsBackupEnabled()>
<android.app.backup.IBackupManager: int requestBackupForUser(int,java.lang.String[],android.app.backup.IBackupObserver,android.app.backup.IBackupManagerMonitor,int)>
<android.app.backup.IBackupManager: void acknowledgeFullBackupOrRestoreForUser(int,int,boolean,java.lang.String,java.lang.String,android.app.backup.IFullBackupRestoreObserver)>
<android.app.backup.IBackupManager: void agentDisconnected(java.lang.String)>
<android.app.backup.IBackupManager: void adbRestore(int,android.os.ParcelFileDescriptor)>
<android.app.backup.IBackupManager: java.lang.String getDestinationString(java.lang.String)>
<android.app.backup.IBackupManager: java.lang.CharSequence getDataManagementLabelForUser(int,java.lang.String)>
<android.app.backup.IBackupManager: void opCompleteForUser(int,int,long)>
<android.app.backup.IBackupManager: void dataChanged(java.lang.String)>
<android.app.backup.IBackupManager: void clearBackupDataForUser(int,java.lang.String,java.lang.String)>
<android.app.backup.IBackupManager: boolean isBackupEnabled()>
<android.app.backup.IBackupManager: android.content.Intent getDataManagementIntent(java.lang.String)>
<android.app.backup.IBackupManager: void semRestorePackage(android.os.ParcelFileDescriptor,java.lang.String)>
<android.app.backup.IBackupManager: void agentDisconnectedForUser(int,java.lang.String)>
<android.app.backup.IBackupManager: void excludeKeysFromRestore(java.lang.String,java.util.List)>
<android.app.backup.IBackupManager: java.lang.String[] listAllTransports()>
<android.app.backup.IBackupManager: long getAvailableRestoreTokenForUser(int,java.lang.String)>
<android.app.backup.IBackupManager: void backupNow()>
<android.app.backup.IBackupManager: void setAncestralSerialNumber(long)>
<android.app.backup.IBackupManager: android.content.Intent getConfigurationIntentForUser(int,java.lang.String)>
<android.app.backup.IBackupManager: void reportDelayedRestoreResult(java.lang.String,java.util.List)>
<android.app.backup.IBackupManager: java.util.Map semBackupPackagePath(android.os.ParcelFileDescriptor,java.lang.String[],java.lang.String,int,java.lang.String[])>
<android.app.backup.IBackupManager: java.lang.String getCurrentTransportForUser(int)>
<android.app.backup.IBackupManager: java.lang.String[] getTransportWhitelist()>
<android.app.backup.IBackupManager: java.lang.String[] listAllTransportsForUser(int)>
<android.app.backup.IBackupManager: void adbBackup(int,android.os.ParcelFileDescriptor,boolean,boolean,boolean,boolean,boolean,boolean,boolean,boolean,java.lang.String[])>
<android.app.backup.IBackupManager: boolean isUserReadyForBackup(int)>
<android.app.backup.IBackupManager: android.content.Intent getDataManagementIntentForUser(int,java.lang.String)>
<android.app.backup.IBackupManager: void initializeTransportsForUser(int,java.lang.String[],android.app.backup.IBackupObserver)>
<android.app.backup.IBackupManager: java.lang.String selectBackupTransportForUser(int,java.lang.String)>
<android.app.backup.IBackupManager: android.app.backup.IRestoreSession beginRestoreSessionForUser(int,java.lang.String,java.lang.String)>
<android.app.backup.IBackupManager: boolean semSetTimeoutBackupAndRestore(int)>
<android.app.backup.IBackupManager: void setBackupEnabled(boolean)>
<android.app.backup.IBackupManager: boolean setBackupPassword(java.lang.String,java.lang.String)>
<android.app.backup.IBackupManager: void fullTransportBackupForUser(int,java.lang.String[])>
<android.app.backup.IBackupManager: void setBackupEnabledForUser(int,boolean)>
<android.app.backup.IBackupManager: void setBackupServiceActive(int,boolean)>
<android.app.backup.IBackupManager: void acknowledgeFullBackupOrRestore(int,boolean,java.lang.String,java.lang.String,android.app.backup.IFullBackupRestoreObserver)>
<android.app.backup.IBackupManager: void selectBackupTransportAsyncForUser(int,android.content.ComponentName,android.app.backup.ISelectBackupTransportCallback)>
<android.app.backup.IBackupManager: void restoreAtInstall(java.lang.String,int)>
<android.app.backup.IBackupManager: boolean isBackupServiceActive(int)>
<android.app.backup.IBackupManager: void clearBackupData(java.lang.String,java.lang.String)>
<android.app.backup.IBackupManager: void opComplete(int,long)>
<android.app.backup.IBackupManager: void cancelBackupsForUser(int)>
<android.app.backup.IBackupManager: boolean hasBackupPassword()>
<android.app.backup.IBackupManager: void cancelBackups()>
<android.app.backup.IBackupManager: void setFrameworkSchedulingEnabledForUser(int,boolean)>
<android.app.backup.IBackupManager: java.lang.String getDestinationStringForUser(int,java.lang.String)>
<android.app.backup.IBackupManager: boolean isAppEligibleForBackupForUser(int,java.lang.String)>
<android.app.backup.IBackupManager: void setAutoRestore(boolean)>
<android.app.backup.IBackupManager: java.lang.String[] filterAppsEligibleForBackupForUser(int,java.lang.String[])>
<com.android.internal.inputmethod.IInputMethodClient: void reportFullscreenMode(boolean)>
<com.android.internal.inputmethod.IInputMethodClient: void onUnbindAccessibilityService(int,int)>
<com.android.internal.inputmethod.IInputMethodClient: void onUnbindMethod(int,int)>
<com.android.internal.inputmethod.IInputMethodClient: void setInteractive(boolean,boolean)>
<com.android.internal.inputmethod.IInputMethodClient: void setImeTraceEnabled(boolean)>
<com.android.internal.inputmethod.IInputMethodClient: void onBindAccessibilityService(com.android.internal.inputmethod.InputBindResult,int)>
<com.android.internal.inputmethod.IInputMethodClient: void scheduleStartInputIfNecessary(boolean)>
<com.android.internal.inputmethod.IInputMethodClient: void onBindMethod(com.android.internal.inputmethod.InputBindResult)>
<com.android.internal.inputmethod.IInputMethodClient: void setActive(boolean,boolean)>
<com.android.internal.inputmethod.IInputMethodClient: void throwExceptionFromSystem(java.lang.String)>
<com.android.internal.inputmethod.IInputMethodClient: void updateVirtualDisplayToScreenMatrix(int,float[])>
<android.view.accessibility.IAccessibilityManagerClient: void setRelevantEventTypes(int)>
<android.view.accessibility.IAccessibilityManagerClient: void notifyServicesStateChanged(long)>
<android.view.accessibility.IAccessibilityManagerClient: void setState(int)>
<android.view.accessibility.IAccessibilityManagerClient: void setFocusAppearance(int,int)>
<android.app.wallpapereffectsgeneration.IWallpaperEffectsGenerationManager: void generateCinematicEffect(android.app.wallpapereffectsgeneration.CinematicEffectRequest,android.app.wallpapereffectsgeneration.ICinematicEffectListener)>
<android.app.wallpapereffectsgeneration.IWallpaperEffectsGenerationManager: void returnCinematicEffectResponse(android.app.wallpapereffectsgeneration.CinematicEffectResponse)>
<com.android.internal.view.IInputMethodManager: int getCurTokenDisplayId()>
<com.android.internal.view.IInputMethodManager: void handleVoiceHWKey()>
<com.android.internal.view.IInputMethodManager: boolean isStylusHandwritingAvailableAsUser(int)>
<com.android.internal.view.IInputMethodManager: void removeImeSurface()>
<com.android.internal.view.IInputMethodManager: java.util.List getEnabledInputMethodList(int)>
<com.android.internal.view.IInputMethodManager: boolean hideSoftInput(com.android.internal.inputmethod.IInputMethodClient,android.os.IBinder,android.view.inputmethod.ImeTracker$Token,int,android.os.ResultReceiver,int)>
<com.android.internal.view.IInputMethodManager: void setExplicitlyEnabledInputMethodSubtypes(java.lang.String,int[],int)>
<com.android.internal.view.IInputMethodManager: void addVirtualStylusIdForTestSession(com.android.internal.inputmethod.IInputMethodClient)>
<com.android.internal.view.IInputMethodManager: boolean minimizeSoftInput(com.android.internal.inputmethod.IInputMethodClient,int)>
<com.android.internal.view.IInputMethodManager: void dismissAndShowAgainInputMethodPicker()>
<com.android.internal.view.IInputMethodManager: void undoMinimizeSoftInput()>
<com.android.internal.view.IInputMethodManager: boolean acceptStylusHandwritingDelegation(com.android.internal.inputmethod.IInputMethodClient,int,java.lang.String,java.lang.String)>
<com.android.internal.view.IInputMethodManager: void startProtoDump(byte[],int,java.lang.String)>
<com.android.internal.view.IInputMethodManager: void reportVirtualDisplayGeometryAsync(com.android.internal.inputmethod.IInputMethodClient,int,float[])>
<com.android.internal.view.IInputMethodManager: java.util.List getEnabledInputMethodSubtypeList(java.lang.String,boolean,int)>
<com.android.internal.view.IInputMethodManager: java.util.List getInputMethodList(int,int)>
<com.android.internal.view.IInputMethodManager: void setAdditionalInputMethodSubtypes(java.lang.String,android.view.inputmethod.InputMethodSubtype[],int)>
<com.android.internal.view.IInputMethodManager: boolean showSoftInput(com.android.internal.inputmethod.IInputMethodClient,android.os.IBinder,android.view.inputmethod.ImeTracker$Token,int,int,android.os.ResultReceiver,int)>
<com.android.internal.view.IInputMethodManager: com.android.internal.inputmethod.InputBindResult startInputOrWindowGainedFocus(int,com.android.internal.inputmethod.IInputMethodClient,android.os.IBinder,int,int,int,android.view.inputmethod.EditorInfo,com.android.internal.inputmethod.IRemoteInputConnection,com.android.internal.inputmethod.IRemoteAccessibilityInputConnection,int,int,android.window.ImeOnBackInvokedDispatcher)>
<com.android.internal.view.IInputMethodManager: void stopImeTrace()>
<com.android.internal.view.IInputMethodManager: int getCurrentFocusDisplayID()>
<com.android.internal.view.IInputMethodManager: android.view.inputmethod.InputMethodSubtype getLastInputMethodSubtype(int)>
<com.android.internal.view.IInputMethodManager: boolean getWACOMPen()>
<com.android.internal.view.IInputMethodManager: com.android.internal.inputmethod.IImeTracker getImeTrackerService()>
<com.android.internal.view.IInputMethodManager: boolean isImeTraceEnabled()>
<com.android.internal.view.IInputMethodManager: void startImeTrace()>
<com.android.internal.view.IInputMethodManager: boolean isInputMethodShown()>
<com.android.internal.view.IInputMethodManager: void startStylusHandwriting(com.android.internal.inputmethod.IInputMethodClient)>
<com.android.internal.view.IInputMethodManager: int getInputMethodWindowVisibleHeight(com.android.internal.inputmethod.IInputMethodClient)>
<com.android.internal.view.IInputMethodManager: void prepareStylusHandwritingDelegation(com.android.internal.inputmethod.IInputMethodClient,int,java.lang.String,java.lang.String)>
<com.android.internal.view.IInputMethodManager: void setStylusWindowIdleTimeoutForTest(com.android.internal.inputmethod.IInputMethodClient,long)>
<com.android.internal.view.IInputMethodManager: void reportPerceptibleAsync(android.os.IBinder,boolean)>
<com.android.internal.view.IInputMethodManager: int isAccessoryKeyboard()>
<com.android.internal.view.IInputMethodManager: void setInputMethodSwitchDisable(com.android.internal.inputmethod.IInputMethodClient,boolean)>
<com.android.internal.view.IInputMethodManager: void addClient(com.android.internal.inputmethod.IInputMethodClient,com.android.internal.inputmethod.IRemoteInputConnection,int)>
<com.android.internal.view.IInputMethodManager: android.view.inputmethod.InputMethodInfo getCurrentInputMethodInfoAsUser(int)>
<com.android.internal.view.IInputMethodManager: boolean isCurrentInputMethodAsSamsungKeyboard()>
<com.android.internal.view.IInputMethodManager: boolean isInputMethodPickerShownForTest()>
<com.android.internal.view.IInputMethodManager: void showInputMethodPickerFromClient(com.android.internal.inputmethod.IInputMethodClient,int)>
<com.android.internal.view.IInputMethodManager: boolean getDexSettingsValue(java.lang.String,java.lang.String)>
<com.android.internal.view.IInputMethodManager: void showInputMethodPickerFromSystem(int,int)>
<com.android.internal.view.IInputMethodManager: void removeImeSurfaceFromWindowAsync(android.os.IBinder)>
<com.android.internal.view.IInputMethodManager: android.view.inputmethod.InputMethodSubtype getCurrentInputMethodSubtype(int)>
<android.credentials.ICreateCredentialCallback: void onError(java.lang.String,java.lang.String)>
<android.credentials.ICreateCredentialCallback: void onPendingIntent(android.app.PendingIntent)>
<android.credentials.ICreateCredentialCallback: void onResponse(android.credentials.CreateCredentialResponse)>
<android.media.IMuteAwaitConnectionCallback: void dispatchOnMutedUntilConnection(android.media.AudioDeviceAttributes,int[])>
<android.media.IMuteAwaitConnectionCallback: void dispatchOnUnmutedEvent(int,android.media.AudioDeviceAttributes,int[])>
<android.window.ITaskFpsCallback: void onFpsReported(float)>
<android.media.soundtrigger_middleware.ISoundTriggerMiddlewareService: android.media.soundtrigger_middleware.SoundTriggerModuleDescriptor[] listModulesAsMiddleman(android.media.permission.Identity,android.media.permission.Identity)>
<android.media.soundtrigger_middleware.ISoundTriggerMiddlewareService: android.media.soundtrigger_middleware.SoundTriggerModuleDescriptor[] listModulesAsOriginator(android.media.permission.Identity)>
<android.media.soundtrigger_middleware.ISoundTriggerMiddlewareService: void attachFakeHalInjection(android.media.soundtrigger_middleware.ISoundTriggerInjection)>
<android.media.soundtrigger_middleware.ISoundTriggerMiddlewareService: android.media.soundtrigger_middleware.ISoundTriggerModule attachAsMiddleman(int,android.media.permission.Identity,android.media.permission.Identity,android.media.soundtrigger_middleware.ISoundTriggerCallback,boolean)>
<android.media.soundtrigger_middleware.ISoundTriggerMiddlewareService: android.media.soundtrigger_middleware.ISoundTriggerModule attachAsOriginator(int,android.media.permission.Identity,android.media.soundtrigger_middleware.ISoundTriggerCallback)>
<com.samsung.android.dsms.aidl.IDsmsService: void sendMessage(java.lang.String,java.lang.String,long)>
<android.nfc.INfcAdapter: boolean isNFCAllowed(int)>
<android.nfc.INfcAdapter: int getSeSupportedTech()>
<android.nfc.INfcAdapter: void unregisterControllerAlwaysOnListener(android.nfc.INfcControllerAlwaysOnListener)>
<android.nfc.INfcAdapter: java.lang.String getPhoneNumber()>
<android.nfc.INfcAdapter: android.nfc.INfcAdapterExtras getNfcAdapterExtrasInterface(java.lang.String)>
<android.nfc.INfcAdapter: void setForegroundDispatch(android.app.PendingIntent,android.content.IntentFilter[],android.nfc.TechListParcel)>
<android.nfc.INfcAdapter: boolean setControllerAlwaysOn(boolean)>
<android.nfc.INfcAdapter: boolean enableReaderOption(boolean)>
<android.nfc.INfcAdapter: void changeRoutingTable(android.os.IBinder,int,java.lang.String,java.lang.String,java.util.List)>
<android.nfc.INfcAdapter: byte[] transceiveAuthData(byte[])>
<android.nfc.INfcAdapter: void changeDiscoveryTech(android.os.IBinder,int,int)>
<android.nfc.INfcAdapter: void addNfcUnlockHandler(android.nfc.INfcUnlockHandler,int[])>
<android.nfc.INfcAdapter: int getState()>
<android.nfc.INfcAdapter: void setDefaultRoutingDestination(java.lang.String)>
<android.nfc.INfcAdapter: void NetworkResetAtt()>
<android.nfc.INfcAdapter: byte[] StartLedCover()>
<android.nfc.INfcAdapter: android.nfc.NfcAntennaInfo getNfcAntennaInfo()>
<android.nfc.INfcAdapter: boolean writeFelicaLockState(java.lang.String,java.lang.String,java.lang.String)>
<android.nfc.INfcAdapter: boolean isReaderOptionEnabled()>
<android.nfc.INfcAdapter: android.nfc.INfcFCardEmulation getNfcFCardEmulationInterface()>
<android.nfc.INfcAdapter: void verifyNfcPermission()>
<android.nfc.INfcAdapter: boolean ignore(int,int,android.nfc.ITagRemovedCallback)>
<android.nfc.INfcAdapter: java.lang.String getDefaultRoutingDestination()>
<android.nfc.INfcAdapter: android.nfc.INfcDta getNfcDtaInterface(java.lang.String)>
<android.nfc.INfcAdapter: void storeEnableHistory(java.lang.String[])>
<android.nfc.INfcAdapter: java.util.Map getTagIntentAppPreferenceForUser(int)>
<android.nfc.INfcAdapter: void setReaderMode(android.os.IBinder,android.nfc.IAppCallback,int,android.os.Bundle)>
<android.nfc.INfcAdapter: void pausePolling(int)>
<android.nfc.INfcAdapter: void enableDisableSeTestMode(java.lang.String,boolean)>
<android.nfc.INfcAdapter: byte[] startCoverAuth()>
<android.nfc.INfcAdapter: android.nfc.INfcCardEmulation getNfcCardEmulationInterface()>
<android.nfc.INfcAdapter: boolean isTagIntentAppPreferenceSupported()>
<android.nfc.INfcAdapter: boolean readerEnable()>
<android.nfc.INfcAdapter: void resumePolling()>
<android.nfc.INfcAdapter: byte[] TransceiveLedCover(byte[])>
<android.nfc.INfcAdapter: boolean SetWirelessChargeEnabled(boolean)>
<android.nfc.INfcAdapter: boolean disable(boolean)>
<android.nfc.INfcAdapter: boolean StopLedCover()>
<android.nfc.INfcAdapter: void setAppCallback(android.nfc.IAppCallback)>
<android.nfc.INfcAdapter: boolean deviceSupportsReaderOption()>
<android.nfc.INfcAdapter: void dispatch(android.nfc.Tag)>
<android.nfc.INfcAdapter: boolean deviceSupportsNfcSecure()>
<android.nfc.INfcAdapter: void removeNfcUnlockHandler(android.nfc.INfcUnlockHandler)>
<android.nfc.INfcAdapter: boolean isControllerAlwaysOn()>
<android.nfc.INfcAdapter: void copyUtilityFiles()>
<android.nfc.INfcAdapter: boolean isControllerAlwaysOnSupported()>
<android.nfc.INfcAdapter: boolean stopCoverAuth()>
<android.nfc.INfcAdapter: int setTagIntentAppPreferenceForUser(int,java.lang.String,boolean)>
<android.nfc.INfcAdapter: boolean readerDisable()>
<android.nfc.INfcAdapter: boolean enable()>
<android.nfc.INfcAdapter: boolean isNfcSecureEnabled()>
<android.nfc.INfcAdapter: android.nfc.INfcTag getNfcTagInterface()>
<android.nfc.INfcAdapter: void registerControllerAlwaysOnListener(android.nfc.INfcControllerAlwaysOnListener)>
<android.nfc.INfcAdapter: boolean setNfcSecure(boolean)>
<android.nfc.INfcAdapter: byte[] apcCommand(int,byte[])>
<com.samsung.android.wifi.SemTasPolicyListener: void onTasPolicyChanged(int,int)>
<android.hardware.camera2.extension.ISessionProcessorImpl: int startCapture(android.hardware.camera2.extension.ICaptureCallback,boolean)>
<android.hardware.camera2.extension.ISessionProcessorImpl: int startRepeating(android.hardware.camera2.extension.ICaptureCallback)>
<android.hardware.camera2.extension.ISessionProcessorImpl: int startTrigger(android.hardware.camera2.CaptureRequest,android.hardware.camera2.extension.ICaptureCallback)>
<android.hardware.camera2.extension.ISessionProcessorImpl: void stopRepeating()>
<android.hardware.camera2.extension.ISessionProcessorImpl: android.hardware.camera2.extension.LatencyPair getRealtimeCaptureLatency()>
<android.hardware.camera2.extension.ISessionProcessorImpl: void setParameters(android.hardware.camera2.CaptureRequest)>
<android.hardware.camera2.extension.ISessionProcessorImpl: void deInitSession(android.os.IBinder)>
<android.hardware.camera2.extension.ISessionProcessorImpl: void onCaptureSessionStart(android.hardware.camera2.extension.IRequestProcessorImpl)>
<android.hardware.camera2.extension.ISessionProcessorImpl: android.hardware.camera2.extension.CameraSessionConfig initSession(android.os.IBinder,java.lang.String,java.util.Map,android.hardware.camera2.extension.OutputSurface,android.hardware.camera2.extension.OutputSurface,android.hardware.camera2.extension.OutputSurface)>
<android.hardware.camera2.extension.ISessionProcessorImpl: void onCaptureSessionEnd()>
<android.app.trust.IStrongAuthTracker: void onStrongAuthRequiredChanged(int,int)>
<android.app.trust.IStrongAuthTracker: void onIsNonStrongBiometricAllowedChanged(boolean,int)>
<android.hardware.ICameraServiceProxy: boolean isCameraDisabled(int)>
<android.hardware.ICameraServiceProxy: void pingForUserUpdate()>
<android.hardware.ICameraServiceProxy: int getAutoframingOverride(java.lang.String)>
<android.hardware.ICameraServiceProxy: int getRotateAndCropOverride(java.lang.String,int,int)>
<android.hardware.ICameraServiceProxy: void notifyCameraState(android.hardware.CameraSessionStats)>
<com.android.internal.telecom.ICallDiagnosticServiceAdapter: void displayDiagnosticMessage(java.lang.String,int,java.lang.CharSequence)>
<com.android.internal.telecom.ICallDiagnosticServiceAdapter: void overrideDisconnectMessage(java.lang.String,java.lang.CharSequence)>
<com.android.internal.telecom.ICallDiagnosticServiceAdapter: void sendDeviceToDeviceMessage(java.lang.String,int,int)>
<com.android.internal.telecom.ICallDiagnosticServiceAdapter: void clearDiagnosticMessage(java.lang.String,int)>
<com.android.internal.app.IAppOpsNotedCallback: void opNoted(int,int,java.lang.String,java.lang.String,int,int)>
<android.app.IAlarmCompleteListener: void alarmComplete(android.os.IBinder)>
<com.samsung.android.camera.iris.IIrisService: void setActiveUser(int)>
<com.samsung.android.camera.iris.IIrisService: java.util.List getEnrolledIrises(int,java.lang.String)>
<com.samsung.android.camera.iris.IIrisService: void cancelAuthentication(android.os.IBinder,java.lang.String)>
<com.samsung.android.camera.iris.IIrisService: long preEnroll(android.os.IBinder)>
<com.samsung.android.camera.iris.IIrisService: long getAuthenticatorId(java.lang.String)>
<com.samsung.android.camera.iris.IIrisService: void enroll(android.os.IBinder,android.os.IBinder,int,int,int,int,byte[],int,com.samsung.android.camera.iris.IIrisServiceReceiver,int,java.lang.String,android.os.Bundle)>
<com.samsung.android.camera.iris.IIrisService: void resetTimeout(byte[])>
<com.samsung.android.camera.iris.IIrisService: void setIrisViewType(int,java.lang.String,int)>
<com.samsung.android.camera.iris.IIrisService: void authenticate(android.os.IBinder,android.os.IBinder,int,int,int,int,long,int,com.samsung.android.camera.iris.IIrisServiceReceiver,int,java.lang.String,android.os.Bundle,byte[])>
<com.samsung.android.camera.iris.IIrisService: void prepareForAuthentication(boolean,android.os.IBinder,long,int,android.hardware.biometrics.IBiometricSensorReceiver,java.lang.String,int,int,int,int,android.os.Bundle)>
<com.samsung.android.camera.iris.IIrisService: int postEnroll(android.os.IBinder)>
<com.samsung.android.camera.iris.IIrisService: void prompt_authenticate(android.os.IBinder,android.os.IBinder,int,int,int,int,long,int,com.samsung.android.camera.iris.IIrisServiceReceiver,int,java.lang.String,android.os.Bundle,byte[])>
<com.samsung.android.camera.iris.IIrisService: boolean hasDisabledIris(int,java.lang.String)>
<com.samsung.android.camera.iris.IIrisService: void cancelAuthenticationFromService(android.os.IBinder,java.lang.String,int,int,int,boolean)>
<com.samsung.android.camera.iris.IIrisService: void rename(int,int,java.lang.String)>
<com.samsung.android.camera.iris.IIrisService: void remove(android.os.IBinder,int,int,int,com.samsung.android.camera.iris.IIrisServiceReceiver)>
<com.samsung.android.camera.iris.IIrisService: int request(android.os.IBinder,int,byte[],byte[],int,int,com.samsung.android.camera.iris.IIrisServiceReceiver)>
<com.samsung.android.camera.iris.IIrisService: void addLockoutResetCallback(com.samsung.android.camera.iris.IIrisServiceLockoutResetCallback)>
<com.samsung.android.camera.iris.IIrisService: void enableIRImageCallback(int,java.lang.String,int)>
<com.samsung.android.camera.iris.IIrisService: boolean hasEnrolledIrises(int,java.lang.String)>
<com.samsung.android.camera.iris.IIrisService: void cancelEnrollment(android.os.IBinder)>
<com.samsung.android.camera.iris.IIrisService: void startPreparedClient(int)>
<com.samsung.android.camera.iris.IIrisService: boolean isHardwareDetected(long,java.lang.String)>
<android.hardware.biometrics.common.ICancellationSignal: java.lang.String getInterfaceHash()>
<android.hardware.biometrics.common.ICancellationSignal: int getInterfaceVersion()>
<android.hardware.biometrics.common.ICancellationSignal: void cancel()>
<com.samsung.android.ims.options.SemImsCapabilityService: com.samsung.android.ims.options.SemCapabilities getCapabilities(java.lang.String,int,int)>
<com.samsung.android.ims.options.SemImsCapabilityService: com.samsung.android.ims.options.SemCapabilities getOwnCapabilities(int)>
<com.samsung.android.ims.options.SemImsCapabilityService: void unregisterListener(java.lang.String,int)>
<com.samsung.android.ims.options.SemImsCapabilityService: java.lang.String registerListener(com.samsung.android.ims.options.SemCapabilityServiceEventListener,int)>
<com.samsung.android.ims.options.SemImsCapabilityService: com.samsung.android.ims.options.SemCapabilities[] getCapabilitiesByContactId(java.lang.String,int,int)>
<com.samsung.android.ims.options.SemImsCapabilityService: com.samsung.android.ims.options.SemCapabilities getCapabilitiesByNumber(java.lang.String,int,boolean,int)>
<android.security.IKeyChainAliasCallback: void alias(java.lang.String)>
<android.os.IVibratorStateListener: void onVibrating(boolean)>
<android.database.IContentObserver: void onChangeEtc(boolean,android.net.Uri[],int,int)>
<android.database.IContentObserver: void onChange(boolean,android.net.Uri,int)>
<android.media.tv.interactive.ITvInteractiveAppSession: void notifyTvMessage(int,android.os.Bundle)>
<android.media.tv.interactive.ITvInteractiveAppSession: void notifySignalStrength(int)>
<android.media.tv.interactive.ITvInteractiveAppSession: void notifyRecordingStopped(java.lang.String)>
<android.media.tv.interactive.ITvInteractiveAppSession: void notifyAdResponse(android.media.tv.AdResponse)>
<android.media.tv.interactive.ITvInteractiveAppSession: void removeMediaView()>
<android.media.tv.interactive.ITvInteractiveAppSession: void sendStreamVolume(float)>
<android.media.tv.interactive.ITvInteractiveAppSession: void setSurface(android.view.Surface)>
<android.media.tv.interactive.ITvInteractiveAppSession: void startInteractiveApp()>
<android.media.tv.interactive.ITvInteractiveAppSession: void notifyAdBufferConsumed(android.media.tv.AdBuffer)>
<android.media.tv.interactive.ITvInteractiveAppSession: void notifyTimeShiftStartPositionChanged(java.lang.String,long)>
<android.media.tv.interactive.ITvInteractiveAppSession: void notifyRecordingConnectionFailed(java.lang.String,java.lang.String)>
<android.media.tv.interactive.ITvInteractiveAppSession: void destroyBiInteractiveApp(java.lang.String)>
<android.media.tv.interactive.ITvInteractiveAppSession: void sendTvRecordingInfo(android.media.tv.TvRecordingInfo)>
<android.media.tv.interactive.ITvInteractiveAppSession: void createMediaView(android.os.IBinder,android.graphics.Rect)>
<android.media.tv.interactive.ITvInteractiveAppSession: void notifyRecordingScheduled(java.lang.String,java.lang.String)>
<android.media.tv.interactive.ITvInteractiveAppSession: void release()>
<android.media.tv.interactive.ITvInteractiveAppSession: void notifyTracksChanged(java.util.List)>
<android.media.tv.interactive.ITvInteractiveAppSession: void createBiInteractiveApp(android.net.Uri,android.os.Bundle)>
<android.media.tv.interactive.ITvInteractiveAppSession: void sendAvailableSpeeds(float[])>
<android.media.tv.interactive.ITvInteractiveAppSession: void sendCurrentChannelLcn(int)>
<android.media.tv.interactive.ITvInteractiveAppSession: void notifyTimeShiftCurrentPositionChanged(java.lang.String,long)>
<android.media.tv.interactive.ITvInteractiveAppSession: void resetInteractiveApp()>
<android.media.tv.interactive.ITvInteractiveAppSession: void stopInteractiveApp()>
<android.media.tv.interactive.ITvInteractiveAppSession: void notifyTimeShiftPlaybackParams(android.media.PlaybackParams)>
<android.media.tv.interactive.ITvInteractiveAppSession: void sendCurrentVideoBounds(android.graphics.Rect)>
<android.media.tv.interactive.ITvInteractiveAppSession: void notifyTuned(android.net.Uri)>
<android.media.tv.interactive.ITvInteractiveAppSession: void sendCurrentTvInputId(java.lang.String)>
<android.media.tv.interactive.ITvInteractiveAppSession: void notifyTimeShiftStatusChanged(java.lang.String,int)>
<android.media.tv.interactive.ITvInteractiveAppSession: void notifyRecordingError(java.lang.String,int)>
<android.media.tv.interactive.ITvInteractiveAppSession: void notifyRecordingTuned(java.lang.String,android.net.Uri)>
<android.media.tv.interactive.ITvInteractiveAppSession: void notifyContentAllowed()>
<android.media.tv.interactive.ITvInteractiveAppSession: void notifyVideoUnavailable(int)>
<android.media.tv.interactive.ITvInteractiveAppSession: void relayoutMediaView(android.graphics.Rect)>
<android.media.tv.interactive.ITvInteractiveAppSession: void notifyBroadcastInfoResponse(android.media.tv.BroadcastInfoResponse)>
<android.media.tv.interactive.ITvInteractiveAppSession: void notifyContentBlocked(java.lang.String)>
<android.media.tv.interactive.ITvInteractiveAppSession: void notifyRecordingDisconnected(java.lang.String,java.lang.String)>
<android.media.tv.interactive.ITvInteractiveAppSession: void notifyTrackSelected(int,java.lang.String)>
<android.media.tv.interactive.ITvInteractiveAppSession: void sendSigningResult(java.lang.String,byte[])>
<android.media.tv.interactive.ITvInteractiveAppSession: void sendTrackInfoList(java.util.List)>
<android.media.tv.interactive.ITvInteractiveAppSession: void notifyVideoAvailable()>
<android.media.tv.interactive.ITvInteractiveAppSession: void sendTvRecordingInfoList(java.util.List)>
<android.media.tv.interactive.ITvInteractiveAppSession: void notifyError(java.lang.String,android.os.Bundle)>
<android.media.tv.interactive.ITvInteractiveAppSession: void sendTimeShiftMode(int)>
<android.media.tv.interactive.ITvInteractiveAppSession: void setTeletextAppEnabled(boolean)>
<android.media.tv.interactive.ITvInteractiveAppSession: void dispatchSurfaceChanged(int,int,int)>
<android.media.tv.interactive.ITvInteractiveAppSession: void notifyRecordingStarted(java.lang.String,java.lang.String)>
<android.media.tv.interactive.ITvInteractiveAppSession: void sendCurrentChannelUri(android.net.Uri)>
<com.samsung.android.bio.fingerprint.ISemFingerprintAodController: void turnOffDozeMode()>
<com.samsung.android.bio.fingerprint.ISemFingerprintAodController: void turnOnDozeHlpmMode()>
<com.samsung.android.bio.fingerprint.ISemFingerprintAodController: void turnOnDozeMode()>
<com.samsung.android.bio.fingerprint.ISemFingerprintAodController: void hideAodScreen()>
<com.samsung.android.bio.fingerprint.ISemFingerprintAodController: void turnOffDozeHlpmMode()>
<com.android.internal.telephony.IIntegerConsumer: void accept(int)>
<android.hardware.radio.IAnnouncementListener: void onListUpdated(java.util.List)>
<android.os.IVibratorManagerService: void vibrate(int,int,java.lang.String,android.os.CombinedVibration,android.os.VibrationAttributes,java.lang.String,android.os.IBinder)>
<android.os.IVibratorManagerService: int getSupportedVibratorGroup()>
<android.os.IVibratorManagerService: boolean registerVibratorStateListener(int,android.os.IVibratorStateListener)>
<android.os.IVibratorManagerService: void cancelVibrate(int,android.os.IBinder)>
<android.os.IVibratorManagerService: android.os.VibratorInfo getVibratorInfo(int)>
<android.os.IVibratorManagerService: boolean isVibrating(int)>
<android.os.IVibratorManagerService: boolean unregisterVibratorStateListener(int,android.os.IVibratorStateListener)>
<android.os.IVibratorManagerService: int[] getVibratorIds()>
<android.os.IVibratorManagerService: int semGetNumberOfSupportedPatterns()>
<android.os.IVibratorManagerService: boolean setAlwaysOnEffect(int,java.lang.String,int,android.os.CombinedVibration,android.os.VibrationAttributes)>
<com.samsung.android.ims.SemImsRegiListener: void onDeregistered(com.samsung.android.ims.SemImsRegistration,com.samsung.android.ims.SemImsRegistrationError)>
<com.samsung.android.ims.SemImsRegiListener: void onRegistered(com.samsung.android.ims.SemImsRegistration)>
<android.content.IRestrictionsManager: android.os.Bundle getApplicationRestrictions(java.lang.String)>
<android.content.IRestrictionsManager: android.content.Intent createLocalApprovalIntent()>
<android.content.IRestrictionsManager: boolean hasRestrictionsProvider()>
<android.content.IRestrictionsManager: java.util.List getApplicationRestrictionsPerAdminForUser(int,java.lang.String)>
<android.content.IRestrictionsManager: void notifyPermissionResponse(java.lang.String,android.os.PersistableBundle)>
<android.content.IRestrictionsManager: void requestPermission(java.lang.String,java.lang.String,java.lang.String,android.os.PersistableBundle)>
<android.hardware.usb.IUsbSerialReader: java.lang.String getSerial(java.lang.String)>
<android.hardware.lights.ILightsManager: void closeSession(android.os.IBinder)>
<android.hardware.lights.ILightsManager: android.hardware.lights.LightState getLightState(int)>
<android.hardware.lights.ILightsManager: java.util.List getLights()>
<android.hardware.lights.ILightsManager: void setLightStates(android.os.IBinder,int[],android.hardware.lights.LightState[])>
<android.hardware.lights.ILightsManager: void openSession(android.os.IBinder,int)>
<android.media.INearbyMediaDevicesUpdateCallback: void onDevicesUpdated(java.util.List)>
<android.hardware.hdmi.IHdmiMhlVendorCommandListener: void onReceived(int,int,int,byte[])>
<android.telephony.ims.aidl.IPublishResponseCallback: void onNetworkResponse(android.telephony.ims.SipDetails)>
<android.telephony.ims.aidl.IPublishResponseCallback: void onCommandError(int)>
<android.app.smartspace.ISmartspaceCallback: void onResult(android.content.pm.ParceledListSlice)>
<android.os.IUpdateEngineCallback: void onStatusUpdate(int,float)>
<android.os.IUpdateEngineCallback: void onPayloadApplicationComplete(int)>
<android.speech.tts.ITextToSpeechSessionCallback: void onConnected(android.speech.tts.ITextToSpeechSession,android.os.IBinder)>
<android.speech.tts.ITextToSpeechSessionCallback: void onDisconnected()>
<android.speech.tts.ITextToSpeechSessionCallback: void onError(java.lang.String)>
<android.window.IWindowOrganizerController: int applySyncTransaction(android.window.WindowContainerTransaction,android.window.IWindowContainerTransactionCallback)>
<android.window.IWindowOrganizerController: android.window.IDisplayAreaOrganizerController getDisplayAreaOrganizerController()>
<android.window.IWindowOrganizerController: android.os.IBinder getApplyToken()>
<android.window.IWindowOrganizerController: void registerTransitionPlayer(android.window.ITransitionPlayer)>
<android.window.IWindowOrganizerController: int finishTransition(android.os.IBinder,android.window.WindowContainerTransaction,android.window.IWindowContainerTransactionCallback)>
<android.window.IWindowOrganizerController: void startTransition(android.os.IBinder,android.window.WindowContainerTransaction)>
<android.window.IWindowOrganizerController: android.window.ITaskOrganizerController getTaskOrganizerController()>
<android.window.IWindowOrganizerController: android.window.ITransitionMetricsReporter getTransitionMetricsReporter()>
<android.window.IWindowOrganizerController: int startLegacyTransition(int,android.view.RemoteAnimationAdapter,android.window.IWindowContainerTransactionCallback,android.window.WindowContainerTransaction)>
<android.window.IWindowOrganizerController: void applyTransaction(android.window.WindowContainerTransaction)>
<android.window.IWindowOrganizerController: android.window.ITaskFragmentOrganizerController getTaskFragmentOrganizerController()>
<android.window.IWindowOrganizerController: android.os.IBinder startNewTransition(int,android.window.WindowContainerTransaction)>
<android.hardware.hdmi.IHdmiControlCallback: void onComplete(int)>
<android.view.contentcapture.IDataShareWriteAdapter: void finish()>
<android.view.contentcapture.IDataShareWriteAdapter: void error(int)>
<android.view.contentcapture.IDataShareWriteAdapter: void rejected()>
<android.view.contentcapture.IDataShareWriteAdapter: void write(android.os.ParcelFileDescriptor)>
<android.security.maintenance.IKeystoreMaintenance: void earlyBootEnded()>
<android.security.maintenance.IKeystoreMaintenance: int getState(int)>
<android.security.maintenance.IKeystoreMaintenance: void onDeviceOffBody()>
<android.security.maintenance.IKeystoreMaintenance: byte[] getRotValue()>
<android.security.maintenance.IKeystoreMaintenance: void onUserAdded(int)>
<android.security.maintenance.IKeystoreMaintenance: void onUserPasswordChanged(int,byte[])>
<android.security.maintenance.IKeystoreMaintenance: void onUserRemoved(int)>
<android.security.maintenance.IKeystoreMaintenance: void migrateKeyNamespace(android.system.keystore2.KeyDescriptor,android.system.keystore2.KeyDescriptor)>
<android.security.maintenance.IKeystoreMaintenance: void clearNamespace(int,long)>
<android.security.maintenance.IKeystoreMaintenance: void deleteAllKeys()>
<com.samsung.android.content.smartclip.ISpenGestureHoverListener: void onBackPressed()>
<com.samsung.android.content.smartclip.ISpenGestureHoverListener: void onHoverEnter()>
<com.samsung.android.content.smartclip.ISpenGestureHoverListener: void onHoverExitTowardBack()>
<com.samsung.android.content.smartclip.ISpenGestureHoverListener: void onHoverExit()>
<com.samsung.android.content.smartclip.ISpenGestureHoverListener: void onHoverStay(int,int)>
<android.security.rkp.IGetKeyCallback: void onSuccess(android.security.rkp.RemotelyProvisionedKey)>
<android.security.rkp.IGetKeyCallback: void onError(byte,java.lang.String)>
<android.security.rkp.IGetKeyCallback: void onCancel()>
<com.samsung.android.icccgrdm.IGrdmIntegrityControlCheckCenter: byte[] grdmSetAttestationData(byte[])>
<com.android.internal.compat.IPlatformCompatNative: void reportChangeByUid(long,int)>
<com.android.internal.compat.IPlatformCompatNative: boolean isChangeEnabledByUid(long,int)>
<com.android.internal.compat.IPlatformCompatNative: boolean isChangeEnabledByPackageName(long,java.lang.String,int)>
<com.android.internal.compat.IPlatformCompatNative: void reportChangeByPackageName(long,java.lang.String,int)>
<android.media.tv.interactive.ITvInteractiveAppService: void createSession(android.view.InputChannel,android.media.tv.interactive.ITvInteractiveAppSessionCallback,java.lang.String,int)>
<android.media.tv.interactive.ITvInteractiveAppService: void sendAppLinkCommand(android.os.Bundle)>
<android.media.tv.interactive.ITvInteractiveAppService: void registerCallback(android.media.tv.interactive.ITvInteractiveAppServiceCallback)>
<android.media.tv.interactive.ITvInteractiveAppService: void unregisterAppLinkInfo(android.media.tv.interactive.AppLinkInfo)>
<android.media.tv.interactive.ITvInteractiveAppService: void registerAppLinkInfo(android.media.tv.interactive.AppLinkInfo)>
<android.media.tv.interactive.ITvInteractiveAppService: void unregisterCallback(android.media.tv.interactive.ITvInteractiveAppServiceCallback)>
<com.samsung.android.media.IResourceManagerObserver: com.samsung.android.media.GetCodecCapacityReturn getCodecCapacity(int)>
<com.samsung.android.media.IResourceManagerObserver: void disconnect()>
<com.samsung.android.media.IResourceManagerObserver: int setResourcePriority(int)>
<com.samsung.android.media.IResourceManagerObserver: com.samsung.android.media.GetResourceInfoReturn getResourceInfo(int)>
<com.samsung.android.media.IResourceManagerObserver: int enableObserver(int,int)>
<android.view.IOnKeyguardExitResult: void onKeyguardExitResult(boolean)>
<android.hardware.gnss.IGnssPsdsCallback: java.lang.String getInterfaceHash()>
<android.hardware.gnss.IGnssPsdsCallback: void downloadRequestCb(int)>
<android.hardware.gnss.IGnssPsdsCallback: int getInterfaceVersion()>
<android.hardware.biometrics.ITestSessionCallback: void onCleanupFinished(int)>
<android.hardware.biometrics.ITestSessionCallback: void onCleanupStarted(int)>
<com.android.internal.telephony.ITelephony: void registerFeatureProvisioningChangedCallback(int,android.telephony.ims.aidl.IFeatureProvisioningCallback)>
<com.android.internal.telephony.ITelephony: android.telephony.CarrierRestrictionRules getAllowedCarriers()>
<com.android.internal.telephony.ITelephony: void setRcsClientConfiguration(int,android.telephony.ims.RcsClientConfiguration)>
<com.android.internal.telephony.ITelephony: java.lang.String getNetworkCountryIsoForPhone(int)>
<com.android.internal.telephony.ITelephony: boolean handlePinMmi(java.lang.String)>
<com.android.internal.telephony.ITelephony: java.lang.String getBoundImsServicePackage(int,boolean,int)>
<com.android.internal.telephony.ITelephony: int getVoiceActivationState(int,java.lang.String)>
<com.android.internal.telephony.ITelephony: boolean isAvailable(int,int,int)>
<com.android.internal.telephony.ITelephony: int getActivePhoneTypeForSlot(int)>
<com.android.internal.telephony.ITelephony: boolean isImsRegistered(int)>
<com.android.internal.telephony.ITelephony: void switchMultiSimConfig(int)>
<com.android.internal.telephony.ITelephony: boolean setVoiceMailNumber(int,java.lang.String,java.lang.String)>
<com.android.internal.telephony.ITelephony: int getSubIdForPhoneAccountHandle(android.telecom.PhoneAccountHandle,java.lang.String,java.lang.String)>
<com.android.internal.telephony.ITelephony: boolean nvWriteCdmaPrl(byte[])>
<com.android.internal.telephony.ITelephony: java.lang.String iccTransmitApduLogicalChannelByPort(int,int,int,int,int,int,int,int,java.lang.String)>
<com.android.internal.telephony.ITelephony: void setCellInfoListRate(int,int)>
<com.android.internal.telephony.ITelephony: android.content.ComponentName getDefaultRespondViaMessageApplication(int,boolean)>
<com.android.internal.telephony.ITelephony: boolean isNrDualConnectivityEnabled(int)>
<com.android.internal.telephony.ITelephony: void requestIsSatelliteCommunicationAllowedForCurrentLocation(int,android.os.ResultReceiver)>
<com.android.internal.telephony.ITelephony: android.telephony.PhoneCapability getPhoneCapability()>
<com.android.internal.telephony.ITelephony: void isMmTelCapabilitySupported(int,com.android.internal.telephony.IIntegerConsumer,int,int)>
<com.android.internal.telephony.ITelephony: boolean getDeviceUceEnabled()>
<com.android.internal.telephony.ITelephony: int getVoiceMessageCountForSubscriber(int,java.lang.String,java.lang.String)>
<com.android.internal.telephony.ITelephony: void setImsProvisioningStatusForCapability(int,int,int,boolean)>
<com.android.internal.telephony.ITelephony: int getAllowedNetworkTypesBitmask(int)>
<com.android.internal.telephony.ITelephony: boolean isDataEnabled(int)>
<com.android.internal.telephony.ITelephony: java.util.List getCarrierPackageNamesForIntentAndPhone(android.content.Intent,int)>
<com.android.internal.telephony.ITelephony: int getCallComposerStatus(int)>
<com.android.internal.telephony.ITelephony: int getDataActivityForSubId(int)>
<com.android.internal.telephony.ITelephony: boolean isCapable(int,int,int)>
<com.android.internal.telephony.ITelephony: void setDeviceToDeviceForceEnabled(boolean)>
<com.android.internal.telephony.ITelephony: void unregisterImsRegistrationCallback(int,android.telephony.ims.aidl.IImsRegistrationCallback)>
<com.android.internal.telephony.ITelephony: void requestCellInfoUpdate(int,android.telephony.ICellInfoCallback,java.lang.String,java.lang.String)>
<com.android.internal.telephony.ITelephony: int changeIccLockPassword(int,java.lang.String,java.lang.String)>
<com.android.internal.telephony.ITelephony: java.lang.String[] getMergedSubscriberIds(int,java.lang.String,java.lang.String)>
<com.android.internal.telephony.ITelephony: void setCarrierServicePackageOverride(int,java.lang.String,java.lang.String)>
<com.android.internal.telephony.ITelephony: boolean setRadioForSubscriber(int,boolean)>
<com.android.internal.telephony.ITelephony: int getSubscriptionSpecificCarrierId(int)>
<com.android.internal.telephony.ITelephony: java.util.List getUiccCardsInfo(java.lang.String)>
<com.android.internal.telephony.ITelephony: void disableIms(int)>
<com.android.internal.telephony.ITelephony: int getLteOnCdmaMode(java.lang.String,java.lang.String)>
<com.android.internal.telephony.ITelephony: void getCallForwarding(int,int,com.android.internal.telephony.ICallForwardingInfoCallback)>
<com.android.internal.telephony.ITelephony: boolean setGbaReleaseTimeOverride(int,int)>
<com.android.internal.telephony.ITelephony: void setVoWiFiModeSetting(int,int)>
<com.android.internal.telephony.ITelephony: int getVoWiFiModeSetting(int)>
<com.android.internal.telephony.ITelephony: boolean isConcurrentVoiceAndDataAllowed(int)>
<com.android.internal.telephony.ITelephony: java.lang.String getManualNetworkSelectionPlmn(int)>
<com.android.internal.telephony.ITelephony: boolean isRttSupported(int)>
<com.android.internal.telephony.ITelephony: void registerMmTelCapabilityCallback(int,android.telephony.ims.aidl.IImsCapabilityCallback)>
<com.android.internal.telephony.ITelephony: java.util.List getPackagesWithCarrierPrivilegesForAllPhones()>
<com.android.internal.telephony.ITelephony: int prepareForUnattendedReboot()>
<com.android.internal.telephony.ITelephony: int[] supplyPinReportResultForSubscriber(int,java.lang.String)>
<com.android.internal.telephony.ITelephony: void triggerRcsReconfiguration(int)>
<com.android.internal.telephony.ITelephony: boolean setRadioPower(boolean)>
<com.android.internal.telephony.ITelephony: void purchasePremiumCapability(int,com.android.internal.telephony.IIntegerConsumer,int)>
<com.android.internal.telephony.ITelephony: int registerForSatelliteProvisionStateChanged(int,android.telephony.satellite.ISatelliteProvisionStateCallback)>
<com.android.internal.telephony.ITelephony: void setVoWiFiRoamingModeSetting(int,int)>
<com.android.internal.telephony.ITelephony: void getImsMmTelRegistrationState(int,com.android.internal.telephony.IIntegerConsumer)>
<com.android.internal.telephony.ITelephony: boolean isVideoTelephonyAvailable(int)>
<com.android.internal.telephony.ITelephony: void unregisterImsProvisioningChangedCallback(int,android.telephony.ims.aidl.IImsConfigCallback)>
<com.android.internal.telephony.ITelephony: void shutdownMobileRadios()>
<com.android.internal.telephony.ITelephony: java.lang.String getImsProvisioningString(int,int)>
<com.android.internal.telephony.ITelephony: java.lang.String getContactFromEab(java.lang.String)>
<com.android.internal.telephony.ITelephony: boolean isAdvancedCallingSettingEnabled(int)>
<com.android.internal.telephony.ITelephony: android.telephony.VisualVoicemailSmsFilterSettings getVisualVoicemailSmsFilterSettings(java.lang.String,int)>
<com.android.internal.telephony.ITelephony: int invokeOemRilRequestRaw(byte[],byte[])>
<com.android.internal.telephony.ITelephony: boolean isPremiumCapabilityAvailableForPurchase(int,int)>
<com.android.internal.telephony.ITelephony: void registerRcsProvisioningCallback(int,android.telephony.ims.aidl.IRcsConfigCallback)>
<com.android.internal.telephony.ITelephony: boolean setCdmaRoamingMode(int,int)>
<com.android.internal.telephony.ITelephony: void requestIsSatelliteSupported(int,android.os.ResultReceiver)>
<com.android.internal.telephony.ITelephony: void setCellBroadcastIdRanges(int,java.util.List,com.android.internal.telephony.IIntegerConsumer)>
<com.android.internal.telephony.ITelephony: boolean setSatelliteGatewayServicePackageName(java.lang.String)>
<com.android.internal.telephony.ITelephony: boolean isManualNetworkSelectionAllowed(int)>
<com.android.internal.telephony.ITelephony: void requestIsDemoModeEnabled(int,android.os.ResultReceiver)>
<com.android.internal.telephony.ITelephony: int getDataActivity()>
<com.android.internal.telephony.ITelephony: boolean clearCarrierImsServiceOverride(int)>
<com.android.internal.telephony.ITelephony: int getCarrierPrivilegeStatusForUid(int,int)>
<com.android.internal.telephony.ITelephony: boolean enableDataConnectivity(java.lang.String)>
<com.android.internal.telephony.ITelephony: android.telephony.VisualVoicemailSmsFilterSettings getActiveVisualVoicemailSmsFilterSettings(int)>
<com.android.internal.telephony.ITelephony: void registerMmTelFeatureCallback(int,com.android.ims.internal.IImsServiceFeatureCallback)>
<com.android.internal.telephony.ITelephony: android.telephony.UiccSlotInfo[] getUiccSlotsInfo(java.lang.String)>
<com.android.internal.telephony.ITelephony: boolean disableDataConnectivity(java.lang.String)>
<com.android.internal.telephony.ITelephony: java.lang.String getCdmaEriTextForSubscriber(int,java.lang.String,java.lang.String)>
<com.android.internal.telephony.ITelephony: boolean getImsProvisioningStatusForCapability(int,int,int)>
<com.android.internal.telephony.ITelephony: void setRttCapabilitySetting(int,boolean)>
<com.android.internal.telephony.ITelephony: void setVtSettingEnabled(int,boolean)>
<com.android.internal.telephony.ITelephony: void setCallComposerStatus(int,int)>
<com.android.internal.telephony.ITelephony: void resetOtaEmergencyNumberDbFilePath()>
<com.android.internal.telephony.ITelephony: boolean needsOtaServiceProvisioning()>
<com.android.internal.telephony.ITelephony: boolean isApnMetered(int,int)>
<com.android.internal.telephony.ITelephony: int registerForSatelliteModemStateChanged(int,android.telephony.satellite.ISatelliteStateCallback)>
<com.android.internal.telephony.ITelephony: java.lang.String getLine1AlphaTagForDisplay(int,java.lang.String,java.lang.String)>
<com.android.internal.telephony.ITelephony: android.telephony.ims.RcsContactUceCapability removeUceRegistrationOverrideShell(int,java.util.List)>
<com.android.internal.telephony.ITelephony: boolean clearRadioPowerOffForReason(int,int)>
<com.android.internal.telephony.ITelephony: void setDeviceSingleRegistrationEnabledOverride(java.lang.String)>
<com.android.internal.telephony.ITelephony: java.lang.String getAidForAppType(int,int)>
<com.android.internal.telephony.ITelephony: int getGbaReleaseTime(int)>
<com.android.internal.telephony.ITelephony: boolean iccCloseLogicalChannel(com.android.internal.telephony.IccLogicalChannelRequest)>
<com.android.internal.telephony.ITelephony: byte[] iccExchangeSimIO(int,int,int,int,int,int,java.lang.String)>
<com.android.internal.telephony.ITelephony: void persistEmergencyCallDiagnosticData(java.lang.String,boolean,long,boolean,boolean)>
<com.android.internal.telephony.ITelephony: boolean switchSlots(int[])>
<com.android.internal.telephony.ITelephony: boolean enableModemForSlot(int,boolean)>
<com.android.internal.telephony.ITelephony: void unregisterForSatelliteDatagram(int,android.telephony.satellite.ISatelliteDatagramCallback)>
<com.android.internal.telephony.ITelephony: android.telecom.PhoneAccountHandle getPhoneAccountHandleForSubscriptionId(int)>
<com.android.internal.telephony.ITelephony: void toggleRadioOnOffForSubscriber(int)>
<com.android.internal.telephony.ITelephony: boolean isDataEnabledForReason(int,int)>
<com.android.internal.telephony.ITelephony: void disableLocationUpdates()>
<com.android.internal.telephony.ITelephony: void registerImsStateCallback(int,int,com.android.internal.telephony.IImsStateCallback,java.lang.String)>
<com.android.internal.telephony.ITelephony: void setSimPowerStateForSlot(int,int)>
<com.android.internal.telephony.ITelephony: java.lang.String getManufacturerCodeForSlot(int)>
<com.android.internal.telephony.ITelephony: boolean isRadioInterfaceCapabilitySupported(java.lang.String)>
<com.android.internal.telephony.ITelephony: void setSignalStrengthUpdateRequest(int,android.telephony.SignalStrengthUpdateRequest,java.lang.String)>
<com.android.internal.telephony.ITelephony: boolean canChangeDtmfToneLength(int,java.lang.String,java.lang.String)>
<com.android.internal.telephony.ITelephony: void setVoiceServiceStateOverride(int,boolean,java.lang.String)>
<com.android.internal.telephony.ITelephony: void unregisterImsFeatureCallback(com.android.ims.internal.IImsServiceFeatureCallback)>
<com.android.internal.telephony.ITelephony: boolean setLine1NumberForDisplayForSubscriber(int,java.lang.String,java.lang.String)>
<com.android.internal.telephony.ITelephony: void updateEmergencyNumberListTestMode(int,android.telephony.emergency.EmergencyNumber)>
<com.android.internal.telephony.ITelephony: android.telephony.ims.RcsContactUceCapability clearUceRegistrationOverrideShell(int)>
<com.android.internal.telephony.ITelephony: void setCrossSimCallingEnabled(int,boolean)>
<com.android.internal.telephony.ITelephony: void setRcsSingleRegistrationTestModeEnabled(boolean)>
<com.android.internal.telephony.ITelephony: void disableVisualVoicemailSmsFilter(java.lang.String,int)>
<com.android.internal.telephony.ITelephony: java.util.List getEquivalentHomePlmns(int,java.lang.String,java.lang.String)>
<com.android.internal.telephony.ITelephony: int getEmergencyNumberDbVersion(int)>
<com.android.internal.telephony.ITelephony: boolean isUserDataEnabled(int)>
<com.android.internal.telephony.ITelephony: void refreshUiccProfile(int)>
<com.android.internal.telephony.ITelephony: void setVoWiFiRoamingSettingEnabled(int,boolean)>
<com.android.internal.telephony.ITelephony: java.lang.String getSubscriptionCarrierName(int)>
<com.android.internal.telephony.ITelephony: java.lang.String getCapabilityFromEab(java.lang.String)>
<com.android.internal.telephony.ITelephony: void unregisterForSatelliteProvisionStateChanged(int,android.telephony.satellite.ISatelliteProvisionStateCallback)>
<com.android.internal.telephony.ITelephony: int checkCarrierPrivilegesForPackageAnyPhone(java.lang.String)>
<com.android.internal.telephony.ITelephony: void unregisterForSatelliteModemStateChanged(int,android.telephony.satellite.ISatelliteStateCallback)>
<com.android.internal.telephony.ITelephony: java.lang.String getCdmaEriText(java.lang.String,java.lang.String)>
<com.android.internal.telephony.ITelephony: boolean isDataEnabledForApn(int,int,java.lang.String)>
<com.android.internal.telephony.ITelephony: void setSystemSelectionChannels(java.util.List,int,com.android.internal.telephony.IBooleanConsumer)>
<com.android.internal.telephony.ITelephony: java.util.List getClientRequestStats(java.lang.String,java.lang.String,int)>
<com.android.internal.telephony.ITelephony: boolean isVtSettingEnabled(int)>
<com.android.internal.telephony.ITelephony: boolean canConnectTo5GInDsdsMode()>
<com.android.internal.telephony.ITelephony: java.util.List getTelephonyHistograms()>
<com.android.internal.telephony.ITelephony: java.lang.String nvReadItem(int)>
<com.android.internal.telephony.ITelephony: int removeContactFromEab(int,java.lang.String)>
<com.android.internal.telephony.ITelephony: void enableVisualVoicemailSmsFilter(java.lang.String,int,android.telephony.VisualVoicemailSmsFilterSettings)>
<com.android.internal.telephony.ITelephony: void setMultiSimCarrierRestriction(boolean)>
<com.android.internal.telephony.ITelephony: int setAllowedCarriers(android.telephony.CarrierRestrictionRules)>
<com.android.internal.telephony.ITelephony: void setSimPowerStateForSlotWithCallback(int,int,com.android.internal.telephony.IIntegerConsumer)>
<com.android.internal.telephony.ITelephony: void requestIsSatelliteProvisioned(int,android.os.ResultReceiver)>
<com.android.internal.telephony.ITelephony: int setVoNrEnabled(int,boolean)>
<com.android.internal.telephony.ITelephony: boolean isTtyOverVolteEnabled(int)>
<com.android.internal.telephony.ITelephony: boolean isWifiCallingAvailable(int)>
<com.android.internal.telephony.ITelephony: int getActivePhoneType()>
<com.android.internal.telephony.ITelephony: java.lang.String getSubscriptionSpecificCarrierName(int)>
<com.android.internal.telephony.ITelephony: java.lang.String getModemService()>
<com.android.internal.telephony.ITelephony: void onDeviceAlignedWithSatellite(int,boolean)>
<com.android.internal.telephony.ITelephony: long getAllowedNetworkTypesForReason(int,int)>
<com.android.internal.telephony.ITelephony: int checkCarrierPrivilegesForPackage(int,java.lang.String)>
<com.android.internal.telephony.ITelephony: java.lang.String getLastUcePidfXmlShell(int)>
<com.android.internal.telephony.ITelephony: void setActiveDeviceToDeviceTransport(java.lang.String)>
<com.android.internal.telephony.ITelephony: java.util.List getAllCellInfo(java.lang.String,java.lang.String)>
<com.android.internal.telephony.ITelephony: int setImsProvisioningInt(int,int,int)>
<com.android.internal.telephony.ITelephony: boolean isRadioOn(java.lang.String)>
<com.android.internal.telephony.ITelephony: int getCdmaRoamingMode(int)>
<com.android.internal.telephony.ITelephony: int getDataActivationState(int,java.lang.String)>
<com.android.internal.telephony.ITelephony: void setNetworkSelectionModeAutomatic(int)>
<com.android.internal.telephony.ITelephony: void enableIms(int)>
<com.android.internal.telephony.ITelephony: boolean requestRadioPowerOffForReason(int,int)>
<com.android.internal.telephony.ITelephony: java.lang.String getDeviceId(java.lang.String)>
<com.android.internal.telephony.ITelephony: boolean isMvnoMatched(int,int,java.lang.String)>
<com.android.internal.telephony.ITelephony: boolean setSatelliteListeningTimeoutDuration(long)>
<com.android.internal.telephony.ITelephony: void enableVideoCalling(boolean)>
<com.android.internal.telephony.ITelephony: java.lang.String getSimLocaleForSubscriber(int)>
<com.android.internal.telephony.ITelephony: boolean setBoundImsServiceOverride(int,boolean,int[],java.lang.String)>
<com.android.internal.telephony.ITelephony: java.lang.String sendEnvelopeWithStatus(int,java.lang.String)>
<com.android.internal.telephony.ITelephony: void unregisterRcsProvisioningCallback(int,android.telephony.ims.aidl.IRcsConfigCallback)>
<com.android.internal.telephony.ITelephony: boolean isModemEnabledForSlot(int,java.lang.String,java.lang.String)>
<com.android.internal.telephony.ITelephony: boolean setModemService(java.lang.String)>
<com.android.internal.telephony.ITelephony: void getSlicingConfig(android.os.ResultReceiver)>
<com.android.internal.telephony.ITelephony: boolean nvWriteItem(int,java.lang.String)>
<com.android.internal.telephony.ITelephony: void setImsRegistrationState(boolean)>
<com.android.internal.telephony.ITelephony: boolean isHearingAidCompatibilitySupported()>
<com.android.internal.telephony.ITelephony: int getRadioHalVersion()>
<com.android.internal.telephony.ITelephony: java.util.List getSlotsMapping(java.lang.String)>
<com.android.internal.telephony.ITelephony: void setDataRoamingEnabled(int,boolean)>
<com.android.internal.telephony.ITelephony: android.telephony.ims.aidl.IImsConfig getImsConfig(int,int)>
<com.android.internal.telephony.ITelephony: void registerImsRegistrationCallback(int,android.telephony.ims.aidl.IImsRegistrationCallback)>
<com.android.internal.telephony.ITelephony: int registerForSatelliteDatagram(int,android.telephony.satellite.ISatelliteDatagramCallback)>
<com.android.internal.telephony.ITelephony: boolean isMobileDataPolicyEnabled(int,int)>
<com.android.internal.telephony.ITelephony: int setIccLockEnabled(int,boolean,java.lang.String)>
<com.android.internal.telephony.ITelephony: void carrierActionResetAll(int)>
<com.android.internal.telephony.ITelephony: void unregisterImsStateCallback(com.android.internal.telephony.IImsStateCallback)>
<com.android.internal.telephony.ITelephony: int getLteOnCdmaModeForSubscriber(int,java.lang.String,java.lang.String)>
<com.android.internal.telephony.ITelephony: void setVoicemailRingtoneUri(java.lang.String,android.telecom.PhoneAccountHandle,android.net.Uri)>
<com.android.internal.telephony.ITelephony: boolean isDataConnectivityPossible(int)>
<com.android.internal.telephony.ITelephony: android.telephony.CellIdentity getCellLocation(java.lang.String,java.lang.String)>
<com.android.internal.telephony.ITelephony: com.android.internal.telephony.CellNetworkScanResult getCellNetworkScanResults(int,java.lang.String,java.lang.String)>
<com.android.internal.telephony.ITelephony: android.telephony.SignalStrength getSignalStrength(int)>
<com.android.internal.telephony.ITelephony: boolean isVoWiFiRoamingSettingEnabled(int)>
<com.android.internal.telephony.ITelephony: boolean isWorldPhone(int,java.lang.String,java.lang.String)>
<com.android.internal.telephony.ITelephony: boolean isRadioOnForSubscriberWithFeature(int,java.lang.String,java.lang.String)>
<com.android.internal.telephony.ITelephony: void stopNetworkScan(int,int)>
<com.android.internal.telephony.ITelephony: int getCallState()>
<com.android.internal.telephony.ITelephony: android.os.ICancellationSignal provisionSatelliteService(int,java.lang.String,byte[],com.android.internal.telephony.IIntegerConsumer)>
<com.android.internal.telephony.ITelephony: java.lang.String getCdmaMdn(int)>
<com.android.internal.telephony.ITelephony: java.lang.String[] getForbiddenPlmns(int,int,java.lang.String,java.lang.String)>
<com.android.internal.telephony.ITelephony: int sendThermalMitigationRequest(int,android.telephony.ThermalMitigationRequest,java.lang.String)>
<com.android.internal.telephony.ITelephony: java.lang.String getImeiForSlot(int,java.lang.String,java.lang.String)>
<com.android.internal.telephony.ITelephony: boolean isApplicationOnUicc(int,int)>
<com.android.internal.telephony.ITelephony: boolean getEmergencyCallbackMode(int)>
<com.android.internal.telephony.ITelephony: android.telephony.ServiceState getServiceStateForSubscriber(int,boolean,boolean,java.lang.String,java.lang.String)>
<com.android.internal.telephony.ITelephony: boolean setCarrierSingleRegistrationEnabledOverride(int,java.lang.String)>
<com.android.internal.telephony.ITelephony: boolean setCdmaSubscriptionMode(int,int)>
<com.android.internal.telephony.ITelephony: void requestUserActivityNotification()>
<com.android.internal.telephony.ITelephony: int getImsRegTechnologyForMmTel(int)>
<com.android.internal.telephony.ITelephony: java.lang.String getMeidForSlot(int,java.lang.String,java.lang.String)>
<com.android.internal.telephony.ITelephony: boolean isRadioOnForSubscriber(int,java.lang.String)>
<com.android.internal.telephony.ITelephony: void requestIsSatelliteEnabled(int,android.os.ResultReceiver)>
<com.android.internal.telephony.ITelephony: boolean doesSwitchMultiSimConfigTriggerReboot(int,java.lang.String,java.lang.String)>
<com.android.internal.telephony.ITelephony: void setAdvancedCallingSettingEnabled(int,boolean)>
<com.android.internal.telephony.ITelephony: java.lang.String getCarrierServicePackageNameForLogicalSlot(int)>
<com.android.internal.telephony.ITelephony: boolean isVideoCallingEnabled(java.lang.String,java.lang.String)>
<com.android.internal.telephony.ITelephony: void unregisterFeatureProvisioningChangedCallback(int,android.telephony.ims.aidl.IFeatureProvisioningCallback)>
<com.android.internal.telephony.ITelephony: void notifyRcsAutoConfigurationReceived(int,byte[],boolean)>
<com.android.internal.telephony.ITelephony: boolean setOperatorBrandOverride(int,java.lang.String)>
<com.android.internal.telephony.ITelephony: void requestNumberVerification(android.telephony.PhoneNumberRange,long,com.android.internal.telephony.INumberVerificationCallback,java.lang.String)>
<com.android.internal.telephony.ITelephony: int getHalVersion(int)>
<com.android.internal.telephony.ITelephony: boolean setNetworkSelectionModeManual(int,com.android.internal.telephony.OperatorInfo,boolean)>
<com.android.internal.telephony.ITelephony: java.util.List getCertsFromCarrierPrivilegeAccessRules(int)>
<com.android.internal.telephony.ITelephony: int getCdmaEriIconModeForSubscriber(int,java.lang.String,java.lang.String)>
<com.android.internal.telephony.ITelephony: boolean hasIccCardUsingSlotIndex(int)>
<com.android.internal.telephony.ITelephony: int getDataState()>
<com.android.internal.telephony.ITelephony: java.lang.String getVisualVoicemailPackageName(java.lang.String,java.lang.String,int)>
<com.android.internal.telephony.ITelephony: void requestModemActivityInfo(android.os.ResultReceiver)>
<com.android.internal.telephony.ITelephony: int getCdmaEriIconIndexForSubscriber(int,java.lang.String,java.lang.String)>
<com.android.internal.telephony.ITelephony: void userActivity()>
<com.android.internal.telephony.ITelephony: int requestNetworkScan(int,boolean,android.telephony.NetworkScanRequest,android.os.Messenger,android.os.IBinder,java.lang.String,java.lang.String)>
<com.android.internal.telephony.ITelephony: void sendSatelliteDatagram(int,int,android.telephony.satellite.SatelliteDatagram,boolean,com.android.internal.telephony.IIntegerConsumer)>
<com.android.internal.telephony.ITelephony: void toggleRadioOnOff()>
<com.android.internal.telephony.ITelephony: android.net.Uri getVoicemailRingtoneUri(android.telecom.PhoneAccountHandle)>
<com.android.internal.telephony.ITelephony: void setCallWaitingStatus(int,boolean,com.android.internal.telephony.IIntegerConsumer)>
<com.android.internal.telephony.ITelephony: int getCallStateForSubscription(int,java.lang.String,java.lang.String)>
<com.android.internal.telephony.ITelephony: java.lang.String getDeviceIdWithFeature(java.lang.String,java.lang.String)>
<com.android.internal.telephony.ITelephony: android.telephony.CellIdentity getLastKnownCellIdentity(int,java.lang.String,java.lang.String)>
<com.android.internal.telephony.ITelephony: void setDeviceUceEnabled(boolean)>
<com.android.internal.telephony.ITelephony: java.lang.String getCurrentPackageName()>
<com.android.internal.telephony.ITelephony: java.lang.String getMobileProvisioningUrl()>
<com.android.internal.telephony.ITelephony: boolean isIccLockEnabled(int)>
<com.android.internal.telephony.ITelephony: int getCardIdForDefaultEuicc(int,java.lang.String)>
<com.android.internal.telephony.ITelephony: void setCallForwarding(int,android.telephony.CallForwardingInfo,com.android.internal.telephony.IIntegerConsumer)>
<com.android.internal.telephony.ITelephony: int setForbiddenPlmns(int,int,java.util.List,java.lang.String,java.lang.String)>
<com.android.internal.telephony.ITelephony: boolean isRemovableEsimDefaultEuicc(java.lang.String)>
<com.android.internal.telephony.ITelephony: void carrierActionSetRadioEnabled(int,boolean)>
<com.android.internal.telephony.ITelephony: int getRadioAccessFamily(int,java.lang.String)>
<com.android.internal.telephony.ITelephony: boolean isInEmergencySmsMode()>
<com.android.internal.telephony.ITelephony: java.lang.String getPrimaryImei(java.lang.String,java.lang.String)>
<com.android.internal.telephony.ITelephony: void getImsMmTelRegistrationTransportType(int,com.android.internal.telephony.IIntegerConsumer)>
<com.android.internal.telephony.ITelephony: void updateOtaEmergencyNumberDbFilePath(android.os.ParcelFileDescriptor)>
<com.android.internal.telephony.ITelephony: boolean setRoamingOverride(int,java.util.List,java.util.List,java.util.List,java.util.List)>
<com.android.internal.telephony.ITelephony: void setRemovableEsimAsDefaultEuicc(boolean,java.lang.String)>
<com.android.internal.telephony.ITelephony: boolean isDataRoamingEnabled(int)>
<com.android.internal.telephony.ITelephony: java.lang.String getDeviceSoftwareVersionForSlot(int,java.lang.String,java.lang.String)>
<com.android.internal.telephony.ITelephony: java.util.List getNeighboringCellInfo(java.lang.String,java.lang.String)>
<com.android.internal.telephony.ITelephony: int getSubscriptionCarrierId(int)>
<com.android.internal.telephony.ITelephony: void requestTimeForNextSatelliteVisibility(int,android.os.ResultReceiver)>
<com.android.internal.telephony.ITelephony: java.util.List getShaIdFromAllowList(java.lang.String,int)>
<com.android.internal.telephony.ITelephony: int getDataNetworkType(java.lang.String,java.lang.String)>
<com.android.internal.telephony.ITelephony: java.lang.String getCdmaMin(int)>
<com.android.internal.telephony.ITelephony: void deprovisionSatelliteService(int,java.lang.String,com.android.internal.telephony.IIntegerConsumer)>
<com.android.internal.telephony.ITelephony: void enableLocationUpdates()>
<com.android.internal.telephony.ITelephony: android.os.Bundle getVisualVoicemailSettings(java.lang.String,int)>
<com.android.internal.telephony.ITelephony: void setVoicemailVibrationEnabled(java.lang.String,android.telecom.PhoneAccountHandle,boolean)>
<com.android.internal.telephony.ITelephony: boolean getDeviceSingleRegistrationEnabled()>
<com.android.internal.telephony.ITelephony: java.lang.String[] getMergedImsisFromGroup(int,java.lang.String)>
<com.android.internal.telephony.ITelephony: boolean isVoicemailVibrationEnabled(android.telecom.PhoneAccountHandle)>
<com.android.internal.telephony.ITelephony: java.lang.String getMmsUserAgent(int)>
<com.android.internal.telephony.ITelephony: boolean hasIccCard()>
<com.android.internal.telephony.ITelephony: boolean getDataEnabled(int)>
<com.android.internal.telephony.ITelephony: void updateServiceLocation()>
<com.android.internal.telephony.ITelephony: boolean supplyPukForSubscriber(int,java.lang.String,java.lang.String)>
<com.android.internal.telephony.ITelephony: android.telephony.IccOpenLogicalChannelResponse iccOpenLogicalChannel(com.android.internal.telephony.IccLogicalChannelRequest)>
<com.android.internal.telephony.ITelephony: int getCdmaSubscriptionMode(int)>
<com.android.internal.telephony.ITelephony: int getNetworkSelectionMode(int)>
<com.android.internal.telephony.ITelephony: boolean isEmergencyNumber(java.lang.String,boolean)>
<com.android.internal.telephony.ITelephony: boolean setSatelliteDeviceAlignedTimeoutDuration(long)>
<com.android.internal.telephony.ITelephony: void setNullCipherAndIntegrityEnabled(boolean)>
<com.android.internal.telephony.ITelephony: void setCepEnabled(boolean)>
<com.android.internal.telephony.ITelephony: void enqueueSmsPickResult(java.lang.String,java.lang.String,com.android.internal.telephony.IIntegerConsumer)>
<com.android.internal.telephony.ITelephony: boolean getCarrierSingleRegistrationEnabled(int)>
<com.android.internal.telephony.ITelephony: java.lang.String getTypeAllocationCodeForSlot(int)>
<com.android.internal.telephony.ITelephony: void stopSatelliteTransmissionUpdates(int,com.android.internal.telephony.IIntegerConsumer,android.telephony.satellite.ISatelliteTransmissionUpdateCallback)>
<com.android.internal.telephony.ITelephony: int getCarrierIdListVersion(int)>
<com.android.internal.telephony.ITelephony: int[] supplyPukReportResultForSubscriber(int,java.lang.String,java.lang.String)>
<com.android.internal.telephony.ITelephony: void setVoiceActivationState(int,int)>
<com.android.internal.telephony.ITelephony: boolean isRadioOnWithFeature(java.lang.String,java.lang.String)>
<com.android.internal.telephony.ITelephony: int getDataStateForSubId(int)>
<com.android.internal.telephony.ITelephony: java.util.Map getEmergencyNumberList(java.lang.String,java.lang.String)>
<com.android.internal.telephony.ITelephony: void unregisterMmTelCapabilityCallback(int,android.telephony.ims.aidl.IImsCapabilityCallback)>
<com.android.internal.telephony.ITelephony: java.lang.String getBoundGbaService(int)>
<com.android.internal.telephony.ITelephony: boolean supplyPinForSubscriber(int,java.lang.String)>
<com.android.internal.telephony.ITelephony: boolean isRcsVolteSingleRegistrationCapable(int)>
<com.android.internal.telephony.ITelephony: void setVoWiFiNonPersistent(int,boolean,int)>
<com.android.internal.telephony.ITelephony: void bootstrapAuthenticationRequest(int,int,android.net.Uri,android.telephony.gba.UaSecurityProtocolIdentifier,boolean,android.telephony.IBootstrapAuthenticationCallback)>
<com.android.internal.telephony.ITelephony: boolean resetModemConfig(int)>
<com.android.internal.telephony.ITelephony: int getImsProvisioningInt(int,int)>
<com.android.internal.telephony.ITelephony: boolean setRadio(boolean)>
<com.android.internal.telephony.ITelephony: boolean setImsFeatureValidationOverride(int,java.lang.String)>
<com.android.internal.telephony.ITelephony: int getDataNetworkTypeForSubscriber(int,java.lang.String,java.lang.String)>
<com.android.internal.telephony.ITelephony: java.util.List getSystemSelectionChannels(int)>
<com.android.internal.telephony.ITelephony: void sendDialerSpecialCode(java.lang.String,java.lang.String)>
<com.android.internal.telephony.ITelephony: boolean getImsFeatureValidationOverride(int)>
<com.android.internal.telephony.ITelephony: void handleUssdRequest(int,java.lang.String,android.os.ResultReceiver)>
<com.android.internal.telephony.ITelephony: java.lang.String iccTransmitApduBasicChannelByPort(int,int,java.lang.String,int,int,int,int,int,java.lang.String)>
<com.android.internal.telephony.ITelephony: void showSwitchToManagedProfileDialog()>
<com.android.internal.telephony.ITelephony: int setImsProvisioningString(int,int,java.lang.String)>
<com.android.internal.telephony.ITelephony: int getCdmaEriIconMode(java.lang.String,java.lang.String)>
<com.android.internal.telephony.ITelephony: void clearSignalStrengthUpdateRequest(int,android.telephony.SignalStrengthUpdateRequest,java.lang.String)>
<com.android.internal.telephony.ITelephony: void startEmergencyCallbackMode()>
<com.android.internal.telephony.ITelephony: void notifyOtaEmergencyNumberDbInstalled()>
<com.android.internal.telephony.ITelephony: void pollPendingSatelliteDatagrams(int,com.android.internal.telephony.IIntegerConsumer)>
<com.android.internal.telephony.ITelephony: java.util.List getEmergencyNumberListTestMode()>
<com.android.internal.telephony.ITelephony: boolean handlePinMmiForSubscriber(int,java.lang.String)>
<com.android.internal.telephony.ITelephony: void resetIms(int)>
<com.android.internal.telephony.ITelephony: void updateServiceLocationWithPackageName(java.lang.String)>
<com.android.internal.telephony.ITelephony: void carrierActionReportDefaultNetworkStatus(int,boolean)>
<com.android.internal.telephony.ITelephony: java.util.List getPackagesWithCarrierPrivileges(int)>
<com.android.internal.telephony.ITelephony: java.lang.String getLine1NumberForDisplay(int,java.lang.String,java.lang.String)>
<com.android.internal.telephony.ITelephony: boolean isCrossSimCallingEnabledByUser(int)>
<com.android.internal.telephony.ITelephony: boolean rebootModem(int)>
<com.android.internal.telephony.ITelephony: void call(java.lang.String,java.lang.String)>
<com.android.internal.telephony.ITelephony: android.telephony.ims.RcsContactUceCapability getLatestRcsContactUceCapabilityShell(int)>
<com.android.internal.telephony.ITelephony: int getNetworkTypeForSubscriber(int,java.lang.String,java.lang.String)>
<com.android.internal.telephony.ITelephony: boolean setSatelliteServicePackageName(java.lang.String)>
<com.android.internal.telephony.ITelephony: void setDataEnabledForReason(int,int,boolean,java.lang.String)>
<com.android.internal.telephony.ITelephony: void requestSatelliteEnabled(int,boolean,boolean,com.android.internal.telephony.IIntegerConsumer)>
<com.android.internal.telephony.ITelephony: int setNrDualConnectivityState(int,int)>
<com.android.internal.telephony.ITelephony: void dial(java.lang.String)>
<com.android.internal.telephony.ITelephony: java.util.List getCellBroadcastIdRanges(int)>
<com.android.internal.telephony.ITelephony: void requestSatelliteCapabilities(int,android.os.ResultReceiver)>
<com.android.internal.telephony.ITelephony: boolean removeUceRequestDisallowedStatus(int)>
<com.android.internal.telephony.ITelephony: boolean setBoundGbaServiceOverride(int,java.lang.String)>
<com.android.internal.telephony.ITelephony: void factoryReset(int,java.lang.String)>
<com.android.internal.telephony.ITelephony: int getRadioPowerState(int,java.lang.String,java.lang.String)>
<com.android.internal.telephony.ITelephony: void sendVisualVoicemailSmsForSubscriber(java.lang.String,java.lang.String,int,java.lang.String,int,java.lang.String,android.app.PendingIntent)>
<com.android.internal.telephony.ITelephony: void startSatelliteTransmissionUpdates(int,com.android.internal.telephony.IIntegerConsumer,android.telephony.satellite.ISatelliteTransmissionUpdateCallback)>
<com.android.internal.telephony.ITelephony: java.lang.String getCdmaPrlVersion(int)>
<com.android.internal.telephony.ITelephony: void getImsMmTelFeatureState(int,com.android.internal.telephony.IIntegerConsumer)>
<com.android.internal.telephony.ITelephony: void registerImsProvisioningChangedCallback(int,android.telephony.ims.aidl.IImsConfigCallback)>
<com.android.internal.telephony.ITelephony: void setRcsProvisioningStatusForCapability(int,int,int,boolean)>
<com.android.internal.telephony.ITelephony: boolean isVoNrEnabled(int)>
<com.android.internal.telephony.ITelephony: void getCarrierRestrictionStatus(com.android.internal.telephony.IIntegerConsumer,java.lang.String)>
<com.android.internal.telephony.ITelephony: int getNumberOfModemsWithSimultaneousDataConnections(int,java.lang.String,java.lang.String)>
<com.android.internal.telephony.ITelephony: boolean setSimSlotMapping(java.util.List)>
<com.android.internal.telephony.ITelephony: void setMobileDataPolicyEnabled(int,int,boolean)>
<com.android.internal.telephony.ITelephony: int isMultiSimSupported(java.lang.String,java.lang.String)>
<com.android.internal.telephony.ITelephony: android.telephony.ims.RcsContactUceCapability addUceRegistrationOverrideShell(int,java.util.List)>
<com.android.internal.telephony.ITelephony: boolean getRcsSingleRegistrationTestModeEnabled()>
<com.android.internal.telephony.ITelephony: boolean isTetheringApnRequiredForSubscriber(int)>
<com.android.internal.telephony.ITelephony: void sendDeviceToDeviceMessage(int,int)>
<com.android.internal.telephony.ITelephony: boolean needMobileRadioShutdown()>
<com.android.internal.telephony.ITelephony: int getVoiceNetworkTypeForSubscriber(int,java.lang.String,java.lang.String)>
<com.android.internal.telephony.ITelephony: boolean setSatellitePointingUiClassName(java.lang.String,java.lang.String)>
<com.android.internal.telephony.ITelephony: boolean isTtyModeSupported()>
<com.android.internal.telephony.ITelephony: java.lang.String getMmsUAProfUrl(int)>
<com.android.internal.telephony.ITelephony: boolean isProvisioningRequiredForCapability(int,int,int)>
<com.android.internal.telephony.ITelephony: int getVoWiFiRoamingModeSetting(int)>
<com.android.internal.telephony.ITelephony: boolean setCapabilitiesRequestTimeout(int,long)>
<com.android.internal.telephony.ITelephony: void setCarrierTestOverride(int,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
<com.android.internal.telephony.ITelephony: java.util.List getRadioPowerOffReasons(int,java.lang.String,java.lang.String)>
<com.android.internal.telephony.ITelephony: boolean setAllowedNetworkTypesForReason(int,int,long)>
<com.android.internal.telephony.ITelephony: void setDataActivationState(int,int)>
<com.android.internal.telephony.ITelephony: int getSimStateForSlotIndex(int)>
<com.android.internal.telephony.ITelephony: void uploadCallComposerPicture(int,java.lang.String,java.lang.String,android.os.ParcelFileDescriptor,android.os.ResultReceiver)>
<com.android.internal.telephony.ITelephony: java.lang.String iccTransmitApduLogicalChannel(int,int,int,int,int,int,int,java.lang.String)>
<com.android.internal.telephony.ITelephony: int getCarrierPrivilegeStatus(int)>
<com.android.internal.telephony.ITelephony: boolean isRcsProvisioningRequiredForCapability(int,int,int)>
<com.android.internal.telephony.ITelephony: boolean isVoWiFiSettingEnabled(int)>
<com.android.internal.telephony.ITelephony: int getCarrierIdFromMccMnc(int,java.lang.String,boolean)>
<com.android.internal.telephony.ITelephony: void setVoWiFiSettingEnabled(int,boolean)>
<com.android.internal.telephony.ITelephony: android.telephony.ims.aidl.IImsRegistration getImsRegistration(int,int)>
<com.android.internal.telephony.ITelephony: void getCallWaitingStatus(int,com.android.internal.telephony.IIntegerConsumer)>
<com.android.internal.telephony.ITelephony: int getCdmaEriIconIndex(java.lang.String,java.lang.String)>
<com.android.internal.telephony.ITelephony: boolean getRcsProvisioningStatusForCapability(int,int,int)>
<com.android.internal.telephony.ITelephony: boolean isDomainSelectionSupported()>
<com.android.internal.telephony.ITelephony: java.lang.String iccTransmitApduBasicChannel(int,java.lang.String,int,int,int,int,int,java.lang.String)>
<com.android.internal.telephony.ITelephony: boolean isNullCipherAndIntegrityPreferenceEnabled()>
<com.android.internal.telephony.ITelephony: java.lang.String getEsn(int)>
<com.android.internal.telephony.ITelephony: void requestCellInfoUpdateWithWorkSource(int,android.telephony.ICellInfoCallback,java.lang.String,java.lang.String,android.os.WorkSource)>
<android.telephony.satellite.ISatelliteDatagramCallback: void onSatelliteDatagramReceived(long,android.telephony.satellite.SatelliteDatagram,int,com.android.internal.telephony.IVoidConsumer)>
<com.samsung.android.wifi.aware.ISemWifiAwareManager: int isPreEnabled()>
<com.samsung.android.wifi.aware.ISemWifiAwareManager: void setClusterMergingEnabled(boolean)>
<android.view.IScrollCaptureCallbacks: void onImageRequestCompleted(int,android.graphics.Rect)>
<android.view.IScrollCaptureCallbacks: void onCaptureStarted()>
<android.view.IScrollCaptureCallbacks: void onCaptureEnded()>
<android.service.credentials.ICredentialProviderService: void onBeginGetCredential(android.service.credentials.BeginGetCredentialRequest,android.service.credentials.IBeginGetCredentialCallback)>
<android.service.credentials.ICredentialProviderService: void onClearCredentialState(android.service.credentials.ClearCredentialStateRequest,android.service.credentials.IClearCredentialStateCallback)>
<android.service.credentials.ICredentialProviderService: void onBeginCreateCredential(android.service.credentials.BeginCreateCredentialRequest,android.service.credentials.IBeginCreateCredentialCallback)>
<android.se.omapi.ISecureElementChannel: byte[] transmit(byte[])>
<android.se.omapi.ISecureElementChannel: java.lang.String getInterfaceHash()>
<android.se.omapi.ISecureElementChannel: byte[] getSelectResponse()>
<android.se.omapi.ISecureElementChannel: boolean isBasicChannel()>
<android.se.omapi.ISecureElementChannel: void close()>
<android.se.omapi.ISecureElementChannel: int getInterfaceVersion()>
<android.se.omapi.ISecureElementChannel: boolean isClosed()>
<android.se.omapi.ISecureElementChannel: boolean selectNext()>
<android.app.ILocaleManager: android.os.LocaleList getApplicationLocales(java.lang.String,int)>
<android.app.ILocaleManager: android.app.LocaleConfig getOverrideLocaleConfig(java.lang.String,int)>
<android.app.ILocaleManager: void setOverrideLocaleConfig(java.lang.String,int,android.app.LocaleConfig)>
<android.app.ILocaleManager: android.os.LocaleList getSystemLocales()>
<android.app.ILocaleManager: void setApplicationLocales(java.lang.String,int,android.os.LocaleList,boolean)>
<com.samsung.android.hardware.context.ISemContextCallback: java.lang.String getListenerInfo()>
<com.samsung.android.hardware.context.ISemContextCallback: void semContextCallback(com.samsung.android.hardware.context.SemContextEvent)>
<android.speech.tts.ITextToSpeechManager: void createSession(java.lang.String,android.speech.tts.ITextToSpeechSessionCallback)>
<com.samsung.android.cover.ICoverService: void onSystemReady()>
<com.samsung.android.cover.ICoverService: void onUpdateCoverState(com.samsung.android.cover.CoverState)>
<com.samsung.android.cover.ICoverService: int onCoverAppCovered(boolean)>
<android.hardware.input.IInputSensorEventListener: void onInputSensorChanged(int,int,int,long,float[])>
<android.hardware.input.IInputSensorEventListener: void onInputSensorAccuracyChanged(int,int,int)>
<com.android.net.ICredentialStatusCallback: void onSuccess()>
<com.android.net.ICredentialStatusCallback: void onFail(int)>
<android.service.credentials.IClearCredentialStateCallback: void onFailure(java.lang.String,java.lang.CharSequence)>
<android.service.credentials.IClearCredentialStateCallback: void onCancellable(android.os.ICancellationSignal)>
<android.service.credentials.IClearCredentialStateCallback: void onSuccess()>
<android.hardware.hdmi.IHdmiVendorCommandListener: void onControlStateChanged(boolean,int)>
<android.hardware.hdmi.IHdmiVendorCommandListener: void onReceived(int,int,byte[],boolean)>
<android.sec.enterprise.IEDMProxy: boolean decreaseNumberOfOutgoingSms()>
<android.sec.enterprise.IEDMProxy: boolean isPackageAllowedToAccessExternalSdcard(int,int)>
<android.sec.enterprise.IEDMProxy: boolean isOcspCheckEnabled()>
<android.sec.enterprise.IEDMProxy: boolean isBluetoothUUIDAllowed(java.lang.String)>
<android.sec.enterprise.IEDMProxy: boolean isBlockMmsWithStorageEnabled()>
<android.sec.enterprise.IEDMProxy: java.lang.String getApplicationNameFromDb(java.lang.String,int)>
<android.sec.enterprise.IEDMProxy: boolean isBlockSmsWithStorageEnabled()>
<android.sec.enterprise.IEDMProxy: boolean isClipboardAllowed(boolean)>
<android.sec.enterprise.IEDMProxy: boolean isWapPushAllowed()>
<android.sec.enterprise.IEDMProxy: boolean addNumberOfIncomingCalls()>
<android.sec.enterprise.IEDMProxy: void notifyPasswordPolicyOneLockChanged(boolean,int)>
<android.sec.enterprise.IEDMProxy: boolean isScreenLockPatternVisibilityEnabledAsUser(int)>
<android.sec.enterprise.IEDMProxy: boolean isLimitNumberOfSmsEnabled()>
<android.sec.enterprise.IEDMProxy: boolean isBackupAllowed(boolean)>
<android.sec.enterprise.IEDMProxy: void notifyCertificateRemovedAsUser(java.lang.String,int)>
<android.sec.enterprise.IEDMProxy: long getNtpTimeout()>
<android.sec.enterprise.IEDMProxy: boolean getToastShowPackageNameState()>
<android.sec.enterprise.IEDMProxy: boolean isCopyContactToSimAllowed(int)>
<android.sec.enterprise.IEDMProxy: void storeSMS(java.lang.String,java.lang.String,java.lang.String,boolean)>
<android.sec.enterprise.IEDMProxy: int getToastGravityYOffset()>
<android.sec.enterprise.IEDMProxy: android.os.Bundle getApplicationRestrictions(java.lang.String,int)>
<android.sec.enterprise.IEDMProxy: int getSensorDisabled()>
<android.sec.enterprise.IEDMProxy: void AuditLogger(int,int,boolean,int,java.lang.String,java.lang.String)>
<android.sec.enterprise.IEDMProxy: void AuditLoggerAsUser(int,int,boolean,int,java.lang.String,java.lang.String,int)>
<android.sec.enterprise.IEDMProxy: boolean canIncomingCall(java.lang.String)>
<android.sec.enterprise.IEDMProxy: boolean isIncomingCallAllowedFromSimSlot(int)>
<android.sec.enterprise.IEDMProxy: boolean isBluetoothLogEnabled()>
<android.sec.enterprise.IEDMProxy: boolean isCertificateValidationAtInstallEnabledAsUser(int)>
<android.sec.enterprise.IEDMProxy: boolean isMockLocationEnabled()>
<android.sec.enterprise.IEDMProxy: boolean getEmergencyCallOnly(boolean)>
<android.sec.enterprise.IEDMProxy: boolean getProKioskNotificationMessagesState()>
<android.sec.enterprise.IEDMProxy: void AuditLoggerPrivileged(int,int,boolean,int,java.lang.String,java.lang.String)>
<android.sec.enterprise.IEDMProxy: java.util.List getELMPermissions(java.lang.String)>
<android.sec.enterprise.IEDMProxy: void storeCalling(java.lang.String,java.lang.String,java.lang.String,java.lang.String,boolean)>
<android.sec.enterprise.IEDMProxy: boolean canOutgoingSms(java.lang.String)>
<android.sec.enterprise.IEDMProxy: boolean isCaCertificateTrustedAsUser(byte[],boolean,boolean,int)>
<android.sec.enterprise.IEDMProxy: boolean isKnoxBluetoothEnabled(int)>
<android.sec.enterprise.IEDMProxy: boolean isVideoRecordAllowed(boolean)>
<android.sec.enterprise.IEDMProxy: void addCallsCount(java.lang.String)>
<android.sec.enterprise.IEDMProxy: boolean getWifiState()>
<android.sec.enterprise.IEDMProxy: boolean getBrowserSettingStatus(int)>
<android.sec.enterprise.IEDMProxy: boolean registerSystemUICallback(android.sec.enterprise.adapterlayer.ISystemUIAdapterCallback)>
<android.sec.enterprise.IEDMProxy: boolean isRevocationCheckEnabled()>
<android.sec.enterprise.IEDMProxy: int getToastGravityXOffset()>
<android.sec.enterprise.IEDMProxy: boolean canIncomingSms(java.lang.String)>
<android.sec.enterprise.IEDMProxy: boolean isOutgoingCallsAllowed()>
<android.sec.enterprise.IEDMProxy: boolean isFactoryResetAllowed()>
<android.sec.enterprise.IEDMProxy: boolean isSmsPatternCheckRequired()>
<android.sec.enterprise.IEDMProxy: boolean getVolumePanelEnabledState()>
<android.sec.enterprise.IEDMProxy: boolean addNumberOfOutgoingSms()>
<android.sec.enterprise.IEDMProxy: boolean getProKioskState()>
<android.sec.enterprise.IEDMProxy: boolean isOutgoingSmsAllowedFromSimSlot(int)>
<android.sec.enterprise.IEDMProxy: void RedactedAuditLoggerPrivileged(int,int,boolean,int,java.lang.String,java.lang.String,java.lang.String)>
<android.sec.enterprise.IEDMProxy: boolean isDiscoverableEnabled()>
<android.sec.enterprise.IEDMProxy: boolean isRoamingDataEnabled()>
<android.sec.enterprise.IEDMProxy: boolean isAllowedMamPackage(java.lang.String)>
<android.sec.enterprise.IEDMProxy: boolean isPackageInAvrWhitelist(int)>
<android.sec.enterprise.IEDMProxy: byte[] ucmSign(java.lang.String,byte[],java.lang.String)>
<android.sec.enterprise.IEDMProxy: boolean getAddHomeShorcutRequested()>
<android.sec.enterprise.IEDMProxy: boolean isScreenLockPatternVisibilityEnabled()>
<android.sec.enterprise.IEDMProxy: boolean shallForceNtpMdmValues()>
<android.sec.enterprise.IEDMProxy: boolean isBluetoothEnabled()>
<android.sec.enterprise.IEDMProxy: boolean canOutgoingCall(java.lang.String)>
<android.sec.enterprise.IEDMProxy: boolean isRoamingPushEnabled()>
<android.sec.enterprise.IEDMProxy: boolean isSMSCaptureEnabled()>
<android.sec.enterprise.IEDMProxy: boolean addNumberOfOutgoingCalls()>
<android.sec.enterprise.IEDMProxy: java.lang.String getUsbNetAddress(int)>
<android.sec.enterprise.IEDMProxy: boolean isGoogleAccountsAutoSyncAllowedAsUser(int)>
<android.sec.enterprise.IEDMProxy: void RedactedAuditLoggerAsUser(int,int,boolean,int,java.lang.String,java.lang.String,java.lang.String,int)>
<android.sec.enterprise.IEDMProxy: boolean isMmsAllowedFromSimSlot(int)>
<android.sec.enterprise.IEDMProxy: byte[] ucmDecrypt(java.lang.String,byte[],java.lang.String,android.os.Bundle)>
<android.sec.enterprise.IEDMProxy: void bluetoothLog(java.lang.String,java.lang.String)>
<android.sec.enterprise.IEDMProxy: boolean getToastEnabledState()>
<android.sec.enterprise.IEDMProxy: boolean isNtpSetByMDM()>
<android.sec.enterprise.IEDMProxy: byte[] ucmMac(java.lang.String,byte[],java.lang.String)>
<android.sec.enterprise.IEDMProxy: boolean isOutgoingCallAllowedFromSimSlot(int)>
<android.sec.enterprise.IEDMProxy: boolean isClipboardShareAllowed()>
<android.sec.enterprise.IEDMProxy: boolean isAuditLogEnabledAsUser(int)>
<android.sec.enterprise.IEDMProxy: boolean addNumberOfIncomingSms()>
<android.sec.enterprise.IEDMProxy: boolean isPairingEnabled()>
<android.sec.enterprise.IEDMProxy: boolean isAudioRecordAllowed(boolean)>
<android.sec.enterprise.IEDMProxy: boolean isCertificateTrustedUntrustedEnabledAsUser(int)>
<android.sec.enterprise.IEDMProxy: void notifyCertificateFailureAsUser(java.lang.String,java.lang.String,boolean,int)>
<android.sec.enterprise.IEDMProxy: boolean getUsbNetStateInternal()>
<android.sec.enterprise.IEDMProxy: boolean getToastGravityEnabledState()>
<android.sec.enterprise.IEDMProxy: boolean isCallingCaptureEnabled()>
<android.sec.enterprise.IEDMProxy: boolean isOutgoingSmsAllowed()>
<android.sec.enterprise.IEDMProxy: void storeBlockedSmsMms(boolean,byte[],java.lang.String,int,java.lang.String,java.lang.String,java.lang.String)>
<android.sec.enterprise.IEDMProxy: boolean isAccountRemovalAllowed(java.lang.String,java.lang.String,boolean)>
<android.sec.enterprise.IEDMProxy: boolean isIncomingSmsAllowed()>
<android.sec.enterprise.IEDMProxy: java.lang.String getNtpServer()>
<android.sec.enterprise.IEDMProxy: boolean isIncomingSmsAllowedFromSimSlot(int)>
<android.sec.enterprise.IEDMProxy: boolean isBluetoothDeviceAllowed(java.lang.String)>
<android.sec.enterprise.IEDMProxy: byte[] ucmGetCertificateChain(java.lang.String)>
<android.sec.enterprise.IEDMProxy: void AuditLoggerPrivilegedAsUser(int,int,boolean,int,java.lang.String,java.lang.String,int)>
<android.sec.enterprise.IEDMProxy: int getKeyboardMode()>
<android.sec.enterprise.IEDMProxy: boolean getAllowBluetoothDataTransfer(boolean)>
<android.sec.enterprise.IEDMProxy: int getVolumeControlStream()>
<android.sec.enterprise.IEDMProxy: boolean getExtendedCallInfoState()>
<android.sec.enterprise.IEDMProxy: int getProKioskHideNotificationMessages()>
<android.sec.enterprise.IEDMProxy: boolean isIncomingMmsAllowed()>
<android.sec.enterprise.IEDMProxy: boolean isAnyApplicationNameChangedAsUser(int)>
<android.sec.enterprise.IEDMProxy: boolean isMicrophoneEnabled(boolean)>
<android.sec.enterprise.IEDMProxy: void RedactedAuditLoggerPrivilegedAsUser(int,int,boolean,int,java.lang.String,java.lang.String,java.lang.String,int)>
<android.sec.enterprise.IEDMProxy: byte[] getApplicationIconFromDb(java.lang.String,int)>
<android.sec.enterprise.IEDMProxy: boolean getVolumeButtonRotationState()>
<android.sec.enterprise.IEDMProxy: int validateCertificateAtInstallAsUser(byte[],int)>
<android.sec.enterprise.IEDMProxy: void RedactedAuditLogger(int,int,boolean,int,java.lang.String,java.lang.String,java.lang.String)>
<android.sec.enterprise.IEDMProxy: boolean isDataAllowedFromSimSlot(int)>
<android.sec.enterprise.IEDMProxy: byte[] ucmEncrypt(java.lang.String,byte[],java.lang.String,android.os.Bundle)>
<android.sec.enterprise.IEDMProxy: int getToastGravity()>
<android.sec.enterprise.IEDMProxy: boolean isTaskManagerAllowed(boolean)>
<android.sec.enterprise.IEDMProxy: boolean isProfileEnabled(int)>
<com.android.internal.telephony.euicc.ICancelSessionCallback: void onComplete(int,byte[])>
<android.telephony.ims.aidl.ICapabilityExchangeEventListener: void onUnpublish()>
<android.telephony.ims.aidl.ICapabilityExchangeEventListener: void onPublishUpdated(android.telephony.ims.SipDetails)>
<android.telephony.ims.aidl.ICapabilityExchangeEventListener: void onRequestPublishCapabilities(int)>
<android.telephony.ims.aidl.ICapabilityExchangeEventListener: void onRemoteCapabilityRequest(android.net.Uri,java.util.List,android.telephony.ims.aidl.IOptionsRequestCallback)>
<com.android.internal.telecom.ITelecomLoader: com.android.internal.telecom.ITelecomService createTelecomService(com.android.internal.telecom.IInternalServiceRetriever)>
<android.service.dreams.IDreamOverlay: void getClient(android.service.dreams.IDreamOverlayClientCallback)>
<android.hardware.input.ISemLidStateChangedListener: void onLidStateChanged(long,boolean)>
<android.media.session.IOnMediaKeyEventDispatchedListener: void onMediaKeyEventDispatched(android.view.KeyEvent,java.lang.String,android.media.session.MediaSession$Token)>
<com.samsung.android.mocca.IMoccaService: boolean isAvailableType(java.lang.String)>
<com.samsung.android.mocca.IMoccaService: void unregisterContextListener(com.samsung.android.mocca.IMoccaEventListener,java.lang.String)>
<com.samsung.android.mocca.IMoccaService: boolean hasContextAvailabilityListener(com.samsung.android.mocca.IMoccaEventListener)>
<com.samsung.android.mocca.IMoccaService: java.util.List getSupportedTypes()>
<com.samsung.android.mocca.IMoccaService: boolean registerContextAvailabilityListener(com.samsung.android.mocca.IMoccaEventListener,java.lang.String)>
<com.samsung.android.mocca.IMoccaService: boolean hasContextListener(com.samsung.android.mocca.IMoccaEventListener)>
<com.samsung.android.mocca.IMoccaService: void unregisterContextAvailabilityListener(com.samsung.android.mocca.IMoccaEventListener,java.lang.String)>
<com.samsung.android.mocca.IMoccaService: boolean registerContextListener(com.samsung.android.mocca.IMoccaEventListener,java.lang.String,com.samsung.android.mocca.ContextParam)>
<android.net.INetworkScoreCache: void updateScores(java.util.List)>
<android.net.INetworkScoreCache: void clearScores()>
<android.service.voice.IDetectorSessionVisualQueryDetectionCallback: void onQueryDetected(java.lang.String)>
<android.service.voice.IDetectorSessionVisualQueryDetectionCallback: void onQueryFinished()>
<android.service.voice.IDetectorSessionVisualQueryDetectionCallback: void onAttentionGained()>
<android.service.voice.IDetectorSessionVisualQueryDetectionCallback: void onQueryRejected()>
<android.service.voice.IDetectorSessionVisualQueryDetectionCallback: void onAttentionLost()>
<com.samsung.android.knox.IBasicCommand: void setCaller(com.samsung.android.knox.IBasicCommand)>
<com.samsung.android.knox.IBasicCommand: android.os.Bundle sendCmd(android.os.Bundle)>
<com.android.internal.inputmethod.IInputMethodPrivilegedOperations: void showMySoftInput(int,com.android.internal.infra.AndroidFuture)>
<com.android.internal.inputmethod.IInputMethodPrivilegedOperations: void resetStylusHandwriting(int)>
<com.android.internal.inputmethod.IInputMethodPrivilegedOperations: void setInputMethod(java.lang.String,com.android.internal.infra.AndroidFuture)>
<com.android.internal.inputmethod.IInputMethodPrivilegedOperations: void reportFullscreenModeAsync(boolean)>
<com.android.internal.inputmethod.IInputMethodPrivilegedOperations: void setInputMethodAndSubtype(java.lang.String,android.view.inputmethod.InputMethodSubtype,com.android.internal.infra.AndroidFuture)>
<com.android.internal.inputmethod.IInputMethodPrivilegedOperations: void applyImeVisibilityAsync(android.os.IBinder,boolean,android.view.inputmethod.ImeTracker$Token)>
<com.android.internal.inputmethod.IInputMethodPrivilegedOperations: void reportStartInputAsync(android.os.IBinder)>
<com.android.internal.inputmethod.IInputMethodPrivilegedOperations: void shouldOfferSwitchingToNextInputMethod(com.android.internal.infra.AndroidFuture)>
<com.android.internal.inputmethod.IInputMethodPrivilegedOperations: void updateStatusIconAsync(java.lang.String,int)>
<com.android.internal.inputmethod.IInputMethodPrivilegedOperations: void notifyUserActionAsync()>
<com.android.internal.inputmethod.IInputMethodPrivilegedOperations: void createInputContentUriToken(android.net.Uri,java.lang.String,com.android.internal.infra.AndroidFuture)>
<com.android.internal.inputmethod.IInputMethodPrivilegedOperations: void switchToPreviousInputMethod(com.android.internal.infra.AndroidFuture)>
<com.android.internal.inputmethod.IInputMethodPrivilegedOperations: void switchToNextInputMethod(boolean,com.android.internal.infra.AndroidFuture)>
<com.android.internal.inputmethod.IInputMethodPrivilegedOperations: void onStylusHandwritingReady(int,int)>
<com.android.internal.inputmethod.IInputMethodPrivilegedOperations: void hideMySoftInput(int,int,com.android.internal.infra.AndroidFuture)>
<com.android.internal.inputmethod.IInputMethodPrivilegedOperations: void setImeWindowStatusAsync(int,int)>
<com.samsung.android.hardware.context.ISemContextService: java.lang.String getCurrentServiceList()>
<com.samsung.android.hardware.context.ISemContextService: boolean unregisterCallback(android.os.IBinder,int)>
<com.samsung.android.hardware.context.ISemContextService: void initializeService(android.os.IBinder,int)>
<com.samsung.android.hardware.context.ISemContextService: java.util.Map getAvailableServiceMap()>
<com.samsung.android.hardware.context.ISemContextService: void requestToUpdate(android.os.IBinder,int,java.lang.String)>
<com.samsung.android.hardware.context.ISemContextService: boolean setReferenceData(int,int,byte[])>
<com.samsung.android.hardware.context.ISemContextService: boolean changeParameters(android.os.IBinder,int,com.samsung.android.hardware.context.SemContextAttribute)>
<com.samsung.android.hardware.context.ISemContextService: void registerCallback(android.os.IBinder,int,com.samsung.android.hardware.context.SemContextAttribute,java.lang.String)>
<com.samsung.android.hardware.context.ISemContextService: void requestHistoryData(android.os.IBinder,int,java.lang.String)>
<android.security.identity.ISession: android.security.identity.ICredential getCredentialForPresentation(java.lang.String)>
<android.security.identity.ISession: void setReaderEphemeralPublicKey(byte[])>
<android.security.identity.ISession: long getAuthChallenge()>
<android.security.identity.ISession: byte[] getEphemeralKeyPair()>
<android.security.identity.ISession: void setSessionTranscript(byte[])>
<android.hardware.radio.config.IRadioConfig: void getPhoneCapability(int)>
<android.hardware.radio.config.IRadioConfig: int getInterfaceVersion()>
<android.hardware.radio.config.IRadioConfig: void setSimSlotsMapping(int,android.hardware.radio.config.SlotPortMapping[])>
<android.hardware.radio.config.IRadioConfig: java.lang.String getInterfaceHash()>
<android.hardware.radio.config.IRadioConfig: void getSimSlotsStatus(int)>
<android.hardware.radio.config.IRadioConfig: void setNumOfLiveModems(int,byte)>
<android.hardware.radio.config.IRadioConfig: void getHalDeviceCapabilities(int)>
<android.hardware.radio.config.IRadioConfig: void setPreferredDataModem(int,byte)>
<android.hardware.radio.config.IRadioConfig: void setResponseFunctions(android.hardware.radio.config.IRadioConfigResponse,android.hardware.radio.config.IRadioConfigIndication)>
<android.hardware.radio.config.IRadioConfig: void getNumOfLiveModems(int)>
<android.content.ISyncServiceAdapter: void startSync(android.content.ISyncContext,android.os.Bundle)>
<android.content.ISyncServiceAdapter: void cancelSync(android.content.ISyncContext)>
<android.window.IDumpCallback: void onDump(android.os.ParcelFileDescriptor)>
<com.samsung.android.cover.ICoverWindowStateListenerCallback: void onCoverAppCovered(boolean)>
<android.os.IServiceCallback: void onRegistration(java.lang.String,android.os.IBinder)>
<android.net.wifi.nl80211.IWificond: void registerWificondEventCallback(android.net.wifi.nl80211.IWificondEventCallback)>
<android.net.wifi.nl80211.IWificond: int[] getAvailable5gNonDFSChannels()>
<android.net.wifi.nl80211.IWificond: java.util.List GetApInterfaces()>
<android.net.wifi.nl80211.IWificond: void RegisterCallback(android.net.wifi.nl80211.IInterfaceEventCallback)>
<android.net.wifi.nl80211.IWificond: int[] getAvailable2gChannels()>
<android.net.wifi.nl80211.IWificond: android.net.wifi.nl80211.DeviceWiphyCapabilities getDeviceWiphyCapabilities(java.lang.String)>
<android.net.wifi.nl80211.IWificond: int[] getAvailableDFSChannels()>
<android.net.wifi.nl80211.IWificond: void notifyCountryCodeChanged()>
<android.net.wifi.nl80211.IWificond: boolean tearDownClientInterface(java.lang.String)>
<android.net.wifi.nl80211.IWificond: android.net.wifi.nl80211.IApInterface createApInterface(java.lang.String)>
<android.net.wifi.nl80211.IWificond: int[] getAvailable60gChannels()>
<android.net.wifi.nl80211.IWificond: void UnregisterCallback(android.net.wifi.nl80211.IInterfaceEventCallback)>
<android.net.wifi.nl80211.IWificond: android.net.wifi.nl80211.IClientInterface createClientInterface(java.lang.String)>
<android.net.wifi.nl80211.IWificond: void tearDownInterfaces()>
<android.net.wifi.nl80211.IWificond: boolean tearDownApInterface(java.lang.String)>
<android.net.wifi.nl80211.IWificond: int[] getAvailable6gChannels()>
<android.net.wifi.nl80211.IWificond: void unregisterWificondEventCallback(android.net.wifi.nl80211.IWificondEventCallback)>
<android.net.wifi.nl80211.IWificond: java.util.List GetClientInterfaces()>
<com.android.internal.statusbar.IStatusBarService: void onPanelHidden()>
<com.android.internal.statusbar.IStatusBarService: void removeIcon(java.lang.String)>
<com.android.internal.statusbar.IStatusBarService: void setPanelExpandStateToType(boolean,int)>
<com.android.internal.statusbar.IStatusBarService: void onClearAllNotifications(int)>
<com.android.internal.statusbar.IStatusBarService: void showAuthenticationDialog(android.hardware.biometrics.PromptInfo,android.hardware.biometrics.IBiometricSysuiReceiver,int[],boolean,boolean,int,long,java.lang.String,long)>
<com.android.internal.statusbar.IStatusBarService: void expandSettingsPanel(java.lang.String)>
<com.android.internal.statusbar.IStatusBarService: void setBiometicContextListener(android.hardware.biometrics.IBiometricContextListener)>
<com.android.internal.statusbar.IStatusBarService: void grantInlineReplyUriPermission(java.lang.String,android.net.Uri,android.os.UserHandle,java.lang.String)>
<com.android.internal.statusbar.IStatusBarService: void onBiometricError(int,int,int)>
<com.android.internal.statusbar.IStatusBarService: void sendKeyEventToDesktopTaskbar(android.view.KeyEvent)>
<com.android.internal.statusbar.IStatusBarService: void collapsePanels()>
<com.android.internal.statusbar.IStatusBarService: void rebootByBixby(boolean)>
<com.android.internal.statusbar.IStatusBarService: void onNotificationSmartSuggestionsAdded(java.lang.String,int,int,boolean,boolean)>
<com.android.internal.statusbar.IStatusBarService: void hideCurrentInputMethodForBubbles()>
<com.android.internal.statusbar.IStatusBarService: void onSessionEnded(int,com.android.internal.logging.InstanceId)>
<com.android.internal.statusbar.IStatusBarService: void setIcon(java.lang.String,java.lang.String,int,int,java.lang.String)>
<com.android.internal.statusbar.IStatusBarService: void showPinningEscapeToast()>
<com.android.internal.statusbar.IStatusBarService: void registerNearbyMediaDevicesProvider(android.media.INearbyMediaDevicesProvider)>
<com.android.internal.statusbar.IStatusBarService: void expandNotificationsPanelToType(int)>
<com.android.internal.statusbar.IStatusBarService: void onNotificationSettingsViewed(java.lang.String)>
<com.android.internal.statusbar.IStatusBarService: void onGlobalActionsShown()>
<com.android.internal.statusbar.IStatusBarService: void onNotificationVisibilityChanged(com.android.internal.statusbar.NotificationVisibility[],com.android.internal.statusbar.NotificationVisibility[])>
<com.android.internal.statusbar.IStatusBarService: void setNavBarMode(int)>
<com.android.internal.statusbar.IStatusBarService: void onNotificationSmartReplySent(java.lang.String,int,java.lang.CharSequence,int,boolean)>
<com.android.internal.statusbar.IStatusBarService: void onBiometricAuthenticated(int)>
<com.android.internal.statusbar.IStatusBarService: void onNotificationFeedbackReceived(java.lang.String,android.os.Bundle)>
<com.android.internal.statusbar.IStatusBarService: void onGlobalActionsHidden()>
<com.android.internal.statusbar.IStatusBarService: void togglePanel()>
<com.android.internal.statusbar.IStatusBarService: void remTile(android.content.ComponentName)>
<com.android.internal.statusbar.IStatusBarService: void clearNotificationEffects()>
<com.android.internal.statusbar.IStatusBarService: void startTracing()>
<com.android.internal.statusbar.IStatusBarService: void resetScheduleAutoHide()>
<com.android.internal.statusbar.IStatusBarService: boolean isTracing()>
<com.android.internal.statusbar.IStatusBarService: void shutdown()>
<com.android.internal.statusbar.IStatusBarService: void disableToType(int,android.os.IBinder,java.lang.String,int)>
<com.android.internal.statusbar.IStatusBarService: void setNavigationBarShortcut(java.lang.String,android.widget.RemoteViews,int,int)>
<com.android.internal.statusbar.IStatusBarService: void suppressAmbientDisplay(boolean)>
<com.android.internal.statusbar.IStatusBarService: int getLastSystemKey()>
<com.android.internal.statusbar.IStatusBarService: com.android.internal.statusbar.RegisterStatusBarResult registerStatusBarAsType(com.android.internal.statusbar.IStatusBar,int)>
<com.android.internal.statusbar.IStatusBarService: void dismissInattentiveSleepWarning(boolean)>
<com.android.internal.statusbar.IStatusBarService: void registerSessionListener(int,com.android.internal.statusbar.ISessionListener)>
<com.android.internal.statusbar.IStatusBarService: void onNotificationExpansionChanged(java.lang.String,boolean,boolean,int)>
<com.android.internal.statusbar.IStatusBarService: void setUdfpsRefreshRateCallback(android.hardware.fingerprint.IUdfpsRefreshRateRequestCallback)>
<com.android.internal.statusbar.IStatusBarService: void onBubbleMetadataFlagChanged(java.lang.String,int)>
<com.android.internal.statusbar.IStatusBarService: void registerStatusBarForCarLife(com.android.internal.carlife.IStatusBarCarLife)>
<com.android.internal.statusbar.IStatusBarService: void setIconVisibility(java.lang.String,boolean)>
<com.android.internal.statusbar.IStatusBarService: void onNotificationError(java.lang.String,java.lang.String,int,int,int,java.lang.String,int)>
<com.android.internal.statusbar.IStatusBarService: void disable2ForUser(int,android.os.IBinder,java.lang.String,int)>
<com.android.internal.statusbar.IStatusBarService: void disable2(int,android.os.IBinder,java.lang.String)>
<com.android.internal.statusbar.IStatusBarService: void stopTracing()>
<com.android.internal.statusbar.IStatusBarService: void updateMediaTapToTransferReceiverDisplay(int,android.media.MediaRoute2Info,android.graphics.drawable.Icon,java.lang.CharSequence)>
<com.android.internal.statusbar.IStatusBarService: void addTile(android.content.ComponentName)>
<com.android.internal.statusbar.IStatusBarService: void onNotificationDirectReplied(java.lang.String)>
<com.android.internal.statusbar.IStatusBarService: boolean getPanelExpandStateToType(int)>
<com.android.internal.statusbar.IStatusBarService: void cancelRequestAddTile(java.lang.String)>
<com.android.internal.statusbar.IStatusBarService: void expandNotificationsPanel()>
<com.android.internal.statusbar.IStatusBarService: void showRearDisplayDialog(int)>
<com.android.internal.statusbar.IStatusBarService: void shutdownByBixby()>
<com.android.internal.statusbar.IStatusBarService: boolean isSysUiSafeModeEnabled()>
<com.android.internal.statusbar.IStatusBarService: void disable(int,android.os.IBinder,java.lang.String)>
<com.android.internal.statusbar.IStatusBarService: void setBlueLightFilter(boolean,int)>
<com.android.internal.statusbar.IStatusBarService: void clearInlineReplyUriPermissions(java.lang.String)>
<com.android.internal.statusbar.IStatusBarService: void setImeWindowStatus(int,android.os.IBinder,int,int,boolean)>
<com.android.internal.statusbar.IStatusBarService: void showInattentiveSleepWarning()>
<com.android.internal.statusbar.IStatusBarService: void onBiometricHelp(int,java.lang.String)>
<com.android.internal.statusbar.IStatusBarService: void onNotificationClick(java.lang.String,com.android.internal.statusbar.NotificationVisibility)>
<com.android.internal.statusbar.IStatusBarService: void requestAddTile(android.content.ComponentName,java.lang.CharSequence,android.graphics.drawable.Icon,int,com.android.internal.statusbar.IAddTileResultCallback)>
<com.android.internal.statusbar.IStatusBarService: com.android.internal.statusbar.RegisterStatusBarResult registerStatusBar(com.android.internal.statusbar.IStatusBar)>
<com.android.internal.statusbar.IStatusBarService: void restart()>
<com.android.internal.statusbar.IStatusBarService: void disable2ToType(int,android.os.IBinder,java.lang.String,int)>
<com.android.internal.statusbar.IStatusBarService: void onNotificationClear(java.lang.String,int,java.lang.String,int,int,com.android.internal.statusbar.NotificationVisibility)>
<com.android.internal.statusbar.IStatusBarService: void unregisterNearbyMediaDevicesProvider(android.media.INearbyMediaDevicesProvider)>
<com.android.internal.statusbar.IStatusBarService: void unregisterSessionListener(int,com.android.internal.statusbar.ISessionListener)>
<com.android.internal.statusbar.IStatusBarService: void clickTile(android.content.ComponentName)>
<com.android.internal.statusbar.IStatusBarService: void updateMediaTapToTransferSenderDisplay(int,android.media.MediaRoute2Info,com.android.internal.statusbar.IUndoMediaTransferCallback)>
<com.android.internal.statusbar.IStatusBarService: void disable2ForUserToType(int,android.os.IBinder,java.lang.String,int,int)>
<com.android.internal.statusbar.IStatusBarService: int getNavBarMode()>
<com.android.internal.statusbar.IStatusBarService: void showPinningEnterExitToast(boolean)>
<com.android.internal.statusbar.IStatusBarService: void collapsePanelsToType(int)>
<com.android.internal.statusbar.IStatusBarService: void handleSystemKey(android.view.KeyEvent)>
<com.android.internal.statusbar.IStatusBarService: void reboot(boolean)>
<com.android.internal.statusbar.IStatusBarService: void onNotificationActionClick(java.lang.String,int,android.app.Notification$Action,com.android.internal.statusbar.NotificationVisibility,boolean)>
<com.android.internal.statusbar.IStatusBarService: void hideAuthenticationDialog(long)>
<com.android.internal.statusbar.IStatusBarService: void setIndicatorBgColor(int)>
<com.android.internal.statusbar.IStatusBarService: int[] getDisableFlags(android.os.IBinder,int)>
<com.android.internal.statusbar.IStatusBarService: int[] getDisableFlagsToType(android.os.IBinder,int,int)>
<com.android.internal.statusbar.IStatusBarService: boolean isFOTAAvailableForGlobalActions()>
<com.android.internal.statusbar.IStatusBarService: void onNotificationBubbleChanged(java.lang.String,boolean,int)>
<com.android.internal.statusbar.IStatusBarService: void requestTileServiceListeningState(android.content.ComponentName,int)>
<com.android.internal.statusbar.IStatusBarService: void disableForUserToType(int,android.os.IBinder,java.lang.String,int,int)>
<com.android.internal.statusbar.IStatusBarService: boolean getQuickSettingPanelExpandStateToType(int)>
<com.android.internal.statusbar.IStatusBarService: void onPanelRevealed(boolean,int)>
<com.android.internal.statusbar.IStatusBarService: void disableForUser(int,android.os.IBinder,java.lang.String,int)>
<com.android.internal.statusbar.IStatusBarService: void expandSettingsPanelToType(java.lang.String,int)>
<com.android.internal.statusbar.IStatusBarService: void onSessionStarted(int,com.android.internal.logging.InstanceId)>
<android.media.ISpatializerOutputCallback: void dispatchSpatializerOutputChanged(int)>
<com.android.internal.widget.ILockSettings: void removeKey(java.lang.String)>
<com.android.internal.widget.ILockSettings: byte[] getHashFactor(com.android.internal.widget.LockscreenCredential,int)>
<com.android.internal.widget.ILockSettings: android.app.RemoteLockscreenValidationResult validateRemoteLockscreen(byte[])>
<com.android.internal.widget.ILockSettings: boolean hasPendingEscrowToken(int)>
<com.android.internal.widget.ILockSettings: long addWeakEscrowToken(byte[],int,com.android.internal.widget.IWeakEscrowTokenActivatedListener)>
<com.android.internal.widget.ILockSettings: java.lang.String importKey(java.lang.String,byte[])>
<com.android.internal.widget.ILockSettings: void notifyPasswordChangedForEnterpriseUser(com.android.internal.widget.LockscreenCredential,int)>
<com.android.internal.widget.ILockSettings: void setLong(java.lang.String,long,int)>
<com.android.internal.widget.ILockSettings: int getCredentialType(int)>
<com.android.internal.widget.ILockSettings: java.util.Map recoverKeyChainSnapshot(java.lang.String,byte[],java.util.List)>
<com.android.internal.widget.ILockSettings: void setAppLockBackupPin(java.lang.String,int)>
<com.android.internal.widget.ILockSettings: void removeCachedUnifiedChallenge(int)>
<com.android.internal.widget.ILockSettings: boolean haveAppLockFingerprintPassword(int)>
<com.android.internal.widget.ILockSettings: boolean hasSecureLockScreen()>
<com.android.internal.widget.ILockSettings: byte[] startRecoverySessionWithCertPath(java.lang.String,java.lang.String,android.security.keystore.recovery.RecoveryCertPath,byte[],byte[],java.util.List)>
<com.android.internal.widget.ILockSettings: int getStrongAuthForUser(int)>
<com.android.internal.widget.ILockSettings: boolean changeToken(byte[],long,byte[],long,int)>
<com.android.internal.widget.ILockSettings: int getPinLength(int)>
<com.android.internal.widget.ILockSettings: java.lang.String importKeyWithMetadata(java.lang.String,byte[],byte[])>
<com.android.internal.widget.ILockSettings: android.security.keystore.recovery.KeyChainSnapshot getKeyChainSnapshot()>
<com.android.internal.widget.ILockSettings: void unregisterRemoteLockCallback(int,com.android.internal.widget.IRemoteLockMonitorCallback)>
<com.android.internal.widget.ILockSettings: boolean haveCarrierPassword(int)>
<com.android.internal.widget.ILockSettings: void setAppLockPin(java.lang.String,int)>
<com.android.internal.widget.ILockSettings: void addLog(int,java.lang.String)>
<com.android.internal.widget.ILockSettings: boolean refreshStoredPinLength(int)>
<com.android.internal.widget.ILockSettings: boolean checkAppLockPin(java.lang.String,int)>
<com.android.internal.widget.ILockSettings: void userPresent(int)>
<com.android.internal.widget.ILockSettings: void setLockModeChangedCallback(android.os.IRemoteCallback)>
<com.android.internal.widget.ILockSettings: void resetKeyStore(int)>
<com.android.internal.widget.ILockSettings: void sendLockTypeChangedInfo(int)>
<com.android.internal.widget.ILockSettings: java.lang.String getKey(java.lang.String)>
<com.android.internal.widget.ILockSettings: void closeSession(java.lang.String)>
<com.android.internal.widget.ILockSettings: void setRecoverySecretTypes(int[])>
<com.android.internal.widget.ILockSettings: void setSeparateProfileChallengeEnabled(int,boolean,com.android.internal.widget.LockscreenCredential)>
<com.android.internal.widget.ILockSettings: boolean isWeakEscrowTokenValid(long,byte[],int)>
<com.android.internal.widget.ILockSettings: void requestRemoteLockInfo(int)>
<com.android.internal.widget.ILockSettings: void updateSdpMdfppForSystem(int,long)>
<com.android.internal.widget.ILockSettings: boolean updateCarrierLock(int)>
<com.android.internal.widget.ILockSettings: java.util.Map getRecoveryStatus()>
<com.android.internal.widget.ILockSettings: void initRecoveryServiceWithSigFile(java.lang.String,byte[],byte[])>
<com.android.internal.widget.ILockSettings: void setRecoveryStatus(java.lang.String,int)>
<com.android.internal.widget.ILockSettings: java.lang.String generateKeyWithMetadata(java.lang.String,byte[])>
<com.android.internal.widget.ILockSettings: int[] getRecoverySecretTypes()>
<com.android.internal.widget.ILockSettings: void setLockFMMPassword(byte[],int)>
<com.android.internal.widget.ILockSettings: boolean checkAppLockFingerprintPassword(java.lang.String,int)>
<com.android.internal.widget.ILockSettings: void removeGatekeeperPasswordHandle(long)>
<com.android.internal.widget.ILockSettings: android.app.RemoteLockscreenValidationSession startRemoteLockscreenValidation()>
<com.android.internal.widget.ILockSettings: boolean setLockCredential(com.android.internal.widget.LockscreenCredential,com.android.internal.widget.LockscreenCredential,int)>
<com.android.internal.widget.ILockSettings: java.lang.String getString(java.lang.String,java.lang.String,int)>
<com.android.internal.widget.ILockSettings: boolean haveAppLockPin(int)>
<com.android.internal.widget.ILockSettings: com.android.internal.widget.VerifyCredentialResponse checkCredentialForDualDarDo(com.android.internal.widget.LockscreenCredential,int,int,com.samsung.android.knox.dar.ddar.IDualDarAuthProgressCallback)>
<com.android.internal.widget.ILockSettings: boolean setKnoxGuard(int,com.android.internal.widget.RemoteLockInfo)>
<com.android.internal.widget.ILockSettings: boolean checkAppLockBackupPin(java.lang.String,int)>
<com.android.internal.widget.ILockSettings: void setString(java.lang.String,java.lang.String,int)>
<com.android.internal.widget.ILockSettings: boolean haveFMMPassword(int)>
<com.android.internal.widget.ILockSettings: void setAppLockPattern(java.lang.String,int)>
<com.android.internal.widget.ILockSettings: void setAppLockFingerprintPassword(java.lang.String,int)>
<com.android.internal.widget.ILockSettings: com.android.internal.widget.VerifyCredentialResponse verifyGatekeeperPasswordHandle(long,long,int)>
<com.android.internal.widget.ILockSettings: com.android.internal.widget.VerifyCredentialResponse checkCredential(com.android.internal.widget.LockscreenCredential,int,com.android.internal.widget.ICheckCredentialProgressCallback)>
<com.android.internal.widget.ILockSettings: boolean tryUnlockWithCachedUnifiedChallenge(int)>
<com.android.internal.widget.ILockSettings: boolean checkAppLockPassword(java.lang.String,int)>
<com.android.internal.widget.ILockSettings: boolean haveAppLockBackupPin(int)>
<com.android.internal.widget.ILockSettings: void setShellCommandCallback(android.os.IRemoteCallback)>
<com.android.internal.widget.ILockSettings: boolean setLockCredentialWithIgnoreNotifyIfNeeded(com.android.internal.widget.LockscreenCredential,com.android.internal.widget.LockscreenCredential,int,boolean)>
<com.android.internal.widget.ILockSettings: void requireStrongAuth(int,int)>
<com.android.internal.widget.ILockSettings: void registerRemoteLockCallback(int,com.android.internal.widget.IRemoteLockMonitorCallback)>
<com.android.internal.widget.ILockSettings: void scheduleNonStrongBiometricIdleTimeout(int)>
<com.android.internal.widget.ILockSettings: com.android.internal.widget.VerifyCredentialResponse verifyTiedProfileChallenge(com.android.internal.widget.LockscreenCredential,int,int)>
<com.android.internal.widget.ILockSettings: boolean checkFMMPassword(byte[],int)>
<com.android.internal.widget.ILockSettings: void unregisterStrongAuthTracker(android.app.trust.IStrongAuthTracker)>
<com.android.internal.widget.ILockSettings: void setSecurityDebugLevel(int)>
<com.android.internal.widget.ILockSettings: boolean isWeakEscrowTokenActive(long,int)>
<com.android.internal.widget.ILockSettings: void reportSuccessfulBiometricUnlock(boolean,int)>
<com.android.internal.widget.ILockSettings: void setAppLockPassword(java.lang.String,int)>
<com.android.internal.widget.ILockSettings: boolean checkAppLockPatternWithHash(java.lang.String,int,byte[])>
<com.android.internal.widget.ILockSettings: boolean unregisterWeakEscrowTokenRemovedListener(com.android.internal.widget.IWeakEscrowTokenRemovedListener)>
<com.android.internal.widget.ILockSettings: boolean removeWeakEscrowToken(long,int)>
<com.android.internal.widget.ILockSettings: boolean haveAppLockPassword(int)>
<com.android.internal.widget.ILockSettings: void checkRemoteLockPassword(int,byte[],int,android.os.IRemoteCallback)>
<com.android.internal.widget.ILockSettings: void setCarrierLockEnabled(int)>
<com.android.internal.widget.ILockSettings: void setLockCarrierPassword(byte[],int)>
<com.android.internal.widget.ILockSettings: java.lang.String generateKey(java.lang.String)>
<com.android.internal.widget.ILockSettings: boolean getSeparateProfileChallengeEnabled(int)>
<com.android.internal.widget.ILockSettings: boolean registerWeakEscrowTokenRemovedListener(com.android.internal.widget.IWeakEscrowTokenRemovedListener)>
<com.android.internal.widget.ILockSettings: boolean checkCarrierPassword(byte[],int)>
<com.android.internal.widget.ILockSettings: com.android.internal.widget.VerifyCredentialResponse verifyCredential(com.android.internal.widget.LockscreenCredential,int,int)>
<com.android.internal.widget.ILockSettings: void setSnapshotCreatedPendingIntent(android.app.PendingIntent)>
<com.android.internal.widget.ILockSettings: void setBoolean(java.lang.String,boolean,int)>
<com.android.internal.widget.ILockSettings: com.android.internal.widget.VerifyCredentialResponse verifyToken(byte[],long,int)>
<com.android.internal.widget.ILockSettings: void setServerParams(byte[])>
<com.android.internal.widget.ILockSettings: boolean getBoolean(java.lang.String,boolean,int)>
<com.android.internal.widget.ILockSettings: boolean getCarrierLock(int)>
<com.android.internal.widget.ILockSettings: void registerStrongAuthTracker(android.app.trust.IStrongAuthTracker)>
<com.android.internal.widget.ILockSettings: void setRemoteLock(int,com.android.internal.widget.RemoteLockInfo)>
<com.android.internal.widget.ILockSettings: boolean haveAppLockPattern(int)>
<com.android.internal.widget.ILockSettings: long getLong(java.lang.String,long,int)>
<com.android.internal.widget.ILockSettings: void systemReady()>
<android.hardware.fingerprint.IUdfpsRefreshRateRequestCallback: void onAuthenticationPossible(int,boolean)>
<android.hardware.fingerprint.IUdfpsRefreshRateRequestCallback: void onRequestDisabled(int)>
<android.hardware.fingerprint.IUdfpsRefreshRateRequestCallback: void onRequestEnabled(int)>
<com.samsung.android.knox.knoxai.IKnoxAiManagerService: void processTaCommand(int,com.samsung.android.knox.knoxai.TaProcessBuffer[],com.samsung.android.knox.knoxai.TaProcessBuffer[])>
<com.samsung.android.knox.knoxai.IKnoxAiManagerService: int initializeTaSession(com.samsung.android.knox.knoxai.TaLoaderOptions)>
<com.samsung.android.knox.knoxai.IKnoxAiManagerService: int terminateTaSession()>
<com.samsung.android.knox.knoxanalyticsproxy.IKnoxAnalyticsProxy: void log(com.samsung.android.knox.knoxanalyticsproxy.KnoxAnalyticsData)>
<android.hardware.devicestate.IDeviceStateManagerCallback: void onDeviceStateInfoChanged(android.hardware.devicestate.DeviceStateInfo)>
<android.hardware.devicestate.IDeviceStateManagerCallback: void onRequestCanceled(android.os.IBinder)>
<android.hardware.devicestate.IDeviceStateManagerCallback: void onRequestActive(android.os.IBinder)>
<android.media.midi.IBluetoothMidiService: android.os.IBinder addBluetoothDevice(android.bluetooth.BluetoothDevice)>
<android.permission.IPermissionController: void getPlatformPermissionsForGroup(java.lang.String,com.android.internal.infra.AndroidFuture)>
<android.permission.IPermissionController: void revokeRuntimePermissions(android.os.Bundle,boolean,int,java.lang.String,com.android.internal.infra.AndroidFuture)>
<android.permission.IPermissionController: void notifyOneTimePermissionSessionTimeout(java.lang.String)>
<android.permission.IPermissionController: void getGroupOfPlatformPermission(java.lang.String,com.android.internal.infra.AndroidFuture)>
<android.permission.IPermissionController: void countPermissionApps(java.util.List,int,com.android.internal.infra.AndroidFuture)>
<android.permission.IPermissionController: void getHibernationEligibility(java.lang.String,com.android.internal.infra.AndroidFuture)>
<android.permission.IPermissionController: void revokeSelfPermissionsOnKill(java.lang.String,java.util.List,com.android.internal.infra.AndroidFuture)>
<android.permission.IPermissionController: void getUnusedAppCount(com.android.internal.infra.AndroidFuture)>
<android.permission.IPermissionController: void stageAndApplyRuntimePermissionsBackup(android.os.UserHandle,android.os.ParcelFileDescriptor)>
<android.permission.IPermissionController: void getAppPermissions(java.lang.String,com.android.internal.infra.AndroidFuture)>
<android.permission.IPermissionController: void grantOrUpgradeDefaultRuntimePermissions(com.android.internal.infra.AndroidFuture)>
<android.permission.IPermissionController: void setRuntimePermissionGrantStateByDeviceAdminFromParams(java.lang.String,android.permission.AdminPermissionControlParams,com.android.internal.infra.AndroidFuture)>
<android.permission.IPermissionController: void getPermissionUsages(boolean,long,com.android.internal.infra.AndroidFuture)>
<android.permission.IPermissionController: void getPrivilegesDescriptionStringForProfile(java.lang.String,com.android.internal.infra.AndroidFuture)>
<android.permission.IPermissionController: void getRuntimePermissionBackup(android.os.UserHandle,android.os.ParcelFileDescriptor)>
<android.permission.IPermissionController: void updateUserSensitiveForApp(int,com.android.internal.infra.AndroidFuture)>
<android.permission.IPermissionController: void applyStagedRuntimePermissionBackup(java.lang.String,android.os.UserHandle,com.android.internal.infra.AndroidFuture)>
<android.permission.IPermissionController: void revokeRuntimePermission(java.lang.String,java.lang.String)>
<com.samsung.android.edge.IEdgeLightingResponse: void onFinished()>
<android.hardware.gnss.IGnssMeasurementInterface: java.lang.String getInterfaceHash()>
<android.hardware.gnss.IGnssMeasurementInterface: int getInterfaceVersion()>
<android.hardware.gnss.IGnssMeasurementInterface: void setCallback(android.hardware.gnss.IGnssMeasurementCallback,boolean,boolean)>
<android.hardware.gnss.IGnssMeasurementInterface: void setCallbackWithOptions(android.hardware.gnss.IGnssMeasurementCallback,android.hardware.gnss.IGnssMeasurementInterface$Options)>
<android.hardware.gnss.IGnssMeasurementInterface: void close()>
<com.android.ims.internal.IImsMMTelFeature: void setUiTTYMode(int,android.os.Message)>
<com.android.ims.internal.IImsMMTelFeature: void acknowledgeSmsReport(int,int,int,int)>
<com.android.ims.internal.IImsMMTelFeature: com.android.ims.internal.IImsCallSession getPendingCallSession(int,java.lang.String)>
<com.android.ims.internal.IImsMMTelFeature: java.lang.String getSmsFormat(int)>
<com.android.ims.internal.IImsMMTelFeature: void setSmsListener(int,android.telephony.ims.aidl.IImsSmsListener)>
<com.android.ims.internal.IImsMMTelFeature: void changeAudioPath(int,int)>
<com.android.ims.internal.IImsMMTelFeature: boolean isConnected(int,int)>
<com.android.ims.internal.IImsMMTelFeature: void turnOnIms()>
<com.android.ims.internal.IImsMMTelFeature: void setRetryCount(int,int,int)>
<com.android.ims.internal.IImsMMTelFeature: void setVideoCrtAudio(int,boolean)>
<com.android.ims.internal.IImsMMTelFeature: android.telephony.ims.ImsCallProfile createCallProfile(int,int,int)>
<com.android.ims.internal.IImsMMTelFeature: void endSession(int)>
<com.android.ims.internal.IImsMMTelFeature: void turnOffIms()>
<com.android.ims.internal.IImsMMTelFeature: boolean isCmcEmergencyCallSupported(int)>
<com.android.ims.internal.IImsMMTelFeature: boolean isOpened()>
<com.android.ims.internal.IImsMMTelFeature: com.android.ims.internal.IImsCallSession createCallSession(int,android.telephony.ims.ImsCallProfile)>
<com.android.ims.internal.IImsMMTelFeature: void setSecImsMmTelEventListener(int,com.android.ims.internal.ISecImsMmTelEventListener)>
<com.android.ims.internal.IImsMMTelFeature: void sendDtmfEvent(int,java.lang.String)>
<com.android.ims.internal.IImsMMTelFeature: void sendSms(int,int,int,java.lang.String,java.lang.String,boolean,byte[])>
<com.android.ims.internal.IImsMMTelFeature: int startLocalRingBackTone(int,int,int)>
<com.android.ims.internal.IImsMMTelFeature: void acknowledgeSms(int,int,int,int)>
<com.android.ims.internal.IImsMMTelFeature: int getFeatureStatus()>
<com.android.ims.internal.IImsMMTelFeature: com.android.ims.internal.IImsMultiEndpoint getMultiEndpointInterface()>
<com.android.ims.internal.IImsMMTelFeature: void onMemoryAvailable(int,int)>
<com.android.ims.internal.IImsMMTelFeature: com.android.ims.internal.IImsEcbm getEcbmInterface()>
<com.android.ims.internal.IImsMMTelFeature: void sendPublishDialog(int,com.android.internal.telephony.PublishDialog)>
<com.android.ims.internal.IImsMMTelFeature: int startSession(android.app.PendingIntent,com.android.ims.internal.IImsRegistrationListener)>
<com.android.ims.internal.IImsMMTelFeature: com.android.ims.internal.IImsUt getUtInterface()>
<com.android.ims.internal.IImsMMTelFeature: void setSmsc(int,java.lang.String)>
<com.android.ims.internal.IImsMMTelFeature: int stopLocalRingBackTone()>
<com.android.ims.internal.IImsMMTelFeature: void removeRegistrationListener(com.android.ims.internal.IImsRegistrationListener)>
<com.android.ims.internal.IImsMMTelFeature: com.android.ims.internal.IImsConfig getConfigInterface()>
<com.android.ims.internal.IImsMMTelFeature: void addRegistrationListener(com.android.ims.internal.IImsRegistrationListener)>
<com.android.ims.internal.IImsMMTelFeature: void acknowledgeSmsWithPdu(int,int,int,byte[])>
<com.android.ims.internal.IImsMMTelFeature: void onSmsReady(int)>
<com.android.ims.internal.IImsMMTelFeature: java.lang.String getTrn(java.lang.String,java.lang.String)>
<android.content.pm.IPinItemRequest: android.appwidget.AppWidgetProviderInfo getAppWidgetProviderInfo()>
<android.content.pm.IPinItemRequest: android.os.Bundle getExtras()>
<android.content.pm.IPinItemRequest: android.content.pm.ShortcutInfo getShortcutInfo()>
<android.content.pm.IPinItemRequest: boolean accept(android.os.Bundle)>
<android.content.pm.IPinItemRequest: boolean isValid()>
<android.app.people.IPeopleManager: void clearStatus(java.lang.String,int,java.lang.String,java.lang.String)>
<android.app.people.IPeopleManager: android.content.pm.ParceledListSlice getRecentConversations()>
<android.app.people.IPeopleManager: android.app.people.ConversationChannel getConversation(java.lang.String,int,java.lang.String)>
<android.app.people.IPeopleManager: long getLastInteraction(java.lang.String,int,java.lang.String)>
<android.app.people.IPeopleManager: android.content.pm.ParceledListSlice getStatuses(java.lang.String,int,java.lang.String)>
<android.app.people.IPeopleManager: void unregisterConversationListener(android.app.people.IConversationListener)>
<android.app.people.IPeopleManager: void registerConversationListener(java.lang.String,int,java.lang.String,android.app.people.IConversationListener)>
<android.app.people.IPeopleManager: void clearStatuses(java.lang.String,int,java.lang.String)>
<android.app.people.IPeopleManager: void addOrUpdateStatus(java.lang.String,int,java.lang.String,android.app.people.ConversationStatus)>
<android.app.people.IPeopleManager: void removeAllRecentConversations()>
<android.app.people.IPeopleManager: boolean isConversation(java.lang.String,int,java.lang.String)>
<android.app.people.IPeopleManager: void removeRecentConversation(java.lang.String,int,java.lang.String)>
<android.hardware.fingerprint.IFingerprintService: void registerAuthenticators(java.util.List)>
<android.hardware.fingerprint.IFingerprintService: void registerBiometricStateListener(android.hardware.biometrics.IBiometricStateListener)>
<android.hardware.fingerprint.IFingerprintService: void onPowerPressed()>
<android.hardware.fingerprint.IFingerprintService: void semRegisterAodController(android.os.IBinder,com.samsung.android.bio.fingerprint.ISemFingerprintAodController)>
<android.hardware.fingerprint.IFingerprintService: long detectFingerprint(android.os.IBinder,android.hardware.fingerprint.IFingerprintServiceReceiver,android.hardware.fingerprint.FingerprintAuthenticateOptions)>
<android.hardware.fingerprint.IFingerprintService: int semRemoveMaskView(android.os.IBinder,java.lang.String)>
<android.hardware.fingerprint.IFingerprintService: void onPointerDown(long,int,android.hardware.biometrics.fingerprint.PointerContext)>
<android.hardware.fingerprint.IFingerprintService: boolean semIsTemplateDbCorrupted()>
<android.hardware.fingerprint.IFingerprintService: void removeAll(android.os.IBinder,int,android.hardware.fingerprint.IFingerprintServiceReceiver,java.lang.String)>
<android.hardware.fingerprint.IFingerprintService: void semForceCBGE()>
<android.hardware.fingerprint.IFingerprintService: boolean isClientActive()>
<android.hardware.fingerprint.IFingerprintService: void setSidefpsController(android.hardware.fingerprint.ISidefpsController)>
<android.hardware.fingerprint.IFingerprintService: long enroll(android.os.IBinder,byte[],int,android.hardware.fingerprint.IFingerprintServiceReceiver,java.lang.String,int)>
<android.hardware.fingerprint.IFingerprintService: android.os.IBinder semAddMaskView(android.os.IBinder,java.lang.String)>
<android.hardware.fingerprint.IFingerprintService: void revokeChallenge(android.os.IBinder,int,int,java.lang.String,long)>
<android.hardware.fingerprint.IFingerprintService: boolean semOpenSession()>
<android.hardware.fingerprint.IFingerprintService: long getAuthenticatorId(int,int)>
<android.hardware.fingerprint.IFingerprintService: void resetLockout(android.os.IBinder,int,int,byte[],java.lang.String)>
<android.hardware.fingerprint.IFingerprintService: void onPointerUp(long,int,android.hardware.biometrics.fingerprint.PointerContext)>
<android.hardware.fingerprint.IFingerprintService: boolean semHasFeature(int)>
<android.hardware.fingerprint.IFingerprintService: int semSetScreenStatus(int)>
<android.hardware.fingerprint.IFingerprintService: int getLockoutModeForUser(int,int)>
<android.hardware.fingerprint.IFingerprintService: void generateChallenge(android.os.IBinder,int,int,android.hardware.fingerprint.IFingerprintServiceReceiver,java.lang.String)>
<android.hardware.fingerprint.IFingerprintService: java.lang.String semGetDaemonVersion()>
<android.hardware.fingerprint.IFingerprintService: boolean semIsEnrollSession()>
<android.hardware.fingerprint.IFingerprintService: long semAuthenticate(android.os.IBinder,long,android.hardware.fingerprint.IFingerprintServiceReceiver,android.hardware.fingerprint.FingerprintAuthenticateOptions,android.os.Bundle)>
<android.hardware.fingerprint.IFingerprintService: void semSetFlagForIFAA(int,java.lang.String)>
<android.hardware.fingerprint.IFingerprintService: void cancelFingerprintDetect(android.os.IBinder,java.lang.String,long)>
<android.hardware.fingerprint.IFingerprintService: void cancelAuthenticationFromService(int,android.os.IBinder,java.lang.String,long)>
<android.hardware.fingerprint.IFingerprintService: void semGetSensorData(android.os.Bundle)>
<android.hardware.fingerprint.IFingerprintService: java.lang.String semGetTrustAppVersion()>
<android.hardware.fingerprint.IFingerprintService: android.hardware.biometrics.ITestSession createTestSession(int,android.hardware.biometrics.ITestSessionCallback,java.lang.String)>
<android.hardware.fingerprint.IFingerprintService: void removeClientActiveCallback(android.hardware.fingerprint.IFingerprintClientActiveCallback)>
<android.hardware.fingerprint.IFingerprintService: boolean hasEnrolledFingerprints(int,int,java.lang.String)>
<android.hardware.fingerprint.IFingerprintService: int semRunSensorTest(android.os.IBinder,int,int,com.samsung.android.bio.fingerprint.ISemFingerprintRequestCallback)>
<android.hardware.fingerprint.IFingerprintService: void setUdfpsOverlay(android.hardware.fingerprint.IUdfpsOverlay)>
<android.hardware.fingerprint.IFingerprintService: long authenticate(android.os.IBinder,long,android.hardware.fingerprint.IFingerprintServiceReceiver,android.hardware.fingerprint.FingerprintAuthenticateOptions)>
<android.hardware.fingerprint.IFingerprintService: void addLockoutResetCallback(android.hardware.biometrics.IBiometricServiceLockoutResetCallback,java.lang.String)>
<android.hardware.fingerprint.IFingerprintService: void rename(int,int,java.lang.String)>
<android.hardware.fingerprint.IFingerprintService: int semBioSysUiRequest(int,int,long,java.lang.String)>
<android.hardware.fingerprint.IFingerprintService: int semProcessFido(int,byte[],byte[],java.lang.String)>
<android.hardware.fingerprint.IFingerprintService: int semGetIconBottomMargin()>
<android.hardware.fingerprint.IFingerprintService: int semGetSensorTestResult(byte[])>
<android.hardware.fingerprint.IFingerprintService: java.util.List getEnrolledFingerprints(int,java.lang.String,java.lang.String)>
<android.hardware.fingerprint.IFingerprintService: void remove(android.os.IBinder,int,int,android.hardware.fingerprint.IFingerprintServiceReceiver,java.lang.String)>
<android.hardware.fingerprint.IFingerprintService: java.lang.String semGetSensorInfo()>
<android.hardware.fingerprint.IFingerprintService: void semUnregisterDisplayStateCallback()>
<android.hardware.fingerprint.IFingerprintService: java.util.List getSensorPropertiesInternal(java.lang.String)>
<android.hardware.fingerprint.IFingerprintService: void semSetFodStrictMode(boolean)>
<android.hardware.fingerprint.IFingerprintService: int semSetCalibrationMode(android.os.IBinder,int,java.lang.String)>
<android.hardware.fingerprint.IFingerprintService: boolean hasEnrolledFingerprintsDeprecated(int,java.lang.String,java.lang.String)>
<android.hardware.fingerprint.IFingerprintService: void semMoveSensorIconInDisplay(int,int)>
<android.hardware.fingerprint.IFingerprintService: void setUdfpsOverlayController(android.hardware.fingerprint.IUdfpsOverlayController)>
<android.hardware.fingerprint.IFingerprintService: android.hardware.fingerprint.FingerprintSensorPropertiesInternal getSensorProperties(int,java.lang.String)>
<android.hardware.fingerprint.IFingerprintService: byte[] dumpSensorServiceStateProto(int,boolean)>
<android.hardware.fingerprint.IFingerprintService: void prepareForAuthentication(android.os.IBinder,long,android.hardware.biometrics.IBiometricSensorReceiver,android.hardware.fingerprint.FingerprintAuthenticateOptions,long,int,boolean)>
<android.hardware.fingerprint.IFingerprintService: int semGetSensorStatus()>
<android.hardware.fingerprint.IFingerprintService: boolean semResumeEnroll()>
<android.hardware.fingerprint.IFingerprintService: void invalidateAuthenticatorId(int,int,android.hardware.biometrics.IInvalidationCallback)>
<android.hardware.fingerprint.IFingerprintService: void semUnregisterAodController(android.os.IBinder)>
<android.hardware.fingerprint.IFingerprintService: int semShowBouncerScreen(int)>
<android.hardware.fingerprint.IFingerprintService: boolean isHardwareDetectedDeprecated(java.lang.String,java.lang.String)>
<android.hardware.fingerprint.IFingerprintService: int semGetRemainingLockoutTime(int)>
<android.hardware.fingerprint.IFingerprintService: void onUiReady(long,int)>
<android.hardware.fingerprint.IFingerprintService: void cancelEnrollment(android.os.IBinder,long)>
<android.hardware.fingerprint.IFingerprintService: boolean isHardwareDetected(int,java.lang.String)>
<android.hardware.fingerprint.IFingerprintService: void startPreparedClient(int,int)>
<android.hardware.fingerprint.IFingerprintService: void cancelAuthentication(android.os.IBinder,java.lang.String,java.lang.String,long)>
<android.hardware.fingerprint.IFingerprintService: void addAuthenticatorsRegisteredCallback(android.hardware.fingerprint.IFingerprintAuthenticatorsRegisteredCallback)>
<android.hardware.fingerprint.IFingerprintService: boolean semPauseEnroll()>
<android.hardware.fingerprint.IFingerprintService: java.lang.String[] semGetUserIdList()>
<android.hardware.fingerprint.IFingerprintService: int semRequest(android.os.IBinder,int,byte[],byte[],int,int,java.lang.String,com.samsung.android.bio.fingerprint.ISemFingerprintRequestCallback)>
<android.hardware.fingerprint.IFingerprintService: void scheduleWatchdog()>
<android.hardware.fingerprint.IFingerprintService: int semGetSecurityLevel()>
<android.hardware.fingerprint.IFingerprintService: void semUpdateTrustApp(java.lang.String,com.samsung.android.bio.fingerprint.ISemFingerprintRequestCallback,java.lang.String)>
<android.hardware.fingerprint.IFingerprintService: int semGetMaxEnrollmentNumber()>
<android.hardware.fingerprint.IFingerprintService: int semRegisterDisplayStateCallback(com.samsung.android.biometrics.ISemBiometricSysUiDisplayStateCallback)>
<android.hardware.fingerprint.IFingerprintService: android.graphics.Rect semGetSensorAreaInDisplay(int,int,android.graphics.Point)>
<android.hardware.fingerprint.IFingerprintService: void addClientActiveCallback(android.hardware.fingerprint.IFingerprintClientActiveCallback)>
<android.app.smartspace.ISmartspaceManager: void requestSmartspaceUpdate(android.app.smartspace.SmartspaceSessionId)>
<android.app.smartspace.ISmartspaceManager: void destroySmartspaceSession(android.app.smartspace.SmartspaceSessionId)>
<android.app.smartspace.ISmartspaceManager: void unregisterSmartspaceUpdates(android.app.smartspace.SmartspaceSessionId,android.app.smartspace.ISmartspaceCallback)>
<android.app.smartspace.ISmartspaceManager: void notifySmartspaceEvent(android.app.smartspace.SmartspaceSessionId,android.app.smartspace.SmartspaceTargetEvent)>
<android.app.smartspace.ISmartspaceManager: void registerSmartspaceUpdates(android.app.smartspace.SmartspaceSessionId,android.app.smartspace.ISmartspaceCallback)>
<android.app.smartspace.ISmartspaceManager: void createSmartspaceSession(android.app.smartspace.SmartspaceConfig,android.app.smartspace.SmartspaceSessionId,android.os.IBinder)>
<com.android.ims.internal.IImsUtListener: void utConfigurationCallForwardQueried(com.android.ims.internal.IImsUt,int,android.telephony.ims.ImsCallForwardInfo[])>
<com.android.ims.internal.IImsUtListener: void utConfigurationUpdated(com.android.ims.internal.IImsUt,int)>
<com.android.ims.internal.IImsUtListener: void utConfigurationUpdateFailed(com.android.ims.internal.IImsUt,int,android.telephony.ims.ImsReasonInfo)>
<com.android.ims.internal.IImsUtListener: void utConfigurationCallBarringQueried(com.android.ims.internal.IImsUt,int,android.telephony.ims.ImsSsInfo[])>
<com.android.ims.internal.IImsUtListener: void utConfigurationQueryFailed(com.android.ims.internal.IImsUt,int,android.telephony.ims.ImsReasonInfo)>
<com.android.ims.internal.IImsUtListener: void lineIdentificationSupplementaryServiceResponse(int,android.telephony.ims.ImsSsInfo)>
<com.android.ims.internal.IImsUtListener: void onSupplementaryServiceIndication(android.telephony.ims.ImsSsData)>
<com.android.ims.internal.IImsUtListener: void utConfigurationQueried(com.android.ims.internal.IImsUt,int,android.os.Bundle)>
<com.android.ims.internal.IImsUtListener: void utConfigurationCallWaitingQueried(com.android.ims.internal.IImsUt,int,android.telephony.ims.ImsSsInfo[])>
<android.service.games.IGameSession: void onDestroyed()>
<android.service.games.IGameSession: void onTransientSystemBarVisibilityFromRevealGestureChanged(boolean)>
<android.service.games.IGameSession: void onTaskFocusChanged(boolean)>
<android.view.IDisplayWindowListener: void onFixedRotationFinished(int)>
<android.view.IDisplayWindowListener: void onDisplayAdded(int)>
<android.view.IDisplayWindowListener: void onDisplayConfigurationChanged(int,android.content.res.Configuration)>
<android.view.IDisplayWindowListener: void onDisplayRemoved(int)>
<android.view.IDisplayWindowListener: void onKeepClearAreasChanged(int,java.util.List,java.util.List)>
<android.view.IDisplayWindowListener: void onFixedRotationStarted(int,int)>
<android.service.autofill.IInlineSuggestionUi: void releaseSurfaceControlViewHost()>
<android.service.autofill.IInlineSuggestionUi: void getSurfacePackage(android.service.autofill.ISurfacePackageResultCallback)>
<android.system.keystore2.IKeystoreSecurityLevel: int getInterfaceVersion()>
<android.system.keystore2.IKeystoreSecurityLevel: java.lang.String getInterfaceHash()>
<android.system.keystore2.IKeystoreSecurityLevel: void deleteKey(android.system.keystore2.KeyDescriptor)>
<android.system.keystore2.IKeystoreSecurityLevel: android.system.keystore2.CreateOperationResponse createOperation(android.system.keystore2.KeyDescriptor,android.hardware.security.keymint.KeyParameter[],boolean)>
<android.system.keystore2.IKeystoreSecurityLevel: android.system.keystore2.KeyMetadata generateKey(android.system.keystore2.KeyDescriptor,android.system.keystore2.KeyDescriptor,android.hardware.security.keymint.KeyParameter[],int,byte[])>
<android.system.keystore2.IKeystoreSecurityLevel: android.system.keystore2.KeyMetadata importKey(android.system.keystore2.KeyDescriptor,android.system.keystore2.KeyDescriptor,android.hardware.security.keymint.KeyParameter[],int,byte[])>
<android.system.keystore2.IKeystoreSecurityLevel: android.system.keystore2.EphemeralStorageKeyResponse convertStorageKeyToEphemeral(android.system.keystore2.KeyDescriptor)>
<android.system.keystore2.IKeystoreSecurityLevel: android.system.keystore2.KeyMetadata importWrappedKey(android.system.keystore2.KeyDescriptor,android.system.keystore2.KeyDescriptor,byte[],android.hardware.security.keymint.KeyParameter[],android.system.keystore2.AuthenticatorSpec[])>
<com.android.internal.inputmethod.IInputMethod: void onNavButtonFlagsChanged(int)>
<com.android.internal.inputmethod.IInputMethod: void startStylusHandwriting(int,android.view.InputChannel,java.util.List)>
<com.android.internal.inputmethod.IInputMethod: void updateEditorToolType(int)>
<com.android.internal.inputmethod.IInputMethod: void changeInputMethodSubtype(android.view.inputmethod.InputMethodSubtype)>
<com.android.internal.inputmethod.IInputMethod: void minimizeSoftInput(int)>
<com.android.internal.inputmethod.IInputMethod: void setStylusWindowIdleTimeoutForTest(long)>
<com.android.internal.inputmethod.IInputMethod: void undoMinimizeSoftInput()>
<com.android.internal.inputmethod.IInputMethod: void canStartStylusHandwriting(int)>
<com.android.internal.inputmethod.IInputMethod: void initializeInternal(com.android.internal.inputmethod.IInputMethod$InitParams)>
<com.android.internal.inputmethod.IInputMethod: void hideSoftInput(android.os.IBinder,android.view.inputmethod.ImeTracker$Token,int,android.os.ResultReceiver)>
<com.android.internal.inputmethod.IInputMethod: void unbindInput()>
<com.android.internal.inputmethod.IInputMethod: void setSessionEnabled(com.android.internal.inputmethod.IInputMethodSession,boolean)>
<com.android.internal.inputmethod.IInputMethod: void bindInput(android.view.inputmethod.InputBinding)>
<com.android.internal.inputmethod.IInputMethod: void startInput(com.android.internal.inputmethod.IInputMethod$StartInputParams)>
<com.android.internal.inputmethod.IInputMethod: void finishStylusHandwriting()>
<com.android.internal.inputmethod.IInputMethod: void initInkWindow()>
<com.android.internal.inputmethod.IInputMethod: void showSoftInput(android.os.IBinder,android.view.inputmethod.ImeTracker$Token,int,android.os.ResultReceiver)>
<com.android.internal.inputmethod.IInputMethod: void createSession(android.view.InputChannel,com.android.internal.inputmethod.IInputMethodSessionCallback)>
<com.android.internal.inputmethod.IInputMethod: void removeStylusHandwritingWindow()>
<com.android.internal.inputmethod.IInputMethod: void onCreateInlineSuggestionsRequest(com.android.internal.inputmethod.InlineSuggestionsRequestInfo,com.android.internal.inputmethod.IInlineSuggestionsRequestCallback)>
<android.media.ISoundDose: float getOutputRs2UpperBound()>
<android.media.ISoundDose: void forceComputeCsdOnAllDevices(boolean)>
<android.media.ISoundDose: float getCsd()>
<android.media.ISoundDose: boolean isSoundDoseHalSupported()>
<android.media.ISoundDose: void setCsdEnabled(boolean)>
<android.media.ISoundDose: void forceUseFrameworkMel(boolean)>
<android.media.ISoundDose: void resetCsd(float,android.media.SoundDoseRecord[])>
<android.media.ISoundDose: void setOutputRs2UpperBound(float)>
<android.media.ISoundDose: void updateAttenuation(float,int)>
<android.service.media.IMediaBrowserServiceCallbacks: void onLoadChildren(java.lang.String,android.content.pm.ParceledListSlice,android.os.Bundle)>
<android.service.media.IMediaBrowserServiceCallbacks: void onConnect(java.lang.String,android.media.session.MediaSession$Token,android.os.Bundle)>
<android.service.media.IMediaBrowserServiceCallbacks: void onConnectFailed()>
<android.app.ITransientNotificationCallback: void onToastHidden()>
<android.app.ITransientNotificationCallback: void onToastShown()>
<android.app.backup.IBackupManagerMonitor: void onEvent(android.os.Bundle)>
<android.view.contentcapture.IContentCaptureDirectManager: void sendEvents(android.content.pm.ParceledListSlice,int,android.content.ContentCaptureOptions)>
<com.samsung.android.mocca.IMoccaEventListener: void onContextUnavailable(java.lang.String)>
<com.samsung.android.mocca.IMoccaEventListener: void onContextChanged(com.samsung.android.mocca.ContextEvent)>
<com.samsung.android.mocca.IMoccaEventListener: void onContextStopped(java.lang.String)>
<com.samsung.android.mocca.IMoccaEventListener: void onContextAvailable(java.lang.String)>
<android.os.ISystemUpdateManager: void updateSystemUpdateInfo(android.os.PersistableBundle)>
<android.os.ISystemUpdateManager: android.os.Bundle retrieveSystemUpdateInfo()>
<android.hardware.camera2.extension.IRequestProcessorImpl: int setRepeating(android.hardware.camera2.extension.Request,android.hardware.camera2.extension.IRequestCallback)>
<android.hardware.camera2.extension.IRequestProcessorImpl: int submit(android.hardware.camera2.extension.Request,android.hardware.camera2.extension.IRequestCallback)>
<android.hardware.camera2.extension.IRequestProcessorImpl: void setImageProcessor(android.hardware.camera2.extension.OutputConfigId,android.hardware.camera2.extension.IImageProcessorImpl)>
<android.hardware.camera2.extension.IRequestProcessorImpl: int submitBurst(java.util.List,android.hardware.camera2.extension.IRequestCallback)>
<android.hardware.camera2.extension.IRequestProcessorImpl: void abortCaptures()>
<android.hardware.camera2.extension.IRequestProcessorImpl: void stopRepeating()>
<android.telephony.mbms.IMbmsStreamingSessionCallback: void onMiddlewareReady()>
<android.telephony.mbms.IMbmsStreamingSessionCallback: void onError(int,java.lang.String)>
<android.telephony.mbms.IMbmsStreamingSessionCallback: void onStreamingServicesUpdated(java.util.List)>
<android.view.contentcapture.IContentCaptureManager: void getServiceComponentName(com.android.internal.os.IResultReceiver)>
<android.view.contentcapture.IContentCaptureManager: void getServiceSettingsActivity(com.android.internal.os.IResultReceiver)>
<android.view.contentcapture.IContentCaptureManager: void isContentCaptureFeatureEnabled(com.android.internal.os.IResultReceiver)>
<android.view.contentcapture.IContentCaptureManager: void registerContentCaptureOptionsCallback(java.lang.String,android.view.contentcapture.IContentCaptureOptionsCallback)>
<android.view.contentcapture.IContentCaptureManager: void setDefaultServiceEnabled(int,boolean)>
<android.view.contentcapture.IContentCaptureManager: void resetTemporaryService(int)>
<android.view.contentcapture.IContentCaptureManager: void shareData(android.view.contentcapture.DataShareRequest,android.view.contentcapture.IDataShareWriteAdapter)>
<android.view.contentcapture.IContentCaptureManager: void finishSession(int)>
<android.view.contentcapture.IContentCaptureManager: void setTemporaryService(int,java.lang.String,int)>
<android.view.contentcapture.IContentCaptureManager: void removeData(android.view.contentcapture.DataRemovalRequest)>
<android.view.contentcapture.IContentCaptureManager: void getContentCaptureConditions(java.lang.String,com.android.internal.os.IResultReceiver)>
<android.view.contentcapture.IContentCaptureManager: void startSession(android.os.IBinder,android.os.IBinder,android.content.ComponentName,int,int,com.android.internal.os.IResultReceiver)>
<android.app.blob.IBlobStoreSession: void abandon()>
<android.app.blob.IBlobStoreSession: boolean isPackageAccessAllowed(java.lang.String,byte[])>
<android.app.blob.IBlobStoreSession: boolean isSameSignatureAccessAllowed()>
<android.app.blob.IBlobStoreSession: void allowPublicAccess()>
<android.app.blob.IBlobStoreSession: void allowPackageAccess(java.lang.String,byte[])>
<android.app.blob.IBlobStoreSession: void allowSameSignatureAccess()>
<android.app.blob.IBlobStoreSession: long getSize()>
<android.app.blob.IBlobStoreSession: android.os.ParcelFileDescriptor openRead()>
<android.app.blob.IBlobStoreSession: android.os.ParcelFileDescriptor openWrite(long,long)>
<android.app.blob.IBlobStoreSession: void close()>
<android.app.blob.IBlobStoreSession: void commit(android.app.blob.IBlobCommitCallback)>
<android.app.blob.IBlobStoreSession: boolean isPublicAccessAllowed()>
<android.os.INetworkManagementService: void addSocksSkipRuleProto(java.lang.String,java.lang.String,java.lang.String,int,java.lang.String)>
<android.os.INetworkManagementService: android.net.NetworkStats getNetworkStatsTethering(int)>
<android.os.INetworkManagementService: void clearEbpfMap(int)>
<android.os.INetworkManagementService: void addPortFwdRules(java.lang.String,java.lang.String,java.lang.String,java.lang.String,int)>
<android.os.INetworkManagementService: android.net.InterfaceConfiguration getInterfaceConfig(java.lang.String)>
<android.os.INetworkManagementService: void setEpdgInterfaceDropRule(java.lang.String,boolean)>
<android.os.INetworkManagementService: void removeUidSocksRule(java.lang.String,java.lang.String,java.lang.String,int,int,java.lang.String)>
<android.os.INetworkManagementService: void disableMptcp()>
<android.os.INetworkManagementService: int removeRoutesFromLocalNetwork(java.util.List)>
<android.os.INetworkManagementService: void enableIpv6(java.lang.String)>
<android.os.INetworkManagementService: void setFirewallRuleMobileData(int,boolean)>
<android.os.INetworkManagementService: long getNetworkStatsVideoCall(java.lang.String,int,int)>
<android.os.INetworkManagementService: void addUidSocksRule(java.lang.String,java.lang.String,java.lang.String,int,int,java.lang.String)>
<android.os.INetworkManagementService: void closeSocketsForUids(int[])>
<android.os.INetworkManagementService: void setUrlFirewallRuleMobileData(int,java.lang.String,boolean)>
<android.os.INetworkManagementService: void closeSocketsForFreecess(int,java.lang.String)>
<android.os.INetworkManagementService: void setKnoxGuardExemptRule(boolean,java.lang.String,int)>
<android.os.INetworkManagementService: void addIpAcceptRule(java.lang.String,java.lang.String,java.lang.String)>
<android.os.INetworkManagementService: void enableMptcp(java.lang.String)>
<android.os.INetworkManagementService: void setBlockListIPs(java.lang.String)>
<android.os.INetworkManagementService: void stopTethering()>
<android.os.INetworkManagementService: boolean isBandwidthControlEnabled()>
<android.os.INetworkManagementService: void setIPv6AddrGenMode(java.lang.String,int)>
<android.os.INetworkManagementService: void denyProtect(int)>
<android.os.INetworkManagementService: void registerTetheringStatsProvider(android.net.ITetheringStatsProvider,java.lang.String)>
<android.os.INetworkManagementService: void cleanAllBlock()>
<android.os.INetworkManagementService: void disableEpdg(java.lang.String,java.lang.String)>
<android.os.INetworkManagementService: void setDnsForwardersForKnoxVpn(int,java.lang.String[])>
<android.os.INetworkManagementService: void addMptcpLink(java.lang.String)>
<android.os.INetworkManagementService: boolean setDataSaverModeEnabled(boolean)>
<android.os.INetworkManagementService: void buildFirewall()>
<android.os.INetworkManagementService: void createNetworkGuardChain()>
<android.os.INetworkManagementService: void removeInterfaceQuota(java.lang.String)>
<android.os.INetworkManagementService: void clearInterfaceAddresses(java.lang.String)>
<android.os.INetworkManagementService: void addInterfaceToLocalNetwork(java.lang.String,java.util.List)>
<android.os.INetworkManagementService: void setMptcpMtuValue(java.lang.String,int)>
<android.os.INetworkManagementService: void removeSocksSkipRule(java.lang.String,java.lang.String,java.lang.String)>
<android.os.INetworkManagementService: void setBlockPorts(java.lang.String,int,java.lang.String)>
<android.os.INetworkManagementService: void removeInterfaceAlert(java.lang.String)>
<android.os.INetworkManagementService: void removeUidFromChain(java.lang.String,java.lang.String,int)>
<android.os.INetworkManagementService: void addSourcePortAcceptRule(java.lang.String,java.lang.String,int)>
<android.os.INetworkManagementService: void setFirewallEnabled(boolean)>
<android.os.INetworkManagementService: void tetherInterface(java.lang.String)>
<android.os.INetworkManagementService: boolean isNetworkRestricted(int)>
<android.os.INetworkManagementService: int replaceApeRule(java.lang.String,int,int)>
<android.os.INetworkManagementService: void setDestinationBasedMarkRule(boolean,java.lang.String,java.lang.String,int,int)>
<android.os.INetworkManagementService: void setUrlFirewallRuleWifi(int,java.lang.String,boolean)>
<android.os.INetworkManagementService: void setNetworkInfo(int,boolean,int)>
<android.os.INetworkManagementService: void allowProtect(int)>
<android.os.INetworkManagementService: void setAllowListIPs(java.lang.String)>
<android.os.INetworkManagementService: void removeSocksSkipRuleProto(java.lang.String,java.lang.String,java.lang.String,int,java.lang.String)>
<android.os.INetworkManagementService: void setFirewallUidRules(int,int[],int[])>
<android.os.INetworkManagementService: void setUidCleartextNetworkPolicy(int,int)>
<android.os.INetworkManagementService: void startInterfaceForwarding(java.lang.String,java.lang.String)>
<android.os.INetworkManagementService: void stopNetworkStatsOnPorts(java.lang.String,int,int)>
<android.os.INetworkManagementService: void addLegacyRoute(int,java.lang.String,java.lang.String,java.lang.String,int)>
<android.os.INetworkManagementService: void enableEpdg(java.lang.String,java.lang.String,boolean)>
<android.os.INetworkManagementService: int addApeRule(boolean,java.lang.String,int)>
<android.os.INetworkManagementService: void setGlobalAlert(long)>
<android.os.INetworkManagementService: void setKnoxVpn(int,boolean)>
<android.os.INetworkManagementService: void enableNetworkGuard(boolean)>
<android.os.INetworkManagementService: void setInterfaceUp(java.lang.String)>
<android.os.INetworkManagementService: void addOrRemoveSystemAppFromDataSaverWhitelist(boolean,int)>
<android.os.INetworkManagementService: void removeSocksRule(java.lang.String,java.lang.String,java.lang.String,int,java.lang.String)>
<android.os.INetworkManagementService: void addUidToChain(java.lang.String,java.lang.String,int)>
<android.os.INetworkManagementService: void shutdown()>
<android.os.INetworkManagementService: void startTetheringWithConfiguration(boolean,java.lang.String[])>
<android.os.INetworkManagementService: void setPrivateIpRoute(boolean,java.lang.String,int)>
<android.os.INetworkManagementService: void setInterfaceAlert(java.lang.String,long)>
<android.os.INetworkManagementService: void setInterfaceDown(java.lang.String)>
<android.os.INetworkManagementService: void startNetworkStatsOnPorts(java.lang.String,int,int)>
<android.os.INetworkManagementService: void tetherLimitReached(android.net.ITetheringStatsProvider)>
<android.os.INetworkManagementService: void closeSocketsForUid(int)>
<android.os.INetworkManagementService: void updateInputFilterUserWideRules(int[],int,int)>
<android.os.INetworkManagementService: void disableNetworkGuard()>
<android.os.INetworkManagementService: void deleteNetworkGuardChain()>
<android.os.INetworkManagementService: void addSourceRoute(java.lang.String,java.lang.String,java.lang.String)>
<android.os.INetworkManagementService: void setAutoConf(java.lang.String,boolean)>
<android.os.INetworkManagementService: void removeChain(java.lang.String,java.lang.String)>
<android.os.INetworkManagementService: java.lang.String[] listInterfaces()>
<android.os.INetworkManagementService: void setFirewallUidRule(int,int,int)>
<android.os.INetworkManagementService: java.lang.String[] getDnsForwarders()>
<android.os.INetworkManagementService: void enableNat(java.lang.String,java.lang.String)>
<android.os.INetworkManagementService: void deleteNetworkGuardWhiteListRule()>
<android.os.INetworkManagementService: void unregisterNetdTetherEventListener()>
<android.os.INetworkManagementService: void enableKnoxVpnFlagForTether(boolean)>
<android.os.INetworkManagementService: void setInterfaceIpv6PrivacyExtensions(java.lang.String,boolean)>
<android.os.INetworkManagementService: boolean getIpForwardingEnabled()>
<android.os.INetworkManagementService: void setAllowHostAlone(java.lang.String)>
<android.os.INetworkManagementService: void setBlockAllDNSPackets(boolean)>
<android.os.INetworkManagementService: void addSocksSkipRule(java.lang.String,java.lang.String,java.lang.String)>
<android.os.INetworkManagementService: void setBlockHostAlone(java.lang.String)>
<android.os.INetworkManagementService: int prioritizeApp(boolean,int)>
<android.os.INetworkManagementService: void setFirewallRuleWifi(int,boolean)>
<android.os.INetworkManagementService: void untetherInterface(java.lang.String)>
<android.os.INetworkManagementService: boolean isTetheringStarted()>
<android.os.INetworkManagementService: java.lang.String runKnoxFirewallRulesCommand(int,java.lang.String)>
<android.os.INetworkManagementService: void updateInputFilterExemptRules(int,int)>
<android.os.INetworkManagementService: void startTethering(java.lang.String[])>
<android.os.INetworkManagementService: void disableDAD(java.lang.String)>
<android.os.INetworkManagementService: void setBlockAllPackets()>
<android.os.INetworkManagementService: void removeMptcpLink(java.lang.String)>
<android.os.INetworkManagementService: void cleanBlockPorts()>
<android.os.INetworkManagementService: void setInterfaceConfig(java.lang.String,android.net.InterfaceConfiguration)>
<android.os.INetworkManagementService: void setFirewallInterfaceRule(java.lang.String,boolean)>
<android.os.INetworkManagementService: void stopQbox()>
<android.os.INetworkManagementService: void removeInterfaceFromLocalNetwork(java.lang.String)>
<android.os.INetworkManagementService: void setUidOnMeteredNetworkDenylist(int,boolean)>
<android.os.INetworkManagementService: void delIpAcceptRule(java.lang.String,java.lang.String,java.lang.String)>
<android.os.INetworkManagementService: void stopInterfaceForwarding(java.lang.String,java.lang.String)>
<android.os.INetworkManagementService: void updateSourceRule(boolean,java.lang.String,java.lang.String)>
<android.os.INetworkManagementService: void setInterfaceQuota(java.lang.String,long)>
<android.os.INetworkManagementService: void disableNat(java.lang.String,java.lang.String)>
<android.os.INetworkManagementService: void addChain(java.lang.String,java.lang.String)>
<android.os.INetworkManagementService: void runKnoxRulesCommand(int,java.lang.String[])>
<android.os.INetworkManagementService: void setTcpBufferSize(java.lang.String,java.lang.String)>
<android.os.INetworkManagementService: void setNetworkGuardUidRangeAcceptRule(int,int)>
<android.os.INetworkManagementService: void removeLegacyRoute(int,java.lang.String,java.lang.String,java.lang.String,int)>
<android.os.INetworkManagementService: void registerNetdTetherEventListener()>
<android.os.INetworkManagementService: void removeRoute(int,android.net.RouteInfo)>
<android.os.INetworkManagementService: java.lang.String[] listTetheredInterfaces()>
<android.os.INetworkManagementService: void spegRestrictNetworkConnection(int,boolean)>
<android.os.INetworkManagementService: void delSourceRoute(java.lang.String,java.lang.String,java.lang.String)>
<android.os.INetworkManagementService: void unregisterTetheringStatsProvider(android.net.ITetheringStatsProvider)>
<android.os.INetworkManagementService: void addSocksRule(java.lang.String,java.lang.String,java.lang.String,int,java.lang.String)>
<android.os.INetworkManagementService: void disableIpv6(java.lang.String)>
<android.os.INetworkManagementService: void delSourcePortAcceptRule(java.lang.String,java.lang.String,int)>
<android.os.INetworkManagementService: void setUidOnMeteredNetworkAllowlist(int,boolean)>
<android.os.INetworkManagementService: void unregisterObserver(android.net.INetworkManagementEventObserver)>
<android.os.INetworkManagementService: void setUIDRoute(boolean,java.lang.String,int,java.lang.String,java.lang.String)>
<android.os.INetworkManagementService: boolean isFirewallEnabled()>
<android.os.INetworkManagementService: void setNetworkGuardProtocolAcceptRule(int)>
<android.os.INetworkManagementService: void updateDefaultGatewayForEpdg(android.net.Network)>
<android.os.INetworkManagementService: void addRoute(int,android.net.RouteInfo)>
<android.os.INetworkManagementService: void setQboxUid(int,boolean)>
<android.os.INetworkManagementService: void registerObserver(android.net.INetworkManagementEventObserver)>
<android.os.INetworkManagementService: void startQbox(java.lang.String)>
<android.os.INetworkManagementService: void setFirewallChainEnabled(int,boolean)>
<android.os.INetworkManagementService: void setIpForwardingEnabled(boolean)>
<android.os.INetworkManagementService: void setNetworkGuardUidRule(int,boolean,boolean)>
<android.os.INetworkManagementService: void updateInputFilterAppWideRules(int[],int,int)>
<com.android.net.IProxyService: java.lang.String resolvePacFile(java.lang.String,java.lang.String)>
<com.android.net.IProxyService: void setPacFile(java.lang.String)>
<com.android.net.IProxyService: int startProxyServerForKnoxProfile(java.lang.String,int,java.lang.String,java.lang.String,boolean,java.lang.String,int)>
<com.android.net.IProxyService: boolean isProxyThreadAlive(java.lang.String)>
<com.android.net.IProxyService: boolean isProxyThreadRunning(java.lang.String)>
<com.android.net.IProxyService: int getProxyPortForProfile(java.lang.String)>
<com.android.net.IProxyService: boolean startPacSystemForKnoxProfile(java.lang.String)>
<com.android.net.IProxyService: void resetInterface(java.lang.String)>
<com.android.net.IProxyService: boolean stopPacSystemForKnoxProfile(java.lang.String)>
<com.android.net.IProxyService: void stopProxyServerForKnoxProfile(java.lang.String)>
<com.android.net.IProxyService: boolean setPacFileForKnoxProfile(java.lang.String,java.lang.String)>
<com.android.net.IProxyService: java.lang.String getProxythreadStatus(java.lang.String)>
<com.android.net.IProxyService: boolean setMiscValueForPacProfile(int,java.lang.String,java.lang.String,int)>
<com.android.net.IProxyService: void handleScreenunlock()>
<com.android.internal.textservice.ITextServicesManager: void getSpellCheckerService(int,java.lang.String,java.lang.String,com.android.internal.textservice.ITextServicesSessionListener,com.android.internal.textservice.ISpellCheckerSessionListener,android.os.Bundle,int)>
<com.android.internal.textservice.ITextServicesManager: void finishSpellCheckerService(int,com.android.internal.textservice.ISpellCheckerSessionListener)>
<com.android.internal.textservice.ITextServicesManager: android.view.textservice.SpellCheckerInfo getCurrentSpellChecker(int,java.lang.String)>
<com.android.internal.textservice.ITextServicesManager: android.view.textservice.SpellCheckerSubtype getCurrentSpellCheckerSubtype(int,boolean)>
<com.android.internal.textservice.ITextServicesManager: android.view.textservice.SpellCheckerInfo[] getEnabledSpellCheckers(int)>
<com.android.internal.textservice.ITextServicesManager: boolean isSpellCheckerEnabled(int)>
<com.samsung.android.emergencymode.IEmergencyManager: boolean isModifying()>
<com.samsung.android.emergencymode.IEmergencyManager: boolean isEmergencyMode()>
<com.samsung.android.emergencymode.IEmergencyManager: void setUserPackageBlocked(boolean)>
<com.samsung.android.emergencymode.IEmergencyManager: int getEmergencyState()>
<com.samsung.android.emergencymode.IEmergencyManager: boolean isUserPackageBlocked()>
<com.samsung.android.emergencymode.IEmergencyManager: boolean checkValidIntentAction(java.lang.String,java.lang.String)>
<com.samsung.android.emergencymode.IEmergencyManager: boolean checkInvalidProcess(java.lang.String)>
<com.samsung.android.emergencymode.IEmergencyManager: boolean needMobileDataBlock()>
<com.samsung.android.emergencymode.IEmergencyManager: boolean isScreenOn()>
<com.samsung.android.emergencymode.IEmergencyManager: void setLocationProviderEnabled(boolean)>
<com.samsung.android.emergencymode.IEmergencyManager: boolean addAppToLauncher(java.lang.String,boolean)>
<com.samsung.android.emergencymode.IEmergencyManager: boolean checkValidPackage(java.lang.String,java.lang.String,int)>
<com.samsung.android.emergencymode.IEmergencyManager: boolean checkInvalidBroadcast(java.lang.String,java.lang.String)>
<com.samsung.android.emergencymode.IEmergencyManager: boolean checkModeType(int)>
<android.media.midi.IMidiDeviceOpenCallback: void onDeviceOpened(android.media.midi.IMidiDeviceServer,android.os.IBinder)>
<android.os.ICancellationSignal: void cancel()>
<android.service.attention.IProximityUpdateCallback: void onProximityUpdate(double)>
<android.hardware.gnss.IAGnss: void dataConnOpen(long,java.lang.String,int)>
<android.hardware.gnss.IAGnss: java.lang.String getInterfaceHash()>
<android.hardware.gnss.IAGnss: void setCallback(android.hardware.gnss.IAGnssCallback)>
<android.hardware.gnss.IAGnss: void setServer(int,java.lang.String,int)>
<android.hardware.gnss.IAGnss: void dataConnFailed()>
<android.hardware.gnss.IAGnss: void dataConnClosed()>
<android.hardware.gnss.IAGnss: int getInterfaceVersion()>
<android.hardware.gnss.IGnssGeofence: int getInterfaceVersion()>
<android.hardware.gnss.IGnssGeofence: void removeGeofence(int)>
<android.hardware.gnss.IGnssGeofence: java.lang.String getInterfaceHash()>
<android.hardware.gnss.IGnssGeofence: void addGeofence(int,double,double,double,int,int,int,int)>
<android.hardware.gnss.IGnssGeofence: void pauseGeofence(int)>
<android.hardware.gnss.IGnssGeofence: void resumeGeofence(int,int)>
<android.hardware.gnss.IGnssGeofence: void setCallback(android.hardware.gnss.IGnssGeofenceCallback)>
<android.hardware.hdmi.IHdmiDeviceEventListener: void onStatusChanged(android.hardware.hdmi.HdmiDeviceInfo,int)>
<android.service.games.IGameSessionController: void restartGame(int)>
<android.service.games.IGameSessionController: void takeScreenshot(int,com.android.internal.infra.AndroidFuture)>
<android.media.tv.interactive.ITvInteractiveAppManager: void notifyRecordingScheduled(android.os.IBinder,java.lang.String,java.lang.String,int)>
<android.media.tv.interactive.ITvInteractiveAppManager: void notifyAdBufferConsumed(android.os.IBinder,android.media.tv.AdBuffer,int)>
<android.media.tv.interactive.ITvInteractiveAppManager: void setSurface(android.os.IBinder,android.view.Surface,int)>
<android.media.tv.interactive.ITvInteractiveAppManager: void createMediaView(android.os.IBinder,android.os.IBinder,android.graphics.Rect,int)>
<android.media.tv.interactive.ITvInteractiveAppManager: void notifyTimeShiftCurrentPositionChanged(android.os.IBinder,java.lang.String,long,int)>
<android.media.tv.interactive.ITvInteractiveAppManager: void notifyTimeShiftStartPositionChanged(android.os.IBinder,java.lang.String,long,int)>
<android.media.tv.interactive.ITvInteractiveAppManager: void sendCurrentTvInputId(android.os.IBinder,java.lang.String,int)>
<android.media.tv.interactive.ITvInteractiveAppManager: void notifyRecordingDisconnected(android.os.IBinder,java.lang.String,java.lang.String,int)>
<android.media.tv.interactive.ITvInteractiveAppManager: void sendCurrentChannelUri(android.os.IBinder,android.net.Uri,int)>
<android.media.tv.interactive.ITvInteractiveAppManager: void registerAppLinkInfo(java.lang.String,android.media.tv.interactive.AppLinkInfo,int)>
<android.media.tv.interactive.ITvInteractiveAppManager: java.util.List getTvInteractiveAppServiceList(int)>
<android.media.tv.interactive.ITvInteractiveAppManager: void notifyContentBlocked(android.os.IBinder,java.lang.String,int)>
<android.media.tv.interactive.ITvInteractiveAppManager: void notifyRecordingConnectionFailed(android.os.IBinder,java.lang.String,java.lang.String,int)>
<android.media.tv.interactive.ITvInteractiveAppManager: void startInteractiveApp(android.os.IBinder,int)>
<android.media.tv.interactive.ITvInteractiveAppManager: void removeMediaView(android.os.IBinder,int)>
<android.media.tv.interactive.ITvInteractiveAppManager: void notifyBroadcastInfoResponse(android.os.IBinder,android.media.tv.BroadcastInfoResponse,int)>
<android.media.tv.interactive.ITvInteractiveAppManager: void sendSigningResult(android.os.IBinder,java.lang.String,byte[],int)>
<android.media.tv.interactive.ITvInteractiveAppManager: void notifyTimeShiftStatusChanged(android.os.IBinder,java.lang.String,int,int)>
<android.media.tv.interactive.ITvInteractiveAppManager: void createBiInteractiveApp(android.os.IBinder,android.net.Uri,android.os.Bundle,int)>
<android.media.tv.interactive.ITvInteractiveAppManager: void notifyRecordingTuned(android.os.IBinder,java.lang.String,android.net.Uri,int)>
<android.media.tv.interactive.ITvInteractiveAppManager: void unregisterAppLinkInfo(java.lang.String,android.media.tv.interactive.AppLinkInfo,int)>
<android.media.tv.interactive.ITvInteractiveAppManager: void sendCurrentVideoBounds(android.os.IBinder,android.graphics.Rect,int)>
<android.media.tv.interactive.ITvInteractiveAppManager: void resetInteractiveApp(android.os.IBinder,int)>
<android.media.tv.interactive.ITvInteractiveAppManager: void notifyRecordingStarted(android.os.IBinder,java.lang.String,java.lang.String,int)>
<android.media.tv.interactive.ITvInteractiveAppManager: void sendCurrentChannelLcn(android.os.IBinder,int,int)>
<android.media.tv.interactive.ITvInteractiveAppManager: void releaseSession(android.os.IBinder,int)>
<android.media.tv.interactive.ITvInteractiveAppManager: void sendTimeShiftMode(android.os.IBinder,int,int)>
<android.media.tv.interactive.ITvInteractiveAppManager: java.util.List getAppLinkInfoList(int)>
<android.media.tv.interactive.ITvInteractiveAppManager: void notifyVideoUnavailable(android.os.IBinder,int,int)>
<android.media.tv.interactive.ITvInteractiveAppManager: void setTeletextAppEnabled(android.os.IBinder,boolean,int)>
<android.media.tv.interactive.ITvInteractiveAppManager: void notifyRecordingStopped(android.os.IBinder,java.lang.String,int)>
<android.media.tv.interactive.ITvInteractiveAppManager: void notifyAdResponse(android.os.IBinder,android.media.tv.AdResponse,int)>
<android.media.tv.interactive.ITvInteractiveAppManager: void sendAppLinkCommand(java.lang.String,android.os.Bundle,int)>
<android.media.tv.interactive.ITvInteractiveAppManager: void registerCallback(android.media.tv.interactive.ITvInteractiveAppManagerCallback,int)>
<android.media.tv.interactive.ITvInteractiveAppManager: void notifyTrackSelected(android.os.IBinder,int,java.lang.String,int)>
<android.media.tv.interactive.ITvInteractiveAppManager: void notifyVideoAvailable(android.os.IBinder,int)>
<android.media.tv.interactive.ITvInteractiveAppManager: void notifyError(android.os.IBinder,java.lang.String,android.os.Bundle,int)>
<android.media.tv.interactive.ITvInteractiveAppManager: void notifyTracksChanged(android.os.IBinder,java.util.List,int)>
<android.media.tv.interactive.ITvInteractiveAppManager: void sendStreamVolume(android.os.IBinder,float,int)>
<android.media.tv.interactive.ITvInteractiveAppManager: void sendTrackInfoList(android.os.IBinder,java.util.List,int)>
<android.media.tv.interactive.ITvInteractiveAppManager: void notifyRecordingError(android.os.IBinder,java.lang.String,int,int)>
<android.media.tv.interactive.ITvInteractiveAppManager: void sendTvRecordingInfo(android.os.IBinder,android.media.tv.TvRecordingInfo,int)>
<android.media.tv.interactive.ITvInteractiveAppManager: void notifySignalStrength(android.os.IBinder,int,int)>
<android.media.tv.interactive.ITvInteractiveAppManager: void notifyTimeShiftPlaybackParams(android.os.IBinder,android.media.PlaybackParams,int)>
<android.media.tv.interactive.ITvInteractiveAppManager: void notifyTuned(android.os.IBinder,android.net.Uri,int)>
<android.media.tv.interactive.ITvInteractiveAppManager: void notifyTvMessage(android.os.IBinder,int,android.os.Bundle,int)>
<android.media.tv.interactive.ITvInteractiveAppManager: void stopInteractiveApp(android.os.IBinder,int)>
<android.media.tv.interactive.ITvInteractiveAppManager: void createSession(android.media.tv.interactive.ITvInteractiveAppClient,java.lang.String,int,int,int)>
<android.media.tv.interactive.ITvInteractiveAppManager: void destroyBiInteractiveApp(android.os.IBinder,java.lang.String,int)>
<android.media.tv.interactive.ITvInteractiveAppManager: void relayoutMediaView(android.os.IBinder,android.graphics.Rect,int)>
<android.media.tv.interactive.ITvInteractiveAppManager: void sendAvailableSpeeds(android.os.IBinder,float[],int)>
<android.media.tv.interactive.ITvInteractiveAppManager: void dispatchSurfaceChanged(android.os.IBinder,int,int,int,int)>
<android.media.tv.interactive.ITvInteractiveAppManager: void sendTvRecordingInfoList(android.os.IBinder,java.util.List,int)>
<android.media.tv.interactive.ITvInteractiveAppManager: void unregisterCallback(android.media.tv.interactive.ITvInteractiveAppManagerCallback,int)>
<android.media.tv.interactive.ITvInteractiveAppManager: void notifyContentAllowed(android.os.IBinder,int)>
<com.android.internal.widget.IRemoteViewsFactory: boolean hasStableIds()>
<com.android.internal.widget.IRemoteViewsFactory: boolean isCreated()>
<com.android.internal.widget.IRemoteViewsFactory: int getCount()>
<com.android.internal.widget.IRemoteViewsFactory: long getItemId(int)>
<com.android.internal.widget.IRemoteViewsFactory: android.widget.RemoteViews getLoadingView()>
<com.android.internal.widget.IRemoteViewsFactory: void onDataSetChangedAsync()>
<com.android.internal.widget.IRemoteViewsFactory: void onDataSetChanged()>
<com.android.internal.widget.IRemoteViewsFactory: android.widget.RemoteViews getViewAt(int)>
<com.android.internal.widget.IRemoteViewsFactory: void onDestroy(android.content.Intent)>
<com.android.internal.widget.IRemoteViewsFactory: int getViewTypeCount()>
<android.content.pm.verify.domain.IDomainVerificationManager: java.util.List queryValidVerificationPackageNames()>
<android.content.pm.verify.domain.IDomainVerificationManager: android.content.pm.verify.domain.DomainVerificationInfo getDomainVerificationInfo(java.lang.String)>
<android.content.pm.verify.domain.IDomainVerificationManager: void setDomainVerificationLinkHandlingAllowed(java.lang.String,boolean,int)>
<android.content.pm.verify.domain.IDomainVerificationManager: int setDomainVerificationStatus(java.lang.String,android.content.pm.verify.domain.DomainSet,int)>
<android.content.pm.verify.domain.IDomainVerificationManager: java.util.List getOwnersForDomain(java.lang.String,int)>
<android.content.pm.verify.domain.IDomainVerificationManager: int setDomainVerificationUserSelection(java.lang.String,android.content.pm.verify.domain.DomainSet,boolean,int)>
<android.content.pm.verify.domain.IDomainVerificationManager: android.content.pm.verify.domain.DomainVerificationUserState getDomainVerificationUserState(java.lang.String,int)>
<android.telephony.ims.aidl.IImsRcsFeature: void addCapabilityCallback(android.telephony.ims.aidl.IImsCapabilityCallback)>
<android.telephony.ims.aidl.IImsRcsFeature: void removeCapabilityCallback(android.telephony.ims.aidl.IImsCapabilityCallback)>
<android.telephony.ims.aidl.IImsRcsFeature: void sendOptionsCapabilityRequest(android.net.Uri,java.util.List,android.telephony.ims.aidl.IOptionsResponseCallback)>
<android.telephony.ims.aidl.IImsRcsFeature: int queryCapabilityStatus()>
<android.telephony.ims.aidl.IImsRcsFeature: int getFeatureState()>
<android.telephony.ims.aidl.IImsRcsFeature: void setCapabilityExchangeEventListener(android.telephony.ims.aidl.ICapabilityExchangeEventListener)>
<android.telephony.ims.aidl.IImsRcsFeature: void changeCapabilitiesConfiguration(android.telephony.ims.feature.CapabilityChangeRequest,android.telephony.ims.aidl.IImsCapabilityCallback)>
<android.telephony.ims.aidl.IImsRcsFeature: void publishCapabilities(java.lang.String,android.telephony.ims.aidl.IPublishResponseCallback)>
<android.telephony.ims.aidl.IImsRcsFeature: void queryCapabilityConfiguration(int,int,android.telephony.ims.aidl.IImsCapabilityCallback)>
<android.telephony.ims.aidl.IImsRcsFeature: void subscribeForCapabilities(java.util.List,android.telephony.ims.aidl.ISubscribeResponseCallback)>
<android.hardware.IConsumerIrService: int[] getCarrierFrequencies()>
<android.hardware.IConsumerIrService: boolean hasIrEmitter()>
<android.hardware.IConsumerIrService: void transmit(java.lang.String,int,int[])>
<android.service.carrier.ICarrierMessagingCallback: void onFilterComplete(int)>
<android.service.carrier.ICarrierMessagingCallback: void onSendMultipartSmsComplete(int,int[])>
<android.service.carrier.ICarrierMessagingCallback: void onSendMmsComplete(int,byte[])>
<android.service.carrier.ICarrierMessagingCallback: void onDownloadMmsComplete(int)>
<android.service.carrier.ICarrierMessagingCallback: void onSendSmsComplete(int,int)>
<android.location.ILocationManager: java.lang.String getExtraLocationControllerPackage()>
<android.location.ILocationManager: void registerLocationPendingIntent(java.lang.String,android.location.LocationRequest,android.app.PendingIntent,java.lang.String,java.lang.String)>
<android.location.ILocationManager: void addGnssNavigationMessageListener(android.location.IGnssNavigationMessageListener,java.lang.String,java.lang.String,java.lang.String)>
<android.location.ILocationManager: java.lang.String getGnssHardwareModelName()>
<android.location.ILocationManager: java.lang.String getBestProvider(android.location.Criteria,boolean)>
<android.location.ILocationManager: boolean isAutomotiveGnssSuspended()>
<android.location.ILocationManager: int getGnssYearOfHardware()>
<android.location.ILocationManager: void setAdasGnssLocationEnabledForUser(boolean,int)>
<android.location.ILocationManager: android.os.PackageTagsList getIgnoreSettingsAllowlist()>
<android.location.ILocationManager: void unregisterGnssNmeaCallback(android.location.IGnssNmeaListener)>
<android.location.ILocationManager: android.location.provider.ProviderProperties getProviderProperties(java.lang.String)>
<android.location.ILocationManager: void setExtraLocationControllerPackage(java.lang.String)>
<android.location.ILocationManager: void getFromLocationName(java.lang.String,double,double,double,double,int,android.location.GeocoderParams,android.location.IGeocodeListener)>
<android.location.ILocationManager: android.location.GnssCapabilities getGnssCapabilities()>
<android.location.ILocationManager: void onFreezeStateChanged(boolean,int)>
<android.location.ILocationManager: void requestListenerFlush(java.lang.String,android.location.ILocationListener,int)>
<android.location.ILocationManager: boolean isProviderPackage(java.lang.String,java.lang.String,java.lang.String)>
<android.location.ILocationManager: void notifyNSFLP(android.os.Message)>
<android.location.ILocationManager: void unregisterLocationListener(android.location.ILocationListener)>
<android.location.ILocationManager: void unregisterLocationPendingIntent(android.app.PendingIntent)>
<android.location.ILocationManager: boolean geocoderIsPresent()>
<android.location.ILocationManager: void setLocationEnabledForUser(boolean,int)>
<android.location.ILocationManager: boolean isProviderEnabledForUser(java.lang.String,int)>
<android.location.ILocationManager: void removeTestProvider(java.lang.String,java.lang.String,java.lang.String)>
<android.location.ILocationManager: void addProviderRequestListener(android.location.provider.IProviderRequestListener)>
<android.location.ILocationManager: android.os.PackageTagsList getAdasAllowlist()>
<android.location.ILocationManager: void removeGnssAntennaInfoListener(android.location.IGnssAntennaInfoListener)>
<android.location.ILocationManager: void registerLocationListener(java.lang.String,android.location.LocationRequest,android.location.ILocationListener,java.lang.String,java.lang.String,java.lang.String)>
<android.location.ILocationManager: void setTestProviderLocation(java.lang.String,android.location.Location,java.lang.String,java.lang.String)>
<android.location.ILocationManager: void requestPendingIntentFlush(java.lang.String,android.app.PendingIntent,int)>
<android.location.ILocationManager: void startGnssBatch(long,android.location.ILocationListener,java.lang.String,java.lang.String,java.lang.String)>
<android.location.ILocationManager: void flushGnssBatch()>
<android.location.ILocationManager: java.util.List getAllProviders()>
<android.location.ILocationManager: java.util.List getProviderPackages(java.lang.String)>
<android.location.ILocationManager: void injectLocation(android.location.Location)>
<android.location.ILocationManager: boolean hasProvider(java.lang.String)>
<android.location.ILocationManager: void addTestProvider(java.lang.String,android.location.provider.ProviderProperties,java.util.List,java.lang.String,java.lang.String)>
<android.location.ILocationManager: void removeGnssNavigationMessageListener(android.location.IGnssNavigationMessageListener)>
<android.location.ILocationManager: java.util.List getGnssAntennaInfos()>
<android.location.ILocationManager: void injectGnssMeasurementCorrections(android.location.GnssMeasurementCorrections)>
<android.location.ILocationManager: void removeProviderRequestListener(android.location.provider.IProviderRequestListener)>
<android.location.ILocationManager: void unregisterGnssStatusCallback(android.location.IGnssStatusListener)>
<android.location.ILocationManager: android.location.LocationTime getGnssTimeMillis()>
<android.location.ILocationManager: java.util.Map getGPSUsingApps()>
<android.location.ILocationManager: boolean isLocationEnabledForUser(int)>
<android.location.ILocationManager: java.util.List getProviders(android.location.Criteria,boolean)>
<android.location.ILocationManager: void getFromLocation(double,double,int,android.location.GeocoderParams,android.location.IGeocodeListener)>
<android.location.ILocationManager: android.location.Location getLastLocation(java.lang.String,android.location.LastLocationRequest,java.lang.String,java.lang.String)>
<android.location.ILocationManager: android.os.ICancellationSignal getCurrentLocation(java.lang.String,android.location.LocationRequest,android.location.ILocationCallback,java.lang.String,java.lang.String,java.lang.String)>
<android.location.ILocationManager: void addGnssMeasurementsListener(android.location.GnssMeasurementRequest,android.location.IGnssMeasurementsListener,java.lang.String,java.lang.String,java.lang.String)>
<android.location.ILocationManager: void setTestProviderEnabled(java.lang.String,boolean,java.lang.String,java.lang.String)>
<android.location.ILocationManager: void setAutomotiveGnssSuspended(boolean)>
<android.location.ILocationManager: void requestGeofence(android.location.Geofence,android.app.PendingIntent,java.lang.String,java.lang.String)>
<android.location.ILocationManager: void stopGnssBatch()>
<android.location.ILocationManager: void sendExtraCommand(java.lang.String,java.lang.String,android.os.Bundle)>
<android.location.ILocationManager: java.lang.String[] getBackgroundThrottlingWhitelist()>
<android.location.ILocationManager: int getGnssBatchSize()>
<android.location.ILocationManager: void registerGnssNmeaCallback(android.location.IGnssNmeaListener,java.lang.String,java.lang.String,java.lang.String)>
<android.location.ILocationManager: boolean isAdasGnssLocationEnabledForUser(int)>
<android.location.ILocationManager: void removeGeofence(android.app.PendingIntent)>
<android.location.ILocationManager: void setExtraLocationControllerPackageEnabled(boolean)>
<android.location.ILocationManager: boolean isExtraLocationControllerPackageEnabled()>
<android.location.ILocationManager: void registerGnssStatusCallback(android.location.IGnssStatusListener,java.lang.String,java.lang.String,java.lang.String)>
<android.location.ILocationManager: void addGnssAntennaInfoListener(android.location.IGnssAntennaInfoListener,java.lang.String,java.lang.String,java.lang.String)>
<android.location.ILocationManager: void removeGnssMeasurementsListener(android.location.IGnssMeasurementsListener)>
<android.location.provider.IProviderRequestListener: void onProviderRequestChanged(java.lang.String,android.location.provider.ProviderRequest)>
<android.media.tv.interactive.ITvInteractiveAppSessionCallback: void onRequestScheduleRecording2(java.lang.String,java.lang.String,android.net.Uri,long,long,int,android.os.Bundle)>
<android.media.tv.interactive.ITvInteractiveAppSessionCallback: void onRequestAvailableSpeeds()>
<android.media.tv.interactive.ITvInteractiveAppSessionCallback: void onRequestCurrentChannelLcn()>
<android.media.tv.interactive.ITvInteractiveAppSessionCallback: void onBroadcastInfoRequest(android.media.tv.BroadcastInfoRequest)>
<android.media.tv.interactive.ITvInteractiveAppSessionCallback: void onSetVideoBounds(android.graphics.Rect)>
<android.media.tv.interactive.ITvInteractiveAppSessionCallback: void onRequestScheduleRecording(java.lang.String,java.lang.String,android.net.Uri,android.net.Uri,android.os.Bundle)>
<android.media.tv.interactive.ITvInteractiveAppSessionCallback: void onSessionCreated(android.media.tv.interactive.ITvInteractiveAppSession)>
<android.media.tv.interactive.ITvInteractiveAppSessionCallback: void onTimeShiftCommandRequest(java.lang.String,android.os.Bundle)>
<android.media.tv.interactive.ITvInteractiveAppSessionCallback: void onRequestStartRecording(java.lang.String,android.net.Uri)>
<android.media.tv.interactive.ITvInteractiveAppSessionCallback: void onAdRequest(android.media.tv.AdRequest)>
<android.media.tv.interactive.ITvInteractiveAppSessionCallback: void onTeletextAppStateChanged(int)>
<android.media.tv.interactive.ITvInteractiveAppSessionCallback: void onRequestStopRecording(java.lang.String)>
<android.media.tv.interactive.ITvInteractiveAppSessionCallback: void onAdBufferReady(android.media.tv.AdBuffer)>
<android.media.tv.interactive.ITvInteractiveAppSessionCallback: void onRequestTvRecordingInfo(java.lang.String)>
<android.media.tv.interactive.ITvInteractiveAppSessionCallback: void onRequestTvRecordingInfoList(int)>
<android.media.tv.interactive.ITvInteractiveAppSessionCallback: void onRequestStreamVolume()>
<android.media.tv.interactive.ITvInteractiveAppSessionCallback: void onRequestTimeShiftMode()>
<android.media.tv.interactive.ITvInteractiveAppSessionCallback: void onRemoveBroadcastInfo(int)>
<android.media.tv.interactive.ITvInteractiveAppSessionCallback: void onLayoutSurface(int,int,int,int)>
<android.media.tv.interactive.ITvInteractiveAppSessionCallback: void onRequestTrackInfoList()>
<android.media.tv.interactive.ITvInteractiveAppSessionCallback: void onSetTvRecordingInfo(java.lang.String,android.media.tv.TvRecordingInfo)>
<android.media.tv.interactive.ITvInteractiveAppSessionCallback: void onRequestCurrentVideoBounds()>
<android.media.tv.interactive.ITvInteractiveAppSessionCallback: void onBiInteractiveAppCreated(android.net.Uri,java.lang.String)>
<android.media.tv.interactive.ITvInteractiveAppSessionCallback: void onRequestCurrentChannelUri()>
<android.media.tv.interactive.ITvInteractiveAppSessionCallback: void onCommandRequest(java.lang.String,android.os.Bundle)>
<android.media.tv.interactive.ITvInteractiveAppSessionCallback: void onRequestSigning(java.lang.String,java.lang.String,java.lang.String,byte[])>
<android.media.tv.interactive.ITvInteractiveAppSessionCallback: void onRequestCurrentTvInputId()>
<android.media.tv.interactive.ITvInteractiveAppSessionCallback: void onSessionStateChanged(int,int)>
<android.media.IMediaResourceMonitor: void notifyResourceGranted(int,int)>
<android.speech.tts.ITextToSpeechService: int speak(android.os.IBinder,java.lang.CharSequence,int,android.os.Bundle,java.lang.String)>
<android.speech.tts.ITextToSpeechService: java.util.List getVoices()>
<android.speech.tts.ITextToSpeechService: int synthesizeToFileDescriptor(android.os.IBinder,java.lang.CharSequence,android.os.ParcelFileDescriptor,android.os.Bundle,java.lang.String)>
<android.speech.tts.ITextToSpeechService: void setCallback(android.os.IBinder,android.speech.tts.ITextToSpeechCallback)>
<android.speech.tts.ITextToSpeechService: int isLanguageAvailable(java.lang.String,java.lang.String,java.lang.String)>
<android.speech.tts.ITextToSpeechService: java.lang.String getDefaultVoiceNameFor(java.lang.String,java.lang.String,java.lang.String)>
<android.speech.tts.ITextToSpeechService: boolean isSpeaking()>
<android.speech.tts.ITextToSpeechService: int loadVoice(android.os.IBinder,java.lang.String)>
<android.speech.tts.ITextToSpeechService: int stop(android.os.IBinder)>
<android.speech.tts.ITextToSpeechService: java.lang.String[] getFeaturesForLanguage(java.lang.String,java.lang.String,java.lang.String)>
<android.speech.tts.ITextToSpeechService: java.lang.String[] getClientDefaultLanguage()>
<android.speech.tts.ITextToSpeechService: int playAudio(android.os.IBinder,android.net.Uri,int,android.os.Bundle,java.lang.String)>
<android.speech.tts.ITextToSpeechService: int playSilence(android.os.IBinder,long,int,java.lang.String)>
<android.speech.tts.ITextToSpeechService: int loadLanguage(android.os.IBinder,java.lang.String,java.lang.String,java.lang.String)>
<android.speech.tts.ITextToSpeechService: java.lang.String[] getLanguage()>
<com.samsung.android.knox.mpos.IMPOSService: boolean loadTa(int,android.os.ParcelFileDescriptor,long,long,com.samsung.android.knox.mpos.MposTZServiceConfig)>
<com.samsung.android.knox.mpos.IMPOSService: com.samsung.android.knox.mpos.TACommandResponse processTACommand(int,com.samsung.android.knox.mpos.TACommandRequest)>
<com.samsung.android.knox.mpos.IMPOSService: boolean unloadTa(int)>
<com.android.ims.internal.IImsFeatureStatusCallback: void notifyImsFeatureStatus(int)>
<android.telephony.ims.aidl.IImsConfigCallback: void onStringConfigChanged(int,java.lang.String)>
<android.telephony.ims.aidl.IImsConfigCallback: void onIntConfigChanged(int,int)>
<android.content.pm.IOnChecksumsReadyListener: void onChecksumsReady(java.util.List)>
<com.android.internal.carlife.IStatusBarCarLife: void showTransient(int,int,boolean)>
<com.android.internal.carlife.IStatusBarCarLife: void abortTransient(int,int)>
<com.android.internal.carlife.IStatusBarCarLife: void onSystemBarAttributesChanged(int,int,com.android.internal.view.AppearanceRegion[],boolean,int,int,java.lang.String)>
<android.window.ISurfaceSyncGroupCompletedListener: void onSurfaceSyncGroupComplete()>
<android.content.ISyncAdapter: void cancelSync(android.content.ISyncContext)>
<android.content.ISyncAdapter: void startSync(android.content.ISyncContext,java.lang.String,android.accounts.Account,android.os.Bundle)>
<android.content.ISyncAdapter: void onUnsyncableAccount(android.content.ISyncAdapterUnsyncableAccountCallback)>
<android.media.tv.tunerresourcemanager.IResourcesReclaimListener: void onReclaimResources()>
<com.samsung.android.security.IDirEncryptServiceListener: void onEncryptionStatusChanged(java.lang.String,int,java.lang.String,int,int)>
<android.os.IClientCallback: void onClients(android.os.IBinder,boolean)>
<android.telephony.satellite.stub.ISatelliteCapabilitiesConsumer: void accept(android.telephony.satellite.stub.SatelliteCapabilities)>
<android.telephony.ims.aidl.ISipTransport: void destroySipDelegate(android.telephony.ims.aidl.ISipDelegate,int)>
<android.telephony.ims.aidl.ISipTransport: void createSipDelegate(int,android.telephony.ims.DelegateRequest,android.telephony.ims.aidl.ISipDelegateStateCallback,android.telephony.ims.aidl.ISipDelegateMessageCallback)>
<android.service.autofill.augmented.IFillCallback: boolean isCompleted()>
<android.service.autofill.augmented.IFillCallback: void cancel()>
<android.service.autofill.augmented.IFillCallback: void onSuccess(java.util.List,android.os.Bundle,boolean)>
<android.service.autofill.augmented.IFillCallback: void onCancellable(android.os.ICancellationSignal)>
<android.hardware.usb.gadget.IUsbGadgetCallback: int getInterfaceVersion()>
<android.hardware.usb.gadget.IUsbGadgetCallback: void resetCb(int,long)>
<android.hardware.usb.gadget.IUsbGadgetCallback: void setCurrentUsbFunctionsCb(long,int,long)>
<android.hardware.usb.gadget.IUsbGadgetCallback: void getUsbSpeedCb(int,long)>
<android.hardware.usb.gadget.IUsbGadgetCallback: java.lang.String getInterfaceHash()>
<android.hardware.usb.gadget.IUsbGadgetCallback: void getCurrentUsbFunctionsCb(long,int,long)>
<android.view.translation.ITranslationServiceCallback: void updateTranslationCapability(android.view.translation.TranslationCapability)>
<com.samsung.android.smartface.ISmartFaceService: boolean register(com.samsung.android.smartface.ISmartFaceClient,int)>
<com.samsung.android.smartface.ISmartFaceService: void setValue(com.samsung.android.smartface.ISmartFaceClient,java.lang.String,java.lang.String)>
<com.samsung.android.smartface.ISmartFaceService: int getSupportedServices()>
<com.samsung.android.smartface.ISmartFaceService: void registerAsync(com.samsung.android.smartface.ISmartFaceClient,int)>
<com.samsung.android.smartface.ISmartFaceService: void unregister(com.samsung.android.smartface.ISmartFaceClient)>
<com.samsung.android.smartface.ISmartFaceService: void unregisterAsync(com.samsung.android.smartface.ISmartFaceClient)>
<com.android.internal.app.IMediaContainerService: android.content.pm.PackageInfoLite getMinimalPackageInfo(java.lang.String,int,java.lang.String)>
<com.android.internal.app.IMediaContainerService: android.content.res.ObbInfo getObbInfo(java.lang.String)>
<com.android.internal.app.IMediaContainerService: int copyPackage(java.lang.String,com.android.internal.os.IParcelFileDescriptorFactory)>
<com.android.internal.app.IMediaContainerService: long calculateInstalledSize(java.lang.String,java.lang.String)>
<android.media.IMediaScannerListener: void scanCompleted(java.lang.String,android.net.Uri)>
<android.content.pm.IPackageManagerNative: java.lang.String[] getStagedApexModuleNames()>
<android.content.pm.IPackageManagerNative: void unregisterStagedApexObserver(android.content.pm.IStagedApexObserver)>
<android.content.pm.IPackageManagerNative: boolean hasSha256SigningCertificate(java.lang.String,byte[])>
<android.content.pm.IPackageManagerNative: boolean[] isAudioPlaybackCaptureAllowed(java.lang.String[])>
<android.content.pm.IPackageManagerNative: android.content.pm.StagedApexInfo getStagedApexInfo(java.lang.String)>
<android.content.pm.IPackageManagerNative: void registerStagedApexObserver(android.content.pm.IStagedApexObserver)>
<android.content.pm.IPackageManagerNative: java.lang.String[] getNamesForUids(int[])>
<android.content.pm.IPackageManagerNative: java.lang.String getModuleMetadataPackageName()>
<android.content.pm.IPackageManagerNative: int getLocationFlags(java.lang.String)>
<android.content.pm.IPackageManagerNative: boolean hasSystemFeature(java.lang.String,int)>
<android.content.pm.IPackageManagerNative: int getTargetSdkVersionForPackage(java.lang.String)>
<android.content.pm.IPackageManagerNative: long getVersionCodeForPackage(java.lang.String)>
<android.content.pm.IPackageManagerNative: boolean isPackageDebuggable(java.lang.String)>
<android.content.pm.IPackageManagerNative: java.lang.String getInstallerForPackage(java.lang.String)>
<com.android.internal.app.IVisualQueryDetectionAttentionListener: void onAttentionLost()>
<com.android.internal.app.IVisualQueryDetectionAttentionListener: void onAttentionGained()>
<android.view.IPinnedTaskListener: void onMovementBoundsChanged(boolean)>
<android.view.IPinnedTaskListener: void onImeVisibilityChanged(boolean,int)>
<android.view.IPinnedTaskListener: void onActivityHidden(android.content.ComponentName)>
<android.speech.IRecognitionService: void cancel(android.speech.IRecognitionListener,boolean)>
<android.speech.IRecognitionService: void stopListening(android.speech.IRecognitionListener)>
<android.speech.IRecognitionService: void triggerModelDownload(android.content.Intent,android.content.AttributionSource,android.speech.IModelDownloadListener)>
<android.speech.IRecognitionService: void startListening(android.content.Intent,android.speech.IRecognitionListener,android.content.AttributionSource)>
<android.speech.IRecognitionService: void checkRecognitionSupport(android.content.Intent,android.content.AttributionSource,android.speech.IRecognitionSupportCallback)>
<android.telephony.data.IQualifiedNetworksService: void createNetworkAvailabilityProvider(int,android.telephony.data.IQualifiedNetworksServiceCallback)>
<android.telephony.data.IQualifiedNetworksService: void reportEmergencyDataNetworkPreferredTransportChanged(int,int)>
<android.telephony.data.IQualifiedNetworksService: void reportThrottleStatusChanged(int,java.util.List)>
<android.telephony.data.IQualifiedNetworksService: void removeNetworkAvailabilityProvider(int)>
<com.samsung.android.hardware.secinputdev.ISemInputDeviceManager: boolean isKeyPressedByKeycode(int)>
<com.samsung.android.hardware.secinputdev.ISemInputDeviceManager: int setAodEnable(int)>
<com.samsung.android.hardware.secinputdev.ISemInputDeviceManager: int setSingletapEnable(int)>
<com.samsung.android.hardware.secinputdev.ISemInputDeviceManager: java.lang.String getCommandList(com.samsung.android.hardware.secinputdev.SemInputConstants$Device)>
<com.samsung.android.hardware.secinputdev.ISemInputDeviceManager: boolean registerListener(android.os.IBinder,int,java.lang.String)>
<com.samsung.android.hardware.secinputdev.ISemInputDeviceManager: int setAodRect(int,int,int,int)>
<com.samsung.android.hardware.secinputdev.ISemInputDeviceManager: int setFodEnable(int,int,int)>
<com.samsung.android.hardware.secinputdev.ISemInputDeviceManager: int setSyncChanged(int)>
<com.samsung.android.hardware.secinputdev.ISemInputDeviceManager: int setMotionControl(java.lang.String,int,java.lang.String)>
<com.samsung.android.hardware.secinputdev.ISemInputDeviceManager: int setTspEnabled(int,int,boolean)>
<com.samsung.android.hardware.secinputdev.ISemInputDeviceManager: int sendRawdataTsp(com.samsung.android.hardware.secinputdev.SemInputConstants$Device,int[])>
<com.samsung.android.hardware.secinputdev.ISemInputDeviceManager: int getTspSupportFeature(com.samsung.android.hardware.secinputdev.SemInputConstants$Device)>
<com.samsung.android.hardware.secinputdev.ISemInputDeviceManager: java.lang.String getKeyPressStateAll()>
<com.samsung.android.hardware.secinputdev.ISemInputDeviceManager: int setSpenEnabled(int,int,boolean)>
<com.samsung.android.hardware.secinputdev.ISemInputDeviceManager: boolean unregisterListener(android.os.IBinder,int,java.lang.String)>
<com.samsung.android.hardware.secinputdev.ISemInputDeviceManager: int getMotionControl(java.lang.String,java.lang.String)>
<com.samsung.android.hardware.secinputdev.ISemInputDeviceManager: java.lang.String runCommand(com.samsung.android.hardware.secinputdev.SemInputConstants$Device,java.lang.String)>
<com.samsung.android.hardware.secinputdev.ISemInputDeviceManager: int getDeviceEnabled(com.samsung.android.hardware.secinputdev.SemInputConstants$Device)>
<com.samsung.android.hardware.secinputdev.ISemInputDeviceManager: int setFodLpMode(int)>
<com.samsung.android.hardware.secinputdev.ISemInputDeviceManager: java.lang.String getProperty(com.samsung.android.hardware.secinputdev.SemInputConstants$Device,com.samsung.android.hardware.secinputdev.SemInputConstants$Property)>
<com.samsung.android.hardware.secinputdev.ISemInputDeviceManager: boolean isSupportMotion(java.lang.String)>
<com.samsung.android.hardware.secinputdev.ISemInputDeviceManager: int enableMotion(java.lang.String,boolean,java.lang.String)>
<com.samsung.android.hardware.secinputdev.ISemInputDeviceManager: int setFodRect(int,int,int,int)>
<com.samsung.android.hardware.secinputdev.ISemInputDeviceManager: int setProperty(com.samsung.android.hardware.secinputdev.SemInputConstants$Device,com.samsung.android.hardware.secinputdev.SemInputConstants$Property,java.lang.String)>
<com.samsung.android.hardware.secinputdev.ISemInputDeviceManager: int activate(com.samsung.android.hardware.secinputdev.SemInputConstants$Device,com.samsung.android.hardware.secinputdev.SemInputConstants$DisplayState,boolean)>
<com.samsung.android.hardware.secinputdev.ISemInputDeviceManager: int isEnableMotion(java.lang.String,java.lang.String)>
<com.samsung.android.hardware.secinputdev.ISemInputDeviceManager: int getSupportDevice(com.samsung.android.hardware.secinputdev.SemInputConstants$Device)>
<com.samsung.android.hardware.secinputdev.ISemInputDeviceManager: int setCommand(com.samsung.android.hardware.secinputdev.SemInputConstants$Device,com.samsung.android.hardware.secinputdev.SemInputConstants$Command,java.lang.String)>
<com.samsung.android.hardware.secinputdev.ISemInputDeviceManager: int setTemperature(int)>
<android.hardware.biometrics.IBiometricServiceLockoutResetCallback: void onLockoutReset(int,android.os.IRemoteCallback)>
<android.view.IInputFilterHost: void sendInputEvent(android.view.InputEvent,int)>
<android.app.usage.IUsageStatsManager: void reportUsageStop(android.os.IBinder,java.lang.String,java.lang.String)>
<android.app.usage.IUsageStatsManager: android.app.usage.UsageEvents queryEventsForPackage(long,long,java.lang.String)>
<android.app.usage.IUsageStatsManager: void reportChooserSelection(java.lang.String,int,java.lang.String,java.lang.String[],java.lang.String)>
<android.app.usage.IUsageStatsManager: void setEstimatedLaunchTimes(android.content.pm.ParceledListSlice,int)>
<android.app.usage.IUsageStatsManager: void reportUserInteraction(java.lang.String,int)>
<android.app.usage.IUsageStatsManager: void forceUsageSourceSettingRead()>
<android.app.usage.IUsageStatsManager: android.app.usage.UsageEvents queryEventsForPackageForUser(long,long,int,java.lang.String,java.lang.String)>
<android.app.usage.IUsageStatsManager: android.content.pm.ParceledListSlice queryUsageStats(int,long,long,java.lang.String,int)>
<android.app.usage.IUsageStatsManager: void registerUsageSessionObserver(int,java.lang.String[],long,long,android.app.PendingIntent,android.app.PendingIntent,java.lang.String)>
<android.app.usage.IUsageStatsManager: void reportUsageStart(android.os.IBinder,java.lang.String,java.lang.String)>
<android.app.usage.IUsageStatsManager: android.content.pm.ParceledListSlice getAppStandbyBuckets(java.lang.String,int)>
<android.app.usage.IUsageStatsManager: boolean isAppInactive(java.lang.String,int,java.lang.String)>
<android.app.usage.IUsageStatsManager: android.content.pm.ParceledListSlice queryConfigurationStats(int,long,long,java.lang.String)>
<android.app.usage.IUsageStatsManager: android.content.pm.ParceledListSlice queryEventStats(int,long,long,java.lang.String)>
<android.app.usage.IUsageStatsManager: android.app.usage.BroadcastResponseStatsList queryBroadcastResponseStats(java.lang.String,long,java.lang.String,int)>
<android.app.usage.IUsageStatsManager: void unregisterUsageStatsWatcher(com.samsung.android.app.usage.IUsageStatsWatcher)>
<android.app.usage.IUsageStatsManager: android.app.usage.UsageEvents queryEvents(long,long,java.lang.String)>
<android.app.usage.IUsageStatsManager: void setAppInactive(java.lang.String,boolean,int)>
<android.app.usage.IUsageStatsManager: boolean isAppStandbyEnabled()>
<android.app.usage.IUsageStatsManager: void registerAppUsageLimitObserver(int,java.lang.String[],long,long,android.app.PendingIntent,java.lang.String)>
<android.app.usage.IUsageStatsManager: android.app.usage.UsageEvents queryEventsForUser(long,long,int,java.lang.String)>
<android.app.usage.IUsageStatsManager: void deleteUsageStats()>
<android.app.usage.IUsageStatsManager: void registerAppUsageObserver(int,java.lang.String[],long,android.app.PendingIntent,java.lang.String)>
<android.app.usage.IUsageStatsManager: void clearBroadcastResponseStats(java.lang.String,long,java.lang.String,int)>
<android.app.usage.IUsageStatsManager: void setAppStandbyBucket(java.lang.String,int,int)>
<android.app.usage.IUsageStatsManager: int getAppMinStandbyBucket(java.lang.String,java.lang.String,int)>
<android.app.usage.IUsageStatsManager: void onCarrierPrivilegedAppsChanged()>
<android.app.usage.IUsageStatsManager: int getAppStandbyBucket(java.lang.String,java.lang.String,int)>
<android.app.usage.IUsageStatsManager: void clearBroadcastEvents(java.lang.String,int)>
<android.app.usage.IUsageStatsManager: long getLastTimeAnyComponentUsed(java.lang.String,java.lang.String)>
<android.app.usage.IUsageStatsManager: java.lang.String getAppStandbyConstant(java.lang.String)>
<android.app.usage.IUsageStatsManager: void registerUsageStatsWatcher(com.samsung.android.app.usage.IUsageStatsWatcher)>
<android.app.usage.IUsageStatsManager: void unregisterAppUsageLimitObserver(int,java.lang.String)>
<android.app.usage.IUsageStatsManager: void unregisterAppUsageObserver(int,java.lang.String)>
<android.app.usage.IUsageStatsManager: void setAppStandbyBuckets(android.content.pm.ParceledListSlice,int)>
<android.app.usage.IUsageStatsManager: void unregisterUsageSessionObserver(int,java.lang.String)>
<android.app.usage.IUsageStatsManager: int getUsageSource()>
<android.app.usage.IUsageStatsManager: void registerUsageStatsWatcherWithComponent(com.samsung.android.app.usage.IUsageStatsWatcher,java.util.List)>
<android.app.usage.IUsageStatsManager: void reportPastUsageStart(android.os.IBinder,java.lang.String,long,java.lang.String)>
<android.app.usage.IUsageStatsManager: void setEstimatedLaunchTime(java.lang.String,long,int)>
<android.media.IMediaRouter2Manager: void notifySessionReleased(android.media.RoutingSessionInfo)>
<android.media.IMediaRouter2Manager: void notifySessionCreated(int,android.media.RoutingSessionInfo)>
<android.media.IMediaRouter2Manager: void notifyRequestFailed(int,int)>
<android.media.IMediaRouter2Manager: void notifyRoutesUpdated(java.util.List)>
<android.media.IMediaRouter2Manager: void notifyDiscoveryPreferenceChanged(java.lang.String,android.media.RouteDiscoveryPreference)>
<android.media.IMediaRouter2Manager: void notifyRouteListingPreferenceChange(java.lang.String,android.media.RouteListingPreference)>
<android.media.IMediaRouter2Manager: void notifySessionUpdated(android.media.RoutingSessionInfo)>
<android.location.IGeofenceProvider: void setGeofenceHardware(android.hardware.location.IGeofenceHardware)>
<com.android.internal.telephony.IWwanSelectorResultCallback: void onComplete(android.telephony.EmergencyRegResult)>
<android.accounts.IAccountAuthenticatorResponse: void onResult(android.os.Bundle)>
<android.accounts.IAccountAuthenticatorResponse: void onRequestContinued()>
<android.accounts.IAccountAuthenticatorResponse: void onError(int,java.lang.String)>
<android.service.contentcapture.IDataShareCallback: void reject()>
<android.service.contentcapture.IDataShareCallback: void accept(android.service.contentcapture.IDataShareReadAdapter)>
<android.view.ISurfaceControlViewHost: void onDispatchDetachedFromWindow()>
<android.view.ISurfaceControlViewHost: void onInsetsChanged(android.view.InsetsState,android.graphics.Rect)>
<android.view.ISurfaceControlViewHost: void onConfigurationChanged(android.content.res.Configuration)>
<android.view.ISurfaceControlViewHost: android.window.ISurfaceSyncGroup getSurfaceSyncGroup()>
<com.samsung.android.knox.app.networkfilter.INetworkFilterProxy: boolean isProxyThreadAlive()>
<com.samsung.android.knox.app.networkfilter.INetworkFilterProxy: int getV6LocalProxyPort()>
<com.samsung.android.knox.app.networkfilter.INetworkFilterProxy: int registerRemoteProxyAddr(java.lang.String,java.lang.String)>
<com.samsung.android.knox.app.networkfilter.INetworkFilterProxy: boolean isV6ProxyThreadRunning()>
<com.samsung.android.knox.app.networkfilter.INetworkFilterProxy: void vpnMessengerForDnsQuery(android.os.IBinder)>
<com.samsung.android.knox.app.networkfilter.INetworkFilterProxy: java.util.List getListener(java.lang.String)>
<com.samsung.android.knox.app.networkfilter.INetworkFilterProxy: int setConfig(java.lang.String,java.lang.String)>
<com.samsung.android.knox.app.networkfilter.INetworkFilterProxy: java.lang.String getProxythreadStatus()>
<com.samsung.android.knox.app.networkfilter.INetworkFilterProxy: int stopV6ProxyServer()>
<com.samsung.android.knox.app.networkfilter.INetworkFilterProxy: java.lang.String getV6LocalProxyAddress()>
<com.samsung.android.knox.app.networkfilter.INetworkFilterProxy: int startV6ProxyServer()>
<com.samsung.android.knox.app.networkfilter.INetworkFilterProxy: java.lang.String getV6ProxythreadStatus()>
<com.samsung.android.knox.app.networkfilter.INetworkFilterProxy: int getLocalProxyPort()>
<com.samsung.android.knox.app.networkfilter.INetworkFilterProxy: int stopProxyServer()>
<com.samsung.android.knox.app.networkfilter.INetworkFilterProxy: boolean isProxyThreadRunning()>
<com.samsung.android.knox.app.networkfilter.INetworkFilterProxy: int startProxyServer()>
<com.samsung.android.knox.app.networkfilter.INetworkFilterProxy: java.lang.String getLocalProxyAddress()>
<com.samsung.android.knox.app.networkfilter.INetworkFilterProxy: boolean isV6ProxyThreadAlive()>
<com.samsung.android.knox.app.networkfilter.INetworkFilterProxy: void updateApplicationInfo(java.lang.String,int,java.lang.String,java.lang.String,int)>
<android.hardware.IDeviceInjectorSession: void stopDeviceInjector()>
<android.hardware.IDeviceInjectorSession: void setDeviceInjectorPending(boolean)>
<android.service.resumeonreboot.IResumeOnRebootService: void unwrap(byte[],android.os.RemoteCallback)>
<android.service.resumeonreboot.IResumeOnRebootService: void wrapSecret(byte[],long,android.os.RemoteCallback)>
<android.view.accessibility.IWindowMagnificationConnection: void moveWindowMagnifierToPosition(int,float,float,android.view.accessibility.IRemoteMagnificationAnimationCallback)>
<android.view.accessibility.IWindowMagnificationConnection: void removeMagnificationButton(int)>
<android.view.accessibility.IWindowMagnificationConnection: void showMagnificationButton(int,int)>
<android.view.accessibility.IWindowMagnificationConnection: void enableWindowMagnification(int,float,float,float,float,float,android.view.accessibility.IRemoteMagnificationAnimationCallback)>
<android.view.accessibility.IWindowMagnificationConnection: void setScale(int,float)>
<android.view.accessibility.IWindowMagnificationConnection: void removeMagnificationSettingsPanel(int)>
<android.view.accessibility.IWindowMagnificationConnection: void setConnectionCallback(android.view.accessibility.IWindowMagnificationConnectionCallback)>
<android.view.accessibility.IWindowMagnificationConnection: void disableWindowMagnification(int,android.view.accessibility.IRemoteMagnificationAnimationCallback)>
<android.view.accessibility.IWindowMagnificationConnection: void moveWindowMagnifier(int,float,float)>
<com.samsung.android.ims.ft.SemImsFtListener: void onFtStateChanged(boolean)>
<android.service.chooser.IChooserTargetResult: void sendResult(java.util.List)>
<com.samsung.android.camera.iris.IIrisDaemon: int enroll(byte[],int,int)>
<com.samsung.android.camera.iris.IIrisDaemon: int setActiveGroup(int,byte[])>
<com.samsung.android.camera.iris.IIrisDaemon: void sendIRProperty(java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
<com.samsung.android.camera.iris.IIrisDaemon: android.os.IBinder createInputSurface(int,int,int)>
<com.samsung.android.camera.iris.IIrisDaemon: int request(int,byte[],byte[],int)>
<com.samsung.android.camera.iris.IIrisDaemon: long preEnroll()>
<com.samsung.android.camera.iris.IIrisDaemon: long openHal()>
<com.samsung.android.camera.iris.IIrisDaemon: int remove(int,int)>
<com.samsung.android.camera.iris.IIrisDaemon: int cancelEnrollment()>
<com.samsung.android.camera.iris.IIrisDaemon: void processFrontImage(android.os.ParcelFileDescriptor,int,int,int)>
<com.samsung.android.camera.iris.IIrisDaemon: int releasePreviewSurface()>
<com.samsung.android.camera.iris.IIrisDaemon: int authenticate(long,int,byte[])>
<com.samsung.android.camera.iris.IIrisDaemon: int cancelAuthentication()>
<com.samsung.android.camera.iris.IIrisDaemon: void init(com.samsung.android.camera.iris.IIrisDaemonCallback)>
<com.samsung.android.camera.iris.IIrisDaemon: int cancelEnumeration()>
<com.samsung.android.camera.iris.IIrisDaemon: int postEnroll()>
<com.samsung.android.camera.iris.IIrisDaemon: int setPreviewTarget(android.os.IBinder)>
<com.samsung.android.camera.iris.IIrisDaemon: int closeHal()>
<com.samsung.android.camera.iris.IIrisDaemon: int enumerate()>
<com.samsung.android.camera.iris.IIrisDaemon: void processIRImage(android.os.ParcelFileDescriptor,int,int,int)>
<com.samsung.android.camera.iris.IIrisDaemon: int release(int)>
<com.samsung.android.camera.iris.IIrisDaemon: long getAuthenticatorId()>
<android.media.IAudioRoutesObserver: void dispatchAudioRoutesChanged(android.media.AudioRoutesInfo)>
<android.app.ambientcontext.IAmbientContextObserver: void onRegistrationComplete(int)>
<android.app.ambientcontext.IAmbientContextObserver: void onEvents(java.util.List)>
<android.telephony.ims.aidl.ISipDelegate: void cleanupSession(java.lang.String)>
<android.telephony.ims.aidl.ISipDelegate: void notifyMessageReceived(java.lang.String)>
<android.telephony.ims.aidl.ISipDelegate: void notifyMessageReceiveError(java.lang.String,int)>
<android.telephony.ims.aidl.ISipDelegate: void sendMessage(android.telephony.ims.SipMessage,long)>
<android.service.assist.classification.IFieldClassificationService: void onConnected(boolean,boolean)>
<android.service.assist.classification.IFieldClassificationService: void onFieldClassificationRequest(android.service.assist.classification.FieldClassificationRequest,android.service.assist.classification.IFieldClassificationCallback)>
<android.service.assist.classification.IFieldClassificationService: void onDisconnected()>
<android.hardware.display.IExynosDisplaySolutionManager: float[] getRgbGain()>
<android.hardware.display.IExynosDisplaySolutionManager: void setEdgeSharpnessSettingValue(int)>
<android.hardware.display.IExynosDisplaySolutionManager: void setSkinColorSettingOn(int)>
<android.hardware.display.IExynosDisplaySolutionManager: void setEyeTempSettingOn(int)>
<android.hardware.display.IExynosDisplaySolutionManager: void setColorTempSettingValue(int)>
<android.hardware.display.IExynosDisplaySolutionManager: void setColorEnhancementSettingValue(int)>
<android.hardware.display.IExynosDisplaySolutionManager: void setRgbGainSettingValue(int,int,int)>
<android.hardware.display.IExynosDisplaySolutionManager: void setColorTempSettingOn(int)>
<android.hardware.display.IExynosDisplaySolutionManager: void setRgbGain(float,float,float)>
<android.hardware.display.IExynosDisplaySolutionManager: void setHsvGainSettingValue(int,int,int)>
<android.hardware.display.IExynosDisplaySolutionManager: void setEyeTempSettingValue(int)>
<android.hardware.display.IExynosDisplaySolutionManager: void setHsvGainSettingOn(int)>
<android.hardware.display.IExynosDisplaySolutionManager: void setRgbGainSettingOn(int)>
<android.hardware.display.IExynosDisplaySolutionManager: void setWhitePointColorSettingOn(int)>
<android.hardware.display.IExynosDisplaySolutionManager: void setEdgeSharpnessSettingOn(int)>
<android.hardware.display.IExynosDisplaySolutionManager: java.lang.String getColorEnhancementMode()>
<android.hardware.display.IExynosDisplaySolutionManager: void setDisplayFeature(java.lang.String,int,int,java.lang.String)>
<com.samsung.android.game.IGameManagerService: boolean disableVrrControl(java.lang.String)>
<com.samsung.android.game.IGameManagerService: boolean initGameManager(int,java.util.Map)>
<com.samsung.android.game.IGameManagerService: com.samsung.android.game.PkgData getGamePkgDataIncServer(java.lang.String)>
<com.samsung.android.game.IGameManagerService: boolean enableVrrControl(java.lang.String)>
<com.samsung.android.game.IGameManagerService: java.lang.String getSosPolicy(java.lang.String)>
<com.samsung.android.game.IGameManagerService: java.lang.String requestWithJson(java.lang.String,java.lang.String)>
<com.samsung.android.game.IGameManagerService: java.lang.String getForegroundApp()>
<com.samsung.android.game.IGameManagerService: int identifyGamePackage(java.lang.String)>
<com.samsung.android.game.IGameManagerService: boolean setTargetFrameRate(android.os.IBinder,int)>
<com.samsung.android.game.IGameManagerService: boolean unregisterCallback(com.samsung.android.game.IGameManagerCallback)>
<com.samsung.android.game.IGameManagerService: java.util.List getGameList()>
<com.samsung.android.game.IGameManagerService: java.lang.String getVersion()>
<com.samsung.android.game.IGameManagerService: boolean registerCallback(com.samsung.android.game.IGameManagerCallback)>
<com.samsung.android.game.IGameManagerService: void syncGameList(java.util.Map)>
<com.samsung.android.game.IGameManagerService: boolean setPackageConfigurations(java.util.List)>
<com.samsung.android.game.IGameManagerService: int identifyForegroundApp()>
<com.samsung.android.game.IGameManagerService: boolean setPerformanceMode(int,java.lang.String)>
<com.samsung.android.game.IGameManagerService: java.lang.String getTopActivityName()>
<com.samsung.android.sepunion.IGalaxyRegistryService: void registerListener(java.lang.String,android.os.IBinder)>
<com.samsung.android.sepunion.IGalaxyRegistryService: void unRegisterListener(java.lang.String,android.os.IBinder)>
<android.view.accessibility.IAccessibilityManager: int getFocusColor()>
<android.view.accessibility.IAccessibilityManager: boolean semIsAccessibilityServiceEnabled(int)>
<android.view.accessibility.IAccessibilityManager: boolean semDisableMdnieColorFilter()>
<android.view.accessibility.IAccessibilityManager: java.lang.String getScreenReaderName()>
<android.view.accessibility.IAccessibilityManager: void sendAccessibilityEvent(android.view.accessibility.AccessibilityEvent,int)>
<android.view.accessibility.IAccessibilityManager: void unregisterUiTestAutomationService(android.accessibilityservice.IAccessibilityServiceClient)>
<android.view.accessibility.IAccessibilityManager: void interrupt(int)>
<android.view.accessibility.IAccessibilityManager: void semPerformAccessibilityButtonClick(int,int,java.lang.String)>
<android.view.accessibility.IAccessibilityManager: void associateEmbeddedHierarchy(android.os.IBinder,android.os.IBinder)>
<android.view.accessibility.IAccessibilityManager: boolean semSetColorBlind(boolean,float)>
<android.view.accessibility.IAccessibilityManager: void semEnableWindowMagnification(int,int)>
<android.view.accessibility.IAccessibilityManager: boolean stopFlashNotificationSequence(java.lang.String)>
<android.view.accessibility.IAccessibilityManager: void registerSystemAction(android.app.RemoteAction,int)>
<android.view.accessibility.IAccessibilityManager: void semOpenDeviceOptions()>
<android.view.accessibility.IAccessibilityManager: void setWindowMagnificationConnection(android.view.accessibility.IWindowMagnificationConnection)>
<android.view.accessibility.IAccessibilityManager: java.util.List getInstalledAccessibilityServiceList(int)>
<android.view.accessibility.IAccessibilityManager: boolean OnStopGestureWakeup()>
<android.view.accessibility.IAccessibilityManager: int convertPixelToDpi(float)>
<android.view.accessibility.IAccessibilityManager: void notifyAccessibilityButtonVisibilityChanged(boolean)>
<android.view.accessibility.IAccessibilityManager: boolean semEnableMdnieColorFilter(int,int)>
<android.view.accessibility.IAccessibilityManager: boolean startFlashNotificationEvent(java.lang.String,int,java.lang.String)>
<android.view.accessibility.IAccessibilityManager: java.util.List getEnabledAccessibilityServiceList(int,int)>
<android.view.accessibility.IAccessibilityManager: void semTurnOnAccessibilityService(int)>
<android.view.accessibility.IAccessibilityManager: void setPictureInPictureActionReplacingConnection(android.view.accessibility.IAccessibilityInteractionConnection)>
<android.view.accessibility.IAccessibilityManager: boolean semCheckMdnieColorBlind(int[])>
<android.view.accessibility.IAccessibilityManager: boolean isScreenReaderEnabled()>
<android.view.accessibility.IAccessibilityManager: boolean removeClient(android.view.accessibility.IAccessibilityManagerClient,int)>
<android.view.accessibility.IAccessibilityManager: long addClient(android.view.accessibility.IAccessibilityManagerClient,int)>
<android.view.accessibility.IAccessibilityManager: void semLockNow()>
<android.view.accessibility.IAccessibilityManager: void setTalkbackMode()>
<android.view.accessibility.IAccessibilityManager: void semMoveWindowMagnification(float,float)>
<android.view.accessibility.IAccessibilityManager: boolean OnStartGestureWakeup()>
<android.view.accessibility.IAccessibilityManager: int getAccessibilityWindowId(android.os.IBinder)>
<android.view.accessibility.IAccessibilityManager: boolean semSetMdnieAccessibilityMode(int,boolean)>
<android.view.accessibility.IAccessibilityManager: java.util.List getAccessibilityShortcutTargets(int)>
<android.view.accessibility.IAccessibilityManager: void semRegisterAssistantMenu(android.os.IBinder)>
<android.view.accessibility.IAccessibilityManager: boolean semIsAccessibilityButtonShown()>
<android.view.accessibility.IAccessibilityManager: void setSystemAudioCaptioningEnabled(boolean,int)>
<android.view.accessibility.IAccessibilityManager: android.os.IBinder getWindowToken(int,int)>
<android.view.accessibility.IAccessibilityManager: void semDisableWindowMagnification()>
<android.view.accessibility.IAccessibilityManager: int addAccessibilityInteractionConnection(android.view.IWindow,android.os.IBinder,android.view.accessibility.IAccessibilityInteractionConnection,java.lang.String,int)>
<android.view.accessibility.IAccessibilityManager: void semTurnOffAccessibilityService(int)>
<android.view.accessibility.IAccessibilityManager: void semToggleDarkScreenMode()>
<android.view.accessibility.IAccessibilityManager: boolean isAudioDescriptionByDefaultEnabled()>
<android.view.accessibility.IAccessibilityManager: android.view.accessibility.IAccessibilityManager$WindowTransformationSpec getWindowTransformationSpec(int)>
<android.view.accessibility.IAccessibilityManager: boolean isAccessibilityTargetAllowed(java.lang.String,int,int)>
<android.view.accessibility.IAccessibilityManager: void setScreenReaderEnabled(boolean)>
<android.view.accessibility.IAccessibilityManager: boolean sendFingerprintGesture(int)>
<android.view.accessibility.IAccessibilityManager: long getRecommendedTimeoutMillis()>
<android.view.accessibility.IAccessibilityManager: void performAccessibilityDirectAccess(java.lang.String)>
<android.view.accessibility.IAccessibilityManager: boolean sendRestrictedDialogIntent(java.lang.String,int,int)>
<android.view.accessibility.IAccessibilityManager: int getFocusStrokeWidth()>
<android.view.accessibility.IAccessibilityManager: boolean semIsWindowMagnificationEnabled()>
<android.view.accessibility.IAccessibilityManager: void semSetTwoFingerGestureRecognitionEnabled(boolean)>
<android.view.accessibility.IAccessibilityManager: boolean startFlashNotificationSequence(java.lang.String,int,android.os.IBinder)>
<android.view.accessibility.IAccessibilityManager: void removeAccessibilityInteractionConnection(android.view.IWindow)>
<android.view.accessibility.IAccessibilityManager: void disassociateEmbeddedHierarchy(android.os.IBinder)>
<android.view.accessibility.IAccessibilityManager: void notifyAccessibilityButtonClicked(int,java.lang.String)>
<android.view.accessibility.IAccessibilityManager: boolean isTwoFingerGestureRecognitionEnabled()>
<android.view.accessibility.IAccessibilityManager: void registerUiTestAutomationService(android.os.IBinder,android.accessibilityservice.IAccessibilityServiceClient,android.accessibilityservice.AccessibilityServiceInfo,int,int)>
<android.view.accessibility.IAccessibilityManager: boolean registerProxyForDisplay(android.accessibilityservice.IAccessibilityServiceClient,int)>
<android.view.accessibility.IAccessibilityManager: void unregisterSystemAction(int)>
<android.view.accessibility.IAccessibilityManager: void setMagnificationDisactivate()>
<android.view.accessibility.IAccessibilityManager: boolean unregisterProxyForDisplay(int)>
<android.view.accessibility.IAccessibilityManager: android.graphics.Rect semGetWindowMagnificationBounds()>
<android.view.accessibility.IAccessibilityManager: float semGetWindowMagnificationScale()>
<android.view.accessibility.IAccessibilityManager: void semDumpCallStack(java.lang.String)>
<android.view.accessibility.IAccessibilityManager: void setAccessibilityWindowAttributes(int,int,int,android.view.accessibility.AccessibilityWindowAttributes)>
<android.view.accessibility.IAccessibilityManager: boolean isActivatedMagnification()>
<android.view.accessibility.IAccessibilityManager: void semUpdateAssitantMenu(android.os.Bundle)>
<android.view.accessibility.IAccessibilityManager: void setSystemAudioCaptioningUiEnabled(boolean,int)>
<android.view.accessibility.IAccessibilityManager: void injectInputEventToInputFilter(android.view.InputEvent)>
<android.view.accessibility.IAccessibilityManager: boolean isSystemAudioCaptioningUiEnabled(int)>
<android.view.accessibility.IAccessibilityManager: boolean semIsDarkScreenMode()>
<android.view.accessibility.IAccessibilityManager: void performAccessibilityShortcut(java.lang.String)>
<android.view.selectiontoolbar.ISelectionToolbarManager: void hideToolbar(long,int)>
<android.view.selectiontoolbar.ISelectionToolbarManager: void showToolbar(android.view.selectiontoolbar.ShowInfo,android.view.selectiontoolbar.ISelectionToolbarCallback,int)>
<android.view.selectiontoolbar.ISelectionToolbarManager: void dismissToolbar(long,int)>
<android.service.euicc.IGetDownloadableSubscriptionMetadataCallback: void onComplete(android.service.euicc.GetDownloadableSubscriptionMetadataResult)>
<android.app.IGrammaticalInflectionManager: void setRequestedApplicationGrammaticalGender(java.lang.String,int,int)>
<android.hardware.soundtrigger3.ISoundTriggerHwGlobalCallback: int getInterfaceVersion()>
<android.hardware.soundtrigger3.ISoundTriggerHwGlobalCallback: java.lang.String getInterfaceHash()>
<android.hardware.soundtrigger3.ISoundTriggerHwGlobalCallback: void onResourcesAvailable()>
<android.os.IIncidentAuthListener: void onReportDenied()>
<android.os.IIncidentAuthListener: void onReportApproved()>
<com.android.internal.telephony.ICallForwardingInfoCallback: void onError(int)>
<com.android.internal.telephony.ICallForwardingInfoCallback: void onCallForwardingInfoAvailable(android.telephony.CallForwardingInfo)>
<android.content.pm.IShortcutChangeCallback: void onShortcutsAddedOrUpdated(java.lang.String,java.util.List,android.os.UserHandle)>
<android.content.pm.IShortcutChangeCallback: void onShortcutsRemoved(java.lang.String,java.util.List,android.os.UserHandle)>
<android.media.IRemoteDisplayProvider: void setVolume(java.lang.String,int)>
<android.media.IRemoteDisplayProvider: void adjustVolume(java.lang.String,int)>
<android.media.IRemoteDisplayProvider: void connect(java.lang.String)>
<android.media.IRemoteDisplayProvider: void disconnect(java.lang.String)>
<android.media.IRemoteDisplayProvider: void setDiscoveryMode(int)>
<android.media.IRemoteDisplayProvider: void setCallback(android.media.IRemoteDisplayCallback)>
<android.service.selectiontoolbar.ISelectionToolbarRenderService: void onHide(long)>
<android.service.selectiontoolbar.ISelectionToolbarRenderService: void onShow(int,android.view.selectiontoolbar.ShowInfo,android.view.selectiontoolbar.ISelectionToolbarCallback)>
<android.service.selectiontoolbar.ISelectionToolbarRenderService: void onDismiss(int,long)>
<android.service.selectiontoolbar.ISelectionToolbarRenderService: void onConnected(android.os.IBinder)>
<com.samsung.android.multiwindow.IDragAndDropControllerProxy: void show(int)>
<android.hardware.biometrics.IBiometricServiceReceiver: void onAcquired(int,java.lang.String)>
<android.hardware.biometrics.IBiometricServiceReceiver: void onAuthenticationFailed()>
<android.hardware.biometrics.IBiometricServiceReceiver: void onError(int,int,int)>
<android.hardware.biometrics.IBiometricServiceReceiver: void onSystemEvent(int)>
<android.hardware.biometrics.IBiometricServiceReceiver: void onSemAuthenticationSucceeded(int,int,byte[])>
<android.hardware.biometrics.IBiometricServiceReceiver: void onDialogDismissed(int)>
<android.hardware.biometrics.IBiometricServiceReceiver: void onAuthenticationSucceeded(int)>
<android.hardware.radio.modem.IRadioModemIndication: int getInterfaceVersion()>
<android.hardware.radio.modem.IRadioModemIndication: void radioStateChanged(int,int)>
<android.hardware.radio.modem.IRadioModemIndication: void hardwareConfigChanged(int,android.hardware.radio.modem.HardwareConfig[])>
<android.hardware.radio.modem.IRadioModemIndication: void modemReset(int,java.lang.String)>
<android.hardware.radio.modem.IRadioModemIndication: void rilConnected(int)>
<android.hardware.radio.modem.IRadioModemIndication: java.lang.String getInterfaceHash()>
<android.hardware.radio.modem.IRadioModemIndication: void radioCapabilityIndication(int,android.hardware.radio.modem.RadioCapability)>
<android.telephony.satellite.ISatelliteTransmissionUpdateCallback: void onSendDatagramStateChanged(int,int,int)>
<android.telephony.satellite.ISatelliteTransmissionUpdateCallback: void onReceiveDatagramStateChanged(int,int,int)>
<android.telephony.satellite.ISatelliteTransmissionUpdateCallback: void onSatellitePositionChanged(android.telephony.satellite.PointingInfo)>
<android.hardware.security.secureclock.ISecureClock: int getInterfaceVersion()>
<android.hardware.security.secureclock.ISecureClock: java.lang.String getInterfaceHash()>
<android.hardware.security.secureclock.ISecureClock: android.hardware.security.secureclock.TimeStampToken generateTimeStamp(long)>
<android.app.IUiModeManager: boolean isUiModeLocked()>
<android.app.IUiModeManager: boolean setNightModeActivatedForCustomMode(int,boolean)>
<android.app.IUiModeManager: void removeOnProjectionStateChangedListener(android.app.IOnProjectionStateChangedListener)>
<android.app.IUiModeManager: void disableCarModeByCallingPackage(int,java.lang.String)>
<android.app.IUiModeManager: void setPackageNightMode(java.lang.String,int,int)>
<android.app.IUiModeManager: boolean requestProjection(android.os.IBinder,int,java.lang.String)>
<android.app.IUiModeManager: long getCustomNightModeEnd()>
<android.app.IUiModeManager: void setApplicationNightMode(int)>
<android.app.IUiModeManager: void addNightPriorityAllowedPackageFromShell(java.lang.String)>
<android.app.IUiModeManager: int getCurrentModeType()>
<android.app.IUiModeManager: float getContrast()>
<android.app.IUiModeManager: void setCustomNightModeStart(long)>
<android.app.IUiModeManager: void setNightModeCustomType(int)>
<android.app.IUiModeManager: int getNightModeCustomType()>
<android.app.IUiModeManager: void addOnProjectionStateChangedListener(android.app.IOnProjectionStateChangedListener,int)>
<android.app.IUiModeManager: int getActiveProjectionTypes()>
<android.app.IUiModeManager: boolean isNightModeLocked()>
<android.app.IUiModeManager: void setNightMode(int)>
<android.app.IUiModeManager: long getCustomNightModeStart()>
<android.app.IUiModeManager: void setDesktopMode(boolean)>
<android.app.IUiModeManager: void addCallback(android.app.IUiModeManagerCallback)>
<android.app.IUiModeManager: boolean setNightModeActivated(boolean)>
<android.app.IUiModeManager: void enableCarMode(int,int,java.lang.String)>
<android.app.IUiModeManager: void removeCallback(android.app.IUiModeManagerCallback)>
<android.app.IUiModeManager: void disableCarMode(int)>
<android.app.IUiModeManager: void resetNightPriorityAppliedPackages(int)>
<android.app.IUiModeManager: int getPackageNightMode(java.lang.String,int)>
<android.app.IUiModeManager: void setCustomNightModeEnd(long)>
<android.app.IUiModeManager: int getNightMode()>
<android.app.IUiModeManager: java.util.List getProjectingPackages(int)>
<android.app.IUiModeManager: java.util.List getNightPriorityAllowedPackagesFromScpm()>
<android.app.IUiModeManager: boolean releaseProjection(int,java.lang.String)>
<android.app.IUiModeManager: void setNightPriorityAllowedPackagesFromScpm(java.util.List)>
<android.nfc.INfcUnlockHandler: boolean onUnlockAttempted(android.nfc.Tag)>
<android.os.ILazyService: android.os.IBinder getService(java.lang.String)>
<android.content.pm.dex.IArtManager: void snapshotRuntimeProfile(int,java.lang.String,java.lang.String,android.content.pm.dex.ISnapshotRuntimeProfileCallback,java.lang.String)>
<android.content.pm.dex.IArtManager: boolean isRuntimeProfilingEnabled(int,java.lang.String)>
<android.media.IAudioServerStateDispatcher: void dispatchAudioServerStateChange(boolean)>
<android.hardware.iris.IIrisService: void registerAuthenticators(java.util.List)>
<com.samsung.android.biometrics.ISemBiometricSysUiService: void setBiometricTheme(int,java.lang.String,byte[],java.io.FileDescriptor)>
<com.samsung.android.biometrics.ISemBiometricSysUiService: void hideBiometricDialog(int,int,int)>
<com.samsung.android.biometrics.ISemBiometricSysUiService: void onBiometricHelp(int,int,int,int,java.lang.String)>
<com.samsung.android.biometrics.ISemBiometricSysUiService: void onBiometricError(int,int,int,int,java.lang.String)>
<com.samsung.android.biometrics.ISemBiometricSysUiService: void showBiometricDialog(int,int,android.os.Bundle,com.samsung.android.biometrics.ISemBiometricSysUiCallback,boolean,int,java.lang.String,long,android.hardware.biometrics.PromptInfo)>
<com.samsung.android.biometrics.ISemBiometricSysUiService: void sendCommand(int,int,int,android.os.Bundle)>
<com.samsung.android.biometrics.ISemBiometricSysUiService: void onBiometricAuthenticated(int,int,boolean,java.lang.String)>
<android.view.IRemoteAnimationFinishedCallback: void onAnimationFinished()>
<android.os.ISpegHelperService: boolean storePrimaryProf(java.lang.String,java.lang.String,int)>
<android.os.ISpegHelperService: boolean createOrDeleteMarkerFiles(java.lang.String,boolean,int)>
<com.android.internal.backup.IBackupTransport: void abortFullRestore(com.android.internal.backup.ITransportStatusCallback)>
<com.android.internal.backup.IBackupTransport: void getNextFullRestoreDataChunk(android.os.ParcelFileDescriptor,com.android.internal.backup.ITransportStatusCallback)>
<com.android.internal.backup.IBackupTransport: void name(com.android.internal.infra.AndroidFuture)>
<com.android.internal.backup.IBackupTransport: void cancelFullBackup(com.android.internal.backup.ITransportStatusCallback)>
<com.android.internal.backup.IBackupTransport: void getBackupQuota(java.lang.String,boolean,com.android.internal.infra.AndroidFuture)>
<com.android.internal.backup.IBackupTransport: void getCurrentRestoreSet(com.android.internal.infra.AndroidFuture)>
<com.android.internal.backup.IBackupTransport: void sendBackupData(int,com.android.internal.backup.ITransportStatusCallback)>
<com.android.internal.backup.IBackupTransport: void finishBackup(com.android.internal.backup.ITransportStatusCallback)>
<com.android.internal.backup.IBackupTransport: void requestBackupTime(com.android.internal.infra.AndroidFuture)>
<com.android.internal.backup.IBackupTransport: void getRestoreData(android.os.ParcelFileDescriptor,com.android.internal.backup.ITransportStatusCallback)>
<com.android.internal.backup.IBackupTransport: void currentDestinationString(com.android.internal.infra.AndroidFuture)>
<com.android.internal.backup.IBackupTransport: void dataManagementIntent(com.android.internal.infra.AndroidFuture)>
<com.android.internal.backup.IBackupTransport: void configurationIntent(com.android.internal.infra.AndroidFuture)>
<com.android.internal.backup.IBackupTransport: void performBackup(android.content.pm.PackageInfo,android.os.ParcelFileDescriptor,int,com.android.internal.backup.ITransportStatusCallback)>
<com.android.internal.backup.IBackupTransport: void transportDirName(com.android.internal.infra.AndroidFuture)>
<com.android.internal.backup.IBackupTransport: void clearBackupData(android.content.pm.PackageInfo,com.android.internal.backup.ITransportStatusCallback)>
<com.android.internal.backup.IBackupTransport: void checkFullBackupSize(long,com.android.internal.backup.ITransportStatusCallback)>
<com.android.internal.backup.IBackupTransport: void finishRestore(com.android.internal.backup.ITransportStatusCallback)>
<com.android.internal.backup.IBackupTransport: void getBackupManagerMonitor(com.android.internal.infra.AndroidFuture)>
<com.android.internal.backup.IBackupTransport: void isAppEligibleForBackup(android.content.pm.PackageInfo,boolean,com.android.internal.infra.AndroidFuture)>
<com.android.internal.backup.IBackupTransport: void getTransportFlags(com.android.internal.infra.AndroidFuture)>
<com.android.internal.backup.IBackupTransport: void nextRestorePackage(com.android.internal.infra.AndroidFuture)>
<com.android.internal.backup.IBackupTransport: void requestFullBackupTime(com.android.internal.infra.AndroidFuture)>
<com.android.internal.backup.IBackupTransport: void startRestore(long,android.content.pm.PackageInfo[],com.android.internal.backup.ITransportStatusCallback)>
<com.android.internal.backup.IBackupTransport: void initializeDevice(com.android.internal.backup.ITransportStatusCallback)>
<com.android.internal.backup.IBackupTransport: void performFullBackup(android.content.pm.PackageInfo,android.os.ParcelFileDescriptor,int,com.android.internal.backup.ITransportStatusCallback)>
<com.android.internal.backup.IBackupTransport: void getAvailableRestoreSets(com.android.internal.infra.AndroidFuture)>
<com.android.internal.backup.IBackupTransport: void dataManagementIntentLabel(com.android.internal.infra.AndroidFuture)>
<android.app.IEphemeralResolver: void getEphemeralResolveInfoList(android.os.IRemoteCallback,int[],int)>
<android.app.IEphemeralResolver: void getEphemeralIntentFilterList(android.os.IRemoteCallback,java.lang.String,int)>
<android.hardware.location.IContextHubTransactionCallback: void onQueryResponse(int,java.util.List)>
<android.hardware.location.IContextHubTransactionCallback: void onTransactionComplete(int)>
<android.service.search.ISearchUiService: void onQuery(android.app.search.SearchSessionId,android.app.search.Query,android.app.search.ISearchCallback)>
<android.service.search.ISearchUiService: void onDestroy(android.app.search.SearchSessionId)>
<android.service.search.ISearchUiService: void onNotifyEvent(android.app.search.SearchSessionId,android.app.search.Query,android.app.search.SearchTargetEvent)>
<android.service.search.ISearchUiService: void onRegisterEmptyQueryResultUpdateCallback(android.app.search.SearchSessionId,android.app.search.ISearchCallback)>
<android.service.search.ISearchUiService: void onUnregisterEmptyQueryResultUpdateCallback(android.app.search.SearchSessionId,android.app.search.ISearchCallback)>
<android.service.search.ISearchUiService: void onCreateSearchSession(android.app.search.SearchContext,android.app.search.SearchSessionId)>
<com.samsung.android.view.IRemoteAnimationMergeCallback: void onAnimationMerged()>
<com.samsung.android.wifi.ai.ISemWifiAiService: void serviceTypeQuery(float[][],java.lang.String[],int[],int)>
<com.samsung.android.wifi.ai.ISemWifiAiService: void toggleDebugMode(boolean)>
<android.service.controls.IControlsProviderInfoSubscriber: void onNext(android.os.IBinder,android.service.controls.ControlsProviderInfo)>
<android.hardware.fingerprint.IUdfpsOverlay: void show(long,int,int)>
<android.hardware.fingerprint.IUdfpsOverlay: void hide(int)>
<android.media.ISoundDoseCallback: void onMomentaryExposure(float,int)>
<android.media.ISoundDoseCallback: void onNewCsdValue(float,android.media.SoundDoseRecord[])>
<com.samsung.android.cocktailbar.ICocktailBarService: boolean bindRemoteViewsService(java.lang.String,int,android.content.Intent,android.app.IApplicationThread,android.os.IBinder,android.app.IServiceConnection,int)>
<com.samsung.android.cocktailbar.ICocktailBarService: int[] getCocktailIds(java.lang.String,android.content.ComponentName)>
<com.samsung.android.cocktailbar.ICocktailBarService: void partiallyUpdateCocktail(java.lang.String,android.widget.RemoteViews,int)>
<com.samsung.android.cocktailbar.ICocktailBarService: java.lang.String getCategoryFilterStr()>
<com.samsung.android.cocktailbar.ICocktailBarService: void updateWakeupGesture(int,boolean)>
<com.samsung.android.cocktailbar.ICocktailBarService: int getCocktailBarVisibility()>
<com.samsung.android.cocktailbar.ICocktailBarService: int getWindowType()>
<com.samsung.android.cocktailbar.ICocktailBarService: void setCocktailBarWakeUpState(boolean)>
<com.samsung.android.cocktailbar.ICocktailBarService: void activateCocktailBar()>
<com.samsung.android.cocktailbar.ICocktailBarService: void removeCocktailUIService()>
<com.samsung.android.cocktailbar.ICocktailBarService: int getCocktailId(java.lang.String,android.content.ComponentName)>
<com.samsung.android.cocktailbar.ICocktailBarService: void closeCocktail(java.lang.String,int,int)>
<com.samsung.android.cocktailbar.ICocktailBarService: int getConfigVersion()>
<com.samsung.android.cocktailbar.ICocktailBarService: boolean isEnabledCocktail(java.lang.String,android.content.ComponentName)>
<com.samsung.android.cocktailbar.ICocktailBarService: void updateCocktail(java.lang.String,com.samsung.android.cocktailbar.CocktailInfo,int)>
<com.samsung.android.cocktailbar.ICocktailBarService: void startListening(com.samsung.android.cocktailbar.ICocktailHost,java.lang.String,int)>
<com.samsung.android.cocktailbar.ICocktailBarService: void registerCocktailBarStateListenerCallback(android.os.IBinder,android.content.ComponentName)>
<com.samsung.android.cocktailbar.ICocktailBarService: void setEnabledCocktailIds(int[])>
<com.samsung.android.cocktailbar.ICocktailBarService: void partiallyUpdateHelpView(java.lang.String,android.widget.RemoteViews,int)>
<com.samsung.android.cocktailbar.ICocktailBarService: boolean getCocktaiBarWakeUpState()>
<com.samsung.android.cocktailbar.ICocktailBarService: void updateCocktailBarVisibility(int)>
<com.samsung.android.cocktailbar.ICocktailBarService: void notifyCocktailVisibiltyChanged(int,int)>
<com.samsung.android.cocktailbar.ICocktailBarService: void notifyKeyguardState(boolean)>
<com.samsung.android.cocktailbar.ICocktailBarService: com.samsung.android.cocktailbar.CocktailBarStateInfo getCocktailBarStateInfo()>
<com.samsung.android.cocktailbar.ICocktailBarService: void unbindRemoteViewsService(java.lang.String,int,android.content.Intent)>
<com.samsung.android.cocktailbar.ICocktailBarService: boolean requestToDisableCocktail(int)>
<com.samsung.android.cocktailbar.ICocktailBarService: int getPreferWidth()>
<com.samsung.android.cocktailbar.ICocktailBarService: boolean isCocktailEnabled(java.lang.String,android.content.ComponentName)>
<com.samsung.android.cocktailbar.ICocktailBarService: void setCocktailHostCallbacks(com.samsung.android.cocktailbar.ICocktailHost,java.lang.String,int)>
<com.samsung.android.cocktailbar.ICocktailBarService: void registerSystemUiVisibilityListenerCallback(android.os.IBinder,android.content.ComponentName)>
<com.samsung.android.cocktailbar.ICocktailBarService: void disableCocktail(java.lang.String,android.content.ComponentName)>
<com.samsung.android.cocktailbar.ICocktailBarService: void notifyCocktailViewDataChanged(java.lang.String,int,int)>
<com.samsung.android.cocktailbar.ICocktailBarService: void stopListening(java.lang.String)>
<com.samsung.android.cocktailbar.ICocktailBarService: int getSystemBarAppearance()>
<com.samsung.android.cocktailbar.ICocktailBarService: void setOnPullPendingIntent(java.lang.String,int,int,android.app.PendingIntent)>
<com.samsung.android.cocktailbar.ICocktailBarService: void unregisterCocktailBarStateListenerCallback(android.os.IBinder)>
<com.samsung.android.cocktailbar.ICocktailBarService: void updateWakeupArea(int)>
<com.samsung.android.cocktailbar.ICocktailBarService: int[] getAllCocktailIds()>
<com.samsung.android.cocktailbar.ICocktailBarService: int[] getEnabledCocktailIds()>
<com.samsung.android.cocktailbar.ICocktailBarService: void updateCocktailBarWindowType(java.lang.String,int)>
<com.samsung.android.cocktailbar.ICocktailBarService: boolean requestToUpdateCocktailByCategory(int)>
<com.samsung.android.cocktailbar.ICocktailBarService: boolean requestToUpdateCocktail(int)>
<com.samsung.android.cocktailbar.ICocktailBarService: void deactivateCocktailBar()>
<com.samsung.android.cocktailbar.ICocktailBarService: void showCocktail(java.lang.String,int)>
<com.samsung.android.cocktailbar.ICocktailBarService: java.lang.String getHideEdgeListStr()>
<com.samsung.android.cocktailbar.ICocktailBarService: boolean isBoundCocktailPackage(java.lang.String,int)>
<com.samsung.android.cocktailbar.ICocktailBarService: void updateCocktailBarPosition(int)>
<com.samsung.android.cocktailbar.ICocktailBarService: com.samsung.android.cocktailbar.Cocktail getCocktail(int)>
<com.samsung.android.cocktailbar.ICocktailBarService: boolean requestToDisableCocktailByCategory(int)>
<com.samsung.android.cocktailbar.ICocktailBarService: void sendExtraDataToCocktailBar(android.os.Bundle)>
<com.samsung.android.cocktailbar.ICocktailBarService: void unregisterSystemUiVisibilityListenerCallback(android.os.IBinder)>
<android.app.search.ISearchUiManager: void query(android.app.search.SearchSessionId,android.app.search.Query,android.app.search.ISearchCallback)>
<android.app.search.ISearchUiManager: void createSearchSession(android.app.search.SearchContext,android.app.search.SearchSessionId,android.os.IBinder)>
<android.app.search.ISearchUiManager: void destroySearchSession(android.app.search.SearchSessionId)>
<android.app.search.ISearchUiManager: void unregisterEmptyQueryResultUpdateCallback(android.app.search.SearchSessionId,android.app.search.ISearchCallback)>
<android.app.search.ISearchUiManager: void registerEmptyQueryResultUpdateCallback(android.app.search.SearchSessionId,android.app.search.ISearchCallback)>
<android.app.search.ISearchUiManager: void notifyEvent(android.app.search.SearchSessionId,android.app.search.Query,android.app.search.SearchTargetEvent)>
<android.hardware.display.IColorDisplayManager: boolean setReduceBrightColorsStrength(int)>
<android.hardware.display.IColorDisplayManager: boolean isReduceBrightColorsActivated()>
<android.hardware.display.IColorDisplayManager: boolean setDisplayWhiteBalanceEnabled(boolean)>
<android.hardware.display.IColorDisplayManager: int getNightDisplayAutoMode()>
<android.hardware.display.IColorDisplayManager: int getNightDisplayColorTemperature()>
<android.hardware.display.IColorDisplayManager: android.hardware.display.Time getNightDisplayCustomStartTime()>
<android.hardware.display.IColorDisplayManager: boolean isSaturationActivated()>
<android.hardware.display.IColorDisplayManager: int getReduceBrightColorsStrength()>
<android.hardware.display.IColorDisplayManager: boolean setAppSaturationLevel(java.lang.String,int)>
<android.hardware.display.IColorDisplayManager: void setColorMode(int)>
<android.hardware.display.IColorDisplayManager: boolean isDeviceColorManaged()>
<android.hardware.display.IColorDisplayManager: boolean setNightDisplayActivated(boolean)>
<android.hardware.display.IColorDisplayManager: boolean setNightDisplayAutoMode(int)>
<android.hardware.display.IColorDisplayManager: boolean setNightDisplayCustomEndTime(android.hardware.display.Time)>
<android.hardware.display.IColorDisplayManager: boolean setNightDisplayColorTemperature(int)>
<android.hardware.display.IColorDisplayManager: boolean setNightDisplayCustomStartTime(android.hardware.display.Time)>
<android.hardware.display.IColorDisplayManager: int getColorMode()>
<android.hardware.display.IColorDisplayManager: android.hardware.display.Time getNightDisplayCustomEndTime()>
<android.hardware.display.IColorDisplayManager: int getTransformCapabilities()>
<android.hardware.display.IColorDisplayManager: int getNightDisplayAutoModeRaw()>
<android.hardware.display.IColorDisplayManager: boolean isNightDisplayActivated()>
<android.hardware.display.IColorDisplayManager: float getReduceBrightColorsOffsetFactor()>
<android.hardware.display.IColorDisplayManager: boolean setReduceBrightColorsActivated(boolean)>
<android.hardware.display.IColorDisplayManager: boolean setSaturationLevel(int)>
<android.hardware.display.IColorDisplayManager: boolean isDisplayWhiteBalanceEnabled()>
<android.security.apc.IProtectedConfirmation: boolean isSupported()>
<android.security.apc.IProtectedConfirmation: void cancelPrompt(android.security.apc.IConfirmationCallback)>
<android.security.apc.IProtectedConfirmation: void presentPrompt(android.security.apc.IConfirmationCallback,java.lang.String,byte[],java.lang.String,int)>
<android.media.tv.ITvRemoteServiceInput: void sendKeyDown(android.os.IBinder,int)>
<android.media.tv.ITvRemoteServiceInput: void sendTimestamp(android.os.IBinder,long)>
<android.media.tv.ITvRemoteServiceInput: void sendKeyUp(android.os.IBinder,int)>
<android.media.tv.ITvRemoteServiceInput: void sendPointerDown(android.os.IBinder,int,int,int)>
<android.media.tv.ITvRemoteServiceInput: void clearInputBridge(android.os.IBinder)>
<android.media.tv.ITvRemoteServiceInput: void openInputBridge(android.os.IBinder,java.lang.String,int,int,int)>
<android.media.tv.ITvRemoteServiceInput: void sendPointerUp(android.os.IBinder,int)>
<android.media.tv.ITvRemoteServiceInput: void closeInputBridge(android.os.IBinder)>
<android.media.tv.ITvRemoteServiceInput: void sendGamepadKeyDown(android.os.IBinder,int)>
<android.media.tv.ITvRemoteServiceInput: void openGamepadBridge(android.os.IBinder,java.lang.String)>
<android.media.tv.ITvRemoteServiceInput: void sendGamepadAxisValue(android.os.IBinder,int,float)>
<android.media.tv.ITvRemoteServiceInput: void sendPointerSync(android.os.IBinder)>
<android.media.tv.ITvRemoteServiceInput: void sendGamepadKeyUp(android.os.IBinder,int)>
<android.view.IDisplayWindowInsetsController: void insetsControlChanged(android.view.InsetsState,android.view.InsetsSourceControl[])>
<android.view.IDisplayWindowInsetsController: void topFocusedWindowChanged(android.content.ComponentName,int)>
<android.view.IDisplayWindowInsetsController: void insetsChanged(android.view.InsetsState)>
<android.view.IDisplayWindowInsetsController: void showInsets(int,boolean,android.view.inputmethod.ImeTracker$Token)>
<android.view.IDisplayWindowInsetsController: void hideInsets(int,boolean,android.view.inputmethod.ImeTracker$Token)>
<android.view.selectiontoolbar.ISelectionToolbarCallback: void onShown(android.view.selectiontoolbar.WidgetInfo)>
<android.view.selectiontoolbar.ISelectionToolbarCallback: void onError(int)>
<android.view.selectiontoolbar.ISelectionToolbarCallback: void onToolbarShowTimeout()>
<android.view.selectiontoolbar.ISelectionToolbarCallback: void onWidgetUpdated(android.view.selectiontoolbar.WidgetInfo)>
<android.view.selectiontoolbar.ISelectionToolbarCallback: void onMenuItemClicked(android.view.selectiontoolbar.ToolbarMenuItem)>
<android.app.IInstantAppResolver: void getInstantAppResolveInfoList(android.content.pm.InstantAppRequestInfo,int,android.os.IRemoteCallback)>
<android.app.IInstantAppResolver: void getInstantAppIntentFilterList(android.content.pm.InstantAppRequestInfo,android.os.IRemoteCallback)>
<android.hardware.input.IWirelessKeyboardShareChangedListener: void onWirelessKeyboardShareChanged(long,int,java.lang.String)>
<com.android.internal.inputmethod.IInlineSuggestionsRequestCallback: void onInputMethodStartInputView()>
<com.android.internal.inputmethod.IInlineSuggestionsRequestCallback: void onInlineSuggestionsSessionInvalidated()>
<com.android.internal.inputmethod.IInlineSuggestionsRequestCallback: void onInputMethodShowInputRequested(boolean)>
<com.android.internal.inputmethod.IInlineSuggestionsRequestCallback: void onInputMethodStartInput(android.view.autofill.AutofillId)>
<com.android.internal.inputmethod.IInlineSuggestionsRequestCallback: void onInputMethodFinishInputView()>
<com.android.internal.inputmethod.IInlineSuggestionsRequestCallback: void onInlineSuggestionsUnsupported()>
<com.android.internal.inputmethod.IInlineSuggestionsRequestCallback: void onInputMethodFinishInput()>
<com.android.internal.inputmethod.IInlineSuggestionsRequestCallback: void onInlineSuggestionsRequest(android.view.inputmethod.InlineSuggestionsRequest,com.android.internal.inputmethod.IInlineSuggestionsResponseCallback)>
<android.service.smartspace.ISmartspaceService: void requestSmartspaceUpdate(android.app.smartspace.SmartspaceSessionId)>
<android.service.smartspace.ISmartspaceService: void notifySmartspaceEvent(android.app.smartspace.SmartspaceSessionId,android.app.smartspace.SmartspaceTargetEvent)>
<android.service.smartspace.ISmartspaceService: void onDestroySmartspaceSession(android.app.smartspace.SmartspaceSessionId)>
<android.service.smartspace.ISmartspaceService: void registerSmartspaceUpdates(android.app.smartspace.SmartspaceSessionId,android.app.smartspace.ISmartspaceCallback)>
<android.service.smartspace.ISmartspaceService: void onCreateSmartspaceSession(android.app.smartspace.SmartspaceConfig,android.app.smartspace.SmartspaceSessionId)>
<android.service.smartspace.ISmartspaceService: void unregisterSmartspaceUpdates(android.app.smartspace.SmartspaceSessionId,android.app.smartspace.ISmartspaceCallback)>
<android.app.blob.IBlobStoreManager: void releaseLease(android.app.blob.BlobHandle,java.lang.String)>
<android.app.blob.IBlobStoreManager: long getRemainingLeaseQuotaBytes(java.lang.String)>
<android.app.blob.IBlobStoreManager: void abandonSession(long,java.lang.String)>
<android.app.blob.IBlobStoreManager: android.app.blob.LeaseInfo getLeaseInfo(android.app.blob.BlobHandle,java.lang.String)>
<android.app.blob.IBlobStoreManager: android.app.blob.IBlobStoreSession openSession(long,java.lang.String)>
<android.app.blob.IBlobStoreManager: void releaseAllLeases(java.lang.String)>
<android.app.blob.IBlobStoreManager: android.os.ParcelFileDescriptor openBlob(android.app.blob.BlobHandle,java.lang.String)>
<android.app.blob.IBlobStoreManager: java.util.List getLeasedBlobs(java.lang.String)>
<android.app.blob.IBlobStoreManager: long createSession(android.app.blob.BlobHandle,java.lang.String)>
<android.app.blob.IBlobStoreManager: java.util.List queryBlobsForUser(int)>
<android.app.blob.IBlobStoreManager: void deleteBlob(long)>
<android.app.blob.IBlobStoreManager: void waitForIdle(android.os.RemoteCallback)>
<android.app.blob.IBlobStoreManager: void acquireLease(android.app.blob.BlobHandle,int,java.lang.CharSequence,long,java.lang.String)>
<com.samsung.android.location.ISLocationListener: void onLocationChanged(android.location.Location,android.location.Address)>
<com.samsung.android.location.ISLocationListener: void onLocationAvailable(android.location.Location[])>
<android.location.ICountryDetector: void removeCountryListener(android.location.ICountryListener)>
<android.location.ICountryDetector: android.location.Country detectCountry()>
<android.location.ICountryDetector: void addCountryListener(android.location.ICountryListener)>
<android.print.IPrintJobStateChangeListener: void onPrintJobStateChanged(android.print.PrintJobId)>
<com.android.internal.app.IVoiceInteractionManagerService: void enableVisualQueryDetection(com.android.internal.app.IVisualQueryDetectionAttentionListener)>
<com.android.internal.app.IVoiceInteractionManagerService: void destroyDetector(android.os.IBinder)>
<com.android.internal.app.IVoiceInteractionManagerService: boolean isEnrolledForKeyphrase(int,java.lang.String)>
<com.android.internal.app.IVoiceInteractionManagerService: void requestDirectActions(android.os.IBinder,int,android.os.IBinder,android.os.RemoteCallback,android.os.RemoteCallback)>
<com.android.internal.app.IVoiceInteractionManagerService: void disableVisualQueryDetection()>
<com.android.internal.app.IVoiceInteractionManagerService: void onLockscreenShown()>
<com.android.internal.app.IVoiceInteractionManagerService: android.hardware.soundtrigger.SoundTrigger$KeyphraseSoundModel getKeyphraseSoundModel(int,java.lang.String)>
<com.android.internal.app.IVoiceInteractionManagerService: void showSession(android.os.Bundle,int,java.lang.String)>
<com.android.internal.app.IVoiceInteractionManagerService: void notifyActivityEventChanged(android.os.IBinder,int)>
<com.android.internal.app.IVoiceInteractionManagerService: int startVoiceActivity(android.os.IBinder,android.content.Intent,java.lang.String,java.lang.String)>
<com.android.internal.app.IVoiceInteractionManagerService: void stopListeningVisibleActivityChanged(android.os.IBinder)>
<com.android.internal.app.IVoiceInteractionManagerService: void triggerHardwareRecognitionEventForTest(android.hardware.soundtrigger.SoundTrigger$KeyphraseRecognitionEvent,com.android.internal.app.IHotwordRecognitionStatusCallback)>
<com.android.internal.app.IVoiceInteractionManagerService: void stopListeningFromMic()>
<com.android.internal.app.IVoiceInteractionManagerService: void stopPerceiving()>
<com.android.internal.app.IVoiceInteractionManagerService: void closeSystemDialogs(android.os.IBinder)>
<com.android.internal.app.IVoiceInteractionManagerService: void getActiveServiceSupportedActions(java.util.List,com.android.internal.app.IVoiceActionCheckCallback)>
<com.android.internal.app.IVoiceInteractionManagerService: boolean showSessionFromSession(android.os.IBinder,android.os.Bundle,int,java.lang.String)>
<com.android.internal.app.IVoiceInteractionManagerService: void setSessionWindowVisible(android.os.IBinder,boolean)>
<com.android.internal.app.IVoiceInteractionManagerService: void startListeningVisibleActivityChanged(android.os.IBinder)>
<com.android.internal.app.IVoiceInteractionManagerService: void shutdownHotwordDetectionService()>
<com.android.internal.app.IVoiceInteractionManagerService: boolean deliverNewSession(android.os.IBinder,android.service.voice.IVoiceInteractionSession,com.android.internal.app.IVoiceInteractor)>
<com.android.internal.app.IVoiceInteractionManagerService: void startPerceiving(android.service.voice.IVisualQueryDetectionVoiceInteractionCallback)>
<com.android.internal.app.IVoiceInteractionManagerService: void finish(android.os.IBinder)>
<com.android.internal.app.IVoiceInteractionManagerService: int getDisabledShowContext()>
<com.android.internal.app.IVoiceInteractionManagerService: void setDisabledShowContext(int)>
<com.android.internal.app.IVoiceInteractionManagerService: com.android.internal.app.IVoiceInteractionSoundTriggerSession createSoundTriggerSessionAsOriginator(android.media.permission.Identity,android.os.IBinder,android.hardware.soundtrigger.SoundTrigger$ModuleProperties)>
<com.android.internal.app.IVoiceInteractionManagerService: void launchVoiceAssistFromKeyguard()>
<com.android.internal.app.IVoiceInteractionManagerService: void startListeningFromExternalSource(android.os.ParcelFileDescriptor,android.media.AudioFormat,android.os.PersistableBundle,android.os.IBinder,android.service.voice.IMicrophoneHotwordDetectionVoiceInteractionCallback)>
<com.android.internal.app.IVoiceInteractionManagerService: void startListeningFromMic(android.media.AudioFormat,android.service.voice.IMicrophoneHotwordDetectionVoiceInteractionCallback)>
<com.android.internal.app.IVoiceInteractionManagerService: int getUserDisabledShowContext()>
<com.android.internal.app.IVoiceInteractionManagerService: void setDisabled(boolean)>
<com.android.internal.app.IVoiceInteractionManagerService: boolean activeServiceSupportsAssist()>
<com.android.internal.app.IVoiceInteractionManagerService: int deleteKeyphraseSoundModel(int,java.lang.String)>
<com.android.internal.app.IVoiceInteractionManagerService: int startAssistantActivity(android.os.IBinder,android.content.Intent,java.lang.String,java.lang.String,android.os.Bundle)>
<com.android.internal.app.IVoiceInteractionManagerService: void performDirectAction(android.os.IBinder,java.lang.String,android.os.Bundle,int,android.os.IBinder,android.os.RemoteCallback,android.os.RemoteCallback)>
<com.android.internal.app.IVoiceInteractionManagerService: boolean hideSessionFromSession(android.os.IBinder)>
<com.android.internal.app.IVoiceInteractionManagerService: boolean activeServiceSupportsLaunchFromKeyguard()>
<com.android.internal.app.IVoiceInteractionManagerService: int updateKeyphraseSoundModel(android.hardware.soundtrigger.SoundTrigger$KeyphraseSoundModel)>
<com.android.internal.app.IVoiceInteractionManagerService: android.content.ComponentName getActiveServiceComponentName()>
<com.android.internal.app.IVoiceInteractionManagerService: void hideCurrentSession()>
<com.android.internal.app.IVoiceInteractionManagerService: void setModelDatabaseForTestEnabled(boolean,android.os.IBinder)>
<com.android.internal.app.IVoiceInteractionManagerService: java.util.List listModuleProperties(android.media.permission.Identity)>
<com.android.internal.app.IVoiceInteractionManagerService: android.hardware.soundtrigger.KeyphraseMetadata getEnrolledKeyphraseMetadata(java.lang.String,java.lang.String)>
<com.android.internal.app.IVoiceInteractionManagerService: void setUiHints(android.os.Bundle)>
<com.android.internal.app.IVoiceInteractionManagerService: boolean showSessionForActiveService(android.os.Bundle,int,java.lang.String,com.android.internal.app.IVoiceInteractionSessionShowCallback,android.os.IBinder)>
<com.android.internal.app.IVoiceInteractionManagerService: void updateState(android.os.PersistableBundle,android.os.SharedMemory,android.os.IBinder)>
<com.android.internal.app.IVoiceInteractionManagerService: boolean isSessionRunning()>
<com.android.internal.app.IVoiceInteractionManagerService: void initAndVerifyDetector(android.media.permission.Identity,android.os.PersistableBundle,android.os.SharedMemory,android.os.IBinder,com.android.internal.app.IHotwordRecognitionStatusCallback,int)>
<com.android.internal.app.IVoiceInteractionManagerService: void registerVoiceInteractionSessionListener(com.android.internal.app.IVoiceInteractionSessionListener)>
<com.android.internal.app.IVoiceInteractionManagerService: void setKeepAwake(android.os.IBinder,boolean)>
<android.os.IProcessInfoService: void getProcessStatesAndOomScoresFromPids(int[],int[],int[])>
<android.os.IProcessInfoService: void getProcessStatesFromPids(int[],int[])>
<android.hardware.biometrics.IInvalidationCallback: void onCompleted()>
<android.accounts.IAccountAuthenticator: void hasFeatures(android.accounts.IAccountAuthenticatorResponse,android.accounts.Account,java.lang.String[])>
<android.accounts.IAccountAuthenticator: void getAccountRemovalAllowed(android.accounts.IAccountAuthenticatorResponse,android.accounts.Account)>
<android.accounts.IAccountAuthenticator: void addAccount(android.accounts.IAccountAuthenticatorResponse,java.lang.String,java.lang.String,java.lang.String[],android.os.Bundle)>
<android.accounts.IAccountAuthenticator: void getAccountCredentialsForCloning(android.accounts.IAccountAuthenticatorResponse,android.accounts.Account)>
<android.accounts.IAccountAuthenticator: void editProperties(android.accounts.IAccountAuthenticatorResponse,java.lang.String)>
<android.accounts.IAccountAuthenticator: void finishSession(android.accounts.IAccountAuthenticatorResponse,java.lang.String,android.os.Bundle)>
<android.accounts.IAccountAuthenticator: void confirmCredentials(android.accounts.IAccountAuthenticatorResponse,android.accounts.Account,android.os.Bundle)>
<android.accounts.IAccountAuthenticator: void getAuthToken(android.accounts.IAccountAuthenticatorResponse,android.accounts.Account,java.lang.String,android.os.Bundle)>
<android.accounts.IAccountAuthenticator: void startUpdateCredentialsSession(android.accounts.IAccountAuthenticatorResponse,android.accounts.Account,java.lang.String,android.os.Bundle)>
<android.accounts.IAccountAuthenticator: void addAccountFromCredentials(android.accounts.IAccountAuthenticatorResponse,android.accounts.Account,android.os.Bundle)>
<android.accounts.IAccountAuthenticator: void getAuthTokenLabel(android.accounts.IAccountAuthenticatorResponse,java.lang.String)>
<android.accounts.IAccountAuthenticator: void updateCredentials(android.accounts.IAccountAuthenticatorResponse,android.accounts.Account,java.lang.String,android.os.Bundle)>
<android.accounts.IAccountAuthenticator: void isCredentialsUpdateSuggested(android.accounts.IAccountAuthenticatorResponse,android.accounts.Account,java.lang.String)>
<android.accounts.IAccountAuthenticator: void startAddAccountSession(android.accounts.IAccountAuthenticatorResponse,java.lang.String,java.lang.String,java.lang.String[],android.os.Bundle)>
<android.service.autofill.IFillCallback: void onCancellable(android.os.ICancellationSignal)>
<android.service.autofill.IFillCallback: void onSuccess(android.service.autofill.FillResponse)>
<android.service.autofill.IFillCallback: void onFailure(int,java.lang.CharSequence)>
<com.android.internal.os.IDropBoxManagerService: boolean isTagEnabled(java.lang.String)>
<com.android.internal.os.IDropBoxManagerService: android.os.DropBoxManager$Entry getNextEntry(java.lang.String,long,java.lang.String)>
<com.android.internal.os.IDropBoxManagerService: void addFile(java.lang.String,android.os.ParcelFileDescriptor,int)>
<com.android.internal.os.IDropBoxManagerService: android.os.DropBoxManager$Entry getNextEntryWithAttribution(java.lang.String,long,java.lang.String,java.lang.String)>
<com.android.internal.os.IDropBoxManagerService: void addData(java.lang.String,byte[],int)>
<com.android.internal.backup.IObbBackupService: void restoreObbFile(java.lang.String,android.os.ParcelFileDescriptor,long,int,java.lang.String,long,long,int,android.app.backup.IBackupManager)>
<com.android.internal.backup.IObbBackupService: void backupObbs(java.lang.String,android.os.ParcelFileDescriptor,int,android.app.backup.IBackupManager)>
<com.android.internal.telephony.euicc.IRemoveNotificationFromListCallback: void onComplete(int)>
<com.android.internal.telephony.euicc.IDeleteProfileCallback: void onComplete(int)>
<android.hardware.camera2.extension.IInitializeSessionCallback: void onFailure()>
<android.hardware.camera2.extension.IInitializeSessionCallback: void onSuccess()>
<android.media.tv.ITvRemoteProvider: void onInputBridgeConnected(android.os.IBinder)>
<android.media.tv.ITvRemoteProvider: void setRemoteServiceInputSink(android.media.tv.ITvRemoteServiceInput)>
<com.android.internal.telecom.ITelecomService: android.telecom.TelecomAnalytics dumpCallAnalytics()>
<com.android.internal.telecom.ITelecomService: android.content.pm.ParceledListSlice getPhoneAccountsSupportingScheme(java.lang.String,java.lang.String)>
<com.android.internal.telecom.ITelecomService: boolean setDefaultDialer(java.lang.String)>
<com.android.internal.telecom.ITelecomService: void cancelMissedCallsNotification(java.lang.String)>
<com.android.internal.telecom.ITelecomService: void clearAccounts(java.lang.String)>
<com.android.internal.telecom.ITelecomService: boolean isInSelfManagedCall(java.lang.String,android.os.UserHandle,java.lang.String)>
<com.android.internal.telecom.ITelecomService: boolean handlePinMmiForPhoneAccount(android.telecom.PhoneAccountHandle,java.lang.String,java.lang.String)>
<com.android.internal.telecom.ITelecomService: void setSystemDialer(android.content.ComponentName)>
<com.android.internal.telecom.ITelecomService: void silenceRinger(java.lang.String)>
<com.android.internal.telecom.ITelecomService: android.content.pm.ParceledListSlice getAllPhoneAccounts()>
<com.android.internal.telecom.ITelecomService: int getCallStateUsingPackage(java.lang.String,java.lang.String)>
<com.android.internal.telecom.ITelecomService: boolean endCall(java.lang.String)>
<com.android.internal.telecom.ITelecomService: boolean isTtySupported(java.lang.String,java.lang.String)>
<com.android.internal.telecom.ITelecomService: int cleanupOrphanPhoneAccounts()>
<com.android.internal.telecom.ITelecomService: android.telecom.PhoneAccountHandle getSimCallManager(int,java.lang.String)>
<com.android.internal.telecom.ITelecomService: void setTestDefaultDialer(java.lang.String)>
<com.android.internal.telecom.ITelecomService: void setTestEmergencyPhoneAccountPackageNameFilter(java.lang.String)>
<com.android.internal.telecom.ITelecomService: android.content.ComponentName getDefaultPhoneApp()>
<com.android.internal.telecom.ITelecomService: boolean isInManagedCall(java.lang.String,java.lang.String)>
<com.android.internal.telecom.ITelecomService: boolean enablePhoneAccount(android.telecom.PhoneAccountHandle,boolean)>
<com.android.internal.telecom.ITelecomService: void showInCallScreen(boolean,java.lang.String,java.lang.String)>
<com.android.internal.telecom.ITelecomService: void addOrRemoveTestCallCompanionApp(java.lang.String,boolean)>
<com.android.internal.telecom.ITelecomService: java.lang.String getVoiceMailNumber(android.telecom.PhoneAccountHandle,java.lang.String,java.lang.String)>
<com.android.internal.telecom.ITelecomService: boolean isInEmergencyCall()>
<com.android.internal.telecom.ITelecomService: void acceptHandover(android.net.Uri,int,android.telecom.PhoneAccountHandle,java.lang.String)>
<com.android.internal.telecom.ITelecomService: void addCall(android.telecom.CallAttributes,com.android.internal.telecom.ICallEventCallback,java.lang.String,java.lang.String)>
<com.android.internal.telecom.ITelecomService: void cleanupStuckCalls()>
<com.android.internal.telecom.ITelecomService: java.lang.String getDefaultDialerPackage(java.lang.String)>
<com.android.internal.telecom.ITelecomService: android.content.pm.ParceledListSlice getCallCapablePhoneAccounts(boolean,java.lang.String,java.lang.String)>
<com.android.internal.telecom.ITelecomService: android.content.Intent createLaunchEmergencyDialerIntent(java.lang.String)>
<com.android.internal.telecom.ITelecomService: boolean isRinging(java.lang.String)>
<com.android.internal.telecom.ITelecomService: void setTestDefaultCallScreeningApp(java.lang.String)>
<com.android.internal.telecom.ITelecomService: void startConference(java.util.List,android.os.Bundle,java.lang.String)>
<com.android.internal.telecom.ITelecomService: boolean isOutgoingCallPermitted(android.telecom.PhoneAccountHandle,java.lang.String)>
<com.android.internal.telecom.ITelecomService: boolean isVoiceMailNumber(android.telecom.PhoneAccountHandle,java.lang.String,java.lang.String,java.lang.String)>
<com.android.internal.telecom.ITelecomService: int getCallState()>
<com.android.internal.telecom.ITelecomService: boolean hasManageOngoingCallsPermission(java.lang.String)>
<com.android.internal.telecom.ITelecomService: boolean isInCall(java.lang.String,java.lang.String)>
<com.android.internal.telecom.ITelecomService: android.telecom.PhoneAccountHandle getUserSelectedOutgoingPhoneAccount(java.lang.String)>
<com.android.internal.telecom.ITelecomService: void resetCarMode()>
<com.android.internal.telecom.ITelecomService: void acceptRingingCall(java.lang.String)>
<com.android.internal.telecom.ITelecomService: void acceptRingingCallWithVideoState(java.lang.String,int)>
<com.android.internal.telecom.ITelecomService: void setTestPhoneAcctSuggestionComponent(java.lang.String)>
<com.android.internal.telecom.ITelecomService: android.net.Uri getAdnUriForPhoneAccount(android.telecom.PhoneAccountHandle,java.lang.String)>
<com.android.internal.telecom.ITelecomService: android.content.pm.ParceledListSlice getSelfManagedPhoneAccounts(java.lang.String,java.lang.String)>
<com.android.internal.telecom.ITelecomService: android.content.pm.ParceledListSlice getOwnSelfManagedPhoneAccounts(java.lang.String,java.lang.String)>
<com.android.internal.telecom.ITelecomService: void addNewUnknownCall(android.telecom.PhoneAccountHandle,android.os.Bundle)>
<com.android.internal.telecom.ITelecomService: int getAllPhoneAccountsCount()>
<com.android.internal.telecom.ITelecomService: int getCurrentTtyMode(java.lang.String,java.lang.String)>
<com.android.internal.telecom.ITelecomService: void placeCall(android.net.Uri,android.os.Bundle,java.lang.String,java.lang.String)>
<com.android.internal.telecom.ITelecomService: void addNewIncomingCall(android.telecom.PhoneAccountHandle,android.os.Bundle,java.lang.String)>
<com.android.internal.telecom.ITelecomService: java.lang.String getDefaultDialerPackageForUser(int)>
<com.android.internal.telecom.ITelecomService: boolean isIncomingCallPermitted(android.telecom.PhoneAccountHandle,java.lang.String)>
<com.android.internal.telecom.ITelecomService: void registerPhoneAccount(android.telecom.PhoneAccount,java.lang.String)>
<com.android.internal.telecom.ITelecomService: android.content.Intent createManageBlockedNumbersIntent(java.lang.String)>
<com.android.internal.telecom.ITelecomService: java.lang.String getSystemDialerPackage(java.lang.String)>
<com.android.internal.telecom.ITelecomService: void handleCallIntent(android.content.Intent,java.lang.String)>
<com.android.internal.telecom.ITelecomService: void setTestDefaultCallRedirectionApp(java.lang.String)>
<com.android.internal.telecom.ITelecomService: void requestLogMark(java.lang.String)>
<com.android.internal.telecom.ITelecomService: void waitOnHandlers()>
<com.android.internal.telecom.ITelecomService: android.content.pm.ParceledListSlice getAllPhoneAccountHandles()>
<com.android.internal.telecom.ITelecomService: android.telecom.PhoneAccountHandle getDefaultOutgoingPhoneAccount(java.lang.String,java.lang.String,java.lang.String)>
<com.android.internal.telecom.ITelecomService: java.lang.String getLine1Number(android.telecom.PhoneAccountHandle,java.lang.String,java.lang.String)>
<com.android.internal.telecom.ITelecomService: android.telecom.PhoneAccount getPhoneAccount(android.telecom.PhoneAccountHandle,java.lang.String)>
<com.android.internal.telecom.ITelecomService: void setTestCallDiagnosticService(java.lang.String)>
<com.android.internal.telecom.ITelecomService: void addNewIncomingConference(android.telecom.PhoneAccountHandle,android.os.Bundle,java.lang.String)>
<com.android.internal.telecom.ITelecomService: void unregisterPhoneAccount(android.telecom.PhoneAccountHandle,java.lang.String)>
<com.android.internal.telecom.ITelecomService: void stopBlockSuppression()>
<com.android.internal.telecom.ITelecomService: boolean handlePinMmi(java.lang.String,java.lang.String)>
<com.android.internal.telecom.ITelecomService: void setUserSelectedOutgoingPhoneAccount(android.telecom.PhoneAccountHandle)>
<com.android.internal.telecom.ITelecomService: android.telecom.PhoneAccountHandle getSimCallManagerForUser(int,java.lang.String)>
<com.android.internal.telecom.ITelecomService: android.content.pm.ParceledListSlice getPhoneAccountsForPackage(java.lang.String)>
<android.hardware.radio.messaging.IRadioMessagingIndication: void cdmaRuimSmsStorageFull(int)>
<android.hardware.radio.messaging.IRadioMessagingIndication: void newSmsOnSim(int,int)>
<android.hardware.radio.messaging.IRadioMessagingIndication: int getInterfaceVersion()>
<android.hardware.radio.messaging.IRadioMessagingIndication: void newBroadcastSms(int,byte[])>
<android.hardware.radio.messaging.IRadioMessagingIndication: void cdmaNewSms(int,android.hardware.radio.messaging.CdmaSmsMessage)>
<android.hardware.radio.messaging.IRadioMessagingIndication: java.lang.String getInterfaceHash()>
<android.hardware.radio.messaging.IRadioMessagingIndication: void newSms(int,byte[])>
<android.hardware.radio.messaging.IRadioMessagingIndication: void simSmsStorageFull(int)>
<android.hardware.radio.messaging.IRadioMessagingIndication: void newSmsStatusReport(int,byte[])>
<android.nfc.IAppCallback: void onTagDiscovered(android.nfc.Tag)>
<android.telephony.ims.aidl.IImsCallSessionListener: void callSessionInitiatingFailed(android.telephony.ims.ImsReasonInfo)>
<android.telephony.ims.aidl.IImsCallSessionListener: void callSessionMergeStarted(com.android.ims.internal.IImsCallSession,android.telephony.ims.ImsCallProfile)>
<android.telephony.ims.aidl.IImsCallSessionListener: void callSessionSendAnbrQuery(int,int,int)>
<android.telephony.ims.aidl.IImsCallSessionListener: void callSessionConferenceExtendReceived(com.android.ims.internal.IImsCallSession,android.telephony.ims.ImsCallProfile)>
<android.telephony.ims.aidl.IImsCallSessionListener: void callSessionHoldReceived(android.telephony.ims.ImsCallProfile)>
<android.telephony.ims.aidl.IImsCallSessionListener: void callSessionInitiating(android.telephony.ims.ImsCallProfile)>
<android.telephony.ims.aidl.IImsCallSessionListener: void callSessionRttModifyResponseReceived(int)>
<android.telephony.ims.aidl.IImsCallSessionListener: void callSessionProgressing(android.telephony.ims.ImsStreamMediaProfile)>
<android.telephony.ims.aidl.IImsCallSessionListener: void callSessionCancelTransferred()>
<android.telephony.ims.aidl.IImsCallSessionListener: void callSessionMergeFailed(android.telephony.ims.ImsReasonInfo)>
<android.telephony.ims.aidl.IImsCallSessionListener: void callSessionHandoverFailed(int,int,android.telephony.ims.ImsReasonInfo)>
<android.telephony.ims.aidl.IImsCallSessionListener: void callSessionRtpHeaderExtensionsReceived(java.util.List)>
<android.telephony.ims.aidl.IImsCallSessionListener: void callSessionUpdated(android.telephony.ims.ImsCallProfile)>
<android.telephony.ims.aidl.IImsCallSessionListener: void callSessionSuppServiceReceived(android.telephony.ims.ImsSuppServiceNotification)>
<android.telephony.ims.aidl.IImsCallSessionListener: void callSessionCancelTransferFailed(android.telephony.ims.ImsReasonInfo)>
<android.telephony.ims.aidl.IImsCallSessionListener: void callSessionConferenceExtendFailed(android.telephony.ims.ImsReasonInfo)>
<android.telephony.ims.aidl.IImsCallSessionListener: void callSessionHoldFailed(android.telephony.ims.ImsReasonInfo)>
<android.telephony.ims.aidl.IImsCallSessionListener: void callSessionResumed(android.telephony.ims.ImsCallProfile)>
<android.telephony.ims.aidl.IImsCallSessionListener: void callSessionTransferFailed(android.telephony.ims.ImsReasonInfo)>
<android.telephony.ims.aidl.IImsCallSessionListener: void callSessionTransferred()>
<android.telephony.ims.aidl.IImsCallSessionListener: void callSessionUpdateReceived(android.telephony.ims.ImsCallProfile)>
<android.telephony.ims.aidl.IImsCallSessionListener: void callSessionRttAudioIndicatorChanged(android.telephony.ims.ImsStreamMediaProfile)>
<android.telephony.ims.aidl.IImsCallSessionListener: void callSessionImsCallEvent(java.lang.String,android.os.Bundle)>
<android.telephony.ims.aidl.IImsCallSessionListener: void callSessionMultipartyStateChanged(boolean)>
<android.telephony.ims.aidl.IImsCallSessionListener: void callSessionRemoveParticipantsRequestFailed(android.telephony.ims.ImsReasonInfo)>
<android.telephony.ims.aidl.IImsCallSessionListener: void callSessionDtmfReceived(char)>
<android.telephony.ims.aidl.IImsCallSessionListener: void callSessionTtyModeReceived(int)>
<android.telephony.ims.aidl.IImsCallSessionListener: void callSessionRttModifyRequestReceived(android.telephony.ims.ImsCallProfile)>
<android.telephony.ims.aidl.IImsCallSessionListener: void callSessionMayHandover(int,int)>
<android.telephony.ims.aidl.IImsCallSessionListener: void callSessionMergeComplete(com.android.ims.internal.IImsCallSession)>
<android.telephony.ims.aidl.IImsCallSessionListener: void callSessionUssdMessageReceived(int,java.lang.String)>
<android.telephony.ims.aidl.IImsCallSessionListener: void callSessionInitiated(android.telephony.ims.ImsCallProfile)>
<android.telephony.ims.aidl.IImsCallSessionListener: void callSessionInviteParticipantsRequestDelivered()>
<android.telephony.ims.aidl.IImsCallSessionListener: void callSessionInviteParticipantsRequestFailed(android.telephony.ims.ImsReasonInfo)>
<android.telephony.ims.aidl.IImsCallSessionListener: void callSessionResumeReceived(android.telephony.ims.ImsCallProfile)>
<android.telephony.ims.aidl.IImsCallSessionListener: void callQualityChanged(android.telephony.CallQuality)>
<android.telephony.ims.aidl.IImsCallSessionListener: void callSessionHandover(int,int,android.telephony.ims.ImsReasonInfo)>
<android.telephony.ims.aidl.IImsCallSessionListener: void callSessionConferenceExtended(com.android.ims.internal.IImsCallSession,android.telephony.ims.ImsCallProfile)>
<android.telephony.ims.aidl.IImsCallSessionListener: void callSessionRttMessageReceived(java.lang.String)>
<android.telephony.ims.aidl.IImsCallSessionListener: void callSessionTerminated(android.telephony.ims.ImsReasonInfo)>
<android.telephony.ims.aidl.IImsCallSessionListener: void callSessionResumeFailed(android.telephony.ims.ImsReasonInfo)>
<android.telephony.ims.aidl.IImsCallSessionListener: void callSessionConferenceStateUpdated(android.telephony.ims.ImsConferenceState)>
<android.telephony.ims.aidl.IImsCallSessionListener: void callSessionHeld(android.telephony.ims.ImsCallProfile)>
<android.telephony.ims.aidl.IImsCallSessionListener: void callSessionRemoveParticipantsRequestDelivered()>
<android.telephony.ims.aidl.IImsCallSessionListener: void callSessionInitiatedFailed(android.telephony.ims.ImsReasonInfo)>
<android.telephony.ims.aidl.IImsCallSessionListener: void callSessionUpdateFailed(android.telephony.ims.ImsReasonInfo)>
<android.hardware.radio.config.IRadioConfigIndication: java.lang.String getInterfaceHash()>
<android.hardware.radio.config.IRadioConfigIndication: void simSlotsStatusChanged(int,android.hardware.radio.config.SimSlotStatus[])>
<android.hardware.radio.config.IRadioConfigIndication: int getInterfaceVersion()>
<android.hardware.hdmi.IHdmiControlService: int[] getAllowedCecSettingIntValues(java.lang.String)>
<android.hardware.hdmi.IHdmiControlService: void removeCecSettingChangeListener(java.lang.String,android.hardware.hdmi.IHdmiCecSettingChangeListener)>
<android.hardware.hdmi.IHdmiControlService: void sendVendorCommand(int,int,byte[],boolean)>
<android.hardware.hdmi.IHdmiControlService: void askRemoteDeviceToBecomeActiveSource(int)>
<android.hardware.hdmi.IHdmiControlService: void clearTimerRecording(int,int,byte[])>
<android.hardware.hdmi.IHdmiControlService: void queryDisplayStatus(android.hardware.hdmi.IHdmiControlCallback)>
<android.hardware.hdmi.IHdmiControlService: void sendMhlVendorCommand(int,int,int,byte[])>
<android.hardware.hdmi.IHdmiControlService: boolean setMessageHistorySize(int)>
<android.hardware.hdmi.IHdmiControlService: void addCecSettingChangeListener(java.lang.String,android.hardware.hdmi.IHdmiCecSettingChangeListener)>
<android.hardware.hdmi.IHdmiControlService: void sendVolumeKeyEvent(int,int,boolean)>
<android.hardware.hdmi.IHdmiControlService: boolean getSystemAudioMode()>
<android.hardware.hdmi.IHdmiControlService: void addDeviceEventListener(android.hardware.hdmi.IHdmiDeviceEventListener)>
<android.hardware.hdmi.IHdmiControlService: void addHotplugEventListener(android.hardware.hdmi.IHdmiHotplugEventListener)>
<android.hardware.hdmi.IHdmiControlService: int getCecSettingIntValue(java.lang.String)>
<android.hardware.hdmi.IHdmiControlService: android.hardware.hdmi.HdmiDeviceInfo getActiveSource()>
<android.hardware.hdmi.IHdmiControlService: boolean canChangeSystemAudioMode()>
<android.hardware.hdmi.IHdmiControlService: void addHdmiCecVolumeControlFeatureListener(android.hardware.hdmi.IHdmiCecVolumeControlFeatureListener)>
<android.hardware.hdmi.IHdmiControlService: void startTimerRecording(int,int,byte[])>
<android.hardware.hdmi.IHdmiControlService: void setCecSettingStringValue(java.lang.String,java.lang.String)>
<android.hardware.hdmi.IHdmiControlService: java.util.List getInputDevices()>
<android.hardware.hdmi.IHdmiControlService: void sendKeyEvent(int,int,boolean)>
<android.hardware.hdmi.IHdmiControlService: java.util.List getPortInfo()>
<android.hardware.hdmi.IHdmiControlService: void setProhibitMode(boolean)>
<android.hardware.hdmi.IHdmiControlService: void addHdmiMhlVendorCommandListener(android.hardware.hdmi.IHdmiMhlVendorCommandListener)>
<android.hardware.hdmi.IHdmiControlService: void removeHdmiCecVolumeControlFeatureListener(android.hardware.hdmi.IHdmiCecVolumeControlFeatureListener)>
<android.hardware.hdmi.IHdmiControlService: void removeSystemAudioModeChangeListener(android.hardware.hdmi.IHdmiSystemAudioModeChangeListener)>
<android.hardware.hdmi.IHdmiControlService: void setSystemAudioModeOnForAudioOnlySource()>
<android.hardware.hdmi.IHdmiControlService: void oneTouchPlay(android.hardware.hdmi.IHdmiControlCallback)>
<android.hardware.hdmi.IHdmiControlService: void portSelect(int,android.hardware.hdmi.IHdmiControlCallback)>
<android.hardware.hdmi.IHdmiControlService: void deviceSelect(int,android.hardware.hdmi.IHdmiControlCallback)>
<android.hardware.hdmi.IHdmiControlService: void setArcMode(boolean)>
<android.hardware.hdmi.IHdmiControlService: void addSystemAudioModeChangeListener(android.hardware.hdmi.IHdmiSystemAudioModeChangeListener)>
<android.hardware.hdmi.IHdmiControlService: void setInputChangeListener(android.hardware.hdmi.IHdmiInputChangeListener)>
<android.hardware.hdmi.IHdmiControlService: java.util.List getDeviceList()>
<android.hardware.hdmi.IHdmiControlService: void addVendorCommandListener(android.hardware.hdmi.IHdmiVendorCommandListener,int)>
<android.hardware.hdmi.IHdmiControlService: int getPhysicalAddress()>
<android.hardware.hdmi.IHdmiControlService: void addHdmiControlStatusChangeListener(android.hardware.hdmi.IHdmiControlStatusChangeListener)>
<android.hardware.hdmi.IHdmiControlService: void startOneTouchRecord(int,byte[])>
<android.hardware.hdmi.IHdmiControlService: void removeHotplugEventListener(android.hardware.hdmi.IHdmiHotplugEventListener)>
<android.hardware.hdmi.IHdmiControlService: void setSystemAudioVolume(int,int,int)>
<android.hardware.hdmi.IHdmiControlService: java.lang.String getCecSettingStringValue(java.lang.String)>
<android.hardware.hdmi.IHdmiControlService: java.util.List getUserCecSettings()>
<android.hardware.hdmi.IHdmiControlService: void sendStandby(int,int)>
<android.hardware.hdmi.IHdmiControlService: void powerOnRemoteDevice(int,int)>
<android.hardware.hdmi.IHdmiControlService: void stopOneTouchRecord(int)>
<android.hardware.hdmi.IHdmiControlService: java.util.List getAllowedCecSettingStringValues(java.lang.String)>
<android.hardware.hdmi.IHdmiControlService: void setSystemAudioMode(boolean,android.hardware.hdmi.IHdmiControlCallback)>
<android.hardware.hdmi.IHdmiControlService: void removeHdmiControlStatusChangeListener(android.hardware.hdmi.IHdmiControlStatusChangeListener)>
<android.hardware.hdmi.IHdmiControlService: void setCecSettingIntValue(java.lang.String,int)>
<android.hardware.hdmi.IHdmiControlService: void setStandbyMode(boolean)>
<android.hardware.hdmi.IHdmiControlService: int getMessageHistorySize()>
<android.hardware.hdmi.IHdmiControlService: void setHdmiRecordListener(android.hardware.hdmi.IHdmiRecordListener)>
<android.hardware.hdmi.IHdmiControlService: void powerOffRemoteDevice(int,int)>
<android.hardware.hdmi.IHdmiControlService: boolean shouldHandleTvPowerKey()>
<android.hardware.hdmi.IHdmiControlService: void toggleAndFollowTvPower()>
<android.hardware.hdmi.IHdmiControlService: void reportAudioStatus(int,int,int,boolean)>
<android.hardware.hdmi.IHdmiControlService: int[] getSupportedTypes()>
<android.hardware.hdmi.IHdmiControlService: void setSystemAudioMute(boolean)>
<android.se.omapi.ISecureElementService: android.se.omapi.ISecureElementReader getReader(java.lang.String)>
<android.se.omapi.ISecureElementService: java.lang.String[] getReaders()>
<android.se.omapi.ISecureElementService: int getInterfaceVersion()>
<android.se.omapi.ISecureElementService: boolean[] isNfcEventAllowed(java.lang.String,byte[],java.lang.String[],int)>
<android.se.omapi.ISecureElementService: java.lang.String getInterfaceHash()>
<com.android.internal.telecom.IConnectionService: void handoverComplete(java.lang.String,android.telecom.Logging.Session$Info)>
<com.android.internal.telecom.IConnectionService: void handoverFailed(java.lang.String,android.telecom.ConnectionRequest,int,android.telecom.Logging.Session$Info)>
<com.android.internal.telecom.IConnectionService: void answerVideo(java.lang.String,int,android.telecom.Logging.Session$Info)>
<com.android.internal.telecom.IConnectionService: void respondToRttUpgradeRequest(java.lang.String,android.os.ParcelFileDescriptor,android.os.ParcelFileDescriptor,android.telecom.Logging.Session$Info)>
<com.android.internal.telecom.IConnectionService: void splitFromConference(java.lang.String,android.telecom.Logging.Session$Info)>
<com.android.internal.telecom.IConnectionService: void abort(java.lang.String,android.telecom.Logging.Session$Info)>
<com.android.internal.telecom.IConnectionService: void addConferenceParticipants(java.lang.String,java.util.List,android.telecom.Logging.Session$Info)>
<com.android.internal.telecom.IConnectionService: void hold(java.lang.String,android.telecom.Logging.Session$Info)>
<com.android.internal.telecom.IConnectionService: void reject(java.lang.String,android.telecom.Logging.Session$Info)>
<com.android.internal.telecom.IConnectionService: void disconnect(java.lang.String,android.telecom.Logging.Session$Info)>
<com.android.internal.telecom.IConnectionService: void rejectWithMessage(java.lang.String,java.lang.String,android.telecom.Logging.Session$Info)>
<com.android.internal.telecom.IConnectionService: void createConferenceComplete(java.lang.String,android.telecom.Logging.Session$Info)>
<com.android.internal.telecom.IConnectionService: void onPostDialContinue(java.lang.String,boolean,android.telecom.Logging.Session$Info)>
<com.android.internal.telecom.IConnectionService: void createConference(android.telecom.PhoneAccountHandle,java.lang.String,android.telecom.ConnectionRequest,boolean,boolean,android.telecom.Logging.Session$Info)>
<com.android.internal.telecom.IConnectionService: void onCallEndpointChanged(java.lang.String,android.telecom.CallEndpoint,android.telecom.Logging.Session$Info)>
<com.android.internal.telecom.IConnectionService: void answer(java.lang.String,android.telecom.Logging.Session$Info)>
<com.android.internal.telecom.IConnectionService: void connectionServiceFocusGained(android.telecom.Logging.Session$Info)>
<com.android.internal.telecom.IConnectionService: void sendCallEvent(java.lang.String,java.lang.String,android.os.Bundle,android.telecom.Logging.Session$Info)>
<com.android.internal.telecom.IConnectionService: void stopRtt(java.lang.String,android.telecom.Logging.Session$Info)>
<com.android.internal.telecom.IConnectionService: void createConnectionComplete(java.lang.String,android.telecom.Logging.Session$Info)>
<com.android.internal.telecom.IConnectionService: void silence(java.lang.String,android.telecom.Logging.Session$Info)>
<com.android.internal.telecom.IConnectionService: void connectionServiceFocusLost(android.telecom.Logging.Session$Info)>
<com.android.internal.telecom.IConnectionService: void unhold(java.lang.String,android.telecom.Logging.Session$Info)>
<com.android.internal.telecom.IConnectionService: void startRtt(java.lang.String,android.os.ParcelFileDescriptor,android.os.ParcelFileDescriptor,android.telecom.Logging.Session$Info)>
<com.android.internal.telecom.IConnectionService: void playDtmfTone(java.lang.String,char,android.telecom.Logging.Session$Info)>
<com.android.internal.telecom.IConnectionService: void onExtrasChanged(java.lang.String,android.os.Bundle,android.telecom.Logging.Session$Info)>
<com.android.internal.telecom.IConnectionService: void createConnectionFailed(android.telecom.PhoneAccountHandle,java.lang.String,android.telecom.ConnectionRequest,boolean,android.telecom.Logging.Session$Info)>
<com.android.internal.telecom.IConnectionService: void onCallAudioStateChanged(java.lang.String,android.telecom.CallAudioState,android.telecom.Logging.Session$Info)>
<com.android.internal.telecom.IConnectionService: void onTrackedByNonUiService(java.lang.String,boolean,android.telecom.Logging.Session$Info)>
<com.android.internal.telecom.IConnectionService: void removeConnectionServiceAdapter(com.android.internal.telecom.IConnectionServiceAdapter,android.telecom.Logging.Session$Info)>
<com.android.internal.telecom.IConnectionService: void pullExternalCall(java.lang.String,android.telecom.Logging.Session$Info)>
<com.android.internal.telecom.IConnectionService: void deflect(java.lang.String,android.net.Uri,android.telecom.Logging.Session$Info)>
<com.android.internal.telecom.IConnectionService: void addConnectionServiceAdapter(com.android.internal.telecom.IConnectionServiceAdapter,android.telecom.Logging.Session$Info)>
<com.android.internal.telecom.IConnectionService: void onAvailableCallEndpointsChanged(java.lang.String,java.util.List,android.telecom.Logging.Session$Info)>
<com.android.internal.telecom.IConnectionService: void transfer(java.lang.String,android.net.Uri,boolean,android.telecom.Logging.Session$Info)>
<com.android.internal.telecom.IConnectionService: void mergeConference(java.lang.String,android.telecom.Logging.Session$Info)>
<com.android.internal.telecom.IConnectionService: void stopDtmfTone(java.lang.String,android.telecom.Logging.Session$Info)>
<com.android.internal.telecom.IConnectionService: void swapConference(java.lang.String,android.telecom.Logging.Session$Info)>
<com.android.internal.telecom.IConnectionService: void onUsingAlternativeUi(java.lang.String,boolean,android.telecom.Logging.Session$Info)>
<com.android.internal.telecom.IConnectionService: void rejectWithReason(java.lang.String,int,android.telecom.Logging.Session$Info)>
<com.android.internal.telecom.IConnectionService: void consultativeTransfer(java.lang.String,java.lang.String,android.telecom.Logging.Session$Info)>
<com.android.internal.telecom.IConnectionService: void createConferenceFailed(android.telecom.PhoneAccountHandle,java.lang.String,android.telecom.ConnectionRequest,boolean,android.telecom.Logging.Session$Info)>
<com.android.internal.telecom.IConnectionService: void createConnection(android.telecom.PhoneAccountHandle,java.lang.String,android.telecom.ConnectionRequest,boolean,boolean,android.telecom.Logging.Session$Info)>
<com.android.internal.telecom.IConnectionService: void conference(java.lang.String,java.lang.String,android.telecom.Logging.Session$Info)>
<com.android.internal.telecom.IConnectionService: void onCallFilteringCompleted(java.lang.String,android.telecom.Connection$CallFilteringCompletionInfo,android.telecom.Logging.Session$Info)>
<com.android.internal.telecom.IConnectionService: void onMuteStateChanged(java.lang.String,boolean,android.telecom.Logging.Session$Info)>
<com.android.net.IProxyCallback: void setEnterpriseProxy(boolean)>
<com.android.net.IProxyCallback: void onCredentialsReceived(android.os.Bundle,android.sec.enterprise.proxy.IProxyCredentialsCallback)>
<com.android.net.IProxyCallback: void clearProxyServerCache()>
<com.android.net.IProxyCallback: void getProxyPort(android.os.IBinder)>
<com.samsung.android.cocktailbar.ICocktailHost: void noteResumeComponent(android.content.ComponentName)>
<com.samsung.android.cocktailbar.ICocktailHost: void showCocktail(int,int)>
<com.samsung.android.cocktailbar.ICocktailHost: void notifyKeyguardState(boolean,int)>
<com.samsung.android.cocktailbar.ICocktailHost: void sendExtraData(int,android.os.Bundle)>
<com.samsung.android.cocktailbar.ICocktailHost: void partiallyUpdateCocktail(int,android.widget.RemoteViews,int)>
<com.samsung.android.cocktailbar.ICocktailHost: void setPullToRefresh(int,int,android.app.PendingIntent,int)>
<com.samsung.android.cocktailbar.ICocktailHost: void updateToolLauncher(int)>
<com.samsung.android.cocktailbar.ICocktailHost: void viewDataChanged(int,int,int)>
<com.samsung.android.cocktailbar.ICocktailHost: void changeVisibleEdgeService(boolean,int)>
<com.samsung.android.cocktailbar.ICocktailHost: void closeCocktail(int,int,int)>
<com.samsung.android.cocktailbar.ICocktailHost: void partiallyUpdateHelpView(int,android.widget.RemoteViews,int)>
<com.samsung.android.cocktailbar.ICocktailHost: void switchDefaultCocktail(int)>
<com.samsung.android.cocktailbar.ICocktailHost: void notifyWakeUpState(boolean,int,int)>
<com.samsung.android.cocktailbar.ICocktailHost: void removeCocktail(int,int)>
<com.samsung.android.cocktailbar.ICocktailHost: void notePauseComponent(android.content.ComponentName)>
<com.samsung.android.cocktailbar.ICocktailHost: void setDisableTickerView(int,int)>
<com.samsung.android.cocktailbar.ICocktailHost: void updateCocktail(int,com.samsung.android.cocktailbar.Cocktail,int)>
<android.apex.IApexService: android.apex.ApexInfo installAndActivatePackage(java.lang.String)>
<android.apex.IApexService: void stagePackages(java.util.List)>
<android.apex.IApexService: void markBootCompleted()>
<android.apex.IApexService: long calculateSizeForCompressedApex(android.apex.CompressedApexInfoList)>
<android.apex.IApexService: android.apex.ApexInfo[] getActivePackages()>
<android.apex.IApexService: void destroyDeSnapshots(int)>
<android.apex.IApexService: void reserveSpaceForCompressedApex(android.apex.CompressedApexInfoList)>
<android.apex.IApexService: android.apex.ApexInfo[] getAllPackages()>
<android.apex.IApexService: void recollectDataApex(java.lang.String,java.lang.String)>
<android.apex.IApexService: void revertActiveSessions()>
<android.apex.IApexService: void recollectPreinstalledData(java.util.List)>
<android.apex.IApexService: void restoreCeData(int,int,java.lang.String)>
<android.apex.IApexService: android.apex.ApexSessionInfo[] getSessions()>
<android.apex.IApexService: void markStagedSessionReady(int)>
<android.apex.IApexService: void submitStagedSession(android.apex.ApexSessionParams,android.apex.ApexInfoList)>
<android.apex.IApexService: void destroyCeSnapshotsNotSpecified(int,int[])>
<android.apex.IApexService: void abortStagedSession(int)>
<android.apex.IApexService: void markStagedSessionSuccessful(int)>
<android.apex.IApexService: void snapshotCeData(int,int,java.lang.String)>
<android.apex.IApexService: android.apex.ApexSessionInfo getStagedSessionInfo(int)>
<android.apex.IApexService: android.apex.ApexInfo getActivePackage(java.lang.String)>
<android.apex.IApexService: void remountPackages()>
<android.apex.IApexService: void unstagePackages(java.util.List)>
<android.apex.IApexService: android.apex.ApexInfo[] getStagedApexInfos(android.apex.ApexSessionParams)>
<android.apex.IApexService: void destroyCeSnapshots(int,int)>
<android.apex.IApexService: void resumeRevertIfNeeded()>
<android.content.pm.IPackageInstallerSession: android.os.ParcelFileDescriptor getAppMetadataFd()>
<android.content.pm.IPackageInstallerSession: void commit(android.content.IntentSender,boolean)>
<android.content.pm.IPackageInstallerSession: void transfer(java.lang.String)>
<android.content.pm.IPackageInstallerSession: void removeFile(int,java.lang.String)>
<android.content.pm.IPackageInstallerSession: void requestUserPreapproval(android.content.pm.PackageInstaller$PreapprovalDetails,android.content.IntentSender)>
<android.content.pm.IPackageInstallerSession: int[] getChildSessionIds()>
<android.content.pm.IPackageInstallerSession: void requestChecksums(java.lang.String,int,int,java.util.List,android.content.pm.IOnChecksumsReadyListener)>
<android.content.pm.IPackageInstallerSession: boolean isApplicationEnabledSettingPersistent()>
<android.content.pm.IPackageInstallerSession: void removeSplit(java.lang.String)>
<android.content.pm.IPackageInstallerSession: void addClientProgress(float)>
<android.content.pm.IPackageInstallerSession: void addChildSessionId(int)>
<android.content.pm.IPackageInstallerSession: void setChecksums(java.lang.String,android.content.pm.Checksum[],byte[])>
<android.content.pm.IPackageInstallerSession: android.os.ParcelFileDescriptor openWrite(java.lang.String,long,long)>
<android.content.pm.IPackageInstallerSession: android.os.ParcelFileDescriptor openRead(java.lang.String)>
<android.content.pm.IPackageInstallerSession: java.lang.String[] getNames()>
<android.content.pm.IPackageInstallerSession: void addFile(int,java.lang.String,long,byte[],byte[])>
<android.content.pm.IPackageInstallerSession: boolean isRequestUpdateOwnership()>
<android.content.pm.IPackageInstallerSession: void seal()>
<android.content.pm.IPackageInstallerSession: android.os.ParcelFileDescriptor openWriteAppMetadata()>
<android.content.pm.IPackageInstallerSession: int getInstallFlags()>
<android.content.pm.IPackageInstallerSession: void setClientProgress(float)>
<android.content.pm.IPackageInstallerSession: void write(java.lang.String,long,long,android.os.ParcelFileDescriptor)>
<android.content.pm.IPackageInstallerSession: void abandon()>
<android.content.pm.IPackageInstallerSession: java.util.List fetchPackageNames()>
<android.content.pm.IPackageInstallerSession: int getParentSessionId()>
<android.content.pm.IPackageInstallerSession: boolean isMultiPackage()>
<android.content.pm.IPackageInstallerSession: boolean isStaged()>
<android.content.pm.IPackageInstallerSession: android.content.pm.DataLoaderParamsParcel getDataLoaderParams()>
<android.content.pm.IPackageInstallerSession: void removeAppMetadata()>
<android.content.pm.IPackageInstallerSession: void stageViaHardLink(java.lang.String)>
<android.content.pm.IPackageInstallerSession: void close()>
<android.content.pm.IPackageInstallerSession: void removeChildSessionId(int)>
<com.samsung.android.knox.util.ISemKeyStoreService: void grantAccessForAKS(int,java.lang.String)>
<com.samsung.android.knox.util.ISemKeyStoreService: int isAliasExists(java.lang.String)>
<com.samsung.android.knox.util.ISemKeyStoreService: int installCACert(com.samsung.android.knox.util.SemCertAndroidKeyStore)>
<com.samsung.android.knox.util.ISemKeyStoreService: int installCertificateInAndroidKeyStore(com.samsung.android.knox.util.SemCertByte,java.lang.String,char[],int)>
<com.samsung.android.knox.util.ISemKeyStoreService: int getKeystoreStatus()>
<android.telephony.data.IDataServiceCallback: void onApnUnthrottled(java.lang.String)>
<android.telephony.data.IDataServiceCallback: void onHandoverCancelled(int)>
<android.telephony.data.IDataServiceCallback: void onSetupDataCallComplete(int,android.telephony.data.DataCallResponse)>
<android.telephony.data.IDataServiceCallback: void onHandoverStarted(int)>
<android.telephony.data.IDataServiceCallback: void onSetInitialAttachApnComplete(int)>
<android.telephony.data.IDataServiceCallback: void onRequestDataCallListComplete(int,java.util.List)>
<android.telephony.data.IDataServiceCallback: void onDataProfileUnthrottled(android.telephony.data.DataProfile)>
<android.telephony.data.IDataServiceCallback: void onSetDataProfileComplete(int)>
<android.telephony.data.IDataServiceCallback: void onDeactivateDataCallComplete(int)>
<android.telephony.data.IDataServiceCallback: void onDataCallListChanged(java.util.List)>
<android.service.wearable.IWearableSensingService: void startDetection(android.app.ambientcontext.AmbientContextEventRequest,java.lang.String,android.os.RemoteCallback,android.os.RemoteCallback)>
<android.service.wearable.IWearableSensingService: void provideDataStream(android.os.ParcelFileDescriptor,android.os.RemoteCallback)>
<android.service.wearable.IWearableSensingService: void provideData(android.os.PersistableBundle,android.os.SharedMemory,android.os.RemoteCallback)>
<android.service.wearable.IWearableSensingService: void queryServiceStatus(int[],java.lang.String,android.os.RemoteCallback)>
<android.service.wearable.IWearableSensingService: void stopDetection(java.lang.String)>
<android.media.soundtrigger_middleware.IInjectModelEvent: void triggerUnloadModel()>
<com.android.internal.statusbar.IUndoMediaTransferCallback: void onUndoTriggered()>
<com.android.internal.app.procstats.IProcessStats: long getCommittedStatsMerged(long,int,boolean,java.util.List,com.android.internal.app.procstats.ProcessStats)>
<com.android.internal.app.procstats.IProcessStats: long getCommittedStats(long,int,boolean,java.util.List)>
<com.android.internal.app.procstats.IProcessStats: long getMinAssociationDumpDuration()>
<com.android.internal.app.procstats.IProcessStats: android.os.ParcelFileDescriptor getStatsOverTime(long)>
<com.android.internal.app.procstats.IProcessStats: int getCurrentMemoryState()>
<com.android.internal.app.procstats.IProcessStats: byte[] getCurrentStats(java.util.List)>
<com.android.internal.telephony.ILongConsumer: void accept(long)>
<android.hardware.fingerprint.IFingerprintServiceReceiver: void onAcquired(int,int)>
<android.hardware.fingerprint.IFingerprintServiceReceiver: void onUdfpsPointerUp(int)>
<android.hardware.fingerprint.IFingerprintServiceReceiver: void onError(int,int)>
<android.hardware.fingerprint.IFingerprintServiceReceiver: void onRemoved(android.hardware.fingerprint.Fingerprint,int)>
<android.hardware.fingerprint.IFingerprintServiceReceiver: void onFingerprintDetected(int,int,boolean)>
<android.hardware.fingerprint.IFingerprintServiceReceiver: void onEnrollResult(android.hardware.fingerprint.Fingerprint,int)>
<android.hardware.fingerprint.IFingerprintServiceReceiver: void onChallengeGenerated(int,int,long)>
<android.hardware.fingerprint.IFingerprintServiceReceiver: void onAuthenticationFailed()>
<android.hardware.fingerprint.IFingerprintServiceReceiver: void onAuthenticationSucceeded(android.hardware.fingerprint.Fingerprint,int,boolean)>
<android.hardware.fingerprint.IFingerprintServiceReceiver: void onUdfpsPointerDown(int)>
<com.samsung.android.multiwindow.IMultiTaskingBinder: boolean exitMultiWindow(android.os.IBinder,boolean)>
<com.samsung.android.multiwindow.IMultiTaskingBinder: void saveFreeformBounds(int)>
<com.samsung.android.multiwindow.IMultiTaskingBinder: void setCornerGestureEnabledWithSettings(boolean)>
<com.samsung.android.multiwindow.IMultiTaskingBinder: android.content.pm.StringParceledListSlice getMultiWindowBlockListApp()>
<com.samsung.android.multiwindow.IMultiTaskingBinder: void setBoostFreeformTaskLayer(int,boolean)>
<com.samsung.android.multiwindow.IMultiTaskingBinder: boolean removeFocusedTask(int)>
<com.samsung.android.multiwindow.IMultiTaskingBinder: boolean startNaturalSwitching()>
<com.samsung.android.multiwindow.IMultiTaskingBinder: boolean getEmbedActivityPackageEnabled(java.lang.String,int)>
<com.samsung.android.multiwindow.IMultiTaskingBinder: void setCandidateTask(int)>
<com.samsung.android.multiwindow.IMultiTaskingBinder: void setEmbedActivityPackageEnabled(java.lang.String,boolean,int)>
<com.samsung.android.multiwindow.IMultiTaskingBinder: void finishNaturalSwitching()>
<com.samsung.android.multiwindow.IMultiTaskingBinder: android.graphics.PointF getFreeformContainerPoint()>
<com.samsung.android.multiwindow.IMultiTaskingBinder: void reportFreeformContainerPoint(android.graphics.PointF)>
<com.samsung.android.multiwindow.IMultiTaskingBinder: java.util.List getAllowedMultiWindowPackageList()>
<com.samsung.android.multiwindow.IMultiTaskingBinder: void setMultiWindowEnabledForUser(java.lang.String,java.lang.String,boolean,int)>
<com.samsung.android.multiwindow.IMultiTaskingBinder: boolean hasMinimizedToggleTasks()>
<com.samsung.android.multiwindow.IMultiTaskingBinder: boolean isSplitImmersiveModeEnabled()>
<com.samsung.android.multiwindow.IMultiTaskingBinder: android.content.pm.StringParceledListSlice getMWDisableRequesters()>
<com.samsung.android.multiwindow.IMultiTaskingBinder: boolean isVisibleTaskByTaskIdInDexDisplay(int)>
<com.samsung.android.multiwindow.IMultiTaskingBinder: boolean isAllowedMultiWindowPackage(java.lang.String)>
<com.samsung.android.multiwindow.IMultiTaskingBinder: void registerFreeformCallback(com.samsung.android.multiwindow.IFreeformCallback)>
<com.samsung.android.multiwindow.IMultiTaskingBinder: void unregisterFreeformCallback(com.samsung.android.multiwindow.IFreeformCallback)>
<com.samsung.android.multiwindow.IMultiTaskingBinder: void unregisterRemoteAppTransitionListener(com.samsung.android.multiwindow.IRemoteAppTransitionListener)>
<com.samsung.android.multiwindow.IMultiTaskingBinder: android.content.pm.ParceledListSlice getMinimizedFreeformTasksForCurrentUser()>
<com.samsung.android.multiwindow.IMultiTaskingBinder: void initDockingBounds(android.graphics.Rect,android.graphics.Rect,int)>
<com.samsung.android.multiwindow.IMultiTaskingBinder: void registerDexSnappingCallback(com.samsung.android.multiwindow.IDexSnappingCallback)>
<com.samsung.android.multiwindow.IMultiTaskingBinder: void setMaxVisibleFreeformCountForDex(int,int)>
<com.samsung.android.multiwindow.IMultiTaskingBinder: java.util.List getSupportEmbedActivityPackages()>
<com.samsung.android.multiwindow.IMultiTaskingBinder: boolean isMultiWindowBlockListApp(java.lang.String)>
<com.samsung.android.multiwindow.IMultiTaskingBinder: void clearAllDockingTasks(java.lang.String)>
<com.samsung.android.multiwindow.IMultiTaskingBinder: boolean isDismissedFlexPanelMode()>
<com.samsung.android.multiwindow.IMultiTaskingBinder: java.util.List getSplitActivityAllowPackages()>
<com.samsung.android.multiwindow.IMultiTaskingBinder: boolean isAllTasksResizable(int,int,int)>
<com.samsung.android.multiwindow.IMultiTaskingBinder: boolean toggleFreeformWindowingMode()>
<com.samsung.android.multiwindow.IMultiTaskingBinder: boolean isVisibleTaskInDexDisplay(android.app.PendingIntent)>
<com.samsung.android.multiwindow.IMultiTaskingBinder: int getSplitActivityPackageEnabled(java.lang.String,int)>
<com.samsung.android.multiwindow.IMultiTaskingBinder: void scheduleNotifyDexSnappingCallback(int,android.graphics.Rect)>
<com.samsung.android.multiwindow.IMultiTaskingBinder: void setSplitImmersiveMode(boolean)>
<com.samsung.android.multiwindow.IMultiTaskingBinder: boolean minimizeTaskById(int)>
<com.samsung.android.multiwindow.IMultiTaskingBinder: void unregisterDexSnappingCallback(com.samsung.android.multiwindow.IDexSnappingCallback)>
<com.samsung.android.multiwindow.IMultiTaskingBinder: boolean preventNaturalSwitching()>
<com.samsung.android.multiwindow.IMultiTaskingBinder: android.content.pm.ParceledListSlice getVisibleTasks()>
<com.samsung.android.multiwindow.IMultiTaskingBinder: boolean isFlexPanelRunning()>
<com.samsung.android.multiwindow.IMultiTaskingBinder: boolean minimizeAllTasksByRecents(int)>
<com.samsung.android.multiwindow.IMultiTaskingBinder: void notifyFreeformMinimizeAnimationEnd(int,android.graphics.PointF)>
<com.samsung.android.multiwindow.IMultiTaskingBinder: void toggleFreeformForDexCompatApp(int)>
<com.samsung.android.multiwindow.IMultiTaskingBinder: void setNaviStarSplitImmersiveMode(boolean)>
<com.samsung.android.multiwindow.IMultiTaskingBinder: int getDexTaskInfoFlags(android.os.IBinder)>
<com.samsung.android.multiwindow.IMultiTaskingBinder: void setStayFocusActivityEnabled(boolean)>
<com.samsung.android.multiwindow.IMultiTaskingBinder: int getResizeMode(android.content.pm.ActivityInfo)>
<com.samsung.android.multiwindow.IMultiTaskingBinder: void dismissSplitTask(android.os.IBinder,boolean)>
<com.samsung.android.multiwindow.IMultiTaskingBinder: void setBlockedMinimizeFreeformEnable(boolean)>
<com.samsung.android.multiwindow.IMultiTaskingBinder: void hideInputMethod(int)>
<com.samsung.android.multiwindow.IMultiTaskingBinder: com.samsung.android.multiwindow.SurfaceFreezerSnapshot getSurfaceFreezerSnapshot(int)>
<com.samsung.android.multiwindow.IMultiTaskingBinder: void registerRemoteAppTransitionListener(com.samsung.android.multiwindow.IRemoteAppTransitionListener)>
<com.samsung.android.multiwindow.IMultiTaskingBinder: boolean minimizeTaskToSpecificPosition(int,boolean,int,int)>
<com.samsung.android.multiwindow.IMultiTaskingBinder: boolean isValidCornerGesture(android.view.MotionEvent)>
<com.samsung.android.multiwindow.IMultiTaskingBinder: void toggleFreeformWindowingModeForDex(android.window.WindowContainerToken)>
<com.samsung.android.multiwindow.IMultiTaskingBinder: void notifyDragSplitAppIconHasDrawable(boolean)>
<com.samsung.android.multiwindow.IMultiTaskingBinder: void setCustomDensityEnabled(int)>
<com.samsung.android.multiwindow.IMultiTaskingBinder: boolean supportsMultiWindow(android.os.IBinder)>
<com.samsung.android.multiwindow.IMultiTaskingBinder: void resizeOtherTaskIfNeeded(int,android.graphics.Rect)>
<com.samsung.android.multiwindow.IMultiTaskingBinder: int calculateMaxWidth(int,int,int)>
<com.samsung.android.multiwindow.IMultiTaskingBinder: int getMultiSplitFlags()>
<com.samsung.android.multiwindow.IMultiTaskingBinder: android.content.pm.ParceledListSlice getTaskInfoFromPackageName(java.lang.String)>
<com.samsung.android.multiwindow.IMultiTaskingBinder: void rotateDexCompatTask(android.os.IBinder)>
<com.samsung.android.multiwindow.IMultiTaskingBinder: boolean supportMultiSplitAppMinimumSize()>
<com.samsung.android.multiwindow.IMultiTaskingBinder: boolean minimizeAllTasks(int)>
<com.samsung.android.multiwindow.IMultiTaskingBinder: void updateMultiSplitAppMinimumSize()>
<com.samsung.android.multiwindow.IMultiTaskingBinder: int getMultiWindowModeStates(int)>
<com.samsung.android.multiwindow.IMultiTaskingBinder: void setSplitActivityPackageEnabled(java.lang.String,int,int)>
<com.android.internal.telecom.ICallStreamingService: void setStreamingCallAdapter(com.android.internal.telecom.IStreamingCallAdapter)>
<com.android.internal.telecom.ICallStreamingService: void onCallStreamingStarted(android.telecom.StreamingCall)>
<com.android.internal.telecom.ICallStreamingService: void onCallStreamingStopped()>
<com.android.internal.telecom.ICallStreamingService: void onCallStreamingStateChanged(int)>
<com.android.ims.internal.IImsConfig: java.lang.String getProvisionedStringValue(int)>
<com.android.ims.internal.IImsConfig: boolean getVolteProvisioned()>
<com.android.ims.internal.IImsConfig: void setFeatureValue(int,int,int,com.android.ims.ImsConfigListener)>
<com.android.ims.internal.IImsConfig: void getFeatureValue(int,int,com.android.ims.ImsConfigListener)>
<com.android.ims.internal.IImsConfig: void setVideoQuality(int,com.android.ims.ImsConfigListener)>
<com.android.ims.internal.IImsConfig: int setProvisionedStringValue(int,java.lang.String)>
<com.android.ims.internal.IImsConfig: void getVideoQuality(com.android.ims.ImsConfigListener)>
<com.android.ims.internal.IImsConfig: int getProvisionedValue(int)>
<com.android.ims.internal.IImsConfig: int setProvisionedValue(int,int)>
<com.android.internal.telecom.RemoteServiceCallback: void onResult(java.util.List,java.util.List)>
<com.android.internal.telecom.RemoteServiceCallback: void onError()>
<com.android.internal.telephony.euicc.IGetEuiccInfo1Callback: void onComplete(int,byte[])>
<android.media.tv.interactive.ITvInteractiveAppClient: void onRequestAvailableSpeeds(int)>
<android.media.tv.interactive.ITvInteractiveAppClient: void onRequestCurrentChannelUri(int)>
<android.media.tv.interactive.ITvInteractiveAppClient: void onRequestTvRecordingInfo(java.lang.String,int)>
<android.media.tv.interactive.ITvInteractiveAppClient: void onRequestTimeShiftMode(int)>
<android.media.tv.interactive.ITvInteractiveAppClient: void onRequestCurrentTvInputId(int)>
<android.media.tv.interactive.ITvInteractiveAppClient: void onRequestCurrentChannelLcn(int)>
<android.media.tv.interactive.ITvInteractiveAppClient: void onRequestScheduleRecording2(java.lang.String,java.lang.String,android.net.Uri,long,long,int,android.os.Bundle,int)>
<android.media.tv.interactive.ITvInteractiveAppClient: void onBroadcastInfoRequest(android.media.tv.BroadcastInfoRequest,int)>
<android.media.tv.interactive.ITvInteractiveAppClient: void onSetVideoBounds(android.graphics.Rect,int)>
<android.media.tv.interactive.ITvInteractiveAppClient: void onRequestCurrentVideoBounds(int)>
<android.media.tv.interactive.ITvInteractiveAppClient: void onRequestSigning(java.lang.String,java.lang.String,java.lang.String,byte[],int)>
<android.media.tv.interactive.ITvInteractiveAppClient: void onRequestStartRecording(java.lang.String,android.net.Uri,int)>
<android.media.tv.interactive.ITvInteractiveAppClient: void onBiInteractiveAppCreated(android.net.Uri,java.lang.String,int)>
<android.media.tv.interactive.ITvInteractiveAppClient: void onCommandRequest(java.lang.String,android.os.Bundle,int)>
<android.media.tv.interactive.ITvInteractiveAppClient: void onAdBufferReady(android.media.tv.AdBuffer,int)>
<android.media.tv.interactive.ITvInteractiveAppClient: void onRemoveBroadcastInfo(int,int)>
<android.media.tv.interactive.ITvInteractiveAppClient: void onRequestTvRecordingInfoList(int,int)>
<android.media.tv.interactive.ITvInteractiveAppClient: void onRequestStreamVolume(int)>
<android.media.tv.interactive.ITvInteractiveAppClient: void onSessionReleased(int)>
<android.media.tv.interactive.ITvInteractiveAppClient: void onTeletextAppStateChanged(int,int)>
<android.media.tv.interactive.ITvInteractiveAppClient: void onSetTvRecordingInfo(java.lang.String,android.media.tv.TvRecordingInfo,int)>
<android.media.tv.interactive.ITvInteractiveAppClient: void onAdRequest(android.media.tv.AdRequest,int)>
<android.media.tv.interactive.ITvInteractiveAppClient: void onSessionStateChanged(int,int,int)>
<android.media.tv.interactive.ITvInteractiveAppClient: void onSessionCreated(java.lang.String,android.os.IBinder,android.view.InputChannel,int)>
<android.media.tv.interactive.ITvInteractiveAppClient: void onLayoutSurface(int,int,int,int,int)>
<android.media.tv.interactive.ITvInteractiveAppClient: void onRequestScheduleRecording(java.lang.String,java.lang.String,android.net.Uri,android.net.Uri,android.os.Bundle,int)>
<android.media.tv.interactive.ITvInteractiveAppClient: void onRequestStopRecording(java.lang.String,int)>
<android.media.tv.interactive.ITvInteractiveAppClient: void onRequestTrackInfoList(int)>
<android.media.tv.interactive.ITvInteractiveAppClient: void onTimeShiftCommandRequest(java.lang.String,android.os.Bundle,int)>
<android.media.session.ISessionCallback: void onRewind(java.lang.String,int,int)>
<android.media.session.ISessionCallback: void onMediaButtonFromController(java.lang.String,int,int,android.content.Intent)>
<android.media.session.ISessionCallback: void onPlayFromSearch(java.lang.String,int,int,java.lang.String,android.os.Bundle)>
<android.media.session.ISessionCallback: void onPlayFromMediaId(java.lang.String,int,int,java.lang.String,android.os.Bundle)>
<android.media.session.ISessionCallback: void onPrepareFromUri(java.lang.String,int,int,android.net.Uri,android.os.Bundle)>
<android.media.session.ISessionCallback: void onPrepareFromMediaId(java.lang.String,int,int,java.lang.String,android.os.Bundle)>
<android.media.session.ISessionCallback: void onSetVolumeTo(java.lang.String,int,int,int)>
<android.media.session.ISessionCallback: void onPrevious(java.lang.String,int,int)>
<android.media.session.ISessionCallback: void onFastForward(java.lang.String,int,int)>
<android.media.session.ISessionCallback: void onMediaButton(java.lang.String,int,int,android.content.Intent,int,android.os.ResultReceiver)>
<android.media.session.ISessionCallback: void onPause(java.lang.String,int,int)>
<android.media.session.ISessionCallback: void onPlayFromUri(java.lang.String,int,int,android.net.Uri,android.os.Bundle)>
<android.media.session.ISessionCallback: void onStop(java.lang.String,int,int)>
<android.media.session.ISessionCallback: void onAdjustVolume(java.lang.String,int,int,int)>
<android.media.session.ISessionCallback: void onNext(java.lang.String,int,int)>
<android.media.session.ISessionCallback: void onCustomAction(java.lang.String,int,int,java.lang.String,android.os.Bundle)>
<android.media.session.ISessionCallback: void onPlay(java.lang.String,int,int)>
<android.media.session.ISessionCallback: void onRate(java.lang.String,int,int,android.media.Rating)>
<android.media.session.ISessionCallback: void onSkipToTrack(java.lang.String,int,int,long)>
<android.media.session.ISessionCallback: void onPrepareFromSearch(java.lang.String,int,int,java.lang.String,android.os.Bundle)>
<android.media.session.ISessionCallback: void onSetPlaybackSpeed(java.lang.String,int,int,float)>
<android.media.session.ISessionCallback: void onCommand(java.lang.String,int,int,java.lang.String,android.os.Bundle,android.os.ResultReceiver)>
<android.media.session.ISessionCallback: void onPrepare(java.lang.String,int,int)>
<android.media.session.ISessionCallback: void onSeekTo(java.lang.String,int,int,long)>
<android.security.IFileIntegrityService: boolean isAppSourceCertificateTrusted(byte[],java.lang.String)>
<android.security.IFileIntegrityService: boolean isApkVeritySupported()>
<android.window.IBackAnimationRunner: void onAnimationCancelled()>
<android.window.IBackAnimationRunner: void onAnimationStart(android.view.RemoteAnimationTarget[],android.view.RemoteAnimationTarget[],android.view.RemoteAnimationTarget[],android.window.IBackAnimationFinishedCallback)>
<android.app.contentsuggestions.ISelectionsCallback: void onContentSelectionsAvailable(int,java.util.List)>
<com.android.internal.telephony.ITransportSelectorCallback: void onWwanSelectedAsync(com.android.internal.telephony.ITransportSelectorResultCallback)>
<com.android.internal.telephony.ITransportSelectorCallback: void onCreated(com.android.internal.telephony.IDomainSelector)>
<com.android.internal.telephony.ITransportSelectorCallback: void onSelectionTerminated(int)>
<com.android.internal.telephony.ITransportSelectorCallback: void onWlanSelected(boolean)>
<com.android.internal.telephony.ITransportSelectorCallback: com.android.internal.telephony.IWwanSelectorCallback onWwanSelected()>
<com.android.internal.app.IVoiceInteractorRequest: void cancel()>
<android.view.accessibility.IAccessibilityEmbeddedConnection: android.os.IBinder associateEmbeddedHierarchy(android.os.IBinder,int)>
<android.view.accessibility.IAccessibilityEmbeddedConnection: void disassociateEmbeddedHierarchy()>
<android.view.accessibility.IAccessibilityEmbeddedConnection: void setWindowMatrix(float[])>
<android.telephony.ims.aidl.ISrvccStartedCallback: void onSrvccCallNotified(java.util.List)>
<android.service.textclassifier.ITextClassifierService: void onConnectedStateChanged(int)>
<android.service.textclassifier.ITextClassifierService: void onDestroyTextClassificationSession(android.view.textclassifier.TextClassificationSessionId)>
<android.service.textclassifier.ITextClassifierService: void onSuggestConversationActions(android.view.textclassifier.TextClassificationSessionId,android.view.textclassifier.ConversationActions$Request,android.service.textclassifier.ITextClassifierCallback)>
<android.service.textclassifier.ITextClassifierService: void onSuggestSelection(android.view.textclassifier.TextClassificationSessionId,android.view.textclassifier.TextSelection$Request,android.service.textclassifier.ITextClassifierCallback)>
<android.service.textclassifier.ITextClassifierService: void onClassifyText(android.view.textclassifier.TextClassificationSessionId,android.view.textclassifier.TextClassification$Request,android.service.textclassifier.ITextClassifierCallback)>
<android.service.textclassifier.ITextClassifierService: void onSelectionEvent(android.view.textclassifier.TextClassificationSessionId,android.view.textclassifier.SelectionEvent)>
<android.service.textclassifier.ITextClassifierService: void onCreateTextClassificationSession(android.view.textclassifier.TextClassificationContext,android.view.textclassifier.TextClassificationSessionId)>
<android.service.textclassifier.ITextClassifierService: void onDetectLanguage(android.view.textclassifier.TextClassificationSessionId,android.view.textclassifier.TextLanguage$Request,android.service.textclassifier.ITextClassifierCallback)>
<android.service.textclassifier.ITextClassifierService: void onGenerateLinks(android.view.textclassifier.TextClassificationSessionId,android.view.textclassifier.TextLinks$Request,android.service.textclassifier.ITextClassifierCallback)>
<android.service.textclassifier.ITextClassifierService: void onTextClassifierEvent(android.view.textclassifier.TextClassificationSessionId,android.view.textclassifier.TextClassifierEvent)>
<android.os.IThermalStatusListener: void onStatusChange(int)>
<com.android.ims.internal.uce.options.IOptionsListener: void cmdStatus(com.android.ims.internal.uce.options.OptionsCmdStatus)>
<com.android.ims.internal.uce.options.IOptionsListener: void serviceAvailable(com.android.ims.internal.uce.common.StatusCode)>
<com.android.ims.internal.uce.options.IOptionsListener: void getVersionCb(java.lang.String)>
<com.android.ims.internal.uce.options.IOptionsListener: void incomingOptions(java.lang.String,com.android.ims.internal.uce.options.OptionsCapInfo,int)>
<com.android.ims.internal.uce.options.IOptionsListener: void serviceUnavailable(com.android.ims.internal.uce.common.StatusCode)>
<com.android.ims.internal.uce.options.IOptionsListener: void sipResponseReceived(java.lang.String,com.android.ims.internal.uce.options.OptionsSipResponse,com.android.ims.internal.uce.options.OptionsCapInfo)>
<com.samsung.android.iccc.IIntegrityControlCheckCenter: byte[] getDeviceStatus(int,byte[])>
<com.samsung.android.iccc.IIntegrityControlCheckCenter: byte[] setAttestationData(byte[])>
<com.samsung.android.iccc.IIntegrityControlCheckCenter: byte[] getDeviceInfo(byte[])>
<com.samsung.android.iccc.IIntegrityControlCheckCenter: int setSecureData(int,int)>
<com.samsung.android.iccc.IIntegrityControlCheckCenter: int getTrustedBootData()>
<com.samsung.android.iccc.IIntegrityControlCheckCenter: int getSecureData(int)>
<com.android.internal.telephony.euicc.IGetEuiccChallengeCallback: void onComplete(int,byte[])>
<android.window.IRemoteTransitionFinishedCallback: void onTransitionFinished(android.window.WindowContainerTransaction,android.view.SurfaceControl$Transaction)>
<android.view.IWindowSessionCallback: void onAnimatorScaleChanged(float)>
<android.media.IMediaHTTPService: android.media.IMediaHTTPConnection makeHTTPConnection()>
<android.permission.IPermissionChecker: int checkOp(int,android.content.AttributionSourceState,java.lang.String,boolean,boolean)>
<android.permission.IPermissionChecker: void finishDataDelivery(int,android.content.AttributionSourceState,boolean)>
<android.permission.IPermissionChecker: int checkPermission(java.lang.String,android.content.AttributionSourceState,java.lang.String,boolean,boolean,boolean,int)>
<android.os.IDeviceIdentifiersPolicyService: java.lang.String getSerialForPackage(java.lang.String,java.lang.String)>
<android.os.IDeviceIdentifiersPolicyService: java.lang.String getSerial()>
<com.samsung.android.service.SemService.ISemService: void start_SLOG()>
<com.samsung.android.service.SemService.ISemService: void check_Network(int)>
<com.samsung.android.service.SemService.ISemService: int deactivate_CardsAID(int,int,java.lang.String[],int[],int)>
<com.samsung.android.service.SemService.ISemService: int grdm_request_key(int,byte[])>
<com.samsung.android.service.SemService.ISemService: int send_Data(byte[],int,byte[],int)>
<com.samsung.android.service.SemService.ISemService: int openSpiDriver()>
<com.samsung.android.service.SemService.ISemService: java.lang.String getCPLC14mode()>
<com.samsung.android.service.SemService.ISemService: void secureLog(java.lang.String)>
<com.samsung.android.service.SemService.ISemService: void sem_factory()>
<com.samsung.android.service.SemService.ISemService: int eSE_LowFactoryReset()>
<com.samsung.android.service.SemService.ISemService: java.lang.String grdm_check_restricted_mode()>
<com.samsung.android.service.SemService.ISemService: void stop_SLOG()>
<com.samsung.android.service.SemService.ISemService: int esek_certificate_check()>
<com.samsung.android.service.SemService.ISemService: int start_attestation(byte[],int,byte[],int)>
<com.samsung.android.service.SemService.ISemService: java.lang.String[] handle_CCMCB(byte[],int,byte[],int)>
<com.samsung.android.service.SemService.ISemService: int get_HQMMemory(byte[])>
<com.samsung.android.service.SemService.ISemService: int inject_esesm_keyset()>
<com.samsung.android.service.SemService.ISemService: int open_Spi(int)>
<com.samsung.android.service.SemService.ISemService: int grdm_release_session()>
<com.samsung.android.service.SemService.ISemService: int eSE_FullFactoryReset()>
<com.samsung.android.service.SemService.ISemService: int grdm_get_session()>
<com.samsung.android.service.SemService.ISemService: java.lang.String[] handle_CCM(byte[],int)>
<com.samsung.android.service.SemService.ISemService: int verify_esesm_keyset()>
<com.samsung.android.service.SemService.ISemService: int closeSpiDriver()>
<com.samsung.android.service.SemService.ISemService: int resetForCOSU()>
<com.samsung.android.service.SemService.ISemService: int deactivate_Cards(int,java.lang.String[],int[],int)>
<com.samsung.android.service.SemService.ISemService: int scp11_certificate_check()>
<com.samsung.android.service.SemService.ISemService: int eSE_FactoryReset()>
<com.samsung.android.service.SemService.ISemService: int getAtr_Spi()>
<com.samsung.android.service.SemService.ISemService: int continue_attestation(java.lang.String,int,byte[])>
<com.samsung.android.service.SemService.ISemService: int isLccmSwp()>
<com.samsung.android.service.SemService.ISemService: void stop_request_credentials()>
<com.samsung.android.service.SemService.ISemService: int close_Spi(int)>
<com.samsung.android.service.SemService.ISemService: int grdm_get_attes_cert(int,byte[])>
<com.samsung.android.service.SemService.ISemService: int ICD()>
<com.samsung.android.service.SemService.ISemService: java.lang.String get_ESEA()>
<com.samsung.android.service.SemService.ISemService: int grdm_Check_Status()>
<com.samsung.android.service.SemService.ISemService: int start_request_credentials(byte[],byte[],java.lang.String,byte[])>
<com.samsung.android.service.SemService.ISemService: int check_SeState(byte[],byte[])>
<android.os.IIncidentCompanion: android.os.IncidentManager$IncidentReport getIncidentReport(java.lang.String,java.lang.String,java.lang.String)>
<android.os.IIncidentCompanion: void approveReport(java.lang.String)>
<android.os.IIncidentCompanion: java.util.List getPendingReports()>
<android.os.IIncidentCompanion: java.util.List getIncidentReportList(java.lang.String,java.lang.String)>
<android.os.IIncidentCompanion: void sendReportReadyBroadcast(java.lang.String,java.lang.String)>
<android.os.IIncidentCompanion: void authorizeReport(int,java.lang.String,java.lang.String,java.lang.String,int,android.os.IIncidentAuthListener)>
<android.os.IIncidentCompanion: void deleteIncidentReports(java.lang.String,java.lang.String,java.lang.String)>
<android.os.IIncidentCompanion: void deleteAllIncidentReports(java.lang.String)>
<android.os.IIncidentCompanion: void cancelAuthorization(android.os.IIncidentAuthListener)>
<android.os.IIncidentCompanion: void denyReport(java.lang.String)>
<com.android.internal.compat.IOverrideValidator: com.android.internal.compat.OverrideAllowedState getOverrideAllowedState(long,java.lang.String)>
<android.app.IBackupAgent: void clearBackupRestoreEventLogger()>
<android.app.IBackupAgent: void doRestoreFinished(int,android.app.backup.IBackupManager)>
<android.app.IBackupAgent: void doFullBackup(android.os.ParcelFileDescriptor,long,int,android.app.backup.IBackupManager,int)>
<android.app.IBackupAgent: void getOperationType(com.android.internal.infra.AndroidFuture)>
<android.app.IBackupAgent: void fail(java.lang.String)>
<android.app.IBackupAgent: void doMeasureFullBackup(long,int,android.app.backup.IBackupManager,int)>
<android.app.IBackupAgent: void getLoggerResults(com.android.internal.infra.AndroidFuture)>
<android.app.IBackupAgent: void doFullBackupPath(android.os.ParcelFileDescriptor,long,int,android.app.backup.IBackupManager,int,java.lang.String[])>
<android.app.IBackupAgent: void doRestoreWithExcludedKeys(android.os.ParcelFileDescriptor,long,android.os.ParcelFileDescriptor,int,android.app.backup.IBackupManager,java.util.List)>
<android.app.IBackupAgent: void doRestoreFile(android.os.ParcelFileDescriptor,long,int,java.lang.String,java.lang.String,long,long,int,android.app.backup.IBackupManager)>
<android.app.IBackupAgent: void doBackup(android.os.ParcelFileDescriptor,android.os.ParcelFileDescriptor,android.os.ParcelFileDescriptor,long,android.app.backup.IBackupCallback,int)>
<android.app.IBackupAgent: void doQuotaExceeded(long,long,android.app.backup.IBackupCallback)>
<android.app.IBackupAgent: void doRestore(android.os.ParcelFileDescriptor,long,android.os.ParcelFileDescriptor,int,android.app.backup.IBackupManager)>
<android.net.vcn.IVcnManagementService: void removeVcnUnderlyingNetworkPolicyListener(android.net.vcn.IVcnUnderlyingNetworkPolicyListener)>
<android.net.vcn.IVcnManagementService: void clearVcnConfig(android.os.ParcelUuid,java.lang.String)>
<android.net.vcn.IVcnManagementService: android.net.vcn.VcnUnderlyingNetworkPolicy getUnderlyingNetworkPolicy(android.net.NetworkCapabilities,android.net.LinkProperties)>
<android.net.vcn.IVcnManagementService: void addVcnUnderlyingNetworkPolicyListener(android.net.vcn.IVcnUnderlyingNetworkPolicyListener)>
<android.net.vcn.IVcnManagementService: void setVcnConfig(android.os.ParcelUuid,android.net.vcn.VcnConfig,java.lang.String)>
<android.net.vcn.IVcnManagementService: void unregisterVcnStatusCallback(android.net.vcn.IVcnStatusCallback)>
<android.net.vcn.IVcnManagementService: java.util.List getConfiguredSubscriptionGroups(java.lang.String)>
<android.net.vcn.IVcnManagementService: void registerVcnStatusCallback(android.os.ParcelUuid,android.net.vcn.IVcnStatusCallback,java.lang.String)>
<android.view.accessibility.IAccessibilityInteractionConnection: void focusSearch(long,int,android.graphics.Region,int,android.view.accessibility.IAccessibilityInteractionConnectionCallback,int,int,long,android.view.MagnificationSpec,float[])>
<android.view.accessibility.IAccessibilityInteractionConnection: void findFocus(long,int,android.graphics.Region,int,android.view.accessibility.IAccessibilityInteractionConnectionCallback,int,int,long,android.view.MagnificationSpec,float[])>
<android.view.accessibility.IAccessibilityInteractionConnection: void findAccessibilityNodeInfoByAccessibilityId(long,android.graphics.Region,int,android.view.accessibility.IAccessibilityInteractionConnectionCallback,int,int,long,android.view.MagnificationSpec,float[],android.os.Bundle)>
<android.view.accessibility.IAccessibilityInteractionConnection: void findAccessibilityNodeInfosByViewId(long,java.lang.String,android.graphics.Region,int,android.view.accessibility.IAccessibilityInteractionConnectionCallback,int,int,long,android.view.MagnificationSpec,float[])>
<android.view.accessibility.IAccessibilityInteractionConnection: void findAccessibilityNodeInfosByText(long,java.lang.String,android.graphics.Region,int,android.view.accessibility.IAccessibilityInteractionConnectionCallback,int,int,long,android.view.MagnificationSpec,float[])>
<android.view.accessibility.IAccessibilityInteractionConnection: void clearAccessibilityFocus()>
<android.view.accessibility.IAccessibilityInteractionConnection: void notifyOutsideTouch()>
<android.view.accessibility.IAccessibilityInteractionConnection: void attachAccessibilityOverlayToWindow(android.view.SurfaceControl)>
<android.view.accessibility.IAccessibilityInteractionConnection: void performAccessibilityAction(long,int,android.os.Bundle,int,android.view.accessibility.IAccessibilityInteractionConnectionCallback,int,int,long)>
<android.view.accessibility.IAccessibilityInteractionConnection: void takeScreenshotOfWindow(int,android.window.ScreenCapture$ScreenCaptureListener,android.view.accessibility.IAccessibilityInteractionConnectionCallback)>
<com.android.internal.telephony.ITelephonyRegistry: void addOnOpportunisticSubscriptionsChangedListener(java.lang.String,java.lang.String,com.android.internal.telephony.IOnSubscriptionsChangedListener)>
<com.android.internal.telephony.ITelephonyRegistry: void clearPreciseDataConnectionStates(int)>
<com.android.internal.telephony.ITelephonyRegistry: void notifyDataActivity(int)>
<com.android.internal.telephony.ITelephonyRegistry: void notifyCallbackModeStarted(int,int,int)>
<com.android.internal.telephony.ITelephonyRegistry: void notifySrvccStateChanged(int,int)>
<com.android.internal.telephony.ITelephonyRegistry: void notifyOutgoingEmergencySms(int,int,android.telephony.emergency.EmergencyNumber)>
<com.android.internal.telephony.ITelephonyRegistry: void notifyUserMobileDataStateChangedForPhoneId(int,int,boolean)>
<com.android.internal.telephony.ITelephonyRegistry: void notifyDataEnabled(int,int,boolean,int)>
<com.android.internal.telephony.ITelephonyRegistry: void notifyDisplayInfoChanged(int,int,android.telephony.TelephonyDisplayInfo)>
<com.android.internal.telephony.ITelephonyRegistry: void listenWithEventList(boolean,boolean,int,java.lang.String,java.lang.String,com.android.internal.telephony.IPhoneStateListener,int[],boolean)>
<com.android.internal.telephony.ITelephonyRegistry: void notifyCarrierNetworkChange(boolean)>
<com.android.internal.telephony.ITelephonyRegistry: void notifyCarrierNetworkChangeWithSubId(int,boolean)>
<com.android.internal.telephony.ITelephonyRegistry: void notifyOpportunisticSubscriptionInfoChanged()>
<com.android.internal.telephony.ITelephonyRegistry: void notifyMessageWaitingChangedForPhoneId(int,int,boolean)>
<com.android.internal.telephony.ITelephonyRegistry: void notifyOemHookRawEventForSubscriber(int,int,byte[])>
<com.android.internal.telephony.ITelephonyRegistry: void notifyDataActivityForSubscriber(int,int)>
<com.android.internal.telephony.ITelephonyRegistry: void notifyCallbackModeStopped(int,int,int,int)>
<com.android.internal.telephony.ITelephonyRegistry: void notifySimActivationStateChangedForPhoneId(int,int,int,int)>
<com.android.internal.telephony.ITelephonyRegistry: void removeCarrierConfigChangeListener(com.android.internal.telephony.ICarrierConfigChangeListener,java.lang.String)>
<com.android.internal.telephony.ITelephonyRegistry: void notifyBarringInfoChanged(int,int,android.telephony.BarringInfo)>
<com.android.internal.telephony.ITelephonyRegistry: void notifyLinkCapacityEstimateChanged(int,int,java.util.List)>
<com.android.internal.telephony.ITelephonyRegistry: void notifyCarrierServiceChanged(int,java.lang.String,int)>
<com.android.internal.telephony.ITelephonyRegistry: void notifyPhysicalChannelConfigForSubscriber(int,int,java.util.List)>
<com.android.internal.telephony.ITelephonyRegistry: void notifyImsDisconnectCause(int,android.telephony.ims.ImsReasonInfo)>
<com.android.internal.telephony.ITelephonyRegistry: void notifyActiveDataSubIdChanged(int)>
<com.android.internal.telephony.ITelephonyRegistry: void notifyCellInfo(java.util.List)>
<com.android.internal.telephony.ITelephonyRegistry: void notifyPhoneCapabilityChanged(android.telephony.PhoneCapability)>
<com.android.internal.telephony.ITelephonyRegistry: void notifyCellLocationForSubscriber(int,android.telephony.CellIdentity)>
<com.android.internal.telephony.ITelephonyRegistry: void addCarrierConfigChangeListener(com.android.internal.telephony.ICarrierConfigChangeListener,java.lang.String,java.lang.String)>
<com.android.internal.telephony.ITelephonyRegistry: void notifyCallState(int,int,int,java.lang.String)>
<com.android.internal.telephony.ITelephonyRegistry: void addOnSubscriptionsChangedListener(java.lang.String,java.lang.String,com.android.internal.telephony.IOnSubscriptionsChangedListener)>
<com.android.internal.telephony.ITelephonyRegistry: void notifyCallStateForAllSubs(int,java.lang.String)>
<com.android.internal.telephony.ITelephonyRegistry: void notifyRegistrationFailed(int,int,android.telephony.CellIdentity,java.lang.String,int,int,int)>
<com.android.internal.telephony.ITelephonyRegistry: void notifyServiceStateForPhoneId(int,int,android.telephony.ServiceState)>
<com.android.internal.telephony.ITelephonyRegistry: void notifyCarrierPrivilegesChanged(int,java.util.List,int[])>
<com.android.internal.telephony.ITelephonyRegistry: void removeCarrierPrivilegesCallback(com.android.internal.telephony.ICarrierPrivilegesCallback,java.lang.String)>
<com.android.internal.telephony.ITelephonyRegistry: void notifySubscriptionInfoChanged()>
<com.android.internal.telephony.ITelephonyRegistry: void notifyDataConnectionForSubscriber(int,int,android.telephony.PreciseDataConnectionState)>
<com.android.internal.telephony.ITelephonyRegistry: void notifyPreciseCallState(int,int,int[],java.lang.String[],int[],int[])>
<com.android.internal.telephony.ITelephonyRegistry: void notifyCallForwardingChanged(boolean)>
<com.android.internal.telephony.ITelephonyRegistry: void removeOnSubscriptionsChangedListener(java.lang.String,com.android.internal.telephony.IOnSubscriptionsChangedListener)>
<com.android.internal.telephony.ITelephonyRegistry: void addCarrierPrivilegesCallback(int,com.android.internal.telephony.ICarrierPrivilegesCallback,java.lang.String,java.lang.String)>
<com.android.internal.telephony.ITelephonyRegistry: void notifyCellInfoForSubscriber(int,java.util.List)>
<com.android.internal.telephony.ITelephonyRegistry: void notifySignalStrengthForPhoneId(int,int,android.telephony.SignalStrength)>
<com.android.internal.telephony.ITelephonyRegistry: void notifyAllowedNetworkTypesChanged(int,int,int,long)>
<com.android.internal.telephony.ITelephonyRegistry: void notifyCarrierConfigChanged(int,int,int,int)>
<com.android.internal.telephony.ITelephonyRegistry: void notifyEmergencyNumberList(int,int)>
<com.android.internal.telephony.ITelephonyRegistry: void notifyMediaQualityStatusChanged(int,int,android.telephony.ims.MediaQualityStatus)>
<com.android.internal.telephony.ITelephonyRegistry: void notifyDisconnectCause(int,int,int,int)>
<com.android.internal.telephony.ITelephonyRegistry: void notifyRadioPowerStateChanged(int,int,int)>
<com.android.internal.telephony.ITelephonyRegistry: void notifyOutgoingEmergencyCall(int,int,android.telephony.emergency.EmergencyNumber)>
<com.android.internal.telephony.ITelephonyRegistry: void notifyCallForwardingChangedForSubscriber(int,boolean)>
<com.android.internal.telephony.ITelephonyRegistry: void notifyCallQualityChanged(android.telephony.CallQuality,int,int,int)>
<android.telephony.ims.aidl.IImsRegistrationCallback: void onDeregistered(android.telephony.ims.ImsReasonInfo,int,int)>
<android.telephony.ims.aidl.IImsRegistrationCallback: void onTechnologyChangeFailed(int,android.telephony.ims.ImsReasonInfo)>
<android.telephony.ims.aidl.IImsRegistrationCallback: void onRegistering(android.telephony.ims.ImsRegistrationAttributes)>
<android.telephony.ims.aidl.IImsRegistrationCallback: void onRegistered(android.telephony.ims.ImsRegistrationAttributes)>
<android.telephony.ims.aidl.IImsRegistrationCallback: void onSubscriberAssociatedUriChanged(android.net.Uri[])>
<android.telephony.ims.aidl.IImsRegistrationCallback: void onDeregisteredWithDetails(android.telephony.ims.ImsReasonInfo,int,int,android.telephony.ims.SipDetails)>
<android.service.attention.IAttentionService: void onStartProximityUpdates(android.service.attention.IProximityUpdateCallback)>
<android.service.attention.IAttentionService: void onStopProximityUpdates()>
<android.service.attention.IAttentionService: void cancelAttentionCheck(android.service.attention.IAttentionCallback)>
<android.service.attention.IAttentionService: void checkAttention(android.service.attention.IAttentionCallback)>
<android.service.rotationresolver.IRotationResolverCallback: void onFailure(int)>
<android.service.rotationresolver.IRotationResolverCallback: void onCancellable(android.os.ICancellationSignal)>
<android.service.rotationresolver.IRotationResolverCallback: void onSuccess(int)>
<com.samsung.android.desktopmode.IDesktopModeBlocker: java.lang.String onBlocked()>
<android.app.prediction.IPredictionManager: void onDestroyPredictionSession(android.app.prediction.AppPredictionSessionId)>
<android.app.prediction.IPredictionManager: void requestPredictionUpdate(android.app.prediction.AppPredictionSessionId)>
<android.app.prediction.IPredictionManager: void notifyLaunchLocationShown(android.app.prediction.AppPredictionSessionId,java.lang.String,android.content.pm.ParceledListSlice)>
<android.app.prediction.IPredictionManager: void registerPredictionUpdates(android.app.prediction.AppPredictionSessionId,android.app.prediction.IPredictionCallback)>
<android.app.prediction.IPredictionManager: void unregisterPredictionUpdates(android.app.prediction.AppPredictionSessionId,android.app.prediction.IPredictionCallback)>
<android.app.prediction.IPredictionManager: void sortAppTargets(android.app.prediction.AppPredictionSessionId,android.content.pm.ParceledListSlice,android.app.prediction.IPredictionCallback)>
<android.app.prediction.IPredictionManager: void createPredictionSession(android.app.prediction.AppPredictionContext,android.app.prediction.AppPredictionSessionId,android.os.IBinder)>
<android.app.prediction.IPredictionManager: void notifyAppTargetEvent(android.app.prediction.AppPredictionSessionId,android.app.prediction.AppTargetEvent)>
<android.hardware.usb.IDisplayPortAltModeInfoListener: void onDisplayPortAltModeInfoChanged(java.lang.String,android.hardware.usb.DisplayPortAltModeInfo)>
<android.content.pm.IPackageLoadingProgressCallback: void onPackageLoadingProgressChanged(float)>
<android.location.ILocationCallback: void onLocation(android.location.Location)>
<com.samsung.android.remoteappmode.IVirtualDisplayAliveChecker: void onVirtualDisplayCreated(int)>
<com.samsung.android.remoteappmode.IVirtualDisplayAliveChecker: void onVirtualDisplayReleased(int)>
<android.service.autofill.augmented.IAugmentedAutofillService: void onConnected(boolean,boolean)>
<android.service.autofill.augmented.IAugmentedAutofillService: void onDisconnected()>
<android.service.autofill.augmented.IAugmentedAutofillService: void onFillRequest(int,android.os.IBinder,int,android.content.ComponentName,android.view.autofill.AutofillId,android.view.autofill.AutofillValue,long,android.view.inputmethod.InlineSuggestionsRequest,android.service.autofill.augmented.IFillCallback)>
<android.service.autofill.augmented.IAugmentedAutofillService: void onDestroyAllFillWindowsRequest()>
<android.hardware.radio.sim.IRadioSimIndication: void stkEventNotify(int,java.lang.String)>
<android.hardware.radio.sim.IRadioSimIndication: void simPhonebookRecordsReceived(int,byte,android.hardware.radio.sim.PhonebookRecordInfo[])>
<android.hardware.radio.sim.IRadioSimIndication: void uiccApplicationsEnablementChanged(int,boolean)>
<android.hardware.radio.sim.IRadioSimIndication: java.lang.String getInterfaceHash()>
<android.hardware.radio.sim.IRadioSimIndication: int getInterfaceVersion()>
<android.hardware.radio.sim.IRadioSimIndication: void stkSessionEnd(int)>
<android.hardware.radio.sim.IRadioSimIndication: void simRefresh(int,android.hardware.radio.sim.SimRefreshResult)>
<android.hardware.radio.sim.IRadioSimIndication: void simPhonebookChanged(int)>
<android.hardware.radio.sim.IRadioSimIndication: void simStatusChanged(int)>
<android.hardware.radio.sim.IRadioSimIndication: void subscriptionStatusChanged(int,boolean)>
<android.hardware.radio.sim.IRadioSimIndication: void cdmaSubscriptionSourceChanged(int,int)>
<android.hardware.radio.sim.IRadioSimIndication: void stkProactiveCommand(int,java.lang.String)>
<android.hardware.radio.sim.IRadioSimIndication: void carrierInfoForImsiEncryption(int)>
<android.os.IHintManager: android.os.IHintSession createHintSession(android.os.IBinder,int[],long)>
<android.os.IHintManager: void setHintSessionThreads(android.os.IHintSession,int[])>
<android.os.IHintManager: long getHintSessionPreferredRate()>
<android.os.IHintManager: int[] getHintSessionThreadIds(android.os.IHintSession)>
<android.speech.tts.ITextToSpeechSession: void disconnect()>
<android.hardware.contexthub.IContextHubCallback: int getInterfaceVersion()>
<android.hardware.contexthub.IContextHubCallback: void handleNanoappInfo(android.hardware.contexthub.NanoappInfo[])>
<android.hardware.contexthub.IContextHubCallback: void handleContextHubAsyncEvent(int)>
<android.hardware.contexthub.IContextHubCallback: void handleContextHubMessage(android.hardware.contexthub.ContextHubMessage,java.lang.String[])>
<android.hardware.contexthub.IContextHubCallback: void handleTransactionResult(int,boolean)>
<android.hardware.contexthub.IContextHubCallback: java.lang.String getInterfaceHash()>
<android.hardware.contexthub.IContextHubCallback: void handleNanSessionRequest(android.hardware.contexthub.NanSessionRequest)>
<com.samsung.android.cover.INfcLedCoverTouchListenerCallback: void onCoverTapLeft()>
<com.samsung.android.cover.INfcLedCoverTouchListenerCallback: void onCoverTapRight()>
<com.samsung.android.cover.INfcLedCoverTouchListenerCallback: void onCoverTouchReject()>
<com.samsung.android.cover.INfcLedCoverTouchListenerCallback: void onCoverTapMid()>
<com.samsung.android.cover.INfcLedCoverTouchListenerCallback: void onCoverTouchAccept()>
<com.samsung.android.cover.INfcLedCoverTouchListenerCallback: void onSystemCoverEvent(int,android.os.Bundle)>
<android.telephony.data.IQualifiedNetworksServiceCallback: void onHandoverEnabledChanged(int)>
<android.telephony.data.IQualifiedNetworksServiceCallback: void onQualifiedNetworkTypesChanged(int,int[])>
<android.media.session.ISessionController: void skipToQueueItem(java.lang.String,long)>
<android.media.session.ISessionController: void prepareFromMediaId(java.lang.String,java.lang.String,android.os.Bundle)>
<android.media.session.ISessionController: void playFromSearch(java.lang.String,java.lang.String,android.os.Bundle)>
<android.media.session.ISessionController: android.media.MediaMetadata getMetadata()>
<android.media.session.ISessionController: long getFlags()>
<android.media.session.ISessionController: void prepareFromSearch(java.lang.String,java.lang.String,android.os.Bundle)>
<android.media.session.ISessionController: void rate(java.lang.String,android.media.Rating)>
<android.media.session.ISessionController: void unregisterCallback(android.media.session.ISessionControllerCallback)>
<android.media.session.ISessionController: void pause(java.lang.String)>
<android.media.session.ISessionController: android.app.PendingIntent getLaunchPendingIntent()>
<android.media.session.ISessionController: void next(java.lang.String)>
<android.media.session.ISessionController: void sendCustomAction(java.lang.String,java.lang.String,android.os.Bundle)>
<android.media.session.ISessionController: void setPlaybackSpeed(java.lang.String,float)>
<android.media.session.ISessionController: void sendCommand(java.lang.String,java.lang.String,android.os.Bundle,android.os.ResultReceiver)>
<android.media.session.ISessionController: void playFromMediaId(java.lang.String,java.lang.String,android.os.Bundle)>
<android.media.session.ISessionController: void seekTo(java.lang.String,long)>
<android.media.session.ISessionController: android.content.pm.ParceledListSlice getQueue()>
<android.media.session.ISessionController: void play(java.lang.String)>
<android.media.session.ISessionController: int getRatingType()>
<android.media.session.ISessionController: void registerCallback(java.lang.String,android.media.session.ISessionControllerCallback)>
<android.media.session.ISessionController: boolean sendMediaButton(java.lang.String,android.view.KeyEvent)>
<android.media.session.ISessionController: void rewind(java.lang.String)>
<android.media.session.ISessionController: java.lang.CharSequence getQueueTitle()>
<android.media.session.ISessionController: void previous(java.lang.String)>
<android.media.session.ISessionController: void stop(java.lang.String)>
<android.media.session.ISessionController: void fastForward(java.lang.String)>
<android.media.session.ISessionController: java.lang.String getTag()>
<android.media.session.ISessionController: android.os.Bundle getSessionInfo()>
<android.media.session.ISessionController: android.media.session.MediaController$PlaybackInfo getVolumeAttributes()>
<android.media.session.ISessionController: java.lang.String getPackageName()>
<android.media.session.ISessionController: android.media.session.PlaybackState getPlaybackState()>
<android.media.session.ISessionController: void setVolumeTo(java.lang.String,java.lang.String,int,int)>
<android.media.session.ISessionController: void prepareFromUri(java.lang.String,android.net.Uri,android.os.Bundle)>
<android.media.session.ISessionController: void prepare(java.lang.String)>
<android.media.session.ISessionController: void playFromUri(java.lang.String,android.net.Uri,android.os.Bundle)>
<android.media.session.ISessionController: void adjustVolume(java.lang.String,java.lang.String,int,int)>
<android.media.session.ISessionController: android.os.Bundle getExtras()>
<android.hardware.location.IContextHubClient: int sendMessageToNanoApp(android.hardware.location.NanoAppMessage)>
<android.hardware.location.IContextHubClient: int getId()>
<android.hardware.location.IContextHubClient: void close()>
<android.hardware.location.IContextHubClient: void callbackFinished()>
<android.view.ICrossWindowBlurEnabledListener: void onCrossWindowBlurEnabledChanged(boolean)>
<android.view.autofill.IAutofillWindowPresenter: void hide(android.graphics.Rect)>
<android.view.autofill.IAutofillWindowPresenter: void show(android.view.WindowManager$LayoutParams,android.graphics.Rect,boolean,int)>
<android.app.IOnProjectionStateChangedListener: void onProjectionStateChanged(int,java.util.List)>
<android.service.euicc.IGetEuiccProfileInfoListCallback: void onComplete(android.service.euicc.GetEuiccProfileInfoListResult)>
<android.view.IScrollCaptureConnection: void close()>
<android.view.IScrollCaptureConnection: android.os.ICancellationSignal endCapture()>
<android.view.IScrollCaptureConnection: android.os.ICancellationSignal startCapture(android.view.Surface,android.view.IScrollCaptureCallbacks)>
<android.view.IScrollCaptureConnection: android.os.ICancellationSignal requestImage(android.graphics.Rect)>
<com.samsung.android.knoxguard.IKnoxGuardManager: int verifyHOTPPin(java.lang.String)>
<com.samsung.android.knoxguard.IKnoxGuardManager: java.lang.String verifyRegistrationInfo(java.lang.String,java.lang.String)>
<com.samsung.android.knoxguard.IKnoxGuardManager: java.lang.String getHotpChallenge()>
<com.samsung.android.knoxguard.IKnoxGuardManager: java.lang.String verifyPolicy(java.lang.String,java.lang.String)>
<com.samsung.android.knoxguard.IKnoxGuardManager: void revokeRuntimePermission(java.lang.String,java.lang.String,android.os.UserHandle)>
<com.samsung.android.knoxguard.IKnoxGuardManager: int getKGServiceVersion()>
<com.samsung.android.knoxguard.IKnoxGuardManager: int verifyHOTPsecret(java.lang.String)>
<com.samsung.android.knoxguard.IKnoxGuardManager: java.lang.String getNonce(java.lang.String,java.lang.String)>
<com.samsung.android.knoxguard.IKnoxGuardManager: boolean isVpnExceptionRequired()>
<com.samsung.android.knoxguard.IKnoxGuardManager: void removeActiveAdmin(android.content.ComponentName)>
<com.samsung.android.knoxguard.IKnoxGuardManager: int lockScreen(java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,boolean,boolean,android.os.Bundle)>
<com.samsung.android.knoxguard.IKnoxGuardManager: boolean shouldBlockCustomRom()>
<com.samsung.android.knoxguard.IKnoxGuardManager: boolean setAdminRemovable(boolean)>
<com.samsung.android.knoxguard.IKnoxGuardManager: void setClientHealthOK()>
<com.samsung.android.knoxguard.IKnoxGuardManager: boolean isSkipSupportContainerSupported()>
<com.samsung.android.knoxguard.IKnoxGuardManager: android.os.Bundle getKGServiceInfo()>
<com.samsung.android.knoxguard.IKnoxGuardManager: void setRemoteLockToLockscreen(int,boolean,java.lang.String,java.lang.String,java.lang.String,boolean,java.lang.String,int,long,int,boolean,android.os.Bundle)>
<com.samsung.android.knoxguard.IKnoxGuardManager: boolean showInstallmentStatus()>
<com.samsung.android.knoxguard.IKnoxGuardManager: int getTAError()>
<com.samsung.android.knoxguard.IKnoxGuardManager: java.lang.String generateHotpDHRequest()>
<com.samsung.android.knoxguard.IKnoxGuardManager: int getTAState()>
<com.samsung.android.knoxguard.IKnoxGuardManager: boolean allowFirmwareRecovery(boolean)>
<com.samsung.android.knoxguard.IKnoxGuardManager: java.lang.String getTAInfo(int)>
<com.samsung.android.knoxguard.IKnoxGuardManager: void setKnoxGuardExemptRule(boolean)>
<com.samsung.android.knoxguard.IKnoxGuardManager: boolean addPackagesToClearCacheBlockList(java.util.List)>
<com.samsung.android.knoxguard.IKnoxGuardManager: java.lang.String getKGID()>
<com.samsung.android.knoxguard.IKnoxGuardManager: boolean setApplicationUninstallationDisabled(java.lang.String)>
<com.samsung.android.knoxguard.IKnoxGuardManager: boolean allowSafeMode(boolean)>
<com.samsung.android.knoxguard.IKnoxGuardManager: int setClientData(java.lang.String)>
<com.samsung.android.knoxguard.IKnoxGuardManager: void registerIntent(java.lang.String,java.util.List)>
<com.samsung.android.knoxguard.IKnoxGuardManager: void setAirplaneMode(boolean)>
<com.samsung.android.knoxguard.IKnoxGuardManager: java.lang.String getClientData()>
<com.samsung.android.knoxguard.IKnoxGuardManager: int setCheckingState()>
<com.samsung.android.knoxguard.IKnoxGuardManager: int getTAStateSetError(boolean)>
<com.samsung.android.knoxguard.IKnoxGuardManager: int resetRPMB()>
<com.samsung.android.knoxguard.IKnoxGuardManager: boolean allowOTAUpgrade(boolean)>
<com.samsung.android.knoxguard.IKnoxGuardManager: java.lang.String getStringSystemProperty(java.lang.String,java.lang.String)>
<com.samsung.android.knoxguard.IKnoxGuardManager: void setRuntimePermission(java.lang.String,java.lang.String,android.os.UserHandle)>
<com.samsung.android.knoxguard.IKnoxGuardManager: void callKGsv()>
<com.samsung.android.knoxguard.IKnoxGuardManager: int unlockScreen()>
<com.samsung.android.knoxguard.IKnoxGuardManager: java.lang.String getPBAUniqueNumber()>
<com.samsung.android.knoxguard.IKnoxGuardManager: void unRegisterIntent()>
<com.samsung.android.knoxguard.IKnoxGuardManager: int verifyCompleteToken(java.lang.String)>
<com.samsung.android.knoxguard.IKnoxGuardManager: void bindToLockScreen()>
<com.samsung.android.knoxguard.IKnoxGuardManager: void setRemoteLockToLockscreenWithSkipSupport(int,boolean,java.lang.String,java.lang.String,java.lang.String,boolean,java.lang.String,int,long,int,boolean,android.os.Bundle,boolean)>
<com.samsung.android.knoxguard.IKnoxGuardManager: int resetRPMB2(java.lang.String)>
<com.samsung.android.knoxguard.IKnoxGuardManager: java.lang.String getKGPolicy()>
<com.samsung.android.knoxguard.IKnoxGuardManager: void setActiveAdmin(android.content.ComponentName)>
<com.samsung.android.knoxguard.IKnoxGuardManager: java.lang.String verifyKgRot()>
<com.samsung.android.knoxguard.IKnoxGuardManager: int verifyHOTPDHChallenge(java.lang.String,java.lang.String,java.lang.String)>
<com.samsung.android.knoxguard.IKnoxGuardManager: boolean addPackagesToForceStopBlockList(java.util.List)>
<com.samsung.android.knoxguard.IKnoxGuardManager: java.lang.String getLockAction()>
<com.samsung.android.knoxguard.IKnoxGuardManager: int provisionCert(java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
<com.android.internal.app.IAppOpsActiveCallback: void opActiveChanged(int,int,java.lang.String,java.lang.String,boolean,int,int)>
<android.app.IGameManager: int getGameMode()>
<android.os.incremental.IIncrementalService: void disallowReadLogs(int)>
<android.os.incremental.IIncrementalService: byte[] getMetadataById(int,byte[])>
<android.os.incremental.IIncrementalService: void deleteStorage(int)>
<android.os.incremental.IIncrementalService: int createLinkedStorage(java.lang.String,int,int)>
<android.os.incremental.IIncrementalService: byte[] getMetadataByPath(int,java.lang.String)>
<android.os.incremental.IIncrementalService: boolean waitForNativeBinariesExtraction(int)>
<android.os.incremental.IIncrementalService: int isFileFullyLoaded(int,java.lang.String)>
<android.os.incremental.IIncrementalService: int makeBindMount(int,java.lang.String,java.lang.String,int)>
<android.os.incremental.IIncrementalService: int makeFile(int,java.lang.String,int,android.os.incremental.IncrementalNewFileParams,byte[])>
<android.os.incremental.IIncrementalService: boolean configureNativeBinaries(int,java.lang.String,java.lang.String,java.lang.String,boolean)>
<android.os.incremental.IIncrementalService: android.os.PersistableBundle getMetrics(int)>
<android.os.incremental.IIncrementalService: int makeLink(int,java.lang.String,int,java.lang.String)>
<android.os.incremental.IIncrementalService: int makeFileFromRange(int,java.lang.String,java.lang.String,long,long)>
<android.os.incremental.IIncrementalService: float getLoadingProgress(int)>
<android.os.incremental.IIncrementalService: int unlink(int,java.lang.String)>
<android.os.incremental.IIncrementalService: int createStorage(java.lang.String,android.content.pm.DataLoaderParamsParcel,int)>
<android.os.incremental.IIncrementalService: int makeDirectory(int,java.lang.String)>
<android.os.incremental.IIncrementalService: boolean startLoading(int,android.content.pm.DataLoaderParamsParcel,android.content.pm.IDataLoaderStatusListener,android.os.incremental.StorageHealthCheckParams,android.os.incremental.IStorageHealthListener,android.os.incremental.PerUidReadTimeouts[])>
<android.os.incremental.IIncrementalService: int openStorage(java.lang.String)>
<android.os.incremental.IIncrementalService: boolean unregisterLoadingProgressListener(int)>
<android.os.incremental.IIncrementalService: int isFullyLoaded(int)>
<android.os.incremental.IIncrementalService: void onInstallationComplete(int)>
<android.os.incremental.IIncrementalService: int makeDirectories(int,java.lang.String)>
<android.os.incremental.IIncrementalService: boolean registerLoadingProgressListener(int,android.os.incremental.IStorageLoadingProgressListener)>
<android.os.incremental.IIncrementalService: int deleteBindMount(int,java.lang.String)>
<android.hardware.camera2.extension.IPreviewImageProcessorImpl: void onImageFormatUpdate(int)>
<android.hardware.camera2.extension.IPreviewImageProcessorImpl: void onOutputSurface(android.view.Surface,int)>
<android.hardware.camera2.extension.IPreviewImageProcessorImpl: void process(android.hardware.camera2.extension.ParcelImage,android.hardware.camera2.impl.CameraMetadataNative,int,android.hardware.camera2.extension.IProcessResultImpl)>
<android.hardware.camera2.extension.IPreviewImageProcessorImpl: void onResolutionUpdate(android.hardware.camera2.extension.Size)>
<android.view.IWindowFocusObserver: void focusLost(android.os.IBinder)>
<android.view.IWindowFocusObserver: void focusGained(android.os.IBinder)>
<android.hardware.display.IDisplayManager: void setWifiDisplayParam(java.lang.String,java.lang.String)>
<android.hardware.display.IDisplayManager: int[] getUserDisabledHdrTypes()>
<android.hardware.display.IDisplayManager: android.content.pm.ParceledListSlice getBrightnessEvents(java.lang.String)>
<android.hardware.display.IDisplayManager: void setBrightness(int,float)>
<android.hardware.display.IDisplayManager: void setHdrConversionMode(android.hardware.display.HdrConversionMode)>
<android.hardware.display.IDisplayManager: void connectWifiDisplay(java.lang.String)>
<android.hardware.display.IDisplayManager: android.hardware.display.BrightnessInfo getBrightnessInfo(int)>
<android.hardware.display.IDisplayManager: void pauseWifiDisplay()>
<android.hardware.display.IDisplayManager: long getPrimaryPhysicalDisplayId()>
<android.hardware.display.IDisplayManager: android.view.Display$Mode getSystemPreferredDisplayMode(int)>
<android.hardware.display.IDisplayManager: void startWifiDisplayChannelScanAndInterval(int,int)>
<android.hardware.display.IDisplayManager: void setBrightnessConfigurationForUser(android.hardware.display.BrightnessConfiguration,int,java.lang.String)>
<android.hardware.display.IDisplayManager: android.hardware.display.SemDlnaDevice getDlnaDevice()>
<android.hardware.display.IDisplayManager: android.hardware.display.BrightnessConfiguration getBrightnessConfigurationForUser(int)>
<android.hardware.display.IDisplayManager: java.lang.String getPresentationOwner(int)>
<android.hardware.display.IDisplayManager: void fitToActiveDisplay(boolean)>
<android.hardware.display.IDisplayManager: int getDeviceMaxVolume()>
<android.hardware.display.IDisplayManager: boolean shouldAlwaysRespectAppRequestedMode()>
<android.hardware.display.IDisplayManager: com.samsung.android.hardware.display.IRefreshRateToken acquireRefreshRateMaxLimitToken(android.os.IBinder,int,java.lang.String)>
<android.hardware.display.IDisplayManager: boolean isDeviceVolumeMuted()>
<android.hardware.display.IDisplayManager: void resetBrightnessConfigurationForUser(int,java.lang.String)>
<android.hardware.display.IDisplayManager: void setTemporaryBrightnessForSlowChange(int,float,boolean)>
<android.hardware.display.IDisplayManager: void stopWifiDisplayScan()>
<android.hardware.display.IDisplayManager: boolean isWifiDisplayWithPinSupported(java.lang.String)>
<android.hardware.display.IDisplayManager: void releaseVirtualDisplay(android.hardware.display.IVirtualDisplayCallback)>
<android.hardware.display.IDisplayManager: void setDlnaDevice(android.hardware.display.SemDlnaDevice,android.os.IBinder)>
<android.hardware.display.IDisplayManager: boolean isUidPresentOnDisplay(int,int)>
<android.hardware.display.IDisplayManager: int getRefreshRateSwitchingType()>
<android.hardware.display.IDisplayManager: android.hardware.OverlayProperties getOverlaySupport()>
<android.hardware.display.IDisplayManager: android.view.DisplayInfo getDisplayInfo(int)>
<android.hardware.display.IDisplayManager: boolean areUserDisabledHdrTypesAllowed()>
<android.hardware.display.IDisplayManager: void requestColorMode(int,int)>
<android.hardware.display.IDisplayManager: void setDisplayIdToMirror(android.os.IBinder,int)>
<android.hardware.display.IDisplayManager: void startWifiDisplayScan()>
<android.hardware.display.IDisplayManager: int getScreenSharingStatus()>
<android.hardware.display.IDisplayManager: float getBrightness(int)>
<android.hardware.display.IDisplayManager: android.hardware.display.BrightnessConfiguration getBrightnessConfigurationForDisplay(java.lang.String,int)>
<android.hardware.display.IDisplayManager: void setDisplayStateLimit(android.os.IBinder,int)>
<android.hardware.display.IDisplayManager: void setVirtualDisplayState(android.hardware.display.IVirtualDisplayCallback,boolean)>
<android.hardware.display.IDisplayManager: android.hardware.display.WifiDisplayStatus getWifiDisplayStatus()>
<android.hardware.display.IDisplayManager: void startWifiDisplayChannelScan(int)>
<android.hardware.display.IDisplayManager: android.content.pm.ParceledListSlice getAmbientBrightnessStats()>
<android.hardware.display.IDisplayManager: void renameWifiDisplay(java.lang.String,java.lang.String)>
<android.hardware.display.IDisplayManager: boolean requestSetWifiDisplayParameters(java.util.List)>
<android.hardware.display.IDisplayManager: com.samsung.android.hardware.display.IRefreshRateToken acquirePassiveModeToken(android.os.IBinder,java.lang.String)>
<android.hardware.display.IDisplayManager: void setDeviceVolumeMuted(boolean)>
<android.hardware.display.IDisplayManager: com.samsung.android.hardware.display.IRefreshRateToken acquireRefreshRateMinLimitToken(android.os.IBinder,int,java.lang.String)>
<android.hardware.display.IDisplayManager: android.view.Display$Mode getUserPreferredDisplayMode(int)>
<android.hardware.display.IDisplayManager: void setAreUserDisabledHdrTypesAllowed(boolean)>
<android.hardware.display.IDisplayManager: int convertToBrightness(float)>
<android.hardware.display.IDisplayManager: int[] getDisplayIds(boolean)>
<android.hardware.display.IDisplayManager: void disconnectWifiDisplay()>
<android.hardware.display.IDisplayManager: void setDeviceVolume(int)>
<android.hardware.display.IDisplayManager: void setScreenSharingStatus(int)>
<android.hardware.display.IDisplayManager: void setTemporaryBrightness(int,float)>
<android.hardware.display.IDisplayManager: int getPreferredWideGamutColorSpaceId()>
<android.hardware.display.IDisplayManager: void overrideHdrTypes(int,int[])>
<android.hardware.display.IDisplayManager: int[] getSupportedHdrOutputTypes()>
<android.hardware.display.IDisplayManager: android.hardware.graphics.common.DisplayDecorationSupport getDisplayDecorationSupport(int)>
<android.hardware.display.IDisplayManager: android.hardware.display.BrightnessConfiguration getDefaultBrightnessConfiguration()>
<android.hardware.display.IDisplayManager: void rotateVirtualDisplay(android.hardware.display.IVirtualDisplayCallback,int)>
<android.hardware.display.IDisplayManager: boolean isFitToActiveDisplay()>
<android.hardware.display.IDisplayManager: boolean requestWifiDisplayParameter(java.lang.String,android.hardware.display.SemWifiDisplayParameter)>
<android.hardware.display.IDisplayManager: android.hardware.display.HdrConversionMode getHdrConversionMode()>
<android.hardware.display.IDisplayManager: void resumeWifiDisplay()>
<android.hardware.display.IDisplayManager: void registerCallback(android.hardware.display.IDisplayManagerCallback)>
<android.hardware.display.IDisplayManager: int getDeviceMinVolume()>
<android.hardware.display.IDisplayManager: void setVolumeKeyEvent(int)>
<android.hardware.display.IDisplayManager: void setUserPreferredDisplayMode(int,android.view.Display$Mode)>
<android.hardware.display.IDisplayManager: void connectWifiDisplayWithConfig(android.hardware.display.SemWifiDisplayConfig,android.hardware.display.IWifiDisplayConnectionCallback)>
<android.hardware.display.IDisplayManager: int createVirtualDisplay(android.hardware.display.VirtualDisplayConfig,android.hardware.display.IVirtualDisplayCallback,android.media.projection.IMediaProjection,java.lang.String)>
<android.hardware.display.IDisplayManager: void setVirtualDisplaySurface(android.hardware.display.IVirtualDisplayCallback,android.view.Surface)>
<android.hardware.display.IDisplayManager: void forgetWifiDisplay(java.lang.String)>
<android.hardware.display.IDisplayManager: android.hardware.display.BrightnessConfiguration getBackupBrightnessConfiguration(int)>
<android.hardware.display.IDisplayManager: void setShouldAlwaysRespectAppRequestedMode(boolean)>
<android.hardware.display.IDisplayManager: android.graphics.Point getStableDisplaySize()>
<android.hardware.display.IDisplayManager: com.samsung.android.hardware.display.IRefreshRateToken acquireLowRefreshRateToken(android.os.IBinder,java.lang.String)>
<android.hardware.display.IDisplayManager: boolean isMinimalPostProcessingRequested(int)>
<android.hardware.display.IDisplayManager: void resizeVirtualDisplay(android.hardware.display.IVirtualDisplayCallback,int,int,int)>
<android.hardware.display.IDisplayManager: android.hardware.display.HdrConversionMode getHdrConversionModeSetting()>
<android.hardware.display.IDisplayManager: void setBackupBrightnessConfiguration(android.hardware.display.BrightnessConfiguration,int,java.lang.String)>
<android.hardware.display.IDisplayManager: android.hardware.display.Curve getMinimumBrightnessCurve()>
<android.hardware.display.IDisplayManager: void registerCallbackWithEventMask(android.hardware.display.IDisplayManagerCallback,long)>
<android.hardware.display.IDisplayManager: void setRefreshRateSwitchingType(int)>
<android.hardware.display.IDisplayManager: void setTemporaryAutoBrightnessAdjustment(float)>
<android.hardware.display.IDisplayManager: void setUserDisabledHdrTypes(int[])>
<android.hardware.display.IDisplayManager: void setBrightnessConfigurationForDisplay(android.hardware.display.BrightnessConfiguration,java.lang.String,int,java.lang.String)>
<android.hardware.display.IDisplayManager: void setBrightnessConfigurationForUserWithStats(android.hardware.display.BrightnessConfiguration,int,java.lang.String,java.util.List,java.util.List,java.util.List)>
<com.samsung.android.wifi.ISemMobileWipsFramework: void partialScanStart(android.os.Message)>
<com.samsung.android.wifi.ISemMobileWipsFramework: java.lang.String invokeMethodStr(int)>
<com.samsung.android.wifi.ISemMobileWipsFramework: void sendHWParamToHQMwithAppId(int,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
<com.samsung.android.wifi.ISemMobileWipsFramework: java.util.List getScanResults()>
<com.samsung.android.wifi.ISemMobileWipsFramework: boolean invokeMethodBool(int)>
<android.os.IRemoteCallback: void sendResult(android.os.Bundle)>
<android.app.IProcessObserver: void onForegroundServicesChanged(int,int,int)>
<android.app.IProcessObserver: void onForegroundActivitiesChanged(int,int,boolean)>
<android.app.IProcessObserver: void onProcessDied(int,int)>
<com.samsung.android.desktopmode.IDesktopMode: void registerDesktopLauncher(com.samsung.android.desktopmode.IDesktopModeLauncher)>
<com.samsung.android.desktopmode.IDesktopMode: boolean registerDesktopModeListener(com.samsung.android.desktopmode.IDesktopModeListener,java.lang.String)>
<com.samsung.android.desktopmode.IDesktopMode: boolean isDesktopDockConnected()>
<com.samsung.android.desktopmode.IDesktopMode: boolean isDeviceConnected()>
<com.samsung.android.desktopmode.IDesktopMode: void onSecuredAppLaunched(android.os.IBinder,java.lang.String)>
<com.samsung.android.desktopmode.IDesktopMode: boolean isDesktopMode()>
<com.samsung.android.desktopmode.IDesktopMode: boolean unregisterBlocker(com.samsung.android.desktopmode.IDesktopModeBlocker)>
<com.samsung.android.desktopmode.IDesktopMode: android.os.Bundle sendMessage(android.os.Bundle)>
<com.samsung.android.desktopmode.IDesktopMode: boolean unregisterDesktopModeListener(com.samsung.android.desktopmode.IDesktopModeListener)>
<com.samsung.android.desktopmode.IDesktopMode: boolean isAllowed()>
<com.samsung.android.desktopmode.IDesktopMode: com.samsung.android.desktopmode.SemDesktopModeState getDesktopModeState()>
<com.samsung.android.desktopmode.IDesktopMode: android.os.Bundle getDesktopModeKillPolicy()>
<com.samsung.android.desktopmode.IDesktopMode: void scheduleUpdateDesktopMode(boolean)>
<com.samsung.android.desktopmode.IDesktopMode: boolean registerBlocker(com.samsung.android.desktopmode.IDesktopModeBlocker,java.lang.String)>
<android.telephony.ims.aidl.IImsTrafficSessionCallback: void onError(android.telephony.ims.feature.ConnectionFailureInfo)>
<android.telephony.ims.aidl.IImsTrafficSessionCallback: void onReady()>
<com.samsung.android.internal.telecom.ISamsungTelecomService: void acceptRingingCallWithVideoState(int,int,android.os.Bundle,java.lang.String,java.lang.String)>
<com.samsung.android.internal.telecom.ISamsungTelecomService: void silenceRinger(int,android.os.Bundle,java.lang.String,java.lang.String)>
<com.samsung.android.internal.telecom.ISamsungTelecomService: void acceptRingingCall(int,android.os.Bundle,java.lang.String,java.lang.String)>
<com.samsung.android.internal.telecom.ISamsungTelecomService: android.content.pm.ParceledListSlice getAllowedPhoneAccounts(boolean,boolean,java.lang.String,java.lang.String)>
<com.samsung.android.internal.telecom.ISamsungTelecomService: boolean isInCall(int,boolean,java.lang.String,java.lang.String)>
<com.samsung.android.internal.telecom.ISamsungTelecomService: void showInCallScreen(boolean,android.os.UserHandle,java.lang.String,java.lang.String)>
<com.samsung.android.internal.telecom.ISamsungTelecomService: boolean endCall(int,android.os.Bundle,java.lang.String,java.lang.String)>
<android.hardware.tv.tuner.IDescrambler: int getInterfaceVersion()>
<android.hardware.tv.tuner.IDescrambler: java.lang.String getInterfaceHash()>
<android.hardware.tv.tuner.IDescrambler: void removePid(android.hardware.tv.tuner.DemuxPid,android.hardware.tv.tuner.IFilter)>
<android.hardware.tv.tuner.IDescrambler: void close()>
<android.hardware.tv.tuner.IDescrambler: void addPid(android.hardware.tv.tuner.DemuxPid,android.hardware.tv.tuner.IFilter)>
<android.hardware.tv.tuner.IDescrambler: void setKeyToken(byte[])>
<android.hardware.tv.tuner.IDescrambler: void setDemuxSource(int)>
<android.media.tv.ITvInputManager: boolean isRatingBlocked(java.lang.String,int)>
<android.media.tv.ITvInputManager: void requestAd(android.os.IBinder,android.media.tv.AdRequest,int)>
<android.media.tv.ITvInputManager: boolean captureFrame(java.lang.String,android.view.Surface,android.media.tv.TvStreamConfig,int)>
<android.media.tv.ITvInputManager: void removeOverlayView(android.os.IBinder,int)>
<android.media.tv.ITvInputManager: android.os.IBinder getExtensionInterface(java.lang.String,java.lang.String,int)>
<android.media.tv.ITvInputManager: void releaseSession(android.os.IBinder,int)>
<android.media.tv.ITvInputManager: int getClientPid(java.lang.String)>
<android.media.tv.ITvInputManager: void setSurface(android.os.IBinder,android.view.Surface,int)>
<android.media.tv.ITvInputManager: android.media.tv.TvInputInfo getTvInputInfo(java.lang.String,int)>
<android.media.tv.ITvInputManager: void requestBroadcastInfo(android.os.IBinder,android.media.tv.BroadcastInfoRequest,int)>
<android.media.tv.ITvInputManager: void setTvMessageEnabled(android.os.IBinder,int,boolean,int)>
<android.media.tv.ITvInputManager: java.util.List getTvInputList(int)>
<android.media.tv.ITvInputManager: int getTvInputState(java.lang.String,int)>
<android.media.tv.ITvInputManager: boolean isSingleSessionActive(int)>
<android.media.tv.ITvInputManager: void createSession(android.media.tv.ITvInputClient,java.lang.String,android.content.AttributionSource,boolean,int,int)>
<android.media.tv.ITvInputManager: void tune(android.os.IBinder,android.net.Uri,android.os.Bundle,int)>
<android.media.tv.ITvInputManager: void timeShiftResume(android.os.IBinder,int)>
<android.media.tv.ITvInputManager: void setCaptionEnabled(android.os.IBinder,boolean,int)>
<android.media.tv.ITvInputManager: void sendAppPrivateCommand(android.os.IBinder,java.lang.String,android.os.Bundle,int)>
<android.media.tv.ITvInputManager: void timeShiftSeekTo(android.os.IBinder,long,int)>
<android.media.tv.ITvInputManager: java.util.List getDvbDeviceList()>
<android.media.tv.ITvInputManager: void requestChannelBrowsable(android.net.Uri,int)>
<android.media.tv.ITvInputManager: void addHardwareDevice(int)>
<android.media.tv.ITvInputManager: void updateTvInputInfo(android.media.tv.TvInputInfo,int)>
<android.media.tv.ITvInputManager: java.util.List getAvailableTvStreamConfigList(java.lang.String,int)>
<android.media.tv.ITvInputManager: void startRecording(android.os.IBinder,android.net.Uri,android.os.Bundle,int)>
<android.media.tv.ITvInputManager: void timeShiftSetPlaybackParams(android.os.IBinder,android.media.PlaybackParams,int)>
<android.media.tv.ITvInputManager: void unblockContent(android.os.IBinder,java.lang.String,int)>
<android.media.tv.ITvInputManager: void removeHardwareDevice(int)>
<android.media.tv.ITvInputManager: void setInteractiveAppNotificationEnabled(android.os.IBinder,boolean,int)>
<android.media.tv.ITvInputManager: void setParentalControlsEnabled(boolean,int)>
<android.media.tv.ITvInputManager: void setVolume(android.os.IBinder,float,int)>
<android.media.tv.ITvInputManager: void selectTrack(android.os.IBinder,int,java.lang.String,int)>
<android.media.tv.ITvInputManager: void unregisterCallback(android.media.tv.ITvInputManagerCallback,int)>
<android.media.tv.ITvInputManager: java.util.List getTvContentRatingSystemList(int)>
<android.media.tv.ITvInputManager: int getClientPriority(int,java.lang.String)>
<android.media.tv.ITvInputManager: android.os.ParcelFileDescriptor openDvbDevice(android.media.tv.DvbDeviceInfo,int)>
<android.media.tv.ITvInputManager: java.util.List getHardwareList()>
<android.media.tv.ITvInputManager: void releaseTvInputHardware(int,android.media.tv.ITvInputHardware,int)>
<android.media.tv.ITvInputManager: void notifyTvMessage(android.os.IBinder,int,android.os.Bundle,int)>
<android.media.tv.ITvInputManager: void dispatchSurfaceChanged(android.os.IBinder,int,int,int,int)>
<android.media.tv.ITvInputManager: boolean isParentalControlsEnabled(int)>
<android.media.tv.ITvInputManager: void removeBlockedRating(java.lang.String,int)>
<android.media.tv.ITvInputManager: void sendTvInputNotifyIntent(android.content.Intent,int)>
<android.media.tv.ITvInputManager: void timeShiftPlay(android.os.IBinder,android.net.Uri,int)>
<android.media.tv.ITvInputManager: java.util.List getCurrentTunedInfos(int)>
<android.media.tv.ITvInputManager: void selectAudioPresentation(android.os.IBinder,int,int,int)>
<android.media.tv.ITvInputManager: void setMainSession(android.os.IBinder,int)>
<android.media.tv.ITvInputManager: void timeShiftEnablePositionTracking(android.os.IBinder,boolean,int)>
<android.media.tv.ITvInputManager: void timeShiftSetMode(android.os.IBinder,int,int)>
<android.media.tv.ITvInputManager: void relayoutOverlayView(android.os.IBinder,android.graphics.Rect,int)>
<android.media.tv.ITvInputManager: void removeBroadcastInfo(android.os.IBinder,int,int)>
<android.media.tv.ITvInputManager: android.media.tv.ITvInputHardware acquireTvInputHardware(int,android.media.tv.ITvInputHardwareCallback,android.media.tv.TvInputInfo,int,java.lang.String,int)>
<android.media.tv.ITvInputManager: void createOverlayView(android.os.IBinder,android.os.IBinder,android.graphics.Rect,int)>
<android.media.tv.ITvInputManager: void addBlockedRating(java.lang.String,int)>
<android.media.tv.ITvInputManager: void resumeRecording(android.os.IBinder,android.os.Bundle,int)>
<android.media.tv.ITvInputManager: void pauseRecording(android.os.IBinder,android.os.Bundle,int)>
<android.media.tv.ITvInputManager: void stopRecording(android.os.IBinder,int)>
<android.media.tv.ITvInputManager: java.util.List getAvailableExtensionInterfaceNames(java.lang.String,int)>
<android.media.tv.ITvInputManager: void notifyAdBufferReady(android.os.IBinder,android.media.tv.AdBuffer,int)>
<android.media.tv.ITvInputManager: void registerCallback(android.media.tv.ITvInputManagerCallback,int)>
<android.media.tv.ITvInputManager: java.util.List getBlockedRatings(int)>
<android.media.tv.ITvInputManager: void timeShiftPause(android.os.IBinder,int)>
<com.android.ims.internal.IImsStreamMediaSession: void close()>
<com.android.internal.telecom.IDeviceIdleControllerAdapter: void exemptAppTemporarilyForEvent(java.lang.String,long,int,java.lang.String)>
<com.android.internal.telephony.IBooleanConsumer: void accept(boolean)>
<android.telephony.mbms.IDownloadProgressListener: void onProgressUpdated(android.telephony.mbms.DownloadRequest,android.telephony.mbms.FileInfo,int,int,int,int)>
<android.hardware.display.IWifiDisplayConnectionCallback: void onFailure(int)>
<android.hardware.display.IWifiDisplayConnectionCallback: void onSuccess(java.util.List)>
<android.app.prediction.IPredictionCallback: void onResult(android.content.pm.ParceledListSlice)>
<android.hardware.hdmi.IHdmiInputChangeListener: void onChanged(android.hardware.hdmi.HdmiDeviceInfo)>
<android.location.INetInitiatedListener: boolean sendNiResponse(int,int)>
<android.media.tv.ITvInputSessionCallback: void onTimeShiftStartPositionChanged(long)>
<android.media.tv.ITvInputSessionCallback: void onTimeShiftCurrentPositionChanged(long)>
<android.media.tv.ITvInputSessionCallback: void onContentAllowed()>
<android.media.tv.ITvInputSessionCallback: void onTvMessage(int,android.os.Bundle)>
<android.media.tv.ITvInputSessionCallback: void onTrackSelected(int,java.lang.String)>
<android.media.tv.ITvInputSessionCallback: void onAitInfoUpdated(android.media.tv.AitInfo)>
<android.media.tv.ITvInputSessionCallback: void onSignalStrength(int)>
<android.media.tv.ITvInputSessionCallback: void onAdBufferConsumed(android.media.tv.AdBuffer)>
<android.media.tv.ITvInputSessionCallback: void onVideoUnavailable(int)>
<android.media.tv.ITvInputSessionCallback: void onAvailableSpeeds(float[])>
<android.media.tv.ITvInputSessionCallback: void onTimeShiftStatusChanged(int)>
<android.media.tv.ITvInputSessionCallback: void onTimeShiftMode(int)>
<android.media.tv.ITvInputSessionCallback: void onVideoAvailable()>
<android.media.tv.ITvInputSessionCallback: void onLayoutSurface(int,int,int,int)>
<android.media.tv.ITvInputSessionCallback: void onBroadcastInfoResponse(android.media.tv.BroadcastInfoResponse)>
<android.media.tv.ITvInputSessionCallback: void onAdResponse(android.media.tv.AdResponse)>
<android.media.tv.ITvInputSessionCallback: void onSessionCreated(android.media.tv.ITvInputSession,android.os.IBinder)>
<android.media.tv.ITvInputSessionCallback: void onContentBlocked(java.lang.String)>
<android.media.tv.ITvInputSessionCallback: void onAudioPresentationSelected(int,int)>
<android.media.tv.ITvInputSessionCallback: void onError(int)>
<android.media.tv.ITvInputSessionCallback: void onAudioPresentationsChanged(java.util.List)>
<android.media.tv.ITvInputSessionCallback: void onTuned(android.net.Uri)>
<android.media.tv.ITvInputSessionCallback: void onSessionEvent(java.lang.String,android.os.Bundle)>
<android.media.tv.ITvInputSessionCallback: void onCueingMessageAvailability(boolean)>
<android.media.tv.ITvInputSessionCallback: void onRecordingStopped(android.net.Uri)>
<android.media.tv.ITvInputSessionCallback: void onChannelRetuned(android.net.Uri)>
<android.media.tv.ITvInputSessionCallback: void onTracksChanged(java.util.List)>
<com.android.internal.app.IAppOpsCallback: void opChanged(int,int,java.lang.String)>
<com.samsung.android.security.IDirEncryptService: int isStorageCardEncryptionPoliciesApplied()>
<com.samsung.android.security.IDirEncryptService: int setSdCardEncryptionPolicy(int,int,java.lang.String)>
<com.samsung.android.security.IDirEncryptService: int encryptStorage(java.lang.String)>
<com.samsung.android.security.IDirEncryptService: boolean isSdCardEncryped()>
<com.samsung.android.security.IDirEncryptService: int setPassword(java.lang.String)>
<com.samsung.android.security.IDirEncryptService: android.os.IVoldTaskListener getListener()>
<com.samsung.android.security.IDirEncryptService: void unregisterListener(com.samsung.android.security.IDirEncryptServiceListener)>
<com.samsung.android.security.IDirEncryptService: int getAdditionalSpaceRequired()>
<com.samsung.android.security.IDirEncryptService: int setStorageCardEncryptionPolicy(int,int,int)>
<com.samsung.android.security.IDirEncryptService: void unmountSDCardByAdmin()>
<com.samsung.android.security.IDirEncryptService: void setNeedToCreateKey(boolean)>
<com.samsung.android.security.IDirEncryptService: int getCurrentStatus()>
<com.samsung.android.security.IDirEncryptService: void registerListener(com.samsung.android.security.IDirEncryptServiceListener)>
<com.samsung.android.security.IDirEncryptService: int getLastError()>
<com.samsung.android.security.IDirEncryptService: void setMountSDcardToHelper(boolean)>
<android.hardware.radio.ITuner: android.graphics.Bitmap getImage(int)>
<android.hardware.radio.ITuner: void cancel()>
<android.hardware.radio.ITuner: boolean isConfigFlagSet(int)>
<android.hardware.radio.ITuner: void close()>
<android.hardware.radio.ITuner: void stopProgramListUpdates()>
<android.hardware.radio.ITuner: void setConfiguration(android.hardware.radio.RadioManager$BandConfig)>
<android.hardware.radio.ITuner: boolean isClosed()>
<android.hardware.radio.ITuner: void setMuted(boolean)>
<android.hardware.radio.ITuner: void tune(android.hardware.radio.ProgramSelector)>
<android.hardware.radio.ITuner: java.util.Map getParameters(java.util.List)>
<android.hardware.radio.ITuner: boolean isConfigFlagSupported(int)>
<android.hardware.radio.ITuner: boolean startBackgroundScan()>
<android.hardware.radio.ITuner: void step(boolean,boolean)>
<android.hardware.radio.ITuner: void setConfigFlag(int,boolean)>
<android.hardware.radio.ITuner: void startProgramListUpdates(android.hardware.radio.ProgramList$Filter)>
<android.hardware.radio.ITuner: java.util.Map setParameters(java.util.Map)>
<android.hardware.radio.ITuner: void cancelAnnouncement()>
<android.hardware.radio.ITuner: android.hardware.radio.RadioManager$BandConfig getConfiguration()>
<android.hardware.radio.ITuner: boolean isMuted()>
<android.hardware.radio.ITuner: void seek(boolean,boolean)>
<com.android.internal.telephony.IOns: void updateAvailableNetworks(java.util.List,com.android.internal.telephony.IUpdateAvailableNetworksCallback,java.lang.String)>
<com.android.internal.telephony.IOns: boolean setEnable(boolean,java.lang.String)>
<com.android.internal.telephony.IOns: void setPreferredDataSubscriptionId(int,boolean,com.android.internal.telephony.ISetOpportunisticDataCallback,java.lang.String)>
<com.android.internal.telephony.IOns: int getPreferredDataSubscriptionId(java.lang.String,java.lang.String)>
<com.android.internal.telephony.IOns: boolean isEnabled(java.lang.String)>
<android.service.settings.suggestions.ISuggestionService: void dismissSuggestion(android.service.settings.suggestions.Suggestion)>
<android.service.settings.suggestions.ISuggestionService: java.util.List getSuggestions()>
<android.service.settings.suggestions.ISuggestionService: void launchSuggestion(android.service.settings.suggestions.Suggestion)>
<android.location.IGnssNmeaListener: void onNmeaReceived(long,java.lang.String)>
<com.samsung.android.camera.iris.IIrisDaemonCallback: void onEnrollResult(long,int,int,int)>
<com.samsung.android.camera.iris.IIrisDaemonCallback: void onRemoved(long,int,int)>
<com.samsung.android.camera.iris.IIrisDaemonCallback: void onIRPropertyChanged(long,java.lang.String,java.lang.String)>
<com.samsung.android.camera.iris.IIrisDaemonCallback: void onAcquired(long,com.samsung.android.camera.iris.EyeInfo)>
<com.samsung.android.camera.iris.IIrisDaemonCallback: void onEnumerate(long,int[],int[])>
<com.samsung.android.camera.iris.IIrisDaemonCallback: void onImageProcessed(long,int,byte[],int,int)>
<com.samsung.android.camera.iris.IIrisDaemonCallback: void onError(long,int)>
<com.samsung.android.camera.iris.IIrisDaemonCallback: void onGeneralParameterChanged(long,java.lang.String,java.lang.String)>
<com.samsung.android.camera.iris.IIrisDaemonCallback: void onAuthenticated(long,int,int,byte[],byte[])>
<com.samsung.android.location.ISCurrentLocListener: void onCurrentLocation(android.location.Location)>
<android.hardware.radio.data.IRadioData: java.lang.String getInterfaceHash()>
<android.hardware.radio.data.IRadioData: void allocatePduSessionId(int)>
<android.hardware.radio.data.IRadioData: void getSlicingConfig(int)>
<android.hardware.radio.data.IRadioData: void setDataThrottling(int,byte,long)>
<android.hardware.radio.data.IRadioData: void getDataCallList(int)>
<android.hardware.radio.data.IRadioData: void cancelHandover(int,int)>
<android.hardware.radio.data.IRadioData: void setResponseFunctions(android.hardware.radio.data.IRadioDataResponse,android.hardware.radio.data.IRadioDataIndication)>
<android.hardware.radio.data.IRadioData: void setDataAllowed(int,boolean)>
<android.hardware.radio.data.IRadioData: void setInitialAttachApn(int,android.hardware.radio.data.DataProfileInfo)>
<android.hardware.radio.data.IRadioData: void setupDataCall(int,int,android.hardware.radio.data.DataProfileInfo,boolean,int,android.hardware.radio.data.LinkAddress[],java.lang.String[],int,android.hardware.radio.data.SliceInfo,boolean)>
<android.hardware.radio.data.IRadioData: void stopKeepalive(int,int)>
<android.hardware.radio.data.IRadioData: void startHandover(int,int)>
<android.hardware.radio.data.IRadioData: void responseAcknowledgement()>
<android.hardware.radio.data.IRadioData: void deactivateDataCall(int,int,int)>
<android.hardware.radio.data.IRadioData: void startKeepalive(int,android.hardware.radio.data.KeepaliveRequest)>
<android.hardware.radio.data.IRadioData: void releasePduSessionId(int,int)>
<android.hardware.radio.data.IRadioData: void setDataProfile(int,android.hardware.radio.data.DataProfileInfo[])>
<android.hardware.radio.data.IRadioData: int getInterfaceVersion()>
<com.samsung.android.wifi.ISemSharedPasswordCallback: void onAvailable(boolean)>
<com.samsung.android.wifi.ISemSharedPasswordCallback: void onAccepted(java.lang.String,java.lang.String)>
<com.samsung.android.wifi.ISemSharedPasswordCallback: void onRejected(java.lang.String)>
<android.service.gatekeeper.IGateKeeperService: void reportDeviceSetupComplete()>
<android.service.gatekeeper.IGateKeeperService: android.service.gatekeeper.GateKeeperResponse verify(int,byte[],byte[])>
<android.service.gatekeeper.IGateKeeperService: android.service.gatekeeper.GateKeeperResponse verifyChallenge(int,long,byte[],byte[])>
<android.service.gatekeeper.IGateKeeperService: android.service.gatekeeper.GateKeeperResponse enroll(int,byte[],byte[],byte[])>
<android.service.gatekeeper.IGateKeeperService: long getSecureUserId(int)>
<android.service.gatekeeper.IGateKeeperService: void clearSecureUserId(int)>
<com.android.internal.telephony.IDomainSelectionServiceController: void selectDomain(android.telephony.DomainSelectionService$SelectionAttributes,com.android.internal.telephony.ITransportSelectorCallback)>
<com.android.internal.telephony.IDomainSelectionServiceController: void updateBarringInfo(int,int,android.telephony.BarringInfo)>
<com.android.internal.telephony.IDomainSelectionServiceController: void updateServiceState(int,int,android.telephony.ServiceState)>
<android.nfc.INfcCardEmulation: android.nfc.cardemulation.AidGroup getAidGroupForService(int,android.content.ComponentName,java.lang.String)>
<android.nfc.INfcCardEmulation: int unregisterOtherService(int,android.content.ComponentName)>
<android.nfc.INfcCardEmulation: boolean registerAidGroupForService(int,android.content.ComponentName,android.nfc.cardemulation.AidGroup)>
<android.nfc.INfcCardEmulation: int registerService(int,android.content.ComponentName,java.lang.String,int)>
<android.nfc.INfcCardEmulation: boolean disableAutoRouting()>
<android.nfc.INfcCardEmulation: android.nfc.cardemulation.ApduServiceInfo getPreferredPaymentService(int)>
<android.nfc.INfcCardEmulation: android.content.ComponentName getPaymentPriority(int)>
<android.nfc.INfcCardEmulation: boolean setOffHostForService(int,android.content.ComponentName,java.lang.String)>
<android.nfc.INfcCardEmulation: int getAidSizeForServiceInPercent(int,android.content.ComponentName)>
<android.nfc.INfcCardEmulation: int getUsedAidTableSizeInPercent(int,java.lang.String)>
<android.nfc.INfcCardEmulation: boolean unsetPreferredService()>
<android.nfc.INfcCardEmulation: boolean isDefaultPaymentRegistered()>
<android.nfc.INfcCardEmulation: boolean setDefaultServiceForCategory(int,android.content.ComponentName,java.lang.String)>
<android.nfc.INfcCardEmulation: android.nfc.cardemulation.ApduServiceInfo getPaymentDefaultServiceInfo(int)>
<android.nfc.INfcCardEmulation: java.util.List getServices(int,java.lang.String)>
<android.nfc.INfcCardEmulation: boolean isDefaultServiceForCategory(int,android.content.ComponentName,java.lang.String)>
<android.nfc.INfcCardEmulation: boolean supportsAidPrefixRegistration()>
<android.nfc.INfcCardEmulation: boolean supportsAutoRouting()>
<android.nfc.INfcCardEmulation: boolean isRegisteredService(int,android.content.ComponentName,java.lang.String)>
<android.nfc.INfcCardEmulation: boolean setDefaultForNextTap(int,android.content.ComponentName)>
<android.nfc.INfcCardEmulation: boolean removeAidGroupForService(int,android.content.ComponentName,java.lang.String)>
<android.nfc.INfcCardEmulation: boolean setOtherService(int,android.content.ComponentName)>
<android.nfc.INfcCardEmulation: boolean unsetOtherService(int,android.content.ComponentName)>
<android.nfc.INfcCardEmulation: boolean enableAutoRouting()>
<android.nfc.INfcCardEmulation: void initializePaymentDefault(int,int)>
<android.nfc.INfcCardEmulation: boolean isDefaultServiceForAid(int,android.content.ComponentName,java.lang.String)>
<android.nfc.INfcCardEmulation: boolean unsetOffHostForService(int,android.content.ComponentName)>
<android.nfc.INfcCardEmulation: boolean setLockPassword(java.lang.String)>
<android.nfc.INfcCardEmulation: boolean setPreferredService(android.content.ComponentName)>
<android.net.IPacProxyInstalledListener: void onPacProxyInstalled(android.net.Network,android.net.ProxyInfo)>
<android.os.IUpdateEngine: boolean bind(android.os.IUpdateEngineCallback)>
<android.os.IUpdateEngine: long allocateSpaceForPayload(java.lang.String,java.lang.String[])>
<android.os.IUpdateEngine: void setShouldSwitchSlotOnReboot(java.lang.String)>
<android.os.IUpdateEngine: void applyPayloadFd(android.os.ParcelFileDescriptor,long,long,java.lang.String[])>
<android.os.IUpdateEngine: void applyPayload(java.lang.String,long,long,java.lang.String[])>
<android.os.IUpdateEngine: boolean unbind(android.os.IUpdateEngineCallback)>
<android.os.IUpdateEngine: void cancel()>
<android.os.IUpdateEngine: void suspend()>
<android.os.IUpdateEngine: void resume()>
<android.os.IUpdateEngine: boolean verifyPayloadApplicable(java.lang.String)>
<android.os.IUpdateEngine: void cleanupSuccessfulUpdate(android.os.IUpdateEngineCallback)>
<android.os.IUpdateEngine: void resetStatus()>
<android.os.IUpdateEngine: void resetShouldSwitchSlotOnReboot()>
<com.android.internal.telecom.IPhoneAccountSuggestionService: void onAccountSuggestionRequest(com.android.internal.telecom.IPhoneAccountSuggestionCallback,java.lang.String)>
<android.view.IWindowManager: android.graphics.Bitmap snapshotTaskForRecents(int)>
<android.view.IWindowManager: int getRemoveContentMode(int)>
<android.view.IWindowManager: void setInTouchModeOnAllDisplays(boolean)>
<android.view.IWindowManager: void setDisplayHashThrottlingEnabled(boolean)>
<android.view.IWindowManager: void setRecentsAppBehindSystemBars(boolean)>
<android.view.IWindowManager: android.graphics.Region getCurrentImeTouchRegion()>
<android.view.IWindowManager: com.samsung.android.view.SemWindowManager$KeyCustomizationInfo getKeyCustomizationInfo(int,int,int)>
<android.view.IWindowManager: boolean isSafeModeEnabled()>
<android.view.IWindowManager: void removeKeyCustomizationInfoByPackage(java.lang.String,int,int)>
<android.view.IWindowManager: int getSupportsFlexPanel(int,java.lang.String)>
<android.view.IWindowManager: void setDragSurfaceToOverlay(boolean)>
<android.view.IWindowManager: android.view.SurfaceControl addShellRoot(int,android.view.IWindow,int)>
<android.view.IWindowManager: boolean isViewServerRunning()>
<android.view.IWindowManager: android.view.SurfaceControl mirrorWallpaperSurface(int)>
<android.view.IWindowManager: void startWindowTrace()>
<android.view.IWindowManager: void reenableKeyguard(android.os.IBinder,int)>
<android.view.IWindowManager: int getBaseDisplayDensity(int)>
<android.view.IWindowManager: boolean registerWallpaperVisibilityListener(android.view.IWallpaperVisibilityListener,int)>
<android.view.IWindowManager: void addKeyguardLockedStateListener(com.android.internal.policy.IKeyguardLockedStateListener)>
<android.view.IWindowManager: void setTableModeEnabled(boolean)>
<android.view.IWindowManager: boolean isLayerTracing()>
<android.view.IWindowManager: void exitKeyguardSecurely(android.view.IOnKeyguardExitResult)>
<android.view.IWindowManager: void removeKeyCustomizationInfo(int,int,int)>
<android.view.IWindowManager: android.graphics.Bitmap screenshotWallpaper()>
<android.view.IWindowManager: int getImeDisplayId()>
<android.view.IWindowManager: void overridePendingAppTransitionMultiThumbFuture(android.view.IAppTransitionAnimationSpecsFuture,android.os.IRemoteCallback,boolean,int)>
<android.view.IWindowManager: int[] registerDisplayWindowListener(android.view.IDisplayWindowListener)>
<android.view.IWindowManager: boolean isGlobalKey(int)>
<android.view.IWindowManager: boolean isKeyguardSecure(int)>
<android.view.IWindowManager: boolean mirrorDisplay(int,android.view.SurfaceControl)>
<android.view.IWindowManager: void removeRotationWatcher(android.view.IRotationWatcher)>
<android.view.IWindowManager: boolean isTaskSnapshotSupported()>
<android.view.IWindowManager: void dispatchSmartClipRemoteRequest(int,int,com.samsung.android.content.smartclip.SmartClipRemoteRequestInfo,android.os.IBinder)>
<android.view.IWindowManager: void setLayerTracing(boolean)>
<android.view.IWindowManager: int registerProposedRotationListener(android.os.IBinder,android.view.IRotationWatcher)>
<android.view.IWindowManager: android.view.IWindowSession openSession(android.view.IWindowSessionCallback)>
<android.view.IWindowManager: void startSurfaceAnimation(android.os.IBinder,java.lang.String)>
<android.view.IWindowManager: boolean isKeyguardShowingAndNotOccluded()>
<android.view.IWindowManager: boolean isDisplayRotationFrozen(int)>
<android.view.IWindowManager: int getTopFocusedDisplayId()>
<android.view.IWindowManager: void freezeDisplayRotation(int,int)>
<android.view.IWindowManager: void lockNow(android.os.Bundle)>
<android.view.IWindowManager: boolean shouldShowSystemDecors(int)>
<android.view.IWindowManager: void dismissKeyguard(com.android.internal.policy.IKeyguardDismissCallback,java.lang.CharSequence)>
<android.view.IWindowManager: java.util.List notifyScreenshotListeners(int)>
<android.view.IWindowManager: void saveWindowTraceToFile()>
<android.view.IWindowManager: void requestScrollCapture(int,android.os.IBinder,int,android.view.IScrollCaptureResponseListener)>
<android.view.IWindowManager: android.content.res.Configuration attachWindowContextToDisplayArea(android.os.IBinder,int,int,android.os.Bundle)>
<android.view.IWindowManager: boolean destroyInputConsumer(java.lang.String,int)>
<android.view.IWindowManager: boolean isLetterboxBackgroundMultiColored()>
<android.view.IWindowManager: void setForcedDisplaySizeDensityWithInfo(com.samsung.android.view.MultiResolutionChangeRequestInfo)>
<android.view.IWindowManager: void unregisterSystemGestureExclusionListener(android.view.ISystemGestureExclusionListener,int)>
<android.view.IWindowManager: void showGlobalActions()>
<android.view.IWindowManager: float getAnimationScale(int)>
<android.view.IWindowManager: java.util.List getBackupKeyCustomizationInfoList()>
<android.view.IWindowManager: boolean isInTouchMode(int)>
<android.view.IWindowManager: void setForcedDisplaySizeDensity(int,int,int,int,boolean,int)>
<android.view.IWindowManager: void startFreezingScreen(int,int)>
<android.view.IWindowManager: int getInitialDisplayDensity(int)>
<android.view.IWindowManager: boolean startViewServer(int)>
<android.view.IWindowManager: void moveDisplayToTop(int,java.lang.String)>
<android.view.IWindowManager: void setEventDispatching(boolean)>
<android.view.IWindowManager: void setDeadzoneHole(android.os.Bundle)>
<android.view.IWindowManager: boolean hasNavigationBar(int)>
<android.view.IWindowManager: void setShouldShowWithInsecureKeyguard(int,boolean)>
<android.view.IWindowManager: void stopTransitionTrace()>
<android.view.IWindowManager: java.util.List getVisibleWindowInfoList()>
<android.view.IWindowManager: int getRotationLockOrientation(int)>
<android.view.IWindowManager: void hideTransientBars(int)>
<android.view.IWindowManager: boolean isMetaKeyEventRequested(android.content.ComponentName)>
<android.view.IWindowManager: void startLockscreenFingerprintAuth()>
<android.view.IWindowManager: void unregisterDisplayWindowListener(android.view.IDisplayWindowListener)>
<android.view.IWindowManager: void setSwitchingUser(boolean)>
<android.view.IWindowManager: void setDisplayImePolicy(int,int)>
<android.view.IWindowManager: void setForcedDisplayDensityForUser(int,int,int)>
<android.view.IWindowManager: void stopWindowTrace()>
<android.view.IWindowManager: void updateStaticPrivacyIndicatorBounds(int,android.graphics.Rect[])>
<android.view.IWindowManager: void setPendingIntentAfterUnlock(android.app.PendingIntent,android.content.Intent)>
<android.view.IWindowManager: void refreshScreenCaptureDisabled()>
<android.view.IWindowManager: void setTaskTransitionSpec(android.view.TaskTransitionSpec)>
<android.view.IWindowManager: void endProlongedAnimations()>
<android.view.IWindowManager: boolean isKeyguardLocked()>
<android.view.IWindowManager: boolean isWindowToken(android.os.IBinder)>
<android.view.IWindowManager: void requestMetaKeyEvent(android.content.ComponentName,boolean)>
<android.view.IWindowManager: boolean isTableMode()>
<android.view.IWindowManager: void setRecentsVisibility(boolean)>
<android.view.IWindowManager: void setLayerTracingFlags(int)>
<android.view.IWindowManager: int getDockedStackSide()>
<android.view.IWindowManager: void thawRotation()>
<android.view.IWindowManager: void registerTaskFpsCallback(int,android.window.ITaskFpsCallback)>
<android.view.IWindowManager: boolean requestAssistScreenshot(android.app.IAssistDataReceiver)>
<android.view.IWindowManager: void setStrictModeVisualIndicatorPreference(java.lang.String)>
<android.view.IWindowManager: void showStrictModeViolation(boolean)>
<android.view.IWindowManager: int getPreferredOptionsPanelGravity(int)>
<android.view.IWindowManager: void getStableInsets(int,android.graphics.Rect)>
<android.view.IWindowManager: void dispatchSPenGestureEvent(int,int,android.view.InputEvent[],android.os.IBinder)>
<android.view.IWindowManager: void disableKeyguard(android.os.IBinder,java.lang.String,int)>
<android.view.IWindowManager: void changeDisplayScale(android.view.MagnificationSpec,boolean,android.view.IInputFilter)>
<android.view.IWindowManager: void closeSystemDialogs(java.lang.String)>
<android.view.IWindowManager: void setDisplayChangeWindowController(android.view.IDisplayChangeWindowController)>
<android.view.IWindowManager: void registerSystemKeyEvent(int,android.content.ComponentName,int)>
<android.view.IWindowManager: int getDefaultDisplayRotation()>
<android.view.IWindowManager: boolean isWindowTraceEnabled()>
<android.view.IWindowManager: void syncInputTransactions(boolean)>
<android.view.IWindowManager: void setAnimationScale(int,float)>
<android.view.IWindowManager: com.samsung.android.view.ScreenshotResult takeScreenshotToTargetWindow(int,int,boolean,android.graphics.Rect,int,int,boolean,boolean)>
<android.view.IWindowManager: void registerShortcutKey(long,com.android.internal.policy.IShortcutService)>
<android.view.IWindowManager: void setInTouchMode(boolean,int)>
<android.view.IWindowManager: void requestAppKeyboardShortcuts(com.android.internal.os.IResultReceiver,int)>
<android.view.IWindowManager: void clearTaskTransitionSpec()>
<android.view.IWindowManager: void attachWindowContextToWindowToken(android.os.IBinder,android.os.IBinder)>
<android.view.IWindowManager: boolean useBLAST()>
<android.view.IWindowManager: void clearKeyCustomizationInfoByAction(int,int,int)>
<android.view.IWindowManager: void setSupportsFlexPanel(int,java.lang.String,boolean)>
<android.view.IWindowManager: void setDisplayColorToSystemProperties(int)>
<android.view.IWindowManager: java.lang.String[] getSupportedDisplayHashAlgorithms()>
<android.view.IWindowManager: void setFixedToUserRotation(int,int)>
<android.view.IWindowManager: void putKeyCustomizationInfo(com.samsung.android.view.SemWindowManager$KeyCustomizationInfo)>
<android.view.IWindowManager: void createInputConsumer(android.os.IBinder,java.lang.String,int,android.view.InputChannel)>
<android.view.IWindowManager: void unregisterOneHandOpWatcher(com.samsung.android.onehandop.IOneHandOpWatcher)>
<android.view.IWindowManager: void registerSystemGestureExclusionListener(android.view.ISystemGestureExclusionListener,int)>
<android.view.IWindowManager: void setMaxAspectRatioPolicy(java.lang.String,int,boolean,int)>
<android.view.IWindowManager: void unregisterTaskFpsCallback(android.window.ITaskFpsCallback)>
<android.view.IWindowManager: void captureDisplay(int,android.window.ScreenCapture$CaptureArgs,android.window.ScreenCapture$ScreenCaptureListener)>
<android.view.IWindowManager: boolean isTransitionTraceEnabled()>
<android.view.IWindowManager: void unregisterSystemKeyEvent(int,android.content.ComponentName)>
<android.view.IWindowManager: void setNavBarVirtualKeyHapticFeedbackEnabled(boolean)>
<android.view.IWindowManager: void stopFreezingScreen()>
<android.view.IWindowManager: void setAnimationScales(float[])>
<android.view.IWindowManager: void clearForcedDisplayDensityForUser(int,int)>
<android.view.IWindowManager: com.samsung.android.view.SemWindowManager$KeyCustomizationInfo getKeyCustomizationInfoByPackage(java.lang.String,int,int)>
<android.view.IWindowManager: void registerPinnedTaskListener(int,android.view.IPinnedTaskListener)>
<android.view.IWindowManager: void setShouldShowSystemDecors(int,boolean)>
<android.view.IWindowManager: void unregisterDisplayFoldListener(android.view.IDisplayFoldListener)>
<android.view.IWindowManager: boolean registerCrossWindowBlurEnabledListener(android.view.ICrossWindowBlurEnabledListener)>
<android.view.IWindowManager: boolean clearWindowContentFrameStats(android.os.IBinder)>
<android.view.IWindowManager: int getAppContinuityMode(int,java.lang.String,android.content.pm.ActivityInfo)>
<android.view.IWindowManager: android.view.WindowContentFrameStats getWindowContentFrameStats(android.os.IBinder)>
<android.view.IWindowManager: void setIgnoreOrientationRequest(int,boolean)>
<android.view.IWindowManager: boolean requestSystemKeyEvent(int,android.content.ComponentName,boolean)>
<android.view.IWindowManager: void unregisterWallpaperVisibilityListener(android.view.IWallpaperVisibilityListener,int)>
<android.view.IWindowManager: float[] getAnimationScales()>
<android.view.IWindowManager: int getMaxAspectRatioPolicyByComponent(android.content.ComponentName,int)>
<android.view.IWindowManager: void startTransitionTrace()>
<android.view.IWindowManager: void clearForcedDisplaySizeDensity(int)>
<android.view.IWindowManager: boolean getWindowInsets(int,android.os.IBinder,android.view.InsetsState)>
<android.view.IWindowManager: void setRemoveContentMode(int,int)>
<android.view.IWindowManager: void unregisterCrossWindowBlurEnabledListener(android.view.ICrossWindowBlurEnabledListener)>
<android.view.IWindowManager: void freezeRotation(int)>
<android.view.IWindowManager: boolean stopViewServer()>
<android.view.IWindowManager: void setForcedDisplayScalingMode(int,int)>
<android.view.IWindowManager: com.samsung.android.view.SemWindowManager$KeyCustomizationInfo getLastKeyCustomizationInfo(int,int)>
<android.view.IWindowManager: void removeKeyguardLockedStateListener(com.android.internal.policy.IKeyguardLockedStateListener)>
<android.view.IWindowManager: void holdLock(android.os.IBinder,int)>
<android.view.IWindowManager: void clearKeyCustomizationInfoByKeyCode(int,int)>
<android.view.IWindowManager: int watchRotation(android.view.IRotationWatcher,int)>
<android.view.IWindowManager: void clearForcedDisplaySize(int)>
<android.view.IWindowManager: float getCurrentAnimatorScale()>
<android.view.IWindowManager: int getDisplayIdByUniqueId(java.lang.String)>
<android.view.IWindowManager: boolean addToSurfaceSyncGroup(android.os.IBinder,boolean,android.window.ISurfaceSyncGroupCompletedListener,android.window.AddToSurfaceSyncGroupResult)>
<android.view.IWindowManager: boolean isSystemKeyEventRequested(int,android.content.ComponentName)>
<android.view.IWindowManager: void addWindowToken(android.os.IBinder,int,int,android.os.Bundle)>
<android.view.IWindowManager: void setTaskSnapshotEnabled(boolean)>
<android.view.IWindowManager: void removeWindowToken(android.os.IBinder,int)>
<android.view.IWindowManager: android.view.displayhash.VerifiedDisplayHash verifyDisplayHash(android.view.displayhash.DisplayHash)>
<android.view.IWindowManager: int getMaxAspectRatioPolicy(java.lang.String,int)>
<android.view.IWindowManager: boolean isFolded()>
<android.view.IWindowManager: void updateDisplayWindowRequestedVisibleTypes(int,int)>
<android.view.IWindowManager: void getBaseDisplaySize(int,android.graphics.Point)>
<android.view.IWindowManager: void setWindowingMode(int,int)>
<android.view.IWindowManager: void restoreKeyCustomizationInfo(java.util.List)>
<android.view.IWindowManager: int getFullScreenAppsSupportMode()>
<android.view.IWindowManager: void getInitialDisplaySize(int,android.graphics.Point)>
<android.view.IWindowManager: boolean shouldShowWithInsecureKeyguard(int)>
<android.view.IWindowManager: boolean isRotationFrozen()>
<android.view.IWindowManager: void getUserDisplaySize(android.graphics.Point)>
<android.view.IWindowManager: void setShellRootAccessibilityWindow(int,int,android.view.IWindow)>
<android.view.IWindowManager: void detachWindowContextFromWindowContainer(android.os.IBinder)>
<android.view.IWindowManager: int getUserDisplayDensity()>
<android.view.IWindowManager: void setActiveTransactionTracing(boolean)>
<android.view.IWindowManager: void setForcedDisplaySize(int,int,int)>
<android.view.IWindowManager: android.content.res.Configuration attachToDisplayContent(android.os.IBinder,int)>
<android.view.IWindowManager: java.util.List getPossibleDisplayInfo(int)>
<android.view.IWindowManager: int getLetterboxBackgroundColorInArgb()>
<android.view.IWindowManager: void thawDisplayRotation(int)>
<android.view.IWindowManager: void setDisplayWindowInsetsController(int,android.view.IDisplayWindowInsetsController)>
<android.view.IWindowManager: void setAppContinuityMode(int,java.lang.String,boolean)>
<android.view.IWindowManager: int getWindowingMode(int)>
<android.view.IWindowManager: void markSurfaceSyncGroupReady(android.os.IBinder)>
<android.view.IWindowManager: int getDisplayImePolicy(int)>
<android.view.IWindowManager: void overridePendingAppTransitionRemote(android.view.RemoteAnimationAdapter,int)>
<android.view.IWindowManager: void closeSystemDialogsInDisplay(java.lang.String,int)>
<android.view.IWindowManager: void registerOneHandOpWatcher(com.samsung.android.onehandop.IOneHandOpWatcher)>
<android.view.IWindowManager: void registerDisplayFoldListener(android.view.IDisplayFoldListener)>
<android.content.pm.IBackgroundInstallControlService: android.content.pm.ParceledListSlice getBackgroundInstalledPackages(long,int)>
<com.sec.android.smartfpsadjuster.IIntelligentDynamicFpsService: int cameraPolicyChange(int)>
<com.sec.android.smartfpsadjuster.IIntelligentDynamicFpsService: void cameraPolicyStart()>
<com.sec.android.smartfpsadjuster.IIntelligentDynamicFpsService: void cameraPolicyStop()>
<android.content.pm.IDataLoader: void prepareImage(int,android.content.pm.InstallationFileParcel[],java.lang.String[])>
<android.content.pm.IDataLoader: void destroy(int)>
<android.content.pm.IDataLoader: void create(int,android.content.pm.DataLoaderParamsParcel,android.content.pm.FileSystemControlParcel,android.content.pm.IDataLoaderStatusListener)>
<android.content.pm.IDataLoader: void stop(int)>
<android.content.pm.IDataLoader: void start(int)>
<android.window.ITransactionReadyCallback: void onTransactionReady(android.view.SurfaceControl$Transaction)>
<android.media.session.IOnMediaKeyListener: void onMediaKey(android.view.KeyEvent,android.os.ResultReceiver)>
<android.service.euicc.IGetEidCallback: void onSuccess(java.lang.String)>
<android.app.IWallpaperManager: void semSetDLSWallpaperColors(android.app.SemWallpaperColors,int)>
<android.app.IWallpaperManager: void setWallpaperComponent(android.content.ComponentName)>
<android.app.IWallpaperManager: java.lang.String semGetUri(int,java.lang.String)>
<android.app.IWallpaperManager: void addOnLocalColorsChangedListener(android.app.ILocalWallpaperColorConsumer,java.util.List,int,int,int)>
<android.app.IWallpaperManager: java.lang.String getLegacyDeviceColor()>
<android.app.IWallpaperManager: boolean isMultiCropEnabled()>
<android.app.IWallpaperManager: void setMotionWallpaper(java.lang.String,java.lang.String,int,boolean)>
<android.app.IWallpaperManager: android.os.ParcelFileDescriptor setWallpaper(java.lang.String,java.lang.String,android.graphics.Rect,boolean,android.os.Bundle,int,android.app.IWallpaperManagerCallback,int,int,boolean,android.os.Bundle)>
<android.app.IWallpaperManager: void notifyGoingToSleep(int,int,android.os.Bundle)>
<android.app.IWallpaperManager: android.graphics.Rect semGetSmartCropRect(int)>
<android.app.IWallpaperManager: boolean isDefaultWallpaperState(int)>
<android.app.IWallpaperManager: boolean isStaticWallpaper(int)>
<android.app.IWallpaperManager: java.lang.String getName()>
<android.app.IWallpaperManager: void semSetSmartCropRect(int,android.graphics.Rect,android.graphics.Rect)>
<android.app.IWallpaperManager: boolean isWallpaperBackupAllowed(int,int)>
<android.app.IWallpaperManager: int getHighlightFilterState(int)>
<android.app.IWallpaperManager: int getHeightHint(int)>
<android.app.IWallpaperManager: boolean setCoverWallpaperCallback(android.app.IWallpaperManagerCallback)>
<android.app.IWallpaperManager: int getWidthHint(int)>
<android.app.IWallpaperManager: void setDimensionHints(int,int,java.lang.String,int)>
<android.app.IWallpaperManager: java.lang.String getVideoFilePath(int)>
<android.app.IWallpaperManager: int getLockWallpaperType()>
<android.app.IWallpaperManager: boolean isDesktopStandAloneMode()>
<android.app.IWallpaperManager: boolean isSystemAndLockPaired(int)>
<android.app.IWallpaperManager: void clearWallpaper(java.lang.String,int,int)>
<android.app.IWallpaperManager: boolean hasNamedWallpaper(java.lang.String)>
<android.app.IWallpaperManager: void removeOnLocalColorsChangedListener(android.app.ILocalWallpaperColorConsumer,java.util.List,int,int,int)>
<android.app.IWallpaperManager: java.lang.String getLastCallingPackage(int)>
<android.app.IWallpaperManager: android.os.ParcelFileDescriptor getWallpaperThumbnailFileDescriptor(int,int,int,int)>
<android.app.IWallpaperManager: void forceRebindWallpaper(int,int)>
<android.app.IWallpaperManager: android.app.SemWallpaperColors semGetPrimaryWallpaperColors(int)>
<android.app.IWallpaperManager: android.content.ComponentName semGetWallpaperComponent(int,int)>
<android.app.IWallpaperManager: java.lang.String getMotionWallpaperPkgName(int)>
<android.app.IWallpaperManager: int getWallpaperIdForUser(int,int)>
<android.app.IWallpaperManager: android.os.ParcelFileDescriptor getLockWallpaper(android.app.IWallpaperManagerCallback,android.os.Bundle,int,int)>
<android.app.IWallpaperManager: int getLidState()>
<android.app.IWallpaperManager: android.graphics.Rect semGetWallpaperCropHint(int)>
<android.app.IWallpaperManager: void setWallpaperComponentChecked(android.content.ComponentName,java.lang.String,int,int,android.os.Bundle)>
<android.app.IWallpaperManager: boolean hasVideoWallpaper()>
<android.app.IWallpaperManager: void semSendWallpaperCommand(int,java.lang.String,android.os.Bundle)>
<android.app.IWallpaperManager: java.lang.String getVideoFileName(int)>
<android.app.IWallpaperManager: android.os.Bundle getWallpaperComponentExtras(int,int)>
<android.app.IWallpaperManager: int makeSnapshot(int,int)>
<android.app.IWallpaperManager: void setKWPTypeLiveWallpaper(int)>
<android.app.IWallpaperManager: boolean restoreSnapshot(int,java.lang.String)>
<android.app.IWallpaperManager: void copyFileToWallpaperFile(int,java.lang.String)>
<android.app.IWallpaperManager: int getDesktopMode()>
<android.app.IWallpaperManager: java.lang.String getVideoPackage(int)>
<android.app.IWallpaperManager: void notifyWakingUp(int,int,android.os.Bundle)>
<android.app.IWallpaperManager: boolean isWallpaperSupported(java.lang.String)>
<android.app.IWallpaperManager: android.app.SemWallpaperColors semGetWallpaperColors(int)>
<android.app.IWallpaperManager: boolean setSnapshotSource(int,java.lang.String)>
<android.app.IWallpaperManager: android.os.ParcelFileDescriptor getWallpaperInfoFile(int)>
<android.app.IWallpaperManager: boolean isWallpaperDataExists(int,int)>
<android.app.IWallpaperManager: boolean isDesktopModeEnabled(int)>
<android.app.IWallpaperManager: void semRequestWallpaperColorsAnalysis(int,java.lang.String)>
<android.app.IWallpaperManager: void registerWallpaperColorsCallback(android.app.IWallpaperManagerCallback,int,int)>
<android.app.IWallpaperManager: void notifyPid(int,int,java.lang.String,boolean)>
<android.app.IWallpaperManager: void removeSnapshotByKey(int)>
<android.app.IWallpaperManager: void setInAmbientMode(boolean,long)>
<android.app.IWallpaperManager: float getWallpaperDimAmount()>
<android.app.IWallpaperManager: boolean isVirtualWallpaperDisplay(int)>
<android.app.IWallpaperManager: boolean isValidSnapshot(int)>
<android.app.IWallpaperManager: java.lang.String getDeviceColor()>
<android.app.IWallpaperManager: android.os.ParcelFileDescriptor getWallpaperWithFeature(java.lang.String,java.lang.String,android.app.IWallpaperManagerCallback,int,android.os.Bundle,int,boolean,int)>
<android.app.IWallpaperManager: void removeSnapshotByWhich(int)>
<android.app.IWallpaperManager: void settingsRestored()>
<android.app.IWallpaperManager: boolean isDesktopMode()>
<android.app.IWallpaperManager: int semGetWallpaperType(int)>
<android.app.IWallpaperManager: void removeSnapshotBySource(java.lang.String)>
<android.app.IWallpaperManager: void setWallpaperDimAmount(float)>
<android.app.IWallpaperManager: int getWallpaperOrientation(int,int)>
<android.app.IWallpaperManager: void setVideoWallpaper(java.lang.String,java.lang.String,java.lang.String,java.lang.String,int,int,boolean,android.os.Bundle)>
<android.app.IWallpaperManager: boolean setLockWallpaperCallback(android.app.IWallpaperManagerCallback)>
<android.app.IWallpaperManager: int getSnapshotCount(int)>
<android.app.IWallpaperManager: void copyPreloadedFileToWallpaperFile(int,java.lang.String)>
<android.app.IWallpaperManager: android.os.Bundle getWallpaperExtras(int,int)>
<android.app.IWallpaperManager: android.app.WallpaperInfo getWallpaperInfoWithFlags(int,int)>
<android.app.IWallpaperManager: void setDisplayPadding(android.graphics.Rect,java.lang.String,int)>
<android.app.IWallpaperManager: void setSnapshotTestMode(boolean)>
<android.app.IWallpaperManager: void setAnimatedWallpaper(java.lang.String,java.lang.String,int,boolean)>
<android.app.IWallpaperManager: android.os.ParcelFileDescriptor getWallpaper(java.lang.String,android.app.IWallpaperManagerCallback,int,android.os.Bundle,int)>
<android.app.IWallpaperManager: void setKWPTypeLiveWallpaperWithMode(int,int)>
<android.app.IWallpaperManager: java.lang.String getAnimatedPkgName(int)>
<android.app.IWallpaperManager: boolean isLockscreenLiveWallpaperEnabled()>
<android.app.IWallpaperManager: boolean isWaitingForUnlockUser(int,int)>
<android.app.IWallpaperManager: void unregisterWallpaperColorsCallback(android.app.IWallpaperManagerCallback,int,int)>
<android.app.IWallpaperManager: boolean lockScreenWallpaperExists()>
<android.app.IWallpaperManager: int getDisplayId(int)>
<android.app.IWallpaperManager: boolean isVideoWallpaper()>
<android.app.IWallpaperManager: void semSetUri(java.lang.String,boolean,int,int,java.lang.String,int,android.os.Bundle)>
<android.app.IWallpaperManager: boolean isSetWallpaperAllowed(java.lang.String)>
<android.app.IWallpaperManager: android.app.WallpaperInfo getWallpaperInfo(int)>
<android.app.IWallpaperManager: boolean isSnapshotTestMode()>
<android.app.IWallpaperManager: android.app.WallpaperColors getWallpaperColors(int,int,int)>
<android.app.IWallpaperManager: boolean isWallpaperBackupEligible(int,int)>
<android.os.storage.IStorageEventListener: void onUsbMassStorageConnectionChanged(boolean)>
<android.os.storage.IStorageEventListener: void onDiskScanned(android.os.storage.DiskInfo,int)>
<android.os.storage.IStorageEventListener: void onVolumeRecordChanged(android.os.storage.VolumeRecord)>
<android.os.storage.IStorageEventListener: void onVolumeStateChanged(android.os.storage.VolumeInfo,int,int)>
<android.os.storage.IStorageEventListener: void onStorageStateChanged(java.lang.String,java.lang.String,java.lang.String)>
<android.os.storage.IStorageEventListener: void onVolumeForgotten(java.lang.String)>
<android.os.storage.IStorageEventListener: void onDiskDestroyed(android.os.storage.DiskInfo)>
<android.service.contentcapture.IContentCaptureServiceCallback: void setContentCaptureConditions(java.lang.String,java.util.List)>
<android.service.contentcapture.IContentCaptureServiceCallback: void setContentCaptureWhitelist(java.util.List,java.util.List)>
<android.service.contentcapture.IContentCaptureServiceCallback: void disableSelf()>
<android.service.contentcapture.IContentCaptureServiceCallback: void writeSessionFlush(int,android.content.ComponentName,android.service.contentcapture.FlushMetrics,android.content.ContentCaptureOptions,int)>
<android.os.IIncidentManager: void unregisterSection(int)>
<android.os.IIncidentManager: void deleteAllIncidentReports(java.lang.String)>
<android.os.IIncidentManager: android.os.IncidentManager$IncidentReport getIncidentReport(java.lang.String,java.lang.String,java.lang.String)>
<android.os.IIncidentManager: void registerSection(int,java.lang.String,android.os.IIncidentDumpCallback)>
<android.os.IIncidentManager: void deleteIncidentReports(java.lang.String,java.lang.String,java.lang.String)>
<android.os.IIncidentManager: void reportIncident(android.os.IncidentReportArgs)>
<android.os.IIncidentManager: void reportIncidentToDumpstate(java.io.FileDescriptor,android.os.IIncidentReportStatusListener)>
<android.os.IIncidentManager: void reportIncidentToStream(android.os.IncidentReportArgs,android.os.IIncidentReportStatusListener,java.io.FileDescriptor)>
<android.os.IIncidentManager: void systemRunning()>
<android.os.IIncidentManager: java.util.List getIncidentReportList(java.lang.String,java.lang.String)>
<com.android.internal.app.IVoiceActionCheckCallback: void onComplete(java.util.List)>
<android.content.om.IOverlayManager: void commit(android.content.om.OverlayManagerTransaction)>
<android.content.om.IOverlayManager: void applyWallpaperColor(java.util.List,java.util.List,boolean)>
<android.content.om.IOverlayManager: void applyWallpaperColors(java.util.List,int,int)>
<android.content.om.IOverlayManager: boolean setEnabledExclusiveInCategory(java.lang.String,int)>
<android.content.om.IOverlayManager: boolean setEnabled(java.lang.String,boolean,int)>
<android.content.om.IOverlayManager: android.content.om.OverlayInfo getOverlayInfoByIdentifier(android.content.om.OverlayIdentifier,int)>
<android.content.om.IOverlayManager: boolean setHighestPriority(java.lang.String,int)>
<android.content.om.IOverlayManager: java.util.List readLastPalette()>
<android.content.om.IOverlayManager: boolean getLastPalette(java.util.List,java.util.List)>
<android.content.om.IOverlayManager: boolean setLowestPriority(java.lang.String,int)>
<android.content.om.IOverlayManager: android.content.om.OverlayInfo getOverlayInfo(java.lang.String,int)>
<android.content.om.IOverlayManager: java.util.List getThemeParkOverlayNames(java.lang.String)>
<android.content.om.IOverlayManager: java.util.List getWallpaperColors()>
<android.content.om.IOverlayManager: void applyThemeParkWallpaperColor(android.net.Uri)>
<android.content.om.IOverlayManager: void removeOverlays(java.util.List,android.content.om.ISamsungOverlayCallback,int)>
<android.content.om.IOverlayManager: java.util.Map getAllOverlays(int)>
<android.content.om.IOverlayManager: android.content.om.OverlayInfoExt[] getAllOverlaysInCategory(int,int)>
<android.content.om.IOverlayManager: boolean changeOverlayState(java.lang.String,int,boolean)>
<android.content.om.IOverlayManager: java.lang.String[] getDefaultOverlayPackages()>
<android.content.om.IOverlayManager: void invalidateCachesForOverlay(java.lang.String,int)>
<android.content.om.IOverlayManager: android.content.om.OverlayInfoExt[] getOverlaysForTarget(java.lang.String,int,int)>
<android.content.om.IOverlayManager: void addOverlays(java.util.List,android.content.om.ISamsungOverlayCallback,int)>
<android.content.om.IOverlayManager: java.util.List getOverlayInfosForTarget(java.lang.String,int)>
<android.content.om.IOverlayManager: boolean setEnabledExclusive(java.lang.String,boolean,int)>
<android.content.om.IOverlayManager: void replaceOverlays(java.util.List,java.util.List,android.content.om.ISamsungOverlayCallback,int)>
<android.content.om.IOverlayManager: boolean setPriority(java.lang.String,java.lang.String,int)>
<android.content.om.IOverlayManager: android.content.om.OverlayInfoExt getOverlayForPath(java.lang.String,int)>
<com.android.internal.telephony.IWapPushManager: boolean deletePackage(java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
<com.android.internal.telephony.IWapPushManager: int processMessage(java.lang.String,java.lang.String,android.content.Intent)>
<com.android.internal.telephony.IWapPushManager: boolean updatePackage(java.lang.String,java.lang.String,java.lang.String,java.lang.String,int,boolean,boolean)>
<com.android.internal.telephony.IWapPushManager: boolean addPackage(java.lang.String,java.lang.String,java.lang.String,java.lang.String,int,boolean,boolean)>
<android.hardware.radio.sim.IRadioSim: void getAllowedCarriers(int)>
<android.hardware.radio.sim.IRadioSim: void sendEnvelope(int,java.lang.String)>
<android.hardware.radio.sim.IRadioSim: void iccTransmitApduLogicalChannel(int,android.hardware.radio.sim.SimApdu)>
<android.hardware.radio.sim.IRadioSim: void getCdmaSubscriptionSource(int)>
<android.hardware.radio.sim.IRadioSim: void supplyIccPinForApp(int,java.lang.String,java.lang.String)>
<android.hardware.radio.sim.IRadioSim: void supplyIccPukForApp(int,java.lang.String,java.lang.String,java.lang.String)>
<android.hardware.radio.sim.IRadioSim: void updateSimPhonebookRecords(int,android.hardware.radio.sim.PhonebookRecordInfo)>
<android.hardware.radio.sim.IRadioSim: void getCdmaSubscription(int)>
<android.hardware.radio.sim.IRadioSim: void supplySimDepersonalization(int,int,java.lang.String)>
<android.hardware.radio.sim.IRadioSim: int getInterfaceVersion()>
<android.hardware.radio.sim.IRadioSim: void setCdmaSubscriptionSource(int,int)>
<android.hardware.radio.sim.IRadioSim: void setFacilityLockForApp(int,java.lang.String,boolean,java.lang.String,int,java.lang.String)>
<android.hardware.radio.sim.IRadioSim: void enableUiccApplications(int,boolean)>
<android.hardware.radio.sim.IRadioSim: void setSimCardPower(int,int)>
<android.hardware.radio.sim.IRadioSim: void getFacilityLockForApp(int,java.lang.String,java.lang.String,int,java.lang.String)>
<android.hardware.radio.sim.IRadioSim: void requestIccSimAuthentication(int,int,java.lang.String,java.lang.String)>
<android.hardware.radio.sim.IRadioSim: void iccCloseLogicalChannel(int,int)>
<android.hardware.radio.sim.IRadioSim: void getSimPhonebookCapacity(int)>
<android.hardware.radio.sim.IRadioSim: void getSimPhonebookRecords(int)>
<android.hardware.radio.sim.IRadioSim: void reportStkServiceIsRunning(int)>
<android.hardware.radio.sim.IRadioSim: void responseAcknowledgement()>
<android.hardware.radio.sim.IRadioSim: void iccOpenLogicalChannel(int,java.lang.String,int)>
<android.hardware.radio.sim.IRadioSim: void sendTerminalResponseToSim(int,java.lang.String)>
<android.hardware.radio.sim.IRadioSim: void iccTransmitApduBasicChannel(int,android.hardware.radio.sim.SimApdu)>
<android.hardware.radio.sim.IRadioSim: void supplyIccPin2ForApp(int,java.lang.String,java.lang.String)>
<android.hardware.radio.sim.IRadioSim: void areUiccApplicationsEnabled(int)>
<android.hardware.radio.sim.IRadioSim: void iccIoForApp(int,android.hardware.radio.sim.IccIo)>
<android.hardware.radio.sim.IRadioSim: void setCarrierInfoForImsiEncryption(int,android.hardware.radio.sim.ImsiEncryptionInfo)>
<android.hardware.radio.sim.IRadioSim: void setResponseFunctions(android.hardware.radio.sim.IRadioSimResponse,android.hardware.radio.sim.IRadioSimIndication)>
<android.hardware.radio.sim.IRadioSim: java.lang.String getInterfaceHash()>
<android.hardware.radio.sim.IRadioSim: void supplyIccPuk2ForApp(int,java.lang.String,java.lang.String,java.lang.String)>
<android.hardware.radio.sim.IRadioSim: void iccCloseLogicalChannelWithSessionInfo(int,android.hardware.radio.sim.SessionInfo)>
<android.hardware.radio.sim.IRadioSim: void setAllowedCarriers(int,android.hardware.radio.sim.CarrierRestrictions,int)>
<android.hardware.radio.sim.IRadioSim: void getImsiForApp(int,java.lang.String)>
<android.hardware.radio.sim.IRadioSim: void changeIccPin2ForApp(int,java.lang.String,java.lang.String,java.lang.String)>
<android.hardware.radio.sim.IRadioSim: void setUiccSubscription(int,android.hardware.radio.sim.SelectUiccSub)>
<android.hardware.radio.sim.IRadioSim: void sendEnvelopeWithStatus(int,java.lang.String)>
<android.hardware.radio.sim.IRadioSim: void changeIccPinForApp(int,java.lang.String,java.lang.String,java.lang.String)>
<android.hardware.radio.sim.IRadioSim: void getIccCardStatus(int)>
<com.samsung.cmfa.AuthTouch.IAuthTouchEventListener: void onPointerEvent(android.view.MotionEvent)>
<android.net.wifi.nl80211.IClientInterface: int[] signalPoll()>
<android.net.wifi.nl80211.IClientInterface: int[] getPacketCounters()>
<android.net.wifi.nl80211.IClientInterface: byte[] getMacAddress()>
<android.net.wifi.nl80211.IClientInterface: void SendMgmtFrame(byte[],android.net.wifi.nl80211.ISendMgmtFrameEvent,int)>
<android.net.wifi.nl80211.IClientInterface: android.net.wifi.nl80211.IWifiScannerImpl getWifiScannerImpl()>
<android.net.wifi.nl80211.IClientInterface: java.lang.String getInterfaceName()>
<android.os.logcat.ILogcatManagerService: void startThread(int,int,int,int)>
<android.os.logcat.ILogcatManagerService: void finishThread(int,int,int,int)>
<android.app.IUriGrantsManager: void takePersistableUriPermission(android.net.Uri,int,java.lang.String,int)>
<android.app.IUriGrantsManager: android.content.pm.ParceledListSlice getUriPermissions(java.lang.String,boolean,boolean)>
<android.app.IUriGrantsManager: void releasePersistableUriPermission(android.net.Uri,int,java.lang.String,int)>
<android.app.IUriGrantsManager: android.content.pm.ParceledListSlice getGrantedUriPermissions(java.lang.String,int)>
<android.app.IUriGrantsManager: void grantUriPermissionFromOwner(android.os.IBinder,int,java.lang.String,android.net.Uri,int,int,int)>
<android.app.IUriGrantsManager: void clearGrantedUriPermissions(java.lang.String,int)>
<android.hardware.gnss.IGnssCallback: void gnssNmeaCb(long,java.lang.String)>
<android.hardware.gnss.IGnssCallback: void gnssReleaseWakelockCb()>
<android.hardware.gnss.IGnssCallback: void gnssSetCapabilitiesCb(int)>
<android.hardware.gnss.IGnssCallback: void gnssSetSystemInfoCb(android.hardware.gnss.IGnssCallback$GnssSystemInfo)>
<android.hardware.gnss.IGnssCallback: void gnssStatusCb(int)>
<android.hardware.gnss.IGnssCallback: int getInterfaceVersion()>
<android.hardware.gnss.IGnssCallback: void gnssRequestTimeCb()>
<android.hardware.gnss.IGnssCallback: void gnssAcquireWakelockCb()>
<android.hardware.gnss.IGnssCallback: void gnssLocationCb(android.hardware.gnss.GnssLocation)>
<android.hardware.gnss.IGnssCallback: java.lang.String getInterfaceHash()>
<android.hardware.gnss.IGnssCallback: void gnssSvStatusCb(android.hardware.gnss.IGnssCallback$GnssSvInfo[])>
<android.hardware.gnss.IGnssCallback: void gnssRequestLocationCb(boolean,boolean)>
<android.view.IRecentsAnimationRunner: void onTasksAppeared(android.view.RemoteAnimationTarget[])>
<android.view.IRecentsAnimationRunner: void onAnimationCanceled(int[],android.window.TaskSnapshot[])>
<android.view.IRecentsAnimationRunner: void onAnimationStart(android.view.IRecentsAnimationController,android.view.RemoteAnimationTarget[],android.view.RemoteAnimationTarget[],android.graphics.Rect,android.graphics.Rect)>
<com.samsung.android.aod.IAODDozeCallback: void onAODToastRequested(com.samsung.android.aod.AODToast)>
<com.samsung.android.aod.IAODDozeCallback: void onDozeAcquired()>
<com.samsung.android.aod.IAODDozeCallback: void onDozeReleased()>
<com.android.internal.os.IResultReceiver: void send(int,android.os.Bundle)>
<android.media.IMediaRouter2: void notifyRoutesUpdated(java.util.List)>
<android.media.IMediaRouter2: void notifySessionReleased(android.media.RoutingSessionInfo)>
<android.media.IMediaRouter2: void requestCreateSessionByManager(long,android.media.RoutingSessionInfo,android.media.MediaRoute2Info)>
<android.media.IMediaRouter2: void notifyRouterRegistered(java.util.List,android.media.RoutingSessionInfo)>
<android.media.IMediaRouter2: void notifySessionCreated(int,android.media.RoutingSessionInfo)>
<android.media.IMediaRouter2: void notifySessionInfoChanged(android.media.RoutingSessionInfo)>
<vendor.samsung.hardware.radio.data.ISehRadioDataIndication: int getInterfaceVersion()>
<vendor.samsung.hardware.radio.data.ISehRadioDataIndication: vendor.samsung.hardware.radio.data.SehApnProfile needApnProfileIndication(java.lang.String)>
<vendor.samsung.hardware.radio.data.ISehRadioDataIndication: java.lang.String getInterfaceHash()>
<vendor.samsung.hardware.radio.data.ISehRadioDataIndication: void timerStatusChangedInd(int,int[])>
<vendor.samsung.hardware.radio.data.ISehRadioDataIndication: vendor.samsung.hardware.radio.data.SehPacketUsage needPacketUsage(java.lang.String)>
<vendor.samsung.hardware.radio.data.ISehRadioDataIndication: void rrcStateChanged(int,vendor.samsung.hardware.radio.data.SehRrcStateInfo)>
<vendor.samsung.hardware.radio.data.ISehRadioDataIndication: int needSettingValueIndication(java.lang.String,java.lang.String)>
<android.speech.IRecognitionServiceManager: void setTemporaryComponent(android.content.ComponentName)>
<android.speech.IRecognitionServiceManager: void createSession(android.content.ComponentName,android.os.IBinder,boolean,android.speech.IRecognitionServiceManagerCallback)>
<android.app.wallpapereffectsgeneration.ICinematicEffectListener: void onCinematicEffectGenerated(android.app.wallpapereffectsgeneration.CinematicEffectResponse)>
<android.os.IIncidentReportStatusListener: void onReportFinished()>
<android.os.IIncidentReportStatusListener: void onReportStarted()>
<android.os.IIncidentReportStatusListener: void onReportFailed()>
<android.os.IIncidentReportStatusListener: void onReportSectionStatus(int,int)>
<android.os.ISemHcmManager: boolean getHcmEnable()>
<android.telephony.satellite.stub.ISatellite: void provisionSatelliteService(java.lang.String,byte[],com.android.internal.telephony.IIntegerConsumer)>
<android.telephony.satellite.stub.ISatellite: void requestIsSatelliteProvisioned(com.android.internal.telephony.IIntegerConsumer,com.android.internal.telephony.IBooleanConsumer)>
<android.telephony.satellite.stub.ISatellite: void requestSatelliteListeningEnabled(boolean,int,com.android.internal.telephony.IIntegerConsumer)>
<android.telephony.satellite.stub.ISatellite: void stopSendingSatellitePointingInfo(com.android.internal.telephony.IIntegerConsumer)>
<android.telephony.satellite.stub.ISatellite: void requestIsSatelliteCommunicationAllowedForCurrentLocation(com.android.internal.telephony.IIntegerConsumer,com.android.internal.telephony.IBooleanConsumer)>
<android.telephony.satellite.stub.ISatellite: void requestSatelliteModemState(com.android.internal.telephony.IIntegerConsumer,com.android.internal.telephony.IIntegerConsumer)>
<android.telephony.satellite.stub.ISatellite: void requestTimeForNextSatelliteVisibility(com.android.internal.telephony.IIntegerConsumer,com.android.internal.telephony.IIntegerConsumer)>
<android.telephony.satellite.stub.ISatellite: void sendSatelliteDatagram(android.telephony.satellite.stub.SatelliteDatagram,boolean,com.android.internal.telephony.IIntegerConsumer)>
<android.telephony.satellite.stub.ISatellite: void deprovisionSatelliteService(java.lang.String,com.android.internal.telephony.IIntegerConsumer)>
<android.telephony.satellite.stub.ISatellite: void requestIsSatelliteEnabled(com.android.internal.telephony.IIntegerConsumer,com.android.internal.telephony.IBooleanConsumer)>
<android.telephony.satellite.stub.ISatellite: void requestSatelliteEnabled(boolean,boolean,com.android.internal.telephony.IIntegerConsumer)>
<android.telephony.satellite.stub.ISatellite: void requestIsSatelliteSupported(com.android.internal.telephony.IIntegerConsumer,com.android.internal.telephony.IBooleanConsumer)>
<android.telephony.satellite.stub.ISatellite: void requestSatelliteCapabilities(com.android.internal.telephony.IIntegerConsumer,android.telephony.satellite.stub.ISatelliteCapabilitiesConsumer)>
<android.telephony.satellite.stub.ISatellite: void enableCellularModemWhileSatelliteModeIsOn(boolean,com.android.internal.telephony.IIntegerConsumer)>
<android.telephony.satellite.stub.ISatellite: void setSatelliteListener(android.telephony.satellite.stub.ISatelliteListener)>
<android.telephony.satellite.stub.ISatellite: void startSendingSatellitePointingInfo(com.android.internal.telephony.IIntegerConsumer)>
<android.telephony.satellite.stub.ISatellite: void pollPendingSatelliteDatagrams(com.android.internal.telephony.IIntegerConsumer)>
<android.service.autofill.ISaveCallback: void onSuccess(android.content.IntentSender)>
<android.service.autofill.ISaveCallback: void onFailure(java.lang.CharSequence)>
<com.android.internal.telephony.euicc.IEuiccController: android.telephony.euicc.EuiccInfo getEuiccInfo(int)>
<com.android.internal.telephony.euicc.IEuiccController: void setSupportedCountries(boolean,java.util.List)>
<com.android.internal.telephony.euicc.IEuiccController: boolean isSimPortAvailable(int,int,java.lang.String)>
<com.android.internal.telephony.euicc.IEuiccController: void retainSubscriptionsForFactoryReset(int,android.app.PendingIntent)>
<com.android.internal.telephony.euicc.IEuiccController: void downloadSubscription(int,android.telephony.euicc.DownloadableSubscription,boolean,java.lang.String,android.os.Bundle,android.app.PendingIntent)>
<com.android.internal.telephony.euicc.IEuiccController: void switchToSubscriptionWithPort(int,int,int,java.lang.String,android.app.PendingIntent)>
<com.android.internal.telephony.euicc.IEuiccController: java.util.List getSupportedCountries(boolean)>
<com.android.internal.telephony.euicc.IEuiccController: void switchToSubscription(int,int,java.lang.String,android.app.PendingIntent)>
<com.android.internal.telephony.euicc.IEuiccController: void getDownloadableSubscriptionMetadata(int,android.telephony.euicc.DownloadableSubscription,java.lang.String,android.app.PendingIntent)>
<com.android.internal.telephony.euicc.IEuiccController: int getOtaStatus(int)>
<com.android.internal.telephony.euicc.IEuiccController: void eraseSubscriptions(int,android.app.PendingIntent)>
<com.android.internal.telephony.euicc.IEuiccController: boolean isCompatChangeEnabled(java.lang.String,long)>
<com.android.internal.telephony.euicc.IEuiccController: void updateSubscriptionNickname(int,int,java.lang.String,java.lang.String,android.app.PendingIntent)>
<com.android.internal.telephony.euicc.IEuiccController: boolean hasCarrierPrivilegesForPackageOnAnyPhone(java.lang.String)>
<com.android.internal.telephony.euicc.IEuiccController: java.lang.String getEid(int,java.lang.String)>
<com.android.internal.telephony.euicc.IEuiccController: void eraseSubscriptionsWithOptions(int,int,android.app.PendingIntent)>
<com.android.internal.telephony.euicc.IEuiccController: void continueOperation(int,android.content.Intent,android.os.Bundle)>
<com.android.internal.telephony.euicc.IEuiccController: void getDefaultDownloadableSubscriptionList(int,java.lang.String,android.app.PendingIntent)>
<com.android.internal.telephony.euicc.IEuiccController: boolean isSupportedCountry(java.lang.String)>
<com.android.internal.telephony.euicc.IEuiccController: void deleteSubscription(int,int,java.lang.String,android.app.PendingIntent)>
<android.app.IApplicationStartInfoCompleteListener: void onApplicationStartInfoComplete(android.app.ApplicationStartInfo)>
<android.service.euicc.IGetDefaultDownloadableSubscriptionListCallback: void onComplete(android.service.euicc.GetDefaultDownloadableSubscriptionListResult)>
<android.media.ICommunicationDeviceDispatcher: void dispatchCommunicationDeviceChanged(int)>
<android.os.IServiceManager: void addService(java.lang.String,android.os.IBinder,boolean,int)>
<android.os.IServiceManager: android.os.IBinder checkService(java.lang.String)>
<android.os.IServiceManager: void registerClientCallback(java.lang.String,android.os.IBinder,android.os.IClientCallback)>
<android.os.IServiceManager: java.lang.String updatableViaApex(java.lang.String)>
<android.os.IServiceManager: void unregisterForNotifications(java.lang.String,android.os.IServiceCallback)>
<android.os.IServiceManager: void tryUnregisterService(java.lang.String,android.os.IBinder)>
<android.os.IServiceManager: android.os.ConnectionInfo getConnectionInfo(java.lang.String)>
<android.os.IServiceManager: android.os.ServiceDebugInfo[] getServiceDebugInfo()>
<android.os.IServiceManager: java.lang.String[] getDeclaredInstances(java.lang.String)>
<android.os.IServiceManager: java.lang.String[] getUpdatableNames(java.lang.String)>
<android.os.IServiceManager: boolean isDeclared(java.lang.String)>
<android.os.IServiceManager: void registerForNotifications(java.lang.String,android.os.IServiceCallback)>
<android.os.IServiceManager: android.os.IBinder getService(java.lang.String)>
<android.os.IServiceManager: java.lang.String[] listServices(int)>
<com.android.internal.policy.IKeyguardDismissCallback: void onDismissSucceeded()>
<com.android.internal.policy.IKeyguardDismissCallback: void onDismissError()>
<com.android.internal.policy.IKeyguardDismissCallback: void onDismissCancelled()>
<android.media.midi.IMidiDeviceListener: void onDeviceStatusChanged(android.media.midi.MidiDeviceStatus)>
<android.media.midi.IMidiDeviceListener: void onDeviceAdded(android.media.midi.MidiDeviceInfo)>
<android.media.midi.IMidiDeviceListener: void onDeviceRemoved(android.media.midi.MidiDeviceInfo)>
<android.os.ISemHqmManager: boolean getDVServerEnable()>
<android.os.ISemHqmManager: boolean sendHWParamServer(int,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
<android.os.ISemHqmManager: boolean sendHWParamToHQMwithAppId(int,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
<android.os.ISemHqmManager: boolean getCFServerEnable()>
<android.os.ISemHqmManager: boolean getHqmEnable()>
<android.os.ISemHqmManager: boolean sendHWParamToHQM(int,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
<android.os.ISemHqmManager: boolean sendHWParamToHQMwithFile(int,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
<android.os.ISemHqmManager: void sendSystemInfoToHQM(int,java.lang.String,java.lang.String)>
<android.os.IIncidentDumpCallback: void onDumpSection(android.os.ParcelFileDescriptor)>
<android.hardware.hdmi.IHdmiRecordListener: byte[] getOneTouchRecordSource(int)>
<android.hardware.hdmi.IHdmiRecordListener: void onClearTimerRecordingResult(int,int)>
<android.hardware.hdmi.IHdmiRecordListener: void onTimerRecordingResult(int,int)>
<android.hardware.hdmi.IHdmiRecordListener: void onOneTouchRecordResult(int,int)>
<android.view.IDockedStackListener: void onAdjustedForImeChanged(boolean,long)>
<android.view.IDockedStackListener: void onDockedStackExistsChanged(boolean)>
<android.view.IDockedStackListener: void onDockSideChanged(int)>
<android.view.IDockedStackListener: void onDockedStackMinimizedChanged(boolean,long,boolean)>
<android.view.IDockedStackListener: void onDividerVisibilityChanged(boolean)>
<android.hardware.location.IContextHubCallback: void onMessageReceipt(int,int,android.hardware.location.ContextHubMessage)>
<android.printservice.recommendation.IRecommendationServiceCallbacks: void onRecommendationsUpdated(java.util.List)>
<android.service.vr.IPersistentVrStateCallbacks: void onPersistentVrStateChanged(boolean)>
<android.service.euicc.IUpdateSubscriptionNicknameCallback: void onComplete(int)>
<android.window.ITaskOrganizerController: boolean togglePinTaskState(int)>
<android.window.ITaskOrganizerController: void createRootTask(int,int,android.os.IBinder,boolean)>
<android.window.ITaskOrganizerController: java.util.List getRootTasks(int,int[])>
<android.window.ITaskOrganizerController: void restartTaskTopActivityProcessIfVisible(android.window.WindowContainerToken)>
<android.window.ITaskOrganizerController: void updateCameraCompatControlState(android.window.WindowContainerToken,int)>
<android.window.ITaskOrganizerController: boolean isKeepScreenOn(int)>
<android.window.ITaskOrganizerController: void createStageRootTask(int,int,int,android.os.IBinder)>
<android.window.ITaskOrganizerController: android.content.pm.ParceledListSlice registerTaskOrganizer(android.window.ITaskOrganizer)>
<android.window.ITaskOrganizerController: void setOrientationRequestPolicy(boolean,int[],int[])>
<android.window.ITaskOrganizerController: float getFreeformTaskOpacity(int)>
<android.window.ITaskOrganizerController: void setFreeformTaskSurfaceOverlappedWithNavi(android.window.WindowContainerToken,boolean)>
<android.window.ITaskOrganizerController: void setInterceptBackPressedOnTaskRoot(android.window.WindowContainerToken,boolean)>
<android.window.ITaskOrganizerController: void setFreeformTaskOpacity(int,float)>
<android.window.ITaskOrganizerController: boolean deleteRootTask(android.window.WindowContainerToken)>
<android.window.ITaskOrganizerController: java.util.List getChildTasks(android.window.WindowContainerToken,int[])>
<android.window.ITaskOrganizerController: void unregisterTaskOrganizer(android.window.ITaskOrganizer)>
<android.window.ITaskOrganizerController: android.window.WindowContainerToken getImeTarget(int)>
<android.window.ITaskOrganizerController: boolean isPinStateChangeable(int)>
<android.os.ISpqrService: boolean createInvariantProfile(java.lang.String,java.lang.String,int,int,java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
<android.hardware.camera2.ICameraDeviceCallbacks: void onPrepared(int)>
<android.hardware.camera2.ICameraDeviceCallbacks: void onDeviceIdle()>
<android.hardware.camera2.ICameraDeviceCallbacks: void onCaptureStarted(android.hardware.camera2.impl.CaptureResultExtras,long)>
<android.hardware.camera2.ICameraDeviceCallbacks: void onRepeatingRequestError(long,int)>
<android.hardware.camera2.ICameraDeviceCallbacks: void onResultReceived(android.hardware.camera2.impl.CameraMetadataNative,android.hardware.camera2.impl.CaptureResultExtras,android.hardware.camera2.impl.PhysicalCaptureResultInfo[])>
<android.hardware.camera2.ICameraDeviceCallbacks: void onDeviceError(int,android.hardware.camera2.impl.CaptureResultExtras)>
<android.hardware.camera2.ICameraDeviceCallbacks: void onRequestQueueEmpty()>
<android.printservice.recommendation.IRecommendationsChangeListener: void onRecommendationsChanged()>
<android.telephony.ims.aidl.IImsMmTelListener: void onAudioModeIsVoipChanged(int)>
<android.telephony.ims.aidl.IImsMmTelListener: void onMediaQualityStatusChanged(android.telephony.ims.MediaQualityStatus)>
<android.telephony.ims.aidl.IImsMmTelListener: android.telephony.ims.aidl.IImsCallSessionListener onIncomingCall(com.android.ims.internal.IImsCallSession,java.lang.String,android.os.Bundle)>
<android.telephony.ims.aidl.IImsMmTelListener: void onRejectedCall(android.telephony.ims.ImsCallProfile,android.telephony.ims.ImsReasonInfo)>
<android.telephony.ims.aidl.IImsMmTelListener: void onStopImsTrafficSession(int)>
<android.telephony.ims.aidl.IImsMmTelListener: void onTriggerEpsFallback(int)>
<android.telephony.ims.aidl.IImsMmTelListener: void onStartImsTrafficSession(int,int,int,int,android.telephony.ims.aidl.IImsTrafficSessionCallback)>
<android.telephony.ims.aidl.IImsMmTelListener: void onCdpnReceived(java.lang.String,int)>
<android.telephony.ims.aidl.IImsMmTelListener: void onVoiceMessageCountUpdate(int)>
<android.telephony.ims.aidl.IImsMmTelListener: void onModifyImsTrafficSession(int,int)>
<android.sec.clipboard.IClipboardService: void updateFilter(int,android.sec.clipboard.IClipboardDataPasteEvent)>
<android.sec.clipboard.IClipboardService: void removeClipboardEventListener(com.samsung.android.content.clipboard.IOnClipboardEventListener)>
<android.sec.clipboard.IClipboardService: void setPrimaryClip(android.content.ClipData,int)>
<android.sec.clipboard.IClipboardService: boolean isEnabled(int)>
<android.sec.clipboard.IClipboardService: void setPrimarySemClip(com.samsung.android.content.clipboard.data.SemClipData,java.lang.String,int)>
<android.sec.clipboard.IClipboardService: com.samsung.android.content.clipboard.data.SemClipData getPrimarySemClip(java.lang.String,int)>
<android.sec.clipboard.IClipboardService: void addClipboardEventListener(com.samsung.android.content.clipboard.IOnClipboardEventListener,java.lang.String)>
<android.sec.clipboard.IClipboardService: int getFilter()>
<android.sec.clipboard.IClipboardService: boolean hasPrimaryClip(java.lang.String,int)>
<android.sec.clipboard.IClipboardService: boolean pasteClipData(android.content.ClipData,java.lang.String,int)>
<com.android.internal.net.INetworkWatchlistManager: void reloadWatchlist()>
<com.android.internal.net.INetworkWatchlistManager: void reportWatchlistIfNecessary()>
<com.android.internal.net.INetworkWatchlistManager: boolean startWatchlistLogging()>
<com.android.internal.net.INetworkWatchlistManager: byte[] getWatchlistConfigHash()>
<com.android.internal.net.INetworkWatchlistManager: boolean stopWatchlistLogging()>
<android.service.carrier.ICarrierMessagingService: void sendMms(android.net.Uri,int,android.net.Uri,android.service.carrier.ICarrierMessagingCallback)>
<android.service.carrier.ICarrierMessagingService: void sendMultipartTextSms(java.util.List,int,java.lang.String,int,android.service.carrier.ICarrierMessagingCallback)>
<android.service.carrier.ICarrierMessagingService: void downloadMms(android.net.Uri,int,android.net.Uri,android.service.carrier.ICarrierMessagingCallback)>
<android.service.carrier.ICarrierMessagingService: void filterSms(android.service.carrier.MessagePdu,java.lang.String,int,int,android.service.carrier.ICarrierMessagingCallback)>
<android.service.carrier.ICarrierMessagingService: void sendDataSms(byte[],int,java.lang.String,int,int,android.service.carrier.ICarrierMessagingCallback)>
<android.service.carrier.ICarrierMessagingService: void sendTextSms(java.lang.String,int,java.lang.String,int,android.service.carrier.ICarrierMessagingCallback)>
<vendor.samsung.hardware.radio.sim.ISehRadioSim: void getPhonebookStorageInfo(int,int)>
<vendor.samsung.hardware.radio.sim.ISehRadioSim: java.lang.String getInterfaceHash()>
<vendor.samsung.hardware.radio.sim.ISehRadioSim: void setSimInitEvent(int)>
<vendor.samsung.hardware.radio.sim.ISehRadioSim: void setResponseFunctions(vendor.samsung.hardware.radio.sim.ISehRadioSimResponse,vendor.samsung.hardware.radio.sim.ISehRadioSimIndication)>
<vendor.samsung.hardware.radio.sim.ISehRadioSim: void getPhonebookEntry(int,int,int)>
<vendor.samsung.hardware.radio.sim.ISehRadioSim: void getAtr(int)>
<vendor.samsung.hardware.radio.sim.ISehRadioSim: void getIccCardStatus(int)>
<vendor.samsung.hardware.radio.sim.ISehRadioSim: int getInterfaceVersion()>
<vendor.samsung.hardware.radio.sim.ISehRadioSim: void setSimOnOff(int,int)>
<vendor.samsung.hardware.radio.sim.ISehRadioSim: void supplyIccPersonalization(int,java.lang.String)>
<vendor.samsung.hardware.radio.sim.ISehRadioSim: void changeIccPersonalization(int,java.lang.String,java.lang.String)>
<vendor.samsung.hardware.radio.sim.ISehRadioSim: void getUsimPhonebookCapability(int)>
<vendor.samsung.hardware.radio.sim.ISehRadioSim: void getSimLockInfo(int,int,int)>
<vendor.samsung.hardware.radio.sim.ISehRadioSim: void accessPhonebookEntry(int,int,int,int,vendor.samsung.hardware.radio.sim.SehAdnRecord,java.lang.String)>
<vendor.samsung.hardware.radio.sim.ISehRadioSim: void supplyNetworkDepersonalization(int,java.lang.String,int)>
<com.samsung.android.cocktailbar.ISystemUiVisibilityCallback: void onSystemUiVisibilityChanged(int)>
<com.android.internal.app.IAppOpsStartedCallback: void opStarted(int,int,java.lang.String,java.lang.String,int,int,int,int,int)>
<android.telephony.mbms.IMbmsGroupCallSessionCallback: void onServiceInterfaceAvailable(java.lang.String,int)>
<android.telephony.mbms.IMbmsGroupCallSessionCallback: void onAvailableSaisUpdated(java.util.List,java.util.List)>
<android.telephony.mbms.IMbmsGroupCallSessionCallback: void onError(int,java.lang.String)>
<android.telephony.mbms.IMbmsGroupCallSessionCallback: void onMiddlewareReady()>
<com.android.internal.os.IBinaryTransparencyService: java.lang.String getSignedImageInfo()>
<com.android.internal.os.IBinaryTransparencyService: void recordMeasurementsForAllPackages()>
<com.android.internal.os.IBinaryTransparencyService: java.util.List collectAllUpdatedPreloadInfo(android.os.Bundle)>
<com.android.internal.os.IBinaryTransparencyService: java.util.List collectAllApexInfo(boolean)>
<com.android.internal.os.IBinaryTransparencyService: java.util.List collectAllSilentInstalledMbaInfo(android.os.Bundle)>
<android.view.IGraphicsStats: android.os.ParcelFileDescriptor requestBufferForProcess(java.lang.String,android.view.IGraphicsStatsCallback)>
<android.hardware.fingerprint.IFingerprintClientActiveCallback: void onClientActiveChanged(boolean)>
<com.samsung.android.wifi.p2p.ISemWifiP2pCallback: void onSuccess()>
<com.samsung.android.wifi.p2p.ISemWifiP2pCallback: void onFailure(int)>
<com.samsung.android.remoteappmode.IRemoteAppMode: void enableSendingUserPresentIntent(java.lang.String)>
<com.samsung.android.remoteappmode.IRemoteAppMode: boolean registerRemoteAppModeListener(com.samsung.android.remoteappmode.IRemoteAppModeListener,java.lang.String)>
<com.samsung.android.remoteappmode.IRemoteAppMode: boolean registerSecureAppChangedListener(com.samsung.android.remoteappmode.ISecureAppChangedListener,java.lang.String)>
<com.samsung.android.remoteappmode.IRemoteAppMode: void startRFCommService()>
<com.samsung.android.remoteappmode.IRemoteAppMode: void launchApplication(int,java.lang.String,android.content.Intent,android.os.Bundle)>
<com.samsung.android.remoteappmode.IRemoteAppMode: void setSendingUserPresentExpiredTime(long)>
<com.samsung.android.remoteappmode.IRemoteAppMode: void transferTaskWithoutIntercept(int,int,android.os.Bundle)>
<com.samsung.android.remoteappmode.IRemoteAppMode: boolean unregisterSecureAppChangedListener(com.samsung.android.remoteappmode.ISecureAppChangedListener)>
<com.samsung.android.remoteappmode.IRemoteAppMode: void resizeVirtualDisplay(int,int,int,int,android.view.Surface)>
<com.samsung.android.remoteappmode.IRemoteAppMode: boolean registerStartActivityInterceptListener(com.samsung.android.remoteappmode.IStartActivityInterceptListener,java.lang.String)>
<com.samsung.android.remoteappmode.IRemoteAppMode: void clearAll()>
<com.samsung.android.remoteappmode.IRemoteAppMode: boolean isSendingUserPresentEnabled()>
<com.samsung.android.remoteappmode.IRemoteAppMode: void getLastAnr(java.lang.String,android.os.ParcelFileDescriptor)>
<com.samsung.android.remoteappmode.IRemoteAppMode: boolean unregisterStartActivityInterceptListener(com.samsung.android.remoteappmode.IStartActivityInterceptListener)>
<com.samsung.android.remoteappmode.IRemoteAppMode: boolean registerRotationChangeListener(com.samsung.android.remoteappmode.IRotationChangeListener,java.lang.String,int)>
<com.samsung.android.remoteappmode.IRemoteAppMode: void releaseVirtualDisplay(int)>
<com.samsung.android.remoteappmode.IRemoteAppMode: int getProtocolVersion()>
<com.samsung.android.remoteappmode.IRemoteAppMode: boolean unregisterRemoteAppModeListener(com.samsung.android.remoteappmode.IRemoteAppModeListener)>
<com.samsung.android.remoteappmode.IRemoteAppMode: void moveDisplayToTop(int)>
<com.samsung.android.remoteappmode.IRemoteAppMode: long getSendingUserPresentExpiredTime()>
<com.samsung.android.remoteappmode.IRemoteAppMode: boolean registerTaskChangeListener(com.samsung.android.remoteappmode.ITaskChangeListener,java.lang.String)>
<com.samsung.android.remoteappmode.IRemoteAppMode: int createVirtualDisplay(java.lang.String,int,int,int,android.view.Surface,com.samsung.android.remoteappmode.IVirtualDisplayAliveChecker)>
<com.samsung.android.remoteappmode.IRemoteAppMode: boolean sendNotificationContent(android.service.notification.StatusBarNotification)>
<com.samsung.android.remoteappmode.IRemoteAppMode: boolean unregisterTaskChangeListener(com.samsung.android.remoteappmode.ITaskChangeListener)>
<com.samsung.android.remoteappmode.IRemoteAppMode: boolean isAllowed()>
<com.samsung.android.remoteappmode.IRemoteAppMode: void setLTWProtocolVersion(int)>
<com.samsung.android.remoteappmode.IRemoteAppMode: boolean unregisterRotationChangeListener(com.samsung.android.remoteappmode.IRotationChangeListener)>
<com.samsung.android.remoteappmode.IRemoteAppMode: void forceStopPackage(java.lang.String)>
<com.samsung.android.remoteappmode.IRemoteAppMode: void stopRFCommService()>
<com.samsung.android.remoteappmode.IRemoteAppMode: void disableSendingUserPresentIntent()>
<com.samsung.android.remoteappmode.IRemoteAppMode: boolean sendNotificationAction(android.service.notification.StatusBarNotification,int,android.content.Intent)>
<com.samsung.android.remoteappmode.IRemoteAppMode: void sendPendingIntent(android.app.PendingIntent)>
<android.companion.ICompanionDeviceService: void onDeviceAppeared(android.companion.AssociationInfo)>
<android.companion.ICompanionDeviceService: void onDeviceDisappeared(android.companion.AssociationInfo)>
<android.service.euicc.IEuiccServiceDumpResultCallback: void onComplete(java.lang.String)>
<android.hardware.input.IKeyboardBacklightListener: void onBrightnessChanged(int,android.hardware.input.IKeyboardBacklightState,boolean)>
<vendor.samsung.hardware.radio.channel.ISehRadioChannelCallback: int getInterfaceVersion()>
<vendor.samsung.hardware.radio.channel.ISehRadioChannelCallback: void receive(byte[])>
<vendor.samsung.hardware.radio.channel.ISehRadioChannelCallback: java.lang.String getInterfaceHash()>
<com.android.net.IProxyPortListener: void setProxyPort(int)>
<com.android.ims.internal.uce.presence.IPresenceService: com.android.ims.internal.uce.common.StatusCode publishMyCap(int,com.android.ims.internal.uce.presence.PresCapInfo,int)>
<com.android.ims.internal.uce.presence.IPresenceService: com.android.ims.internal.uce.common.StatusCode setNewFeatureTag(int,java.lang.String,com.android.ims.internal.uce.presence.PresServiceInfo,int)>
<com.android.ims.internal.uce.presence.IPresenceService: com.android.ims.internal.uce.common.StatusCode removeListener(int,com.android.ims.internal.uce.common.UceLong)>
<com.android.ims.internal.uce.presence.IPresenceService: com.android.ims.internal.uce.common.StatusCode getContactCap(int,java.lang.String,int)>
<com.android.ims.internal.uce.presence.IPresenceService: com.android.ims.internal.uce.common.StatusCode getVersion(int)>
<com.android.ims.internal.uce.presence.IPresenceService: com.android.ims.internal.uce.common.StatusCode addListener(int,com.android.ims.internal.uce.presence.IPresenceListener,com.android.ims.internal.uce.common.UceLong)>
<com.android.ims.internal.uce.presence.IPresenceService: com.android.ims.internal.uce.common.StatusCode getContactListCap(int,java.lang.String[],int)>
<com.android.ims.internal.uce.presence.IPresenceService: com.android.ims.internal.uce.common.StatusCode reenableService(int,int)>
<com.samsung.android.multicontrol.IMultiControlManager: void setCursorPosition(int,int,int)>
<com.samsung.android.multicontrol.IMultiControlManager: void setInteractive(boolean)>
<com.samsung.android.multicontrol.IMultiControlManager: void setProtocolVersion(int)>
<com.samsung.android.multicontrol.IMultiControlManager: void enableTriggerDetection(boolean)>
<com.samsung.android.multicontrol.IMultiControlManager: boolean isAllowed()>
<com.samsung.android.multicontrol.IMultiControlManager: void stopDeathChecker()>
<com.samsung.android.multicontrol.IMultiControlManager: void forceHideCursor(boolean)>
<com.samsung.android.multicontrol.IMultiControlManager: void setMultiControlOutOfFocus(boolean)>
<com.samsung.android.multicontrol.IMultiControlManager: int getProtocolVersion()>
<com.samsung.android.multicontrol.IMultiControlManager: void setTriggerThreshold(int)>
<com.samsung.android.multicontrol.IMultiControlManager: void resetInputFilter()>
<com.samsung.android.multicontrol.IMultiControlManager: void startDeathChecker(com.samsung.android.multicontrol.IMultiControlDeathChecker)>
<com.samsung.android.multicontrol.IMultiControlManager: void setInputFilter(android.view.IInputFilter,com.samsung.android.multicontrol.IInputFilterInstallListener)>
<com.android.internal.telephony.ICarrierPrivilegesCallback: void onCarrierPrivilegesChanged(java.util.List,int[])>
<com.android.internal.telephony.ICarrierPrivilegesCallback: void onCarrierServiceChanged(java.lang.String,int)>
<android.companion.IOnTransportsChangedListener: void onTransportsChanged(java.util.List)>
<android.security.rkp.IStoreUpgradedKeyCallback: void onError(java.lang.String)>
<android.security.rkp.IStoreUpgradedKeyCallback: void onSuccess()>
<com.android.ims.internal.IImsMultiEndpoint: void setListener(com.android.ims.internal.IImsExternalCallStateListener)>
<com.android.ims.internal.IImsMultiEndpoint: void requestImsExternalCallStateInfo()>
<android.app.IAppTask: void finishAndRemoveTask()>
<android.app.IAppTask: int startActivity(android.os.IBinder,java.lang.String,java.lang.String,android.content.Intent,java.lang.String,android.os.Bundle)>
<android.app.IAppTask: void moveToFront(android.app.IApplicationThread,java.lang.String)>
<android.app.IAppTask: void setExcludeFromRecents(boolean)>
<android.app.IAppTask: android.app.ActivityManager$RecentTaskInfo getTaskInfo()>
<android.media.INearbyMediaDevicesProvider: void unregisterNearbyDevicesCallback(android.media.INearbyMediaDevicesUpdateCallback)>
<android.media.INearbyMediaDevicesProvider: void registerNearbyDevicesCallback(android.media.INearbyMediaDevicesUpdateCallback)>
<android.service.euicc.IRetainSubscriptionsForFactoryResetCallback: void onComplete(int)>
<android.hardware.hdmi.IHdmiHotplugEventListener: void onReceived(android.hardware.hdmi.HdmiHotplugEvent)>
<android.net.IIpConnectivityMetrics: void logDefaultNetworkEvent(android.net.Network,int,boolean,android.net.LinkProperties,android.net.NetworkCapabilities,android.net.Network,int,android.net.LinkProperties,android.net.NetworkCapabilities)>
<android.net.IIpConnectivityMetrics: boolean addNetdEventCallback(int,android.net.INetdEventCallback)>
<android.net.IIpConnectivityMetrics: void logDefaultNetworkValidity(boolean)>
<android.net.IIpConnectivityMetrics: int logEvent(android.net.ConnectivityMetricsEvent)>
<android.net.IIpConnectivityMetrics: boolean removeNetdEventCallback(int)>
<android.telephony.ims.aidl.IImsRcsController: void triggerNetworkRegistration(int,android.telephony.ims.aidl.ISipDelegate,int,java.lang.String)>
<android.telephony.ims.aidl.IImsRcsController: void unregisterRcsAvailabilityCallback(int,android.telephony.ims.aidl.IImsCapabilityCallback)>
<android.telephony.ims.aidl.IImsRcsController: void registerUcePublishStateCallback(int,android.telephony.ims.aidl.IRcsUcePublishStateCallback)>
<android.telephony.ims.aidl.IImsRcsController: void unregisterImsRegistrationCallback(int,android.telephony.ims.aidl.IImsRegistrationCallback)>
<android.telephony.ims.aidl.IImsRcsController: boolean isUceSettingEnabled(int,java.lang.String,java.lang.String)>
<android.telephony.ims.aidl.IImsRcsController: void requestCapabilities(int,java.lang.String,java.lang.String,java.util.List,android.telephony.ims.aidl.IRcsUceControllerCallback)>
<android.telephony.ims.aidl.IImsRcsController: boolean isSipDelegateSupported(int)>
<android.telephony.ims.aidl.IImsRcsController: void registerRcsFeatureCallback(int,com.android.ims.internal.IImsServiceFeatureCallback)>
<android.telephony.ims.aidl.IImsRcsController: void requestAvailability(int,java.lang.String,java.lang.String,android.net.Uri,android.telephony.ims.aidl.IRcsUceControllerCallback)>
<android.telephony.ims.aidl.IImsRcsController: void registerSipDialogStateCallback(int,com.android.internal.telephony.ISipDialogStateCallback)>
<android.telephony.ims.aidl.IImsRcsController: void createSipDelegate(int,android.telephony.ims.DelegateRequest,java.lang.String,android.telephony.ims.aidl.ISipDelegateConnectionStateCallback,android.telephony.ims.aidl.ISipDelegateMessageCallback)>
<android.telephony.ims.aidl.IImsRcsController: boolean isAvailable(int,int,int)>
<android.telephony.ims.aidl.IImsRcsController: void unregisterUcePublishStateCallback(int,android.telephony.ims.aidl.IRcsUcePublishStateCallback)>
<android.telephony.ims.aidl.IImsRcsController: void unregisterImsFeatureCallback(com.android.ims.internal.IImsServiceFeatureCallback)>
<android.telephony.ims.aidl.IImsRcsController: int getUcePublishState(int)>
<android.telephony.ims.aidl.IImsRcsController: void destroySipDelegate(int,android.telephony.ims.aidl.ISipDelegate,int)>
<android.telephony.ims.aidl.IImsRcsController: void getImsRcsRegistrationTransportType(int,com.android.internal.telephony.IIntegerConsumer)>
<android.telephony.ims.aidl.IImsRcsController: void setUceSettingEnabled(int,boolean)>
<android.telephony.ims.aidl.IImsRcsController: void registerRcsAvailabilityCallback(int,android.telephony.ims.aidl.IImsCapabilityCallback)>
<android.telephony.ims.aidl.IImsRcsController: boolean isCapable(int,int,int)>
<android.telephony.ims.aidl.IImsRcsController: void unregisterSipDialogStateCallback(int,com.android.internal.telephony.ISipDialogStateCallback)>
<android.telephony.ims.aidl.IImsRcsController: void getImsRcsRegistrationState(int,com.android.internal.telephony.IIntegerConsumer)>
<android.telephony.ims.aidl.IImsRcsController: void registerImsRegistrationCallback(int,android.telephony.ims.aidl.IImsRegistrationCallback)>
<com.android.ims.internal.uce.uceservice.IUceService: int createOptionsService(com.android.ims.internal.uce.options.IOptionsListener,com.android.ims.internal.uce.common.UceLong)>
<com.android.ims.internal.uce.uceservice.IUceService: void destroyOptionsService(int)>
<com.android.ims.internal.uce.uceservice.IUceService: boolean isServiceStarted()>
<com.android.ims.internal.uce.uceservice.IUceService: boolean stopService()>
<com.android.ims.internal.uce.uceservice.IUceService: int createPresenceService(com.android.ims.internal.uce.presence.IPresenceListener,com.android.ims.internal.uce.common.UceLong)>
<com.android.ims.internal.uce.uceservice.IUceService: int createPresenceServiceForSubscription(com.android.ims.internal.uce.presence.IPresenceListener,com.android.ims.internal.uce.common.UceLong,java.lang.String)>
<com.android.ims.internal.uce.uceservice.IUceService: void destroyPresenceService(int)>
<com.android.ims.internal.uce.uceservice.IUceService: boolean startService(com.android.ims.internal.uce.uceservice.IUceListener)>
<com.android.ims.internal.uce.uceservice.IUceService: com.android.ims.internal.uce.options.IOptionsService getOptionsServiceForSubscription(java.lang.String)>
<com.android.ims.internal.uce.uceservice.IUceService: com.android.ims.internal.uce.presence.IPresenceService getPresenceService()>
<com.android.ims.internal.uce.uceservice.IUceService: com.android.ims.internal.uce.options.IOptionsService getOptionsService()>
<com.android.ims.internal.uce.uceservice.IUceService: int createOptionsServiceForSubscription(com.android.ims.internal.uce.options.IOptionsListener,com.android.ims.internal.uce.common.UceLong,java.lang.String)>
<com.android.ims.internal.uce.uceservice.IUceService: boolean getServiceStatus()>
<com.android.ims.internal.uce.uceservice.IUceService: com.android.ims.internal.uce.presence.IPresenceService getPresenceServiceForSubscription(java.lang.String)>
<com.android.internal.telephony.euicc.ISetNicknameCallback: void onComplete(int)>
<android.location.INSLocationManager: void setCallback(android.location.INSLocationCallback)>
<android.location.INSLocationManager: java.util.Map getGPSUsingApps()>
<android.location.INSLocationManager: void onGnssEventUpdated(java.lang.String)>
<android.location.INSLocationManager: void onGnssEngineStatusUpdated(boolean)>
<android.location.INSLocationManager: void onPassiveLocationReported(android.location.Location)>
<android.location.INSLocationManager: void onMessageUpdated(android.os.Message)>
<android.location.INSLocationManager: void onSatelliteStatusUpdated(android.location.GnssStatus)>
<android.location.INSLocationManager: void onStateUpdated(android.location.LocationConstants$STATE_TYPE,android.os.Bundle)>
<com.android.modules.utils.ISynchronousResultReceiver: void send(com.android.modules.utils.SynchronousResultReceiver$Result)>
<android.hardware.security.keymint.IKeyMintOperation: int getInterfaceVersion()>
<android.hardware.security.keymint.IKeyMintOperation: java.lang.String getInterfaceHash()>
<android.hardware.security.keymint.IKeyMintOperation: byte[] update(byte[],android.hardware.security.keymint.HardwareAuthToken,android.hardware.security.secureclock.TimeStampToken)>
<android.hardware.security.keymint.IKeyMintOperation: void abort()>
<android.hardware.security.keymint.IKeyMintOperation: void updateAad(byte[],android.hardware.security.keymint.HardwareAuthToken,android.hardware.security.secureclock.TimeStampToken)>
<android.hardware.security.keymint.IKeyMintOperation: byte[] finish(byte[],byte[],android.hardware.security.keymint.HardwareAuthToken,android.hardware.security.secureclock.TimeStampToken,byte[])>
<com.android.internal.statusbar.IAppClipsService: boolean canLaunchCaptureContentActivityForNote(int)>
<android.hardware.ICameraService: void notifySystemEvent(int,int[])>
<android.hardware.ICameraService: android.hardware.camera2.ICameraDeviceUser connectDevice(android.hardware.camera2.ICameraDeviceCallbacks,java.lang.String,java.lang.String,java.lang.String,int,int,int,boolean)>
<android.hardware.ICameraService: boolean applyExtraRequestsToRequestInjector(android.os.PersistableBundle[])>
<android.hardware.ICameraService: android.hardware.camera2.impl.CameraMetadataNative getCameraCharacteristics(java.lang.String,int,boolean)>
<android.hardware.ICameraService: void setTorchMode(java.lang.String,boolean,android.os.IBinder)>
<android.hardware.ICameraService: void notifyDeviceStateChange(long)>
<android.hardware.ICameraService: void startRemoteDeviceInjector(java.lang.String[],java.lang.String[],android.hardware.IRemoteDevice,android.hardware.IDeviceInjectorCallback)>
<android.hardware.ICameraService: android.hardware.camera2.params.VendorTagDescriptorCache getCameraVendorTagCache()>
<android.hardware.ICameraService: android.hardware.CameraInfo getCameraInfo(int,boolean)>
<android.hardware.ICameraService: android.hardware.camera2.ICameraInjectionSession injectCamera(java.lang.String,java.lang.String,java.lang.String,android.hardware.camera2.ICameraInjectionCallback)>
<android.hardware.ICameraService: void turnOnTorchWithStrengthLevel(java.lang.String,int,android.os.IBinder)>
<android.hardware.ICameraService: void notifyPkgListParamChange(java.lang.String[],java.lang.String[])>
<android.hardware.ICameraService: java.lang.String getLegacyParameters(int)>
<android.hardware.ICameraService: void updateRequestInjectorAllowedList(java.lang.String[])>
<android.hardware.ICameraService: android.hardware.camera2.params.VendorTagDescriptor getCameraVendorTagDescriptor()>
<android.hardware.ICameraService: void notifyDisplayConfigurationChange()>
<android.hardware.ICameraService: void startDeviceInjector(java.lang.String[],java.lang.String[],java.lang.String,android.hardware.IDeviceInjectorCallback)>
<android.hardware.ICameraService: void setDeviceInjectorPending(boolean)>
<android.hardware.ICameraService: int getTorchStrengthLevel(java.lang.String)>
<android.hardware.ICameraService: boolean isHiddenIdPermittedPackage(java.lang.String)>
<android.hardware.ICameraService: int getNumberOfCameras(int)>
<android.hardware.ICameraService: void notifyDeviceInjectorOrientationChange()>
<android.hardware.ICameraService: void removeListener(android.hardware.ICameraServiceListener)>
<android.hardware.ICameraService: android.hardware.camera2.utils.ConcurrentCameraIdCombination[] getConcurrentCameraIds()>
<android.hardware.ICameraService: void stopDeviceInjector()>
<android.hardware.ICameraService: boolean supportsCameraApi(java.lang.String,int)>
<android.hardware.ICameraService: boolean isConcurrentSessionConfigurationSupported(android.hardware.camera2.utils.CameraIdAndSessionConfiguration[],int)>
<android.hardware.ICameraService: android.hardware.CameraStatus[] addListener(android.hardware.ICameraServiceListener)>
<android.hardware.ICameraService: void notifyDeviceStateChangeSync(long)>
<android.hardware.ICameraService: java.lang.String reportExtensionSessionStats(android.hardware.CameraExtensionSessionStats)>
<android.hardware.ICameraService: android.hardware.ICamera connect(android.hardware.ICameraClient,int,java.lang.String,int,int,int,boolean,boolean)>
<android.hardware.ICameraService: boolean isHiddenPhysicalCamera(java.lang.String)>
<com.android.internal.telephony.ISetOpportunisticDataCallback: void onComplete(int)>
<android.view.IDisplayFoldListener: void onDisplayFoldChanged(int,boolean)>
<com.samsung.android.content.smartclip.IInputMethodInfoChangeListener: void onKeyboardClosed()>
<com.samsung.android.content.smartclip.IInputMethodInfoChangeListener: void onInputInfoChanged(com.android.internal.inputmethod.IRemoteInputConnection,android.view.inputmethod.EditorInfo)>
<android.view.IGraphicsStatsCallback: void onRotateGraphicsStatsBuffer()>
<android.hardware.gnss.IGnssDebug: java.lang.String getInterfaceHash()>
<android.hardware.gnss.IGnssDebug: android.hardware.gnss.IGnssDebug$DebugData getDebugData()>
<android.hardware.gnss.IGnssDebug: int getInterfaceVersion()>
<com.samsung.android.sepunion.IGoodCatchDispatcher: void onStop(java.lang.String)>
<com.samsung.android.sepunion.IGoodCatchDispatcher: void onStart(java.lang.String)>
<com.samsung.android.knox.ISemPersonaManager: int getSecureFolderId()>
<com.samsung.android.knox.ISemPersonaManager: boolean clearAttributes(int,int)>
<com.samsung.android.knox.ISemPersonaManager: java.lang.String getPersonaCacheValue(java.lang.String)>
<com.samsung.android.knox.ISemPersonaManager: boolean isContainerCorePackageUID(int)>
<com.samsung.android.knox.ISemPersonaManager: boolean isExternalStorageEnabled(int)>
<com.samsung.android.knox.ISemPersonaManager: int getFocusedUser()>
<com.samsung.android.knox.ISemPersonaManager: java.lang.String getRCPDataPolicyForUser(int,java.lang.String,java.lang.String)>
<com.samsung.android.knox.ISemPersonaManager: void setFocusedLauncherId(int)>
<com.samsung.android.knox.ISemPersonaManager: boolean setRCPDataPolicy(java.lang.String,java.lang.String,java.lang.String)>
<com.samsung.android.knox.ISemPersonaManager: boolean bindCoreServiceAsUser(android.content.ComponentName,android.app.IApplicationThread,android.os.IBinder,android.content.Intent,android.app.IServiceConnection,int,int)>
<com.samsung.android.knox.ISemPersonaManager: java.lang.String getCustomResource(int,java.lang.String)>
<com.samsung.android.knox.ISemPersonaManager: void startTermsActivity()>
<com.samsung.android.knox.ISemPersonaManager: android.os.Bundle getDualDARProfile()>
<com.samsung.android.knox.ISemPersonaManager: java.util.List getUpdatedListWithAppSeparation(java.util.List)>
<com.samsung.android.knox.ISemPersonaManager: boolean setPackageSettingInstalled(java.lang.String,boolean,int)>
<com.samsung.android.knox.ISemPersonaManager: boolean isPossibleAddAppsToContainer(java.lang.String,int)>
<com.samsung.android.knox.ISemPersonaManager: java.lang.String getRCPDataPolicy(java.lang.String,java.lang.String)>
<com.samsung.android.knox.ISemPersonaManager: android.os.Bundle getSeparationConfigfromCache()>
<com.samsung.android.knox.ISemPersonaManager: int getFocusedLauncherId()>
<com.samsung.android.knox.ISemPersonaManager: boolean isShareClipboardDataToOwnerAllowed(int)>
<com.samsung.android.knox.ISemPersonaManager: java.lang.String getECName(int)>
<com.samsung.android.knox.ISemPersonaManager: void sendRequestKeyStatus(int)>
<com.samsung.android.knox.ISemPersonaManager: java.util.List getSeparatedAppsList()>
<com.samsung.android.knox.ISemPersonaManager: boolean isFOTAUpgrade()>
<com.samsung.android.knox.ISemPersonaManager: android.content.ComponentName getAdminComponentName(int)>
<com.samsung.android.knox.ISemPersonaManager: boolean isInSeparatedAppsOnly(java.lang.String)>
<com.samsung.android.knox.ISemPersonaManager: void CMFAUnLock(int)>
<com.samsung.android.knox.ISemPersonaManager: android.os.Bundle sendProxyMessage(java.lang.String,java.lang.String,android.os.Bundle)>
<com.samsung.android.knox.ISemPersonaManager: boolean broadcastIntentThroughPersona(android.content.Intent,int)>
<com.samsung.android.knox.ISemPersonaManager: com.samsung.android.knox.IBasicCommand getKnoxForesightService()>
<com.samsung.android.knox.ISemPersonaManager: boolean isMoveFilesToOwnerAllowed(int)>
<com.samsung.android.knox.ISemPersonaManager: boolean updatePersonaCache(java.lang.String,java.lang.String)>
<com.samsung.android.knox.ISemPersonaManager: int getFotaVersion()>
<com.samsung.android.knox.ISemPersonaManager: void logDpmsKA(android.os.Bundle)>
<com.samsung.android.knox.ISemPersonaManager: boolean sendKnoxForesightBroadcast(android.content.Intent)>
<com.samsung.android.knox.ISemPersonaManager: void refreshLockTimer(int)>
<com.samsung.android.knox.ISemPersonaManager: boolean registerSystemPersonaObserver(android.content.pm.ISystemPersonaObserver)>
<com.samsung.android.knox.ISemPersonaManager: boolean getPersonaUserHasBeenShutdownBefore(int)>
<com.samsung.android.knox.ISemPersonaManager: void setAppSeparationDefaultPolicy(int)>
<com.samsung.android.knox.ISemPersonaManager: boolean setSecureFolderPolicy(java.lang.String,java.util.List,int)>
<com.samsung.android.knox.ISemPersonaManager: boolean isKnoxWindowExist(int,int,int)>
<com.samsung.android.knox.ISemPersonaManager: boolean isAppSeparationPresent()>
<com.samsung.android.knox.ISemPersonaManager: boolean setPersonalModeName(int,java.lang.String)>
<com.samsung.android.knox.ISemPersonaManager: byte[] getKnoxIcon(java.lang.String,java.lang.String,int)>
<com.samsung.android.knox.ISemPersonaManager: void hideMultiWindows(int)>
<com.samsung.android.knox.ISemPersonaManager: int getContainerOrder(int)>
<com.samsung.android.knox.ISemPersonaManager: boolean isFotaUpgradeVersionChanged()>
<com.samsung.android.knox.ISemPersonaManager: int setDualDARProfile(android.os.Bundle)>
<com.samsung.android.knox.ISemPersonaManager: boolean hasLicensePermission(int,java.lang.String)>
<com.samsung.android.knox.ISemPersonaManager: boolean setProfileName(int,java.lang.String)>
<com.samsung.android.knox.ISemPersonaManager: boolean isKnoxProfileActivePasswordSufficientForParent(int)>
<com.samsung.android.knox.ISemPersonaManager: java.lang.String getSecureFolderName()>
<com.samsung.android.knox.ISemPersonaManager: boolean isMoveFilesToContainerAllowed(int)>
<com.samsung.android.knox.ISemPersonaManager: java.lang.String getProfileName(int)>
<com.samsung.android.knox.ISemPersonaManager: boolean setAttributes(int,int)>
<com.samsung.android.knox.ISemPersonaManager: java.util.List getMoveToKnoxMenuList(int)>
<com.samsung.android.knox.ISemPersonaManager: boolean isPasswordSufficientAfterKnoxProfileUnification(int)>
<com.samsung.android.knox.ISemPersonaManager: boolean isShareClipboardDataToContainerAllowed(int)>
<com.samsung.android.knox.ISemPersonaManager: boolean appliedPasswordPolicy(int)>
<com.samsung.android.knox.ISemPersonaManager: void CMFALock(int)>
<com.samsung.android.knox.ISemPersonaManager: int getAttributes(int)>
<com.samsung.android.knox.ISemPersonaManager: java.util.List getSecureFolderPolicy(java.lang.String,int)>
<com.samsung.android.knox.ISemPersonaManager: void startCountrySelectionActivity(boolean)>
<com.samsung.android.knox.ISemPersonaManager: java.lang.String getContainerName(int)>
<com.samsung.android.knox.ISemPersonaManager: java.lang.String getPersonalModeName(int)>
<com.samsung.android.knox.ISemPersonaManager: void updateProfileActivityTimeFromKnox(int,long)>
<com.samsung.android.knox.ISemPersonaManager: java.util.List getProfiles(int,boolean)>
<com.samsung.android.knox.ISemPersonaManager: java.lang.String getWorkspaceName(android.content.pm.UserInfo,boolean)>
<com.samsung.android.knox.ISemPersonaManager: void postPwdChangeNotificationForDeviceOwner(int)>
<com.samsung.android.knox.ISemPersonaManager: boolean isContainerService(int)>
<com.samsung.android.knox.ISemPersonaManager: void addAppPackageNameToAllowList(int,java.util.List)>
<com.samsung.android.knox.ISemPersonaManager: boolean startActivityThroughPersona(android.content.Intent)>
<com.samsung.android.biometrics.ISemBiometricSysUiCallback: void onError(int,int,int)>
<com.samsung.android.biometrics.ISemBiometricSysUiCallback: void onEvent(int,int,int)>
<com.samsung.android.biometrics.ISemBiometricSysUiCallback: void onTouchEvent(int,int)>
<com.samsung.android.biometrics.ISemBiometricSysUiCallback: void onSysUiDismissed(int,int,byte[])>
<android.telephony.data.IDataService: void createDataServiceProvider(int)>
<android.telephony.data.IDataService: void cancelHandover(int,int,android.telephony.data.IDataServiceCallback)>
<android.telephony.data.IDataService: void unregisterForUnthrottleApn(int,android.telephony.data.IDataServiceCallback)>
<android.telephony.data.IDataService: void requestDataCallList(int,android.telephony.data.IDataServiceCallback)>
<android.telephony.data.IDataService: void registerForUnthrottleApn(int,android.telephony.data.IDataServiceCallback)>
<android.telephony.data.IDataService: void removeDataServiceProvider(int)>
<android.telephony.data.IDataService: void setupDataCall(int,int,android.telephony.data.DataProfile,boolean,boolean,int,android.net.LinkProperties,int,android.telephony.data.NetworkSliceInfo,android.telephony.data.TrafficDescriptor,boolean,android.telephony.data.IDataServiceCallback)>
<android.telephony.data.IDataService: void deactivateDataCall(int,int,int,android.telephony.data.IDataServiceCallback)>
<android.telephony.data.IDataService: void registerForDataCallListChanged(int,android.telephony.data.IDataServiceCallback)>
<android.telephony.data.IDataService: void setInitialAttachApn(int,android.telephony.data.DataProfile,boolean,android.telephony.data.IDataServiceCallback)>
<android.telephony.data.IDataService: void setDataProfile(int,java.util.List,boolean,android.telephony.data.IDataServiceCallback)>
<android.telephony.data.IDataService: void unregisterForDataCallListChanged(int,android.telephony.data.IDataServiceCallback)>
<android.telephony.data.IDataService: void startHandover(int,int,android.telephony.data.IDataServiceCallback)>
<android.media.soundtrigger_middleware.IInjectRecognitionEvent: void triggerAbortRecognition()>
<android.media.soundtrigger_middleware.IInjectRecognitionEvent: void triggerRecognitionEvent(byte[],android.media.soundtrigger.PhraseRecognitionExtra[])>
<android.companion.virtual.audio.IAudioConfigChangedCallback: void onPlaybackConfigChanged(java.util.List)>
<android.companion.virtual.audio.IAudioConfigChangedCallback: void onRecordingConfigChanged(java.util.List)>
<android.service.displayhash.IDisplayHashingService: void generateDisplayHash(byte[],android.hardware.HardwareBuffer,android.graphics.Rect,java.lang.String,android.os.RemoteCallback)>
<android.service.displayhash.IDisplayHashingService: void verifyDisplayHash(byte[],android.view.displayhash.DisplayHash,android.os.RemoteCallback)>
<android.service.displayhash.IDisplayHashingService: void getIntervalBetweenRequestsMillis(android.os.RemoteCallback)>
<android.service.displayhash.IDisplayHashingService: void getDisplayHashAlgorithms(android.os.RemoteCallback)>
<android.service.autofill.IInlineSuggestionRenderService: void renderSuggestion(android.service.autofill.IInlineSuggestionUiCallback,android.service.autofill.InlinePresentation,int,int,android.os.IBinder,int,int,int)>
<android.service.autofill.IInlineSuggestionRenderService: void getInlineSuggestionsRendererInfo(android.os.RemoteCallback)>
<android.service.autofill.IInlineSuggestionRenderService: void destroySuggestionViews(int,int)>
<android.window.ITaskFragmentOrganizer: void onTransactionReady(android.window.TaskFragmentTransaction)>
<android.hardware.input.IInputDevicesChangedListener: void onInputDevicesChanged(int[])>
<com.samsung.android.service.vaultkeeper.IVaultKeeperService: int write(java.lang.String,int,byte[],byte[],byte[])>
<com.samsung.android.service.vaultkeeper.IVaultKeeperService: int checkDataWritable(java.lang.String)>
<com.samsung.android.service.vaultkeeper.IVaultKeeperService: boolean migrationStorage(java.lang.String)>
<com.samsung.android.service.vaultkeeper.IVaultKeeperService: byte[] sensitiveBox(java.lang.String,int,int[])>
<com.samsung.android.service.vaultkeeper.IVaultKeeperService: int destroy(java.lang.String,byte[],byte[],byte[])>
<com.samsung.android.service.vaultkeeper.IVaultKeeperService: int generateHotpCode(java.lang.String)>
<com.samsung.android.service.vaultkeeper.IVaultKeeperService: boolean verifyCertificate(java.lang.String,byte[])>
<com.samsung.android.service.vaultkeeper.IVaultKeeperService: byte[] encryptMessage(java.lang.String,byte[])>
<com.samsung.android.service.vaultkeeper.IVaultKeeperService: boolean isInitialized(java.lang.String)>
<com.samsung.android.service.vaultkeeper.IVaultKeeperService: byte[] read(java.lang.String,int,int[])>
<com.samsung.android.service.vaultkeeper.IVaultKeeperService: int initialize(java.lang.String,byte[],byte[],byte[],byte[])>
<android.os.IPowerManager: void updateWakeLockUidsAsync(android.os.IBinder,int[])>
<android.os.IPowerManager: void crash(java.lang.String)>
<android.os.IPowerManager: void wakeUp(long,int,java.lang.String,java.lang.String)>
<android.os.IPowerManager: boolean setPowerModeChecked(int,boolean)>
<android.os.IPowerManager: boolean isLowPowerStandbyEnabled()>
<android.os.IPowerManager: android.os.ParcelDuration getBatteryDischargePrediction()>
<android.os.IPowerManager: boolean isBatteryDischargePredictionPersonalized()>
<android.os.IPowerManager: boolean isDisplayInteractive(int)>
<android.os.IPowerManager: int getLastShutdownReason()>
<android.os.IPowerManager: void updateWakeLockUids(android.os.IBinder,int[])>
<android.os.IPowerManager: boolean isAmbientDisplaySuppressedForTokenByApp(java.lang.String,int)>
<android.os.IPowerManager: boolean isLowPowerStandbySupported()>
<android.os.IPowerManager: void setPowerBoost(int,int)>
<android.os.IPowerManager: java.util.List getActiveLowPowerStandbyPorts()>
<android.os.IPowerManager: boolean isReasonAllowedInLowPowerStandby(int)>
<android.os.IPowerManager: boolean isWakeLockLevelSupported(int)>
<android.os.IPowerManager: void releaseWakeLockAsync(android.os.IBinder,int)>
<android.os.IPowerManager: void releaseWakeLock(android.os.IBinder,int)>
<android.os.IPowerManager: void updateCoverState(boolean)>
<android.os.IPowerManager: android.os.PowerSaveState getPowerSaveState(int)>
<android.os.IPowerManager: boolean isExemptFromLowPowerStandby()>
<android.os.IPowerManager: void setBatteryDischargePrediction(android.os.ParcelDuration,boolean)>
<android.os.IPowerManager: void acquireWakeLockWithUid(android.os.IBinder,int,java.lang.String,java.lang.String,int,int,android.os.IWakeLockCallback)>
<android.os.IPowerManager: void shutdown(boolean,java.lang.String,boolean)>
<android.os.IPowerManager: int getLastSleepReason()>
<android.os.IPowerManager: boolean isDeviceIdleMode()>
<android.os.IPowerManager: boolean setAdaptivePowerSavePolicy(android.os.BatterySaverPolicyConfig)>
<android.os.IPowerManager: void releaseLowPowerStandbyPorts(android.os.IBinder)>
<android.os.IPowerManager: void setLCDFlashMode(boolean,android.os.IBinder)>
<android.os.IPowerManager: void updateWakeLockCallback(android.os.IBinder,android.os.IWakeLockCallback)>
<android.os.IPowerManager: boolean isAmbientDisplaySuppressed()>
<android.os.IPowerManager: void setLowPowerStandbyEnabled(boolean)>
<android.os.IPowerManager: void setAttentionLight(boolean,int)>
<android.os.IPowerManager: boolean forceSuspend()>
<android.os.IPowerManager: void acquireWakeLockAsync(android.os.IBinder,int,java.lang.String,java.lang.String,android.os.WorkSource,java.lang.String)>
<android.os.IPowerManager: void setScreenCurtainEnabled(android.os.IBinder,boolean,int)>
<android.os.IPowerManager: java.lang.String[] getWakeLockPackageList()>
<android.os.IPowerManager: void setScreenBrightnessScaleFactor(float,android.os.IBinder)>
<android.os.IPowerManager: void boostScreenBrightness(long)>
<android.os.IPowerManager: boolean areAutoPowerSaveModesEnabled()>
<android.os.IPowerManager: android.os.IPowerManager$LowPowerStandbyPolicy getLowPowerStandbyPolicy()>
<android.os.IPowerManager: void goToSleep(long,int,int)>
<android.os.IPowerManager: void setProximityDebounceTime(android.os.IBinder,int,int)>
<android.os.IPowerManager: java.lang.String getPackageNameOnScreenCurtain()>
<android.os.IPowerManager: boolean isFeatureAllowedInLowPowerStandby(java.lang.String)>
<android.os.IPowerManager: boolean isInteractive()>
<android.os.IPowerManager: void nap(long)>
<android.os.IPowerManager: void setFreezingScreenBrightness(boolean)>
<android.os.IPowerManager: void goToSleepWithDisplayId(int,long,int,int)>
<android.os.IPowerManager: void setDozeAfterScreenOff(boolean)>
<android.os.IPowerManager: boolean setPowerSaveModeEnabled(boolean)>
<android.os.IPowerManager: void suppressAmbientDisplay(java.lang.String,boolean)>
<android.os.IPowerManager: void setLowPowerStandbyActiveDuringMaintenance(boolean)>
<android.os.IPowerManager: boolean isScreenCurtainEntryAvailable()>
<android.os.IPowerManager: long getLastUserActivityTime(int)>
<android.os.IPowerManager: boolean isScreenBrightnessBoosted()>
<android.os.IPowerManager: void setAutoBrightnessLimit(int,int,boolean)>
<android.os.IPowerManager: void setStayOnSetting(int)>
<android.os.IPowerManager: float getBrightnessConstraint(int)>
<android.os.IPowerManager: void setMasterBrightnessLimit(int,int,int)>
<android.os.IPowerManager: boolean isAmbientDisplaySuppressedForToken(java.lang.String)>
<android.os.IPowerManager: void reboot(boolean,java.lang.String,boolean)>
<android.os.IPowerManager: void updateWakeLockWorkSource(android.os.IBinder,android.os.WorkSource,java.lang.String)>
<android.os.IPowerManager: boolean isPowerSaveMode()>
<android.os.IPowerManager: int getPowerSaveModeTrigger()>
<android.os.IPowerManager: boolean setDynamicPowerSaveHint(boolean,int)>
<android.os.IPowerManager: void userActivity(int,long,int,int)>
<android.os.IPowerManager: float getCurrentBrightness(boolean)>
<android.os.IPowerManager: void systemReboot(java.lang.String)>
<android.os.IPowerManager: void acquireWakeLock(android.os.IBinder,int,java.lang.String,java.lang.String,android.os.WorkSource,java.lang.String,int,android.os.IWakeLockCallback)>
<android.os.IPowerManager: boolean setAdaptivePowerSaveEnabled(boolean)>
<android.os.IPowerManager: boolean isInteractiveForDisplay(int)>
<android.os.IPowerManager: void rebootSafeMode(boolean,boolean)>
<android.os.IPowerManager: boolean isLightDeviceIdleMode()>
<android.os.IPowerManager: void switchForceLcdBacklightOffState()>
<android.os.IPowerManager: void setEarlyWakeUp(boolean)>
<android.os.IPowerManager: void setLowPowerStandbyPolicy(android.os.IPowerManager$LowPowerStandbyPolicy)>
<android.os.IPowerManager: void setCoverType(int)>
<android.os.IPowerManager: void forceLowPowerStandbyActive(boolean)>
<android.os.IPowerManager: void setPowerMode(int,boolean)>
<android.os.IPowerManager: boolean isAmbientDisplayAvailable()>
<android.os.IPowerManager: boolean setFullPowerSavePolicy(android.os.BatterySaverPolicyConfig)>
<android.os.IPowerManager: android.os.BatterySaverPolicyConfig getFullPowerSavePolicy()>
<android.os.IPowerManager: boolean isScreenCurtainEnabled()>
<android.os.IPowerManager: void acquireLowPowerStandbyPorts(android.os.IBinder,java.util.List)>
<android.hardware.biometrics.fingerprint.ISessionCallback: void onLockoutPermanent()>
<android.hardware.biometrics.fingerprint.ISessionCallback: void onChallengeGenerated(long)>
<android.hardware.biometrics.fingerprint.ISessionCallback: int getInterfaceVersion()>
<android.hardware.biometrics.fingerprint.ISessionCallback: void onError(byte,int)>
<android.hardware.biometrics.fingerprint.ISessionCallback: void onEnrollmentProgress(int,int)>
<android.hardware.biometrics.fingerprint.ISessionCallback: void onLockoutCleared()>
<android.hardware.biometrics.fingerprint.ISessionCallback: void onEnrollmentsEnumerated(int[])>
<android.hardware.biometrics.fingerprint.ISessionCallback: void onEnrollmentsRemoved(int[])>
<android.hardware.biometrics.fingerprint.ISessionCallback: void onAcquired(byte,int)>
<android.hardware.biometrics.fingerprint.ISessionCallback: void onChallengeRevoked(long)>
<android.hardware.biometrics.fingerprint.ISessionCallback: void onLockoutTimed(long)>
<android.hardware.biometrics.fingerprint.ISessionCallback: void onAuthenticatorIdInvalidated(long)>
<android.hardware.biometrics.fingerprint.ISessionCallback: void onAuthenticatorIdRetrieved(long)>
<android.hardware.biometrics.fingerprint.ISessionCallback: void onSessionClosed()>
<android.hardware.biometrics.fingerprint.ISessionCallback: void onAuthenticationSucceeded(int,android.hardware.keymaster.HardwareAuthToken)>
<android.hardware.biometrics.fingerprint.ISessionCallback: void onAuthenticationFailed()>
<android.hardware.biometrics.fingerprint.ISessionCallback: void onInteractionDetected()>
<android.hardware.biometrics.fingerprint.ISessionCallback: java.lang.String getInterfaceHash()>
<android.telephony.satellite.stub.ISatelliteListener: void onSatelliteModemStateChanged(int)>
<android.telephony.satellite.stub.ISatelliteListener: void onSatelliteProvisionStateChanged(boolean)>
<android.telephony.satellite.stub.ISatelliteListener: void onSatelliteDatagramReceived(android.telephony.satellite.stub.SatelliteDatagram,int)>
<android.telephony.satellite.stub.ISatelliteListener: void onSatellitePositionChanged(android.telephony.satellite.stub.PointingInfo)>
<android.telephony.satellite.stub.ISatelliteListener: void onPendingDatagrams()>
<android.nfc.ITagRemovedCallback: void onTagRemoved()>
<android.net.vcn.IVcnUnderlyingNetworkPolicyListener: void onPolicyChanged()>
<com.samsung.android.hardware.display.ISemMdnieManager: boolean afpcDataApply()>
<com.samsung.android.hardware.display.ISemMdnieManager: int getScreenMode()>
<com.samsung.android.hardware.display.ISemMdnieManager: int[] getSupportedContentMode()>
<com.samsung.android.hardware.display.ISemMdnieManager: boolean setContentMode(int)>
<com.samsung.android.hardware.display.ISemMdnieManager: void updateAlwaysOnDisplay(boolean,int)>
<com.samsung.android.hardware.display.ISemMdnieManager: boolean disableNightMode()>
<com.samsung.android.hardware.display.ISemMdnieManager: boolean setmDNIeScreenCurtain(boolean)>
<com.samsung.android.hardware.display.ISemMdnieManager: boolean setColorVision(boolean,int,int)>
<com.samsung.android.hardware.display.ISemMdnieManager: int[] getSupportedScreenMode()>
<com.samsung.android.hardware.display.ISemMdnieManager: boolean isContentModeSupported()>
<com.samsung.android.hardware.display.ISemMdnieManager: boolean enableNightMode(int)>
<com.samsung.android.hardware.display.ISemMdnieManager: boolean setLightNotificationMode(boolean)>
<com.samsung.android.hardware.display.ISemMdnieManager: boolean setNightModeBlock(boolean)>
<com.samsung.android.hardware.display.ISemMdnieManager: int getNightModeStep()>
<com.samsung.android.hardware.display.ISemMdnieManager: boolean isScreenModeSupported()>
<com.samsung.android.hardware.display.ISemMdnieManager: boolean setWhiteRGB(int,int,int)>
<com.samsung.android.hardware.display.ISemMdnieManager: int getContentMode()>
<com.samsung.android.hardware.display.ISemMdnieManager: boolean setColorFadeNightDim(boolean)>
<com.samsung.android.hardware.display.ISemMdnieManager: boolean afpcDataOff()>
<com.samsung.android.hardware.display.ISemMdnieManager: boolean afpcDataWrite()>
<com.samsung.android.hardware.display.ISemMdnieManager: boolean setmDNIeColorBlind(boolean,int[])>
<com.samsung.android.hardware.display.ISemMdnieManager: boolean setNightModeStep(int)>
<com.samsung.android.hardware.display.ISemMdnieManager: boolean setNightMode(boolean,int)>
<com.samsung.android.hardware.display.ISemMdnieManager: boolean afpcWorkOff()>
<com.samsung.android.hardware.display.ISemMdnieManager: boolean setmDNIeNegative(boolean)>
<com.samsung.android.hardware.display.ISemMdnieManager: boolean setmDNIeAccessibilityMode(int,boolean)>
<com.samsung.android.hardware.display.ISemMdnieManager: boolean afpcDataVerify()>
<com.samsung.android.hardware.display.ISemMdnieManager: boolean isNightModeSupported()>
<com.samsung.android.hardware.display.ISemMdnieManager: boolean setAmoledACL(int)>
<com.samsung.android.hardware.display.ISemMdnieManager: boolean getNightModeBlock()>
<com.samsung.android.hardware.display.ISemMdnieManager: boolean setScreenMode(int)>
<com.samsung.android.hardware.display.ISemMdnieManager: boolean setmDNIeEmergencyMode(boolean)>
<android.os.IRecoverySystemProgressListener: void onProgress(int)>
<vendor.samsung.hardware.radio.messaging.ISehRadioMessaging: void setResponseFunctions(vendor.samsung.hardware.radio.messaging.ISehRadioMessagingResponse,vendor.samsung.hardware.radio.messaging.ISehRadioMessagingIndication)>
<vendor.samsung.hardware.radio.messaging.ISehRadioMessaging: void sendSms(int,vendor.samsung.hardware.radio.messaging.SehGsmSmsMessage)>
<vendor.samsung.hardware.radio.messaging.ISehRadioMessaging: void writeSmsToSim(int,vendor.samsung.hardware.radio.messaging.SehSimMsgArgs)>
<vendor.samsung.hardware.radio.messaging.ISehRadioMessaging: int getInterfaceVersion()>
<vendor.samsung.hardware.radio.messaging.ISehRadioMessaging: void sendCdmaSms(int,vendor.samsung.hardware.radio.messaging.SehCdmaSmsMessage)>
<vendor.samsung.hardware.radio.messaging.ISehRadioMessaging: java.lang.String getInterfaceHash()>
<vendor.samsung.hardware.radio.messaging.ISehRadioMessaging: void sendSMSExpectMore(int,vendor.samsung.hardware.radio.messaging.SehGsmSmsMessage)>
<vendor.samsung.hardware.radio.messaging.ISehRadioMessaging: void getImsRegistrationState(int)>
<vendor.samsung.hardware.radio.messaging.ISehRadioMessaging: void getStoredMsgCountFromSim(int)>
<vendor.samsung.hardware.radio.messaging.ISehRadioMessaging: void sendCdmaSmsExpectMore(int,vendor.samsung.hardware.radio.messaging.SehCdmaSmsMessage)>
<vendor.samsung.hardware.radio.messaging.ISehRadioMessaging: void getCellBroadcastConfig(int)>
<vendor.samsung.hardware.radio.messaging.ISehRadioMessaging: void readSmsFromSim(int,int)>
<android.hardware.gnss.IGnssBatchingCallback: int getInterfaceVersion()>
<android.hardware.gnss.IGnssBatchingCallback: void gnssLocationBatchCb(android.hardware.gnss.GnssLocation[])>
<android.hardware.gnss.IGnssBatchingCallback: java.lang.String getInterfaceHash()>
<android.app.IApplicationThread: void dumpGfxInfo(android.os.ParcelFileDescriptor,java.lang.String[])>
<android.app.IApplicationThread: void clearDnsCache()>
<android.app.IApplicationThread: void bindApplication(java.lang.String,android.content.pm.ApplicationInfo,java.lang.String,java.lang.String,android.content.pm.ProviderInfoList,android.content.ComponentName,android.app.ProfilerInfo,android.os.Bundle,android.app.IInstrumentationWatcher,android.app.IUiAutomationConnection,int,boolean,boolean,boolean,boolean,android.content.res.Configuration,android.content.res.CompatibilityInfo,java.util.Map,android.os.Bundle,float,java.lang.String,android.content.AutofillOptions,android.content.ContentCaptureOptions,long[],android.os.SharedMemory,long,long,int,boolean)>
<android.app.IApplicationThread: void scheduleApplicationInfoChanged(android.content.pm.ApplicationInfo)>
<android.app.IApplicationThread: void dumpResources(android.os.ParcelFileDescriptor,android.os.RemoteCallback)>
<android.app.IApplicationThread: void scheduleLowMemory()>
<android.app.IApplicationThread: void requestDirectActions(android.os.IBinder,com.android.internal.app.IVoiceInteractor,android.os.RemoteCallback,android.os.RemoteCallback)>
<android.app.IApplicationThread: void scheduleTransaction(android.app.servertransaction.ClientTransaction)>
<android.app.IApplicationThread: void dumpDbInfo(android.os.ParcelFileDescriptor,java.lang.String[])>
<android.app.IApplicationThread: void scheduleServiceArgs(android.os.IBinder,android.content.pm.ParceledListSlice)>
<android.app.IApplicationThread: void runIsolatedEntryPoint(java.lang.String,java.lang.String[])>
<android.app.IApplicationThread: void dumpMemInfoProto(android.os.ParcelFileDescriptor,android.os.Debug$MemoryInfo,boolean,boolean,boolean,boolean,java.lang.String[])>
<android.app.IApplicationThread: void setSchedulingGroup(int)>
<android.app.IApplicationThread: void scheduleExit()>
<android.app.IApplicationThread: void schedulePing(android.os.RemoteCallback)>
<android.app.IApplicationThread: void attachAgent(java.lang.String)>
<android.app.IApplicationThread: void attachStartupAgents(java.lang.String)>
<android.app.IApplicationThread: void scheduleTrimMemory(int)>
<android.app.IApplicationThread: void scheduleStopService(android.os.IBinder)>
<android.app.IApplicationThread: void dumpProvider(android.os.ParcelFileDescriptor,android.os.IBinder,java.lang.String[])>
<android.app.IApplicationThread: void scheduleReceiverList(java.util.List)>
<android.app.IApplicationThread: void scheduleReceiver(android.content.Intent,android.content.pm.ActivityInfo,android.content.res.CompatibilityInfo,int,java.lang.String,android.os.Bundle,boolean,boolean,int,int,int,java.lang.String)>
<android.app.IApplicationThread: void scheduleRegisteredReceiver(android.content.IIntentReceiver,android.content.Intent,int,java.lang.String,android.os.Bundle,boolean,boolean,boolean,int,int,int,java.lang.String)>
<android.app.IApplicationThread: void stopBinderTrackingAndDump(android.os.ParcelFileDescriptor)>
<android.app.IApplicationThread: void dispatchPackageBroadcast(int,java.lang.String[])>
<android.app.IApplicationThread: void scheduleTranslucentConversionComplete(android.os.IBinder,boolean)>
<android.app.IApplicationThread: void setCoreSettings(android.os.Bundle)>
<android.app.IApplicationThread: void scheduleInstallProvider(android.content.pm.ProviderInfo)>
<android.app.IApplicationThread: void stopBinderTrackingAndDumpSystemServer(android.os.ParcelFileDescriptor,java.lang.String,java.lang.String,int,int)>
<android.app.IApplicationThread: void scheduleCrash(java.lang.String,int,android.os.Bundle)>
<android.app.IApplicationThread: void setHttpProxyInfo(android.net.ProxyInfoWrapper)>
<android.app.IApplicationThread: void scheduleLocalVoiceInteractionStarted(android.os.IBinder,com.android.internal.app.IVoiceInteractor)>
<android.app.IApplicationThread: void scheduleSuicide()>
<android.app.IApplicationThread: void processInBackground()>
<android.app.IApplicationThread: void setFlingerFlag(java.lang.String)>
<android.app.IApplicationThread: void scheduleTimeoutService(android.os.IBinder,int)>
<android.app.IApplicationThread: void performDirectAction(android.os.IBinder,java.lang.String,android.os.Bundle,android.os.RemoteCallback,android.os.RemoteCallback)>
<android.app.IApplicationThread: void forceGc()>
<android.app.IApplicationThread: void updateTimeZone()>
<android.app.IApplicationThread: void dumpMemInfo(android.os.ParcelFileDescriptor,android.os.Debug$MemoryInfo,boolean,boolean,boolean,boolean,boolean,java.lang.String[])>
<android.app.IApplicationThread: void profilerControl(boolean,android.app.ProfilerInfo,int)>
<android.app.IApplicationThread: void scheduleCreateBackupAgent(android.content.pm.ApplicationInfo,int,int,int)>
<android.app.IApplicationThread: void unstableProviderDied(android.os.IBinder)>
<android.app.IApplicationThread: void updateUiTranslationState(android.os.IBinder,int,android.view.translation.TranslationSpec,android.view.translation.TranslationSpec,java.util.List,android.view.translation.UiTranslationSpec)>
<android.app.IApplicationThread: void dumpHeap(boolean,boolean,boolean,java.lang.String,android.os.ParcelFileDescriptor,android.os.RemoteCallback)>
<android.app.IApplicationThread: void requestAssistContextExtras(android.os.IBinder,android.os.IBinder,int,int,int)>
<android.app.IApplicationThread: void scheduleBindService(android.os.IBinder,android.content.Intent,boolean,int,long)>
<android.app.IApplicationThread: void scheduleEnterAnimationComplete(android.os.IBinder)>
<android.app.IApplicationThread: void setProcessState(int)>
<android.app.IApplicationThread: void dumpService(android.os.ParcelFileDescriptor,android.os.IBinder,java.lang.String[])>
<android.app.IApplicationThread: void startBinderTracking()>
<android.app.IApplicationThread: void dumpCacheInfo(android.os.ParcelFileDescriptor,java.lang.String[])>
<android.app.IApplicationThread: void getProfileLength(java.lang.String)>
<android.app.IApplicationThread: void scheduleDestroyBackupAgent(android.content.pm.ApplicationInfo,int)>
<android.app.IApplicationThread: void updatePackageCompatibilityInfo(java.lang.String,android.content.res.CompatibilityInfo)>
<android.app.IApplicationThread: void scheduleUnbindService(android.os.IBinder,android.content.Intent)>
<android.app.IApplicationThread: void dumpActivity(android.os.ParcelFileDescriptor,android.os.IBinder,java.lang.String,java.lang.String[])>
<android.app.IApplicationThread: void setNetworkBlockSeq(long)>
<android.app.IApplicationThread: void updateTimePrefs(int)>
<android.app.IApplicationThread: void notifyCleartextNetwork(byte[])>
<android.app.IApplicationThread: void clearIdsTrainingData(boolean)>
<android.app.IApplicationThread: void handleTrustStorageUpdate()>
<android.app.IApplicationThread: void notifyContentProviderPublishStatus(android.app.ContentProviderHolder,java.lang.String,int,boolean)>
<android.app.IApplicationThread: void scheduleCreateService(android.os.IBinder,android.content.pm.ServiceInfo,android.content.res.CompatibilityInfo,int)>
<android.app.IApplicationThread: void scheduleOnNewActivityOptions(android.os.IBinder,android.os.Bundle)>
<android.app.IApplicationThread: void instrumentWithoutRestart(android.content.ComponentName,android.os.Bundle,android.app.IInstrumentationWatcher,android.app.IUiAutomationConnection,android.content.pm.ApplicationInfo)>
<android.app.IApplicationThread: void updateHttpProxy()>
<com.samsung.android.security.mdf.MdfService.IMdfService: int initCCMode()>
<android.service.controls.IControlsProvider: void loadControlsProviderInfo(android.service.controls.IControlsProviderInfoSubscriber)>
<android.service.controls.IControlsProvider: void loadSuggested(android.service.controls.IControlsSubscriber)>
<android.service.controls.IControlsProvider: void load(android.service.controls.IControlsSubscriber)>
<android.service.controls.IControlsProvider: void subscribe(java.util.List,android.service.controls.IControlsSubscriber)>
<android.service.controls.IControlsProvider: void action(java.lang.String,android.service.controls.actions.ControlActionWrapper,android.service.controls.IControlsActionCallback)>
<android.blockchain.IBlockchainManager: byte[] getMeasurementFile()>
<android.blockchain.IBlockchainManager: int sspExit()>
<android.blockchain.IBlockchainManager: byte[] getCredential(int)>
<android.blockchain.IBlockchainManager: boolean putCredential(int,byte[])>
<android.blockchain.IBlockchainManager: int sspInit()>
<android.blockchain.IBlockchainManager: android.blockchain.BlockchainTZServiceCommnInfo registerBlockchainFW(android.blockchain.BlockchainTZServiceConfig)>
<android.telephony.ims.aidl.ISubscribeResponseCallback: void onResourceTerminated(java.util.List)>
<android.telephony.ims.aidl.ISubscribeResponseCallback: void onNetworkResponse(android.telephony.ims.SipDetails)>
<android.telephony.ims.aidl.ISubscribeResponseCallback: void onTerminated(java.lang.String,long)>
<android.telephony.ims.aidl.ISubscribeResponseCallback: void onCommandError(int)>
<android.telephony.ims.aidl.ISubscribeResponseCallback: void onNotifyCapabilitiesUpdate(java.util.List)>
<android.content.pm.IPackageStatsObserver: void onGetStatsCompleted(android.content.pm.PackageStats,boolean)>
<android.accessibilityservice.IAccessibilityServiceConnection: android.graphics.Region getMagnificationRegion(int)>
<android.accessibilityservice.IAccessibilityServiceConnection: boolean isAccessibilityButtonAvailable()>
<android.accessibilityservice.IAccessibilityServiceConnection: android.view.accessibility.AccessibilityWindowInfo getWindow(int)>
<android.accessibilityservice.IAccessibilityServiceConnection: void setInstalledAndEnabledServices(java.util.List)>
<android.accessibilityservice.IAccessibilityServiceConnection: void setTouchExplorationPassthroughRegion(int,android.graphics.Region)>
<android.accessibilityservice.IAccessibilityServiceConnection: void dispatchGesture(int,android.content.pm.ParceledListSlice,int)>
<android.accessibilityservice.IAccessibilityServiceConnection: void requestDelegating(int)>
<android.accessibilityservice.IAccessibilityServiceConnection: float getMagnificationCenterY(int)>
<android.accessibilityservice.IAccessibilityServiceConnection: boolean setMagnificationConfig(int,android.accessibilityservice.MagnificationConfig,boolean)>
<android.accessibilityservice.IAccessibilityServiceConnection: android.os.IBinder getOverlayWindowToken(int)>
<android.accessibilityservice.IAccessibilityServiceConnection: java.lang.String[] findAccessibilityNodeInfosByViewId(int,long,java.lang.String,int,android.view.accessibility.IAccessibilityInteractionConnectionCallback,long)>
<android.accessibilityservice.IAccessibilityServiceConnection: java.lang.String[] findFocus(int,long,int,int,android.view.accessibility.IAccessibilityInteractionConnectionCallback,long)>
<android.accessibilityservice.IAccessibilityServiceConnection: boolean resetCurrentMagnification(int,boolean)>
<android.accessibilityservice.IAccessibilityServiceConnection: void setCacheEnabled(boolean)>
<android.accessibilityservice.IAccessibilityServiceConnection: void requestDragging(int,int)>
<android.accessibilityservice.IAccessibilityServiceConnection: void setServiceDetectsGesturesEnabled(int,boolean)>
<android.accessibilityservice.IAccessibilityServiceConnection: void setAttributionTag(java.lang.String)>
<android.accessibilityservice.IAccessibilityServiceConnection: boolean isFingerprintGestureDetectionAvailable()>
<android.accessibilityservice.IAccessibilityServiceConnection: java.lang.String[] focusSearch(int,long,int,int,android.view.accessibility.IAccessibilityInteractionConnectionCallback,long)>
<android.accessibilityservice.IAccessibilityServiceConnection: void attachAccessibilityOverlayToWindow(int,android.view.SurfaceControl)>
<android.accessibilityservice.IAccessibilityServiceConnection: boolean performAccessibilityAction(int,long,int,android.os.Bundle,int,android.view.accessibility.IAccessibilityInteractionConnectionCallback,long)>
<android.accessibilityservice.IAccessibilityServiceConnection: int setInputMethodEnabled(java.lang.String,boolean)>
<android.accessibilityservice.IAccessibilityServiceConnection: android.accessibilityservice.AccessibilityServiceInfo getServiceInfo()>
<android.accessibilityservice.IAccessibilityServiceConnection: void setServiceInfo(android.accessibilityservice.AccessibilityServiceInfo)>
<android.accessibilityservice.IAccessibilityServiceConnection: java.util.List getInstalledAndEnabledServices()>
<android.accessibilityservice.IAccessibilityServiceConnection: boolean switchToInputMethod(java.lang.String)>
<android.accessibilityservice.IAccessibilityServiceConnection: void onDoubleTap(int)>
<android.accessibilityservice.IAccessibilityServiceConnection: void attachAccessibilityOverlayToDisplay(int,android.view.SurfaceControl)>
<android.accessibilityservice.IAccessibilityServiceConnection: android.accessibilityservice.MagnificationConfig getMagnificationConfig(int)>
<android.accessibilityservice.IAccessibilityServiceConnection: float getMagnificationScale(int)>
<android.accessibilityservice.IAccessibilityServiceConnection: void disableSelf()>
<android.accessibilityservice.IAccessibilityServiceConnection: void sendGesture(int,android.content.pm.ParceledListSlice)>
<android.accessibilityservice.IAccessibilityServiceConnection: void takeScreenshotOfWindow(int,int,android.window.ScreenCapture$ScreenCaptureListener,android.view.accessibility.IAccessibilityInteractionConnectionCallback)>
<android.accessibilityservice.IAccessibilityServiceConnection: void setMagnificationCallbackEnabled(int,boolean)>
<android.accessibilityservice.IAccessibilityServiceConnection: void takeScreenshot(int,android.os.RemoteCallback)>
<android.accessibilityservice.IAccessibilityServiceConnection: java.lang.String[] findAccessibilityNodeInfoByAccessibilityId(int,long,int,android.view.accessibility.IAccessibilityInteractionConnectionCallback,int,long,android.os.Bundle)>
<android.accessibilityservice.IAccessibilityServiceConnection: java.lang.String[] findAccessibilityNodeInfosByText(int,long,java.lang.String,int,android.view.accessibility.IAccessibilityInteractionConnectionCallback,long)>
<android.accessibilityservice.IAccessibilityServiceConnection: java.util.List getSystemActions()>
<android.accessibilityservice.IAccessibilityServiceConnection: void setOnKeyEventResult(boolean,int)>
<android.accessibilityservice.IAccessibilityServiceConnection: void setFocusAppearance(int,int)>
<android.accessibilityservice.IAccessibilityServiceConnection: int getSoftKeyboardShowMode()>
<android.accessibilityservice.IAccessibilityServiceConnection: void setSoftKeyboardCallbackEnabled(boolean)>
<android.accessibilityservice.IAccessibilityServiceConnection: java.util.List getWindowsMainDisplay(int)>
<android.accessibilityservice.IAccessibilityServiceConnection: void setAnimationScale(float)>
<android.accessibilityservice.IAccessibilityServiceConnection: android.graphics.Region getCurrentMagnificationRegion(int)>
<android.accessibilityservice.IAccessibilityServiceConnection: void setGestureDetectionPassthroughRegion(int,android.graphics.Region)>
<android.accessibilityservice.IAccessibilityServiceConnection: float getMagnificationCenterX(int)>
<android.accessibilityservice.IAccessibilityServiceConnection: boolean resetMagnification(int,boolean)>
<android.accessibilityservice.IAccessibilityServiceConnection: boolean setSoftKeyboardShowMode(int)>
<android.accessibilityservice.IAccessibilityServiceConnection: void logTrace(long,java.lang.String,long,java.lang.String,int,long,int,android.os.Bundle)>
<android.accessibilityservice.IAccessibilityServiceConnection: void onDoubleTapAndHold(int)>
<android.accessibilityservice.IAccessibilityServiceConnection: void requestTouchExploration(int)>
<android.accessibilityservice.IAccessibilityServiceConnection: android.view.accessibility.AccessibilityWindowInfo$WindowListSparseArray getWindows()>
<android.accessibilityservice.IAccessibilityServiceConnection: boolean performGlobalAction(int)>
<android.accessibilityservice.IAccessibilityServiceConnection: int getWindowIdForLeashToken(android.os.IBinder)>
<android.location.provider.ILocationProvider: void setRequest(android.location.provider.ProviderRequest)>
<android.location.provider.ILocationProvider: void sendExtraCommand(java.lang.String,android.os.Bundle)>
<android.location.provider.ILocationProvider: void setLocationProviderManager(android.location.provider.ILocationProviderManager)>
<android.location.provider.ILocationProvider: void flush()>
<android.service.contentcapture.IContentCaptureService: void onDisconnected()>
<android.service.contentcapture.IContentCaptureService: void onActivityEvent(android.service.contentcapture.ActivityEvent)>
<android.service.contentcapture.IContentCaptureService: void onConnected(android.os.IBinder,boolean,boolean)>
<android.service.contentcapture.IContentCaptureService: void onDataShared(android.view.contentcapture.DataShareRequest,android.service.contentcapture.IDataShareCallback)>
<android.service.contentcapture.IContentCaptureService: void onSessionStarted(android.view.contentcapture.ContentCaptureContext,int,int,com.android.internal.os.IResultReceiver,int)>
<android.service.contentcapture.IContentCaptureService: void onActivitySnapshot(int,android.service.contentcapture.SnapshotData)>
<android.service.contentcapture.IContentCaptureService: void onDataRemovalRequest(android.view.contentcapture.DataRemovalRequest)>
<android.service.contentcapture.IContentCaptureService: void onSessionFinished(int)>
<android.app.IAlarmManager: void setAutoPowerUp(java.lang.String)>
<android.app.IAlarmManager: int getConfigVersion()>
<android.app.IAlarmManager: long getNextWakeFromIdleTime()>
<android.app.IAlarmManager: boolean canScheduleExactAlarms(java.lang.String)>
<android.app.IAlarmManager: java.util.List getNextAlarmClocks(int)>
<android.app.IAlarmManager: void set(java.lang.String,int,long,long,long,int,android.app.PendingIntent,android.app.IAlarmListener,java.lang.String,android.os.WorkSource,android.app.AlarmManager$AlarmClockInfo)>
<android.app.IAlarmManager: boolean setTime(long)>
<android.app.IAlarmManager: android.app.AlarmManager$AlarmClockInfo getNextAlarmClock(int)>
<android.app.IAlarmManager: boolean hasScheduleExactAlarm(java.lang.String,int)>
<android.app.IAlarmManager: void remove(android.app.PendingIntent,android.app.IAlarmListener)>
<android.app.IAlarmManager: void setTimeZone(java.lang.String)>
<android.app.IAlarmManager: void removeAll(java.lang.String)>
<com.android.internal.appwidget.IAppWidgetHost: void appWidgetRemoved(int)>
<com.android.internal.appwidget.IAppWidgetHost: void viewDataChanged(int,int)>
<com.android.internal.appwidget.IAppWidgetHost: void updateAppWidget(int,android.widget.RemoteViews)>
<com.android.internal.appwidget.IAppWidgetHost: void providersChanged()>
<com.android.internal.appwidget.IAppWidgetHost: void providerChanged(int,android.appwidget.AppWidgetProviderInfo)>
<android.content.pm.ISystemPersonaObserver: void onStateChange(int,com.samsung.android.knox.SemPersonaState,com.samsung.android.knox.SemPersonaState)>
<android.content.pm.ISystemPersonaObserver: void onKnoxContainerLaunch(int)>
<android.content.pm.ISystemPersonaObserver: void onRemovePersona(int)>
<android.content.pm.ISystemPersonaObserver: void onPersonaActive(int)>
<android.content.pm.ISystemPersonaObserver: void onResetPersona(int)>
<android.service.chooser.IChooserTargetService: void getChooserTargets(android.content.ComponentName,android.content.IntentFilter,android.service.chooser.IChooserTargetResult)>
<com.android.ims.internal.IImsServiceFeatureCallback: void updateCapabilities(long)>
<com.android.ims.internal.IImsServiceFeatureCallback: void imsFeatureRemoved(int)>
<com.android.ims.internal.IImsServiceFeatureCallback: void imsFeatureCreated(com.android.ims.ImsFeatureContainer,int)>
<com.android.ims.internal.IImsServiceFeatureCallback: void imsStatusChanged(int,int)>
<vendor.samsung.hardware.authfw.ISehAuthenticationFramework: boolean load(int,byte[])>
<vendor.samsung.hardware.authfw.ISehAuthenticationFramework: vendor.samsung.hardware.authfw.SehResult execute(int,byte[])>
<vendor.samsung.hardware.authfw.ISehAuthenticationFramework: java.lang.String getInterfaceHash()>
<vendor.samsung.hardware.authfw.ISehAuthenticationFramework: int getInterfaceVersion()>
<vendor.samsung.hardware.authfw.ISehAuthenticationFramework: boolean terminate(int)>
<android.os.IRunnableCallback: android.os.Bundle run(android.os.Bundle)>
<android.media.soundtrigger.ISoundTriggerDetectionService: void setClient(android.os.ParcelUuid,android.os.Bundle,android.media.soundtrigger.ISoundTriggerDetectionServiceClient)>
<android.media.soundtrigger.ISoundTriggerDetectionService: void onStopOperation(android.os.ParcelUuid,int)>
<android.media.soundtrigger.ISoundTriggerDetectionService: void removeClient(android.os.ParcelUuid)>
<android.media.soundtrigger.ISoundTriggerDetectionService: void onGenericRecognitionEvent(android.os.ParcelUuid,int,android.hardware.soundtrigger.SoundTrigger$GenericRecognitionEvent)>
<android.media.soundtrigger.ISoundTriggerDetectionService: void onError(android.os.ParcelUuid,int,int)>
<android.hardware.biometrics.IBiometricSysuiReceiver: void onStartFingerprintNow()>
<android.hardware.biometrics.IBiometricSysuiReceiver: void onDeviceCredentialPressed()>
<android.hardware.biometrics.IBiometricSysuiReceiver: void onDialogDismissed(int,byte[])>
<android.hardware.biometrics.IBiometricSysuiReceiver: void onSystemEvent(int)>
<android.hardware.biometrics.IBiometricSysuiReceiver: void onDialogAnimatedIn(boolean)>
<android.hardware.biometrics.IBiometricSysuiReceiver: void onTryAgainPressed()>
<com.android.ims.internal.IImsVideoCallProvider: void setDisplaySurface(android.view.Surface)>
<com.android.ims.internal.IImsVideoCallProvider: void setZoom(float)>
<com.android.ims.internal.IImsVideoCallProvider: void requestCameraCapabilities()>
<com.android.ims.internal.IImsVideoCallProvider: void setCallback(com.android.ims.internal.IImsVideoCallCallback)>
<com.android.ims.internal.IImsVideoCallProvider: void sendSessionModifyResponse(android.telecom.VideoProfile)>
<com.android.ims.internal.IImsVideoCallProvider: void requestCallDataUsage()>
<com.android.ims.internal.IImsVideoCallProvider: void setCamera(java.lang.String,int)>
<com.android.ims.internal.IImsVideoCallProvider: void setPauseImage(android.net.Uri)>
<com.android.ims.internal.IImsVideoCallProvider: void setPreviewSurface(android.view.Surface)>
<com.android.ims.internal.IImsVideoCallProvider: void sendSessionModifyRequest(android.telecom.VideoProfile,android.telecom.VideoProfile)>
<com.android.ims.internal.IImsVideoCallProvider: void setDeviceOrientation(int)>
<android.os.IIntelligentBatterySaverService: java.util.List dexoptPackages(java.util.List)>
<android.os.IIntelligentBatterySaverService: java.util.Map getSqdBlockList()>
<android.os.IIntelligentBatterySaverService: boolean isEnableSerive()>
<android.os.IIntelligentBatterySaverService: void setSarrUiControlEnable(boolean)>
<android.os.IIntelligentBatterySaverService: android.os.Bundle getOperationHistory()>
<android.os.IIntelligentBatterySaverService: void setSqdUiControlEnabled(boolean)>
<android.os.IIntelligentBatterySaverService: boolean addSqdBlockList(int,java.lang.String)>
<android.os.IIntelligentBatterySaverService: void setSleepModeEnabled(boolean)>
<android.os.IIntelligentBatterySaverService: void setSleepTime(long,long)>
<android.os.IIntelligentBatterySaverService: boolean removeSqdBlockList(int,java.lang.String)>
<android.os.IIntelligentBatterySaverService: boolean isSqdUiControlEnabled()>
<android.os.IIntelligentBatterySaverService: void setRubinEvent(java.lang.String)>
<android.os.IIntelligentBatterySaverService: long[] getGain()>
<android.os.IIntelligentBatterySaverService: int dexoptPackage(java.lang.String)>
<android.os.IIntelligentBatterySaverService: android.os.Bundle getSleepTime()>
<android.app.job.IJobCallback: void acknowledgeStartMessage(int,boolean)>
<android.app.job.IJobCallback: void jobFinished(int,boolean)>
<android.app.job.IJobCallback: void acknowledgeGetTransferredUploadBytesMessage(int,int,long)>
<android.app.job.IJobCallback: void acknowledgeStopMessage(int,boolean)>
<android.app.job.IJobCallback: void updateTransferredNetworkBytes(int,android.app.job.JobWorkItem,long,long)>
<android.app.job.IJobCallback: boolean completeWork(int,int)>
<android.app.job.IJobCallback: void setNotification(int,int,android.app.Notification,int)>
<android.app.job.IJobCallback: android.app.job.JobWorkItem dequeueWork(int)>
<android.app.job.IJobCallback: void acknowledgeGetTransferredDownloadBytesMessage(int,int,long)>
<android.app.job.IJobCallback: void updateEstimatedNetworkBytes(int,android.app.job.JobWorkItem,long,long)>
<android.credentials.ICredentialManager: boolean isEnabledCredentialProviderService(android.content.ComponentName,java.lang.String)>
<android.credentials.ICredentialManager: void setEnabledProviders(java.util.List,java.util.List,int,android.credentials.ISetEnabledProvidersCallback)>
<android.credentials.ICredentialManager: android.os.ICancellationSignal clearCredentialState(android.credentials.ClearCredentialStateRequest,android.credentials.IClearCredentialStateCallback,java.lang.String)>
<android.credentials.ICredentialManager: android.os.ICancellationSignal executeCreateCredential(android.credentials.CreateCredentialRequest,android.credentials.ICreateCredentialCallback,java.lang.String)>
<android.credentials.ICredentialManager: android.os.ICancellationSignal executePrepareGetCredential(android.credentials.GetCredentialRequest,android.credentials.IPrepareGetCredentialCallback,android.credentials.IGetCredentialCallback,java.lang.String)>
<android.credentials.ICredentialManager: java.util.List getCredentialProviderServicesForTesting(int)>
<android.credentials.ICredentialManager: android.os.ICancellationSignal executeGetCredential(android.credentials.GetCredentialRequest,android.credentials.IGetCredentialCallback,java.lang.String)>
<android.credentials.ICredentialManager: void unregisterCredentialDescription(android.credentials.UnregisterCredentialDescriptionRequest,java.lang.String)>
<android.credentials.ICredentialManager: java.util.List getCredentialProviderServices(int,int)>
<android.credentials.ICredentialManager: boolean isServiceEnabled()>
<android.credentials.ICredentialManager: void registerCredentialDescription(android.credentials.RegisterCredentialDescriptionRequest,java.lang.String)>
<com.samsung.android.wifi.p2p.ISemWifiP2pManager: void discoverPeers(int,com.samsung.android.wifi.p2p.ISemWifiP2pCallback)>
<com.samsung.android.wifi.p2p.ISemWifiP2pManager: void setInUsePackage(java.lang.String,java.lang.String,java.lang.String,boolean)>
<com.samsung.android.wifi.p2p.ISemWifiP2pManager: int[] getChannelsMhzForBand(int)>
<com.samsung.android.wifi.p2p.ISemWifiP2pManager: java.util.List getInUsePackageList(java.lang.String)>
<com.samsung.android.wifi.p2p.ISemWifiP2pManager: void setMsMiceInfo(int,java.lang.String,java.lang.String)>
<com.samsung.android.wifi.p2p.ISemWifiP2pManager: void removeClient(java.lang.String,com.samsung.android.wifi.p2p.ISemWifiP2pCallback)>
<com.samsung.android.wifi.p2p.ISemWifiP2pManager: com.samsung.android.wifi.p2p.SemWifiP2pDevice getSemWifiP2pDevice(java.lang.String)>
<com.samsung.android.wifi.p2p.ISemWifiP2pManager: void unsetAllInUsePackage(java.lang.String)>
<com.samsung.android.wifi.p2p.ISemWifiP2pManager: void setPreparedAccountPin(java.lang.String,java.lang.String,java.lang.String)>
<com.samsung.android.wifi.p2p.ISemWifiP2pManager: int getWifiP2pState()>
<com.samsung.android.wifi.p2p.ISemWifiP2pManager: void controlOpenWifiScanTimer(int)>
<com.samsung.android.wifi.p2p.ISemWifiP2pManager: android.net.MacAddress getP2pFactoryMacAddress()>
<com.samsung.android.wifi.p2p.ISemWifiP2pManager: void setListenOffloading(int,int,int,int)>
<com.samsung.android.wifi.p2p.ISemWifiP2pManager: boolean isP2pSoftApConcurrencySupported()>
<com.samsung.android.wifi.p2p.ISemWifiP2pManager: boolean disconnectApBlockAutojoin(boolean)>
<com.samsung.android.wifi.p2p.ISemWifiP2pManager: void unsetInUsePackage(java.lang.String,java.lang.String,java.lang.String,boolean)>
<com.samsung.android.wifi.p2p.ISemWifiP2pManager: void setScreenSharing(boolean)>
<android.hardware.fingerprint.IUdfpsOverlayControllerCallback: void onUserCanceled()>
<android.content.pm.IOtaDexopt: void prepare()>
<android.content.pm.IOtaDexopt: void dexoptNextPackage()>
<android.content.pm.IOtaDexopt: float getProgress()>
<android.content.pm.IOtaDexopt: java.lang.String nextDexoptCommand()>
<android.content.pm.IOtaDexopt: void cleanup()>
<android.content.pm.IOtaDexopt: boolean isDone()>
<android.hardware.radio.data.IRadioDataIndication: void slicingConfigChanged(int,android.hardware.radio.data.SlicingConfig)>
<android.hardware.radio.data.IRadioDataIndication: int getInterfaceVersion()>
<android.hardware.radio.data.IRadioDataIndication: void keepaliveStatus(int,android.hardware.radio.data.KeepaliveStatus)>
<android.hardware.radio.data.IRadioDataIndication: void pcoData(int,android.hardware.radio.data.PcoDataInfo)>
<android.hardware.radio.data.IRadioDataIndication: void dataCallListChanged(int,android.hardware.radio.data.SetupDataCallResult[])>
<android.hardware.radio.data.IRadioDataIndication: java.lang.String getInterfaceHash()>
<android.hardware.radio.data.IRadioDataIndication: void unthrottleApn(int,android.hardware.radio.data.DataProfileInfo)>
<android.hardware.IRemoteDeviceCallback: void onCaptureResult(android.hardware.camera2.impl.CameraMetadataNative)>
<android.hardware.IRemoteDeviceCallback: void onError(int)>
<vendor.samsung.hardware.radio.messaging.ISehRadioMessagingIndication: java.lang.String getInterfaceHash()>
<vendor.samsung.hardware.radio.messaging.ISehRadioMessagingIndication: int getInterfaceVersion()>
<vendor.samsung.hardware.radio.messaging.ISehRadioMessagingIndication: void stkSmsSendResultIndication(int,int)>
<vendor.samsung.hardware.radio.messaging.ISehRadioMessagingIndication: void deviceReadyNoti(int)>
<android.app.IUnsafeIntentStrictModeCallback: void onImplicitIntentMatchedInternalComponent(android.content.Intent)>
<android.hardware.radio.config.IRadioConfigResponse: java.lang.String getInterfaceHash()>
<android.hardware.radio.config.IRadioConfigResponse: void setPreferredDataModemResponse(android.hardware.radio.RadioResponseInfo)>
<android.hardware.radio.config.IRadioConfigResponse: void getHalDeviceCapabilitiesResponse(android.hardware.radio.RadioResponseInfo,boolean)>
<android.hardware.radio.config.IRadioConfigResponse: void getPhoneCapabilityResponse(android.hardware.radio.RadioResponseInfo,android.hardware.radio.config.PhoneCapability)>
<android.hardware.radio.config.IRadioConfigResponse: void setNumOfLiveModemsResponse(android.hardware.radio.RadioResponseInfo)>
<android.hardware.radio.config.IRadioConfigResponse: int getInterfaceVersion()>
<android.hardware.radio.config.IRadioConfigResponse: void setSimSlotsMappingResponse(android.hardware.radio.RadioResponseInfo)>
<android.hardware.radio.config.IRadioConfigResponse: void getNumOfLiveModemsResponse(android.hardware.radio.RadioResponseInfo,byte)>
<android.hardware.radio.config.IRadioConfigResponse: void getSimSlotsStatusResponse(android.hardware.radio.RadioResponseInfo,android.hardware.radio.config.SimSlotStatus[])>
<android.service.carrier.ICarrierService: void getCarrierConfig(int,android.service.carrier.CarrierIdentifier,android.os.ResultReceiver)>
<android.service.euicc.IOtaStatusChangedCallback: void onOtaStatusChanged(int)>
<android.os.IUserRestrictionsListener: void onUserRestrictionsChanged(int,android.os.Bundle,android.os.Bundle)>
<android.media.ISpatializer: void setHingeAngle(float)>
<android.media.ISpatializer: void setScreenSensor(int)>
<android.media.ISpatializer: void setDisplayOrientation(float)>
<android.media.ISpatializer: void setGlobalTransform(float[])>
<android.media.ISpatializer: byte[] getSupportedModes()>
<android.media.ISpatializer: void registerHeadTrackingCallback(android.media.ISpatializerHeadTrackingCallback)>
<android.media.ISpatializer: void setLevel(byte)>
<android.media.ISpatializer: boolean isHeadTrackingSupported()>
<android.media.ISpatializer: void recenterHeadTracker()>
<android.media.ISpatializer: void setFoldState(boolean)>
<android.media.ISpatializer: void setParameter(int,byte[])>
<android.media.ISpatializer: byte getActualHeadTrackingMode()>
<android.media.ISpatializer: byte[] getSupportedHeadTrackingModes()>
<android.media.ISpatializer: void release()>
<android.media.ISpatializer: void setDesiredHeadTrackingMode(byte)>
<android.media.ISpatializer: void setHeadSensor(int)>
<android.media.ISpatializer: int getOutput()>
<android.media.ISpatializer: void getParameter(int,byte[])>
<android.media.ISpatializer: byte[] getSupportedLevels()>
<android.media.ISpatializer: byte getLevel()>
<android.speech.IRecognitionListener: void onEvent(int,android.os.Bundle)>
<android.speech.IRecognitionListener: void onEndOfSegmentedSession()>
<android.speech.IRecognitionListener: void onRmsChanged(float)>
<android.speech.IRecognitionListener: void onResults(android.os.Bundle)>
<android.speech.IRecognitionListener: void onError(int)>
<android.speech.IRecognitionListener: void onPartialResults(android.os.Bundle)>
<android.speech.IRecognitionListener: void onSegmentResults(android.os.Bundle)>
<android.speech.IRecognitionListener: void onBeginningOfSpeech()>
<android.speech.IRecognitionListener: void onBufferReceived(byte[])>
<android.speech.IRecognitionListener: void onReadyForSpeech(android.os.Bundle)>
<android.speech.IRecognitionListener: void onEndOfSpeech()>
<android.speech.IRecognitionListener: void onLanguageDetection(android.os.Bundle)>
<android.app.blob.IBlobCommitCallback: void onResult(int)>
<android.content.pm.IPackageInstaller: void updateSessionAppIcon(int,android.graphics.Bitmap)>
<android.content.pm.IPackageInstaller: android.content.pm.ParceledListSlice getAllSessions(int)>
<android.content.pm.IPackageInstaller: android.content.pm.PackageInstaller$SessionInfo getSessionInfo(int)>
<android.content.pm.IPackageInstaller: void setAllowUnlimitedSilentUpdates(java.lang.String)>
<android.content.pm.IPackageInstaller: void installExistingPackage(java.lang.String,int,int,android.content.IntentSender,int,java.util.List)>
<android.content.pm.IPackageInstaller: android.content.pm.IPackageInstallerSession openSession(int)>
<android.content.pm.IPackageInstaller: void setUnknownSourceConfirmResult(int,boolean)>
<android.content.pm.IPackageInstaller: void waitForInstallConstraints(java.lang.String,java.util.List,android.content.pm.PackageInstaller$InstallConstraints,android.content.IntentSender,long)>
<android.content.pm.IPackageInstaller: void setPermissionsResult(int,boolean)>
<android.content.pm.IPackageInstaller: void setSilentUpdatesThrottleTime(long)>
<android.content.pm.IPackageInstaller: void abandonSession(int)>
<android.content.pm.IPackageInstaller: android.content.pm.ParceledListSlice getMySessions(java.lang.String,int)>
<android.content.pm.IPackageInstaller: void uninstall(android.content.pm.VersionedPackage,java.lang.String,int,android.content.IntentSender,int)>
<android.content.pm.IPackageInstaller: android.content.pm.ParceledListSlice getStagedSessions()>
<android.content.pm.IPackageInstaller: void updateSessionAppLabel(int,java.lang.String)>
<android.content.pm.IPackageInstaller: void checkInstallConstraints(java.lang.String,java.util.List,android.content.pm.PackageInstaller$InstallConstraints,android.os.RemoteCallback)>
<android.content.pm.IPackageInstaller: void bypassNextAllowedApexUpdateCheck(boolean)>
<android.content.pm.IPackageInstaller: int createSession(android.content.pm.PackageInstaller$SessionParams,java.lang.String,java.lang.String,int)>
<android.content.pm.IPackageInstaller: void registerCallback(android.content.pm.IPackageInstallerCallback,int)>
<android.content.pm.IPackageInstaller: void unregisterCallback(android.content.pm.IPackageInstallerCallback)>
<android.content.pm.IPackageInstaller: void bypassNextStagedInstallerCheck(boolean)>
<android.content.pm.IPackageInstaller: void disableVerificationForUid(int)>
<android.content.pm.IPackageInstaller: void uninstallExistingPackage(android.content.pm.VersionedPackage,java.lang.String,android.content.IntentSender,int)>
<com.samsung.android.aod.IAODCallback: void onScreenTurningOn()>
<android.telephony.INetworkService: void createNetworkServiceProvider(int)>
<android.telephony.INetworkService: void unregisterForNetworkRegistrationInfoChanged(int,android.telephony.INetworkServiceCallback)>
<android.telephony.INetworkService: void removeNetworkServiceProvider(int)>
<android.telephony.INetworkService: void registerForNetworkRegistrationInfoChanged(int,android.telephony.INetworkServiceCallback)>
<android.telephony.INetworkService: void requestNetworkRegistrationInfo(int,int,android.telephony.INetworkServiceCallback)>
<com.samsung.android.ims.SemImsService: boolean isSimMobilityActivated(int)>
<com.samsung.android.ims.SemImsService: void sendIidToken(java.lang.String,int)>
<com.samsung.android.ims.SemImsService: boolean isCmcEmergencyCallSupported()>
<com.samsung.android.ims.SemImsService: boolean isCmcEmergencyNumber(java.lang.String,int)>
<com.samsung.android.ims.SemImsService: void unregisterAutoConfigurationListener(java.lang.String,int)>
<com.samsung.android.ims.SemImsService: void registerDmValueListener(com.samsung.android.ims.SemImsDmConfigListener)>
<com.samsung.android.ims.SemImsService: void unregisterImsRegistrationListenerForSlot(java.lang.String,int)>
<com.samsung.android.ims.SemImsService: void sendTryRegisterByPhoneId(int)>
<com.samsung.android.ims.SemImsService: void unregisterImsOngoingFtEventListener(java.lang.String)>
<com.samsung.android.ims.SemImsService: java.lang.String registerSimMobilityStatusListener(com.samsung.android.ims.SemSimMobStatusListener,int)>
<com.samsung.android.ims.SemImsService: void unRegisterEpdgListener(java.lang.String)>
<com.samsung.android.ims.SemImsService: com.samsung.android.ims.settings.SemImsProfile[] getCurrentProfileForSlot(int)>
<com.samsung.android.ims.SemImsService: void sendVerificationCode(java.lang.String,int)>
<com.samsung.android.ims.SemImsService: boolean isForbiddenByPhoneId(int)>
<com.samsung.android.ims.SemImsService: boolean isServiceAvailable(java.lang.String,int,int)>
<com.samsung.android.ims.SemImsService: java.lang.String getRcsProfileType(int)>
<com.samsung.android.ims.SemImsService: boolean isVoLteAvailable(int)>
<com.samsung.android.ims.SemImsService: void sendMsisdnNumber(java.lang.String,int)>
<com.samsung.android.ims.SemImsService: boolean isCmcPotentialEmergencyNumber(java.lang.String,int)>
<com.samsung.android.ims.SemImsService: void sendSemCmcRecordingEvent(com.samsung.android.ims.cmc.SemCmcRecordingInfo,int,int)>
<com.samsung.android.ims.SemImsService: boolean isCrossSimCallingRegistered(int)>
<com.samsung.android.ims.SemImsService: void unregisterSimMobilityStatusListener(java.lang.String,int)>
<com.samsung.android.ims.SemImsService: java.lang.String registerEpdgListener(com.samsung.android.ims.ISemEpdgListener)>
<com.samsung.android.ims.SemImsService: com.samsung.android.ims.SemImsRegistration getRegistrationInfoByServiceType(java.lang.String,int)>
<com.samsung.android.ims.SemImsService: com.samsung.android.ims.SemImsRegistration[] getRegistrationInfoByPhoneId(int)>
<com.samsung.android.ims.SemImsService: java.lang.String registerImsOngoingFtEventListener(com.samsung.android.ims.ft.SemImsFtListener)>
<com.samsung.android.ims.SemImsService: java.lang.String registerImsRegistrationListenerForSlot(com.samsung.android.ims.SemImsRegiListener,int)>
<com.samsung.android.ims.SemImsService: boolean getBooleanConfig(java.lang.String,int)>
<com.samsung.android.ims.SemImsService: boolean hasCrossSimCallingSupport(int)>
<com.samsung.android.ims.SemImsService: java.lang.String registerAutoConfigurationListener(com.samsung.android.ims.SemAutoConfigListener,int)>
<com.samsung.android.ims.SemImsService: void setRttMode(int,int)>
<com.samsung.android.ims.SemImsService: void registerSemCmcRecordingListener(com.samsung.android.ims.cmc.ISemCmcRecordingListener,int)>
<com.samsung.android.ims.SemImsService: void unregisterDmValueListener(com.samsung.android.ims.SemImsDmConfigListener)>
<com.samsung.android.ims.SemImsService: void enableRcsByPhoneId(boolean,int)>
<com.samsung.android.ims.SemImsService: android.content.ContentValues getConfigValues(java.lang.String[],int)>
<com.samsung.android.ims.SemImsService: boolean isRcsEnabled(boolean,int)>
<android.view.IInputMonitorHost: void pilferPointers()>
<android.view.IInputMonitorHost: void dispose()>
<android.media.ICapturePresetDevicesRoleDispatcher: void dispatchDevicesRoleChanged(int,int,java.util.List)>
<android.companion.virtual.sensor.IVirtualSensorCallback: void onDirectChannelCreated(int,android.os.SharedMemory)>
<android.companion.virtual.sensor.IVirtualSensorCallback: void onConfigurationChanged(android.companion.virtual.sensor.VirtualSensor,boolean,int,int)>
<android.companion.virtual.sensor.IVirtualSensorCallback: void onDirectChannelConfigured(int,android.companion.virtual.sensor.VirtualSensor,int,int)>
<android.companion.virtual.sensor.IVirtualSensorCallback: void onDirectChannelDestroyed(int)>
<com.samsung.android.desktopmode.IDesktopModeLauncher: android.os.Bundle sendMessage(android.os.Bundle)>
<android.service.trust.ITrustAgentServiceCallback: void setManagingTrust(boolean)>
<android.service.trust.ITrustAgentServiceCallback: void showKeyguardErrorMessage(java.lang.CharSequence)>
<android.service.trust.ITrustAgentServiceCallback: void revokeTrust()>
<android.service.trust.ITrustAgentServiceCallback: void lockUser()>
<android.service.trust.ITrustAgentServiceCallback: void addEscrowToken(byte[],int)>
<android.service.trust.ITrustAgentServiceCallback: void grantTrust(java.lang.CharSequence,long,int,com.android.internal.infra.AndroidFuture)>
<android.service.trust.ITrustAgentServiceCallback: void unlockUserWithToken(long,byte[],int)>
<android.service.trust.ITrustAgentServiceCallback: void onConfigureCompleted(boolean,android.os.IBinder)>
<android.service.trust.ITrustAgentServiceCallback: void isEscrowTokenActive(long,int)>
<android.service.trust.ITrustAgentServiceCallback: void removeEscrowToken(long,int)>
<android.location.IGeocodeProvider: void getFromLocationName(java.lang.String,double,double,double,double,int,android.location.GeocoderParams,android.location.IGeocodeListener)>
<android.location.IGeocodeProvider: void getFromLocation(double,double,int,android.location.GeocoderParams,android.location.IGeocodeListener)>
<android.service.wallpaper.IWallpaperService: void setCurrentUserId(int)>
<android.service.wallpaper.IWallpaperService: void detach(android.os.IBinder)>
<android.service.wallpaper.IWallpaperService: void attach(android.service.wallpaper.IWallpaperConnection,android.os.IBinder,int,boolean,int,int,android.graphics.Rect,int,int)>
<com.samsung.android.mhs.ai.ISemMhsAiService: void serviceTypeQuery(float[][],java.lang.String[],int[],int)>
<com.samsung.android.mhs.ai.ISemMhsAiService: void toggleDebugMode(boolean)>
<com.samsung.android.content.smartclip.IAirGestureListener: void onGesture(java.lang.String)>
<com.android.internal.telephony.IDomainSelector: void reselectDomain(android.telephony.DomainSelectionService$SelectionAttributes)>
<com.android.internal.telephony.IDomainSelector: void cancelSelection()>
<com.android.internal.telephony.IDomainSelector: void finishSelection()>
<android.app.contentsuggestions.IClassificationsCallback: void onContentClassificationsAvailable(int,java.util.List)>
<android.service.dreams.IDreamOverlayCallback: void onExitRequested()>
<android.app.IUidFrozenStateChangedCallback: void onUidFrozenStateChanged(int[],int[])>
<android.os.incremental.IStorageHealthListener: void onHealthStatus(int,int)>
<com.samsung.android.aod.IAODManager: boolean isSViewCoverBrightnessHigh()>
<com.samsung.android.aod.IAODManager: void unregisterAODListener(android.os.IBinder)>
<com.samsung.android.aod.IAODManager: void updateAODTspRect(int,int,int,int,java.lang.String)>
<com.samsung.android.aod.IAODManager: int setLiveClockImage(int,int,byte[],java.lang.String)>
<com.samsung.android.aod.IAODManager: void registerAODDozeCallback(android.os.IBinder)>
<com.samsung.android.aod.IAODManager: void releaseDoze(android.os.IBinder)>
<com.samsung.android.aod.IAODManager: void requestAODToast(java.lang.String,com.samsung.android.aod.AODToast)>
<com.samsung.android.aod.IAODManager: java.lang.String getAodActiveArea(boolean)>
<com.samsung.android.aod.IAODManager: void writeAODCommand(java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
<com.samsung.android.aod.IAODManager: void registerAODListener(android.os.IBinder)>
<com.samsung.android.aod.IAODManager: void acquireDoze(android.os.IBinder,java.lang.String,java.lang.String)>
<com.samsung.android.aod.IAODManager: int setLiveClockCommand(int,int,int,int[])>
<com.samsung.android.aod.IAODManager: int setLiveClockInfo(int,long,long,long,long,long,long,long,long)>
<com.samsung.android.aod.IAODManager: void setLiveClockNeedle(byte[])>
<com.samsung.android.aod.IAODManager: void addLogText(java.util.List)>
<com.samsung.android.aod.IAODManager: java.lang.String getActiveImageInfo()>
<com.samsung.android.aod.IAODManager: void readyToScreenTurningOn()>
<com.samsung.android.aod.IAODManager: boolean isAODState()>
<com.samsung.android.aod.IAODManager: void unregisterAODDozeCallback(android.os.IBinder)>
<android.app.IStopUserCallback: void userStopAborted(int)>
<android.app.IStopUserCallback: void userStopped(int)>
<com.android.ims.internal.uce.uceservice.IUceListener: void setStatus(int)>
<com.android.internal.policy.IKeyguardStateCallback: void onInputRestrictedStateChanged(boolean)>
<com.android.internal.policy.IKeyguardStateCallback: void onTrustedChanged(boolean)>
<com.android.internal.policy.IKeyguardStateCallback: void onShowingStateChanged(boolean,int)>
<com.android.internal.policy.IKeyguardStateCallback: void onSimSecureStateChanged(boolean)>
<android.location.IGpsGeofenceHardware: boolean isHardwareGeofenceSupported()>
<android.location.IGpsGeofenceHardware: boolean addCircularHardwareGeofence(int,double,double,double,int,int,int,int)>
<android.location.IGpsGeofenceHardware: boolean pauseHardwareGeofence(int)>
<android.location.IGpsGeofenceHardware: boolean removeHardwareGeofence(int)>
<android.location.IGpsGeofenceHardware: boolean resumeHardwareGeofence(int,int)>
<android.window.IDisplayAreaOrganizerController: android.window.DisplayAreaAppearedInfo createTaskDisplayArea(android.window.IDisplayAreaOrganizer,int,int,java.lang.String)>
<android.window.IDisplayAreaOrganizerController: void deleteTaskDisplayArea(android.window.WindowContainerToken)>
<android.window.IDisplayAreaOrganizerController: void unregisterOrganizer(android.window.IDisplayAreaOrganizer)>
<android.window.IDisplayAreaOrganizerController: android.content.pm.ParceledListSlice registerOrganizer(android.window.IDisplayAreaOrganizer,int)>
<com.android.internal.app.IAppOpsService: void resetPackageOpsNoHistory(java.lang.String)>
<com.android.internal.app.IAppOpsService: void rebootHistory(long)>
<com.android.internal.app.IAppOpsService: void startWatchingNoted(int[],com.android.internal.app.IAppOpsNotedCallback)>
<com.android.internal.app.IAppOpsService: void stopWatchingNoted(com.android.internal.app.IAppOpsNotedCallback)>
<com.android.internal.app.IAppOpsService: int checkAudioOperation(int,int,int,java.lang.String)>
<com.android.internal.app.IAppOpsService: com.android.internal.app.MessageSamplingConfig reportRuntimeAppOpAccessMessageAndGetConfig(java.lang.String,android.app.SyncNotedAppOp,java.lang.String)>
<com.android.internal.app.IAppOpsService: android.app.SyncNotedAppOp noteProxyOperation(int,android.content.AttributionSource,boolean,java.lang.String,boolean,boolean)>
<com.android.internal.app.IAppOpsService: void setAudioRestriction(int,int,int,int,java.lang.String[])>
<com.android.internal.app.IAppOpsService: void stopWatchingAsyncNoted(java.lang.String,com.android.internal.app.IAppOpsAsyncNotedCallback)>
<com.android.internal.app.IAppOpsService: boolean isOperationActive(int,int,java.lang.String)>
<com.android.internal.app.IAppOpsService: void stopWatchingStarted(com.android.internal.app.IAppOpsStartedCallback)>
<com.android.internal.app.IAppOpsService: int permissionToOpCode(java.lang.String)>
<com.android.internal.app.IAppOpsService: void stopWatchingActive(com.android.internal.app.IAppOpsActiveCallback)>
<com.android.internal.app.IAppOpsService: void finishOperation(android.os.IBinder,int,int,java.lang.String,java.lang.String)>
<com.android.internal.app.IAppOpsService: void setUserRestriction(int,boolean,android.os.IBinder,int,android.os.PackageTagsList)>
<com.android.internal.app.IAppOpsService: java.util.List getUidOps(int,int[])>
<com.android.internal.app.IAppOpsService: android.app.SyncNotedAppOp startProxyOperation(android.os.IBinder,int,android.content.AttributionSource,boolean,boolean,java.lang.String,boolean,boolean,int,int,int)>
<com.android.internal.app.IAppOpsService: void reloadNonHistoricalState()>
<com.android.internal.app.IAppOpsService: void getHistoricalOps(int,java.lang.String,java.lang.String,java.util.List,int,int,long,long,int,android.os.RemoteCallback)>
<com.android.internal.app.IAppOpsService: void startWatchingActive(int[],com.android.internal.app.IAppOpsActiveCallback)>
<com.android.internal.app.IAppOpsService: int checkOperationRaw(int,int,java.lang.String,java.lang.String)>
<com.android.internal.app.IAppOpsService: void clearHistory()>
<com.android.internal.app.IAppOpsService: void setUserRestrictions(android.os.Bundle,android.os.IBinder,int)>
<com.android.internal.app.IAppOpsService: java.util.List getPackagesForOps(int[])>
<com.android.internal.app.IAppOpsService: int checkPackage(int,java.lang.String)>
<com.android.internal.app.IAppOpsService: void finishProxyOperation(android.os.IBinder,int,android.content.AttributionSource,boolean)>
<com.android.internal.app.IAppOpsService: void setHistoryParameters(int,long,int)>
<com.android.internal.app.IAppOpsService: boolean isProxying(int,java.lang.String,java.lang.String,int,java.lang.String)>
<com.android.internal.app.IAppOpsService: void startWatchingMode(int,java.lang.String,com.android.internal.app.IAppOpsCallback)>
<com.android.internal.app.IAppOpsService: void addHistoricalOps(android.app.AppOpsManager$HistoricalOps)>
<com.android.internal.app.IAppOpsService: void setCameraAudioRestriction(int)>
<com.android.internal.app.IAppOpsService: void stopWatchingMode(com.android.internal.app.IAppOpsCallback)>
<com.android.internal.app.IAppOpsService: void requestPermissionAccessInformation()>
<com.android.internal.app.IAppOpsService: void startWatchingStarted(int[],com.android.internal.app.IAppOpsStartedCallback)>
<com.android.internal.app.IAppOpsService: boolean shouldCollectNotes(int)>
<com.android.internal.app.IAppOpsService: void resetHistoryParameters()>
<com.android.internal.app.IAppOpsService: void getHistoricalOpsFromDiskRaw(int,java.lang.String,java.lang.String,java.util.List,int,int,long,long,int,android.os.RemoteCallback)>
<com.android.internal.app.IAppOpsService: void offsetHistory(long)>
<com.android.internal.app.IAppOpsService: void setMode(int,int,java.lang.String,int)>
<com.android.internal.app.IAppOpsService: void resetAllModes(int,java.lang.String)>
<com.android.internal.app.IAppOpsService: android.app.SyncNotedAppOp startOperation(android.os.IBinder,int,int,java.lang.String,java.lang.String,boolean,boolean,java.lang.String,boolean,int,int)>
<com.android.internal.app.IAppOpsService: void setUidMode(int,int,int)>
<com.android.internal.app.IAppOpsService: void collectNoteOpCallsForValidation(java.lang.String,int,java.lang.String,long)>
<com.android.internal.app.IAppOpsService: void startWatchingModeWithFlags(int,java.lang.String,int,com.android.internal.app.IAppOpsCallback)>
<com.android.internal.app.IAppOpsService: java.util.List extractAsyncOps(java.lang.String)>
<com.android.internal.app.IAppOpsService: void startWatchingAsyncNoted(java.lang.String,com.android.internal.app.IAppOpsAsyncNotedCallback)>
<com.android.internal.app.IAppOpsService: android.app.SyncNotedAppOp noteOperation(int,int,java.lang.String,java.lang.String,boolean,java.lang.String,boolean)>
<com.android.internal.app.IAppOpsService: void removeUser(int)>
<com.android.internal.app.IAppOpsService: int checkOperation(int,int,java.lang.String)>
<com.android.internal.app.IAppOpsService: java.util.List getOpsForPackage(int,java.lang.String,int[])>
<com.android.internal.app.IAppOpsService: android.app.RuntimeAppOpAccessMessage collectRuntimeAppOpAccessMessage()>
<android.companion.virtual.IVirtualDeviceActivityListener: void onTopActivityChanged(int,android.content.ComponentName,int)>
<android.companion.virtual.IVirtualDeviceActivityListener: void onDisplayEmpty(int)>
<com.android.internal.app.ISoundTriggerSession: int loadGenericSoundModel(android.hardware.soundtrigger.SoundTrigger$GenericSoundModel)>
<com.android.internal.app.ISoundTriggerSession: int stopRecognitionForService(android.os.ParcelUuid)>
<com.android.internal.app.ISoundTriggerSession: android.hardware.soundtrigger.SoundTrigger$ModelParamRange queryParameter(android.os.ParcelUuid,int)>
<com.android.internal.app.ISoundTriggerSession: int startRecognitionForService(android.os.ParcelUuid,android.os.Bundle,android.content.ComponentName,android.hardware.soundtrigger.SoundTrigger$RecognitionConfig)>
<com.android.internal.app.ISoundTriggerSession: int getParameter(android.os.ParcelUuid,int)>
<com.android.internal.app.ISoundTriggerSession: int loadKeyphraseSoundModel(android.hardware.soundtrigger.SoundTrigger$KeyphraseSoundModel)>
<com.android.internal.app.ISoundTriggerSession: int setParameter(android.os.ParcelUuid,int,int)>
<com.android.internal.app.ISoundTriggerSession: android.hardware.soundtrigger.SoundTrigger$ModuleProperties getModuleProperties()>
<com.android.internal.app.ISoundTriggerSession: int stopRecognition(android.os.ParcelUuid,android.hardware.soundtrigger.IRecognitionStatusCallback)>
<com.android.internal.app.ISoundTriggerSession: boolean isRecognitionActive(android.os.ParcelUuid)>
<com.android.internal.app.ISoundTriggerSession: int startRecognition(android.hardware.soundtrigger.SoundTrigger$GenericSoundModel,android.hardware.soundtrigger.IRecognitionStatusCallback,android.hardware.soundtrigger.SoundTrigger$RecognitionConfig,boolean)>
<com.android.internal.app.ISoundTriggerSession: int getModelState(android.os.ParcelUuid)>
<com.android.internal.app.ISoundTriggerSession: android.hardware.soundtrigger.SoundTrigger$GenericSoundModel getSoundModel(android.os.ParcelUuid)>
<com.android.internal.app.ISoundTriggerSession: void updateSoundModel(android.hardware.soundtrigger.SoundTrigger$GenericSoundModel)>
<com.android.internal.app.ISoundTriggerSession: int unloadSoundModel(android.os.ParcelUuid)>
<com.android.internal.app.ISoundTriggerSession: void deleteSoundModel(android.os.ParcelUuid)>
<android.service.remotelockscreenvalidation.IRemoteLockscreenValidationCallback: void onFailure(java.lang.String)>
<android.service.remotelockscreenvalidation.IRemoteLockscreenValidationCallback: void onSuccess(android.app.RemoteLockscreenValidationResult)>
<android.hardware.biometrics.IBiometricService: int getCurrentStrength(int)>
<android.hardware.biometrics.IBiometricService: void registerAuthenticator(int,int,int,android.hardware.biometrics.IBiometricAuthenticator)>
<android.hardware.biometrics.IBiometricService: java.util.List getSensorProperties(java.lang.String)>
<android.hardware.biometrics.IBiometricService: void resetLockoutTimeBound(android.os.IBinder,java.lang.String,int,int,byte[])>
<android.hardware.biometrics.IBiometricService: android.hardware.biometrics.ITestSession createTestSession(int,android.hardware.biometrics.ITestSessionCallback,java.lang.String)>
<android.hardware.biometrics.IBiometricService: void cancelAuthentication(android.os.IBinder,java.lang.String,long)>
<android.hardware.biometrics.IBiometricService: int getCurrentModality(java.lang.String,int,int,int)>
<android.hardware.biometrics.IBiometricService: int canAuthenticate(java.lang.String,int,int,int)>
<android.hardware.biometrics.IBiometricService: boolean hasEnrolledBiometrics(int,java.lang.String)>
<android.hardware.biometrics.IBiometricService: int getSupportedModalities(int)>
<android.hardware.biometrics.IBiometricService: android.hardware.biometrics.PromptInfo semGetPromptInfo(int)>
<android.hardware.biometrics.IBiometricService: long authenticate(android.os.IBinder,long,int,android.hardware.biometrics.IBiometricServiceReceiver,java.lang.String,android.hardware.biometrics.PromptInfo)>
<android.hardware.biometrics.IBiometricService: void resetLockout(int,byte[])>
<android.hardware.biometrics.IBiometricService: long[] getAuthenticatorIds(int)>
<android.hardware.biometrics.IBiometricService: void invalidateAuthenticatorIds(int,int,android.hardware.biometrics.IInvalidationCallback)>
<android.hardware.biometrics.IBiometricService: void onReadyForAuthentication(long,int)>
<android.hardware.biometrics.IBiometricService: void registerEnabledOnKeyguardCallback(android.hardware.biometrics.IBiometricEnabledOnKeyguardCallback)>
<com.android.internal.telephony.euicc.IRetrieveNotificationListCallback: void onComplete(int,android.telephony.euicc.EuiccNotification[])>
<com.android.internal.telephony.ICarrierConfigChangeListener: void onCarrierConfigChanged(int,int,int,int)>
<android.view.accessibility.IAccessibilityInteractionConnectionCallback: void setFindAccessibilityNodeInfoResult(android.view.accessibility.AccessibilityNodeInfo,int)>
<android.view.accessibility.IAccessibilityInteractionConnectionCallback: void setPerformAccessibilityActionResult(boolean,int)>
<android.view.accessibility.IAccessibilityInteractionConnectionCallback: void setFindAccessibilityNodeInfosResult(java.util.List,int)>
<android.view.accessibility.IAccessibilityInteractionConnectionCallback: void sendTakeScreenshotOfWindowError(int,int)>
<android.view.accessibility.IAccessibilityInteractionConnectionCallback: void setPrefetchAccessibilityNodeInfoResult(java.util.List,int)>
<android.hardware.radio.modem.IRadioModem: void sendDeviceState(int,int,boolean)>
<android.hardware.radio.modem.IRadioModem: void nvResetConfig(int,int)>
<android.hardware.radio.modem.IRadioModem: void getImei(int)>
<android.hardware.radio.modem.IRadioModem: void setRadioCapability(int,android.hardware.radio.modem.RadioCapability)>
<android.hardware.radio.modem.IRadioModem: void getDeviceIdentity(int)>
<android.hardware.radio.modem.IRadioModem: void requestShutdown(int)>
<android.hardware.radio.modem.IRadioModem: void getModemStackStatus(int)>
<android.hardware.radio.modem.IRadioModem: void getRadioCapability(int)>
<android.hardware.radio.modem.IRadioModem: void getModemActivityInfo(int)>
<android.hardware.radio.modem.IRadioModem: java.lang.String getInterfaceHash()>
<android.hardware.radio.modem.IRadioModem: void setResponseFunctions(android.hardware.radio.modem.IRadioModemResponse,android.hardware.radio.modem.IRadioModemIndication)>
<android.hardware.radio.modem.IRadioModem: void getHardwareConfig(int)>
<android.hardware.radio.modem.IRadioModem: void nvWriteItem(int,android.hardware.radio.modem.NvWriteItem)>
<android.hardware.radio.modem.IRadioModem: void nvReadItem(int,int)>
<android.hardware.radio.modem.IRadioModem: int getInterfaceVersion()>
<android.hardware.radio.modem.IRadioModem: void getBasebandVersion(int)>
<android.hardware.radio.modem.IRadioModem: void setRadioPower(int,boolean,boolean,boolean)>
<android.hardware.radio.modem.IRadioModem: void responseAcknowledgement()>
<android.hardware.radio.modem.IRadioModem: void enableModem(int,boolean)>
<android.hardware.radio.modem.IRadioModem: void nvWriteCdmaPrl(int,byte[])>
<android.hardware.gnss.IGnssAntennaInfo: void close()>
<android.hardware.gnss.IGnssAntennaInfo: int getInterfaceVersion()>
<android.hardware.gnss.IGnssAntennaInfo: void setCallback(android.hardware.gnss.IGnssAntennaInfoCallback)>
<android.hardware.gnss.IGnssAntennaInfo: java.lang.String getInterfaceHash()>
<android.hardware.tv.tuner.IFilterCallback: java.lang.String getInterfaceHash()>
<android.hardware.tv.tuner.IFilterCallback: int getInterfaceVersion()>
<android.hardware.tv.tuner.IFilterCallback: void onFilterEvent(android.hardware.tv.tuner.DemuxFilterEvent[])>
<android.hardware.tv.tuner.IFilterCallback: void onFilterStatus(byte)>
<android.hardware.cas.ICasListener: void onEvent(int,int,byte[])>
<android.hardware.cas.ICasListener: void onStatusUpdate(byte,int)>
<android.hardware.cas.ICasListener: void onSessionEvent(byte[],int,int,byte[])>
<android.hardware.cas.ICasListener: java.lang.String getInterfaceHash()>
<android.hardware.cas.ICasListener: int getInterfaceVersion()>
<android.se.omapi.ISecureElementReader: int getInterfaceVersion()>
<android.se.omapi.ISecureElementReader: void closeSessions()>
<android.se.omapi.ISecureElementReader: boolean isSecureElementPresent()>
<android.se.omapi.ISecureElementReader: java.lang.String getInterfaceHash()>
<android.se.omapi.ISecureElementReader: android.se.omapi.ISecureElementSession openSession()>
<android.se.omapi.ISecureElementReader: boolean reset()>
<android.hardware.radio.network.IRadioNetwork: void setCellInfoListRate(int,int)>
<android.hardware.radio.network.IRadioNetwork: void getAvailableBandModes(int)>
<android.hardware.radio.network.IRadioNetwork: void setLocationUpdates(int,boolean)>
<android.hardware.radio.network.IRadioNetwork: void setResponseFunctions(android.hardware.radio.network.IRadioNetworkResponse,android.hardware.radio.network.IRadioNetworkIndication)>
<android.hardware.radio.network.IRadioNetwork: void setSystemSelectionChannels(int,boolean,android.hardware.radio.network.RadioAccessSpecifier[])>
<android.hardware.radio.network.IRadioNetwork: void getVoiceRadioTechnology(int)>
<android.hardware.radio.network.IRadioNetwork: void stopNetworkScan(int)>
<android.hardware.radio.network.IRadioNetwork: void getCdmaRoamingPreference(int)>
<android.hardware.radio.network.IRadioNetwork: void supplyNetworkDepersonalization(int,java.lang.String)>
<android.hardware.radio.network.IRadioNetwork: void getCellInfoList(int)>
<android.hardware.radio.network.IRadioNetwork: void setBandMode(int,int)>
<android.hardware.radio.network.IRadioNetwork: void getVoiceRegistrationState(int)>
<android.hardware.radio.network.IRadioNetwork: void setBarringPassword(int,java.lang.String,java.lang.String,java.lang.String)>
<android.hardware.radio.network.IRadioNetwork: void triggerEmergencyNetworkScan(int,android.hardware.radio.network.EmergencyNetworkScanTrigger)>
<android.hardware.radio.network.IRadioNetwork: void cancelEmergencyNetworkScan(int,boolean)>
<android.hardware.radio.network.IRadioNetwork: void isNullCipherAndIntegrityEnabled(int)>
<android.hardware.radio.network.IRadioNetwork: void getBarringInfo(int)>
<android.hardware.radio.network.IRadioNetwork: void setAllowedNetworkTypesBitmap(int,int)>
<android.hardware.radio.network.IRadioNetwork: void setSignalStrengthReportingCriteria(int,android.hardware.radio.network.SignalThresholdInfo[])>
<android.hardware.radio.network.IRadioNetwork: void getSystemSelectionChannels(int)>
<android.hardware.radio.network.IRadioNetwork: java.lang.String getInterfaceHash()>
<android.hardware.radio.network.IRadioNetwork: void getNetworkSelectionMode(int)>
<android.hardware.radio.network.IRadioNetwork: void setIndicationFilter(int,int)>
<android.hardware.radio.network.IRadioNetwork: void isNrDualConnectivityEnabled(int)>
<android.hardware.radio.network.IRadioNetwork: void getImsRegistrationState(int)>
<android.hardware.radio.network.IRadioNetwork: void setNetworkSelectionModeManual(int,java.lang.String,int)>
<android.hardware.radio.network.IRadioNetwork: void setEmergencyMode(int,int)>
<android.hardware.radio.network.IRadioNetwork: void setN1ModeEnabled(int,boolean)>
<android.hardware.radio.network.IRadioNetwork: void startNetworkScan(int,android.hardware.radio.network.NetworkScanRequest)>
<android.hardware.radio.network.IRadioNetwork: void getUsageSetting(int)>
<android.hardware.radio.network.IRadioNetwork: void setSuppServiceNotifications(int,boolean)>
<android.hardware.radio.network.IRadioNetwork: void setNetworkSelectionModeAutomatic(int)>
<android.hardware.radio.network.IRadioNetwork: void getOperator(int)>
<android.hardware.radio.network.IRadioNetwork: void getSignalStrength(int)>
<android.hardware.radio.network.IRadioNetwork: void getAllowedNetworkTypesBitmap(int)>
<android.hardware.radio.network.IRadioNetwork: void setNullCipherAndIntegrityEnabled(int,boolean)>
<android.hardware.radio.network.IRadioNetwork: void setNrDualConnectivityState(int,byte)>
<android.hardware.radio.network.IRadioNetwork: void setCdmaRoamingPreference(int,int)>
<android.hardware.radio.network.IRadioNetwork: void responseAcknowledgement()>
<android.hardware.radio.network.IRadioNetwork: void setUsageSetting(int,int)>
<android.hardware.radio.network.IRadioNetwork: void exitEmergencyMode(int)>
<android.hardware.radio.network.IRadioNetwork: int getInterfaceVersion()>
<android.hardware.radio.network.IRadioNetwork: void getAvailableNetworks(int)>
<android.hardware.radio.network.IRadioNetwork: void isN1ModeEnabled(int)>
<android.hardware.radio.network.IRadioNetwork: void setLinkCapacityReportingCriteria(int,int,int,int,int[],int[],int)>
<android.hardware.radio.network.IRadioNetwork: void getDataRegistrationState(int)>
<android.location.IGeocodeListener: void onResults(java.lang.String,java.util.List)>
<android.app.job.IUserVisibleJobObserver: void onUserVisibleJobStateChanged(android.app.job.UserVisibleJobSummary,boolean)>
<android.debug.IAdbManager: int getAdbWirelessPort()>
<android.debug.IAdbManager: void unpairDevice(java.lang.String)>
<android.debug.IAdbManager: void clearDebuggingKeys()>
<android.debug.IAdbManager: android.debug.FingerprintAndPairDevice[] getPairedDevices()>
<android.debug.IAdbManager: void allowDebugging(boolean,java.lang.String)>
<android.debug.IAdbManager: void allowWirelessDebugging(boolean,java.lang.String)>
<android.debug.IAdbManager: void unregisterCallback(android.debug.IAdbCallback)>
<android.debug.IAdbManager: void disablePairing()>
<android.debug.IAdbManager: void denyDebugging()>
<android.debug.IAdbManager: void enablePairingByQrCode(java.lang.String,java.lang.String)>
<android.debug.IAdbManager: void denyWirelessDebugging()>
<android.debug.IAdbManager: void registerCallback(android.debug.IAdbCallback)>
<android.debug.IAdbManager: boolean isAdbWifiQrSupported()>
<android.debug.IAdbManager: void enablePairingByPairingCode()>
<android.debug.IAdbManager: boolean isAdbWifiSupported()>
<android.os.IDumpstateListener: void onError(int)>
<android.os.IDumpstateListener: void onProgress(int)>
<android.os.IDumpstateListener: void onUiIntensiveBugreportDumpsFinished()>
<android.os.IDumpstateListener: void onFinished(java.lang.String)>
<android.os.IDumpstateListener: void onScreenshotTaken(boolean)>
<android.hardware.camera2.extension.IAdvancedExtenderImpl: android.hardware.camera2.impl.CameraMetadataNative getAvailableCaptureResultKeys(java.lang.String)>
<android.hardware.camera2.extension.IAdvancedExtenderImpl: java.util.List getSupportedPreviewOutputResolutions(java.lang.String)>
<android.hardware.camera2.extension.IAdvancedExtenderImpl: void init(java.lang.String,java.util.Map)>
<android.hardware.camera2.extension.IAdvancedExtenderImpl: java.util.List getSupportedPostviewResolutions(android.hardware.camera2.extension.Size)>
<android.hardware.camera2.extension.IAdvancedExtenderImpl: boolean isCaptureProcessProgressAvailable()>
<android.hardware.camera2.extension.IAdvancedExtenderImpl: android.hardware.camera2.extension.LatencyRange getEstimatedCaptureLatencyRange(java.lang.String,android.hardware.camera2.extension.Size,int)>
<android.hardware.camera2.extension.IAdvancedExtenderImpl: java.util.List getSupportedCaptureOutputResolutions(java.lang.String)>
<android.hardware.camera2.extension.IAdvancedExtenderImpl: android.hardware.camera2.impl.CameraMetadataNative getAvailableCaptureRequestKeys(java.lang.String)>
<android.hardware.camera2.extension.IAdvancedExtenderImpl: boolean isPostviewAvailable()>
<android.hardware.camera2.extension.IAdvancedExtenderImpl: android.hardware.camera2.extension.ISessionProcessorImpl getSessionProcessor()>
<android.hardware.camera2.extension.IAdvancedExtenderImpl: boolean isExtensionAvailable(java.lang.String,java.util.Map)>
<com.android.internal.app.ISoundTriggerService: void setInPhoneCallState(boolean)>
<com.android.internal.app.ISoundTriggerService: com.android.internal.app.ISoundTriggerSession attachAsOriginator(android.media.permission.Identity,android.hardware.soundtrigger.SoundTrigger$ModuleProperties,android.os.IBinder)>
<com.android.internal.app.ISoundTriggerService: void attachInjection(android.media.soundtrigger_middleware.ISoundTriggerInjection)>
<com.android.internal.app.ISoundTriggerService: com.android.internal.app.ISoundTriggerSession attachAsMiddleman(android.media.permission.Identity,android.media.permission.Identity,android.hardware.soundtrigger.SoundTrigger$ModuleProperties,android.os.IBinder)>
<com.android.internal.app.ISoundTriggerService: java.util.List listModuleProperties(android.media.permission.Identity)>
<android.hardware.gnss.IGnssBatching: void stop()>
<android.hardware.gnss.IGnssBatching: void flush()>
<android.hardware.gnss.IGnssBatching: int getBatchSize()>
<android.hardware.gnss.IGnssBatching: void start(android.hardware.gnss.IGnssBatching$Options)>
<android.hardware.gnss.IGnssBatching: void cleanup()>
<android.hardware.gnss.IGnssBatching: void init(android.hardware.gnss.IGnssBatchingCallback)>
<android.hardware.gnss.IGnssBatching: java.lang.String getInterfaceHash()>
<android.hardware.gnss.IGnssBatching: int getInterfaceVersion()>
<android.media.IMediaRouterService: void setBluetoothA2dpOn(android.media.IMediaRouterClient,boolean)>
<android.media.IMediaRouterService: void setRouteVolumeWithRouter2(android.media.IMediaRouter2,android.media.MediaRoute2Info,int)>
<android.media.IMediaRouterService: void requestSetVolume(android.media.IMediaRouterClient,java.lang.String,int)>
<android.media.IMediaRouterService: boolean showMediaOutputSwitcher(java.lang.String)>
<android.media.IMediaRouterService: void setDiscoveryRequest(android.media.IMediaRouterClient,int,boolean)>
<android.media.IMediaRouterService: void setSessionVolumeWithManager(android.media.IMediaRouter2Manager,int,java.lang.String,int)>
<android.media.IMediaRouterService: void registerClientAsUser(android.media.IMediaRouterClient,java.lang.String,int)>
<android.media.IMediaRouterService: void deselectRouteWithRouter2(android.media.IMediaRouter2,java.lang.String,android.media.MediaRoute2Info)>
<android.media.IMediaRouterService: void transferToRouteWithManager(android.media.IMediaRouter2Manager,int,java.lang.String,android.media.MediaRoute2Info)>
<android.media.IMediaRouterService: android.media.RoutingSessionInfo getSystemSessionInfoForPackage(android.media.IMediaRouter2Manager,java.lang.String)>
<android.media.IMediaRouterService: void selectRouteWithManager(android.media.IMediaRouter2Manager,int,java.lang.String,android.media.MediaRoute2Info)>
<android.media.IMediaRouterService: void setRouteListingPreference(android.media.IMediaRouter2,android.media.RouteListingPreference)>
<android.media.IMediaRouterService: void transferToRouteWithRouter2(android.media.IMediaRouter2,java.lang.String,android.media.MediaRoute2Info)>
<android.media.IMediaRouterService: void setSelectedRoute(android.media.IMediaRouterClient,java.lang.String,boolean)>
<android.media.IMediaRouterService: java.util.List getRemoteSessions(android.media.IMediaRouter2Manager)>
<android.media.IMediaRouterService: void registerClientGroupId(android.media.IMediaRouterClient,java.lang.String)>
<android.media.IMediaRouterService: void registerManager(android.media.IMediaRouter2Manager,java.lang.String)>
<android.media.IMediaRouterService: void setRouteVolumeWithManager(android.media.IMediaRouter2Manager,int,android.media.MediaRoute2Info,int)>
<android.media.IMediaRouterService: void unregisterClient(android.media.IMediaRouterClient)>
<android.media.IMediaRouterService: void stopScan(android.media.IMediaRouter2Manager)>
<android.media.IMediaRouterService: java.util.List getSystemRoutes()>
<android.media.IMediaRouterService: void setDiscoveryRequestWithRouter2(android.media.IMediaRouter2,android.media.RouteDiscoveryPreference)>
<android.media.IMediaRouterService: void requestCreateSessionWithRouter2(android.media.IMediaRouter2,int,long,android.media.RoutingSessionInfo,android.media.MediaRoute2Info,android.os.Bundle)>
<android.media.IMediaRouterService: void registerRouter2(android.media.IMediaRouter2,java.lang.String)>
<android.media.IMediaRouterService: void startScan(android.media.IMediaRouter2Manager)>
<android.media.IMediaRouterService: boolean isPlaybackActive(android.media.IMediaRouterClient)>
<android.media.IMediaRouterService: void releaseSessionWithManager(android.media.IMediaRouter2Manager,int,java.lang.String)>
<android.media.IMediaRouterService: void releaseSessionWithRouter2(android.media.IMediaRouter2,java.lang.String)>
<android.media.IMediaRouterService: void unregisterManager(android.media.IMediaRouter2Manager)>
<android.media.IMediaRouterService: void unregisterRouter2(android.media.IMediaRouter2)>
<android.media.IMediaRouterService: void requestUpdateVolume(android.media.IMediaRouterClient,java.lang.String,int)>
<android.media.IMediaRouterService: boolean verifyPackageExists(java.lang.String)>
<android.media.IMediaRouterService: android.media.MediaRouterClientState getState(android.media.IMediaRouterClient)>
<android.media.IMediaRouterService: void setSessionVolumeWithRouter2(android.media.IMediaRouter2,java.lang.String,int)>
<android.media.IMediaRouterService: android.media.RoutingSessionInfo getSystemSessionInfo()>
<android.media.IMediaRouterService: void deselectRouteWithManager(android.media.IMediaRouter2Manager,int,java.lang.String,android.media.MediaRoute2Info)>
<android.media.IMediaRouterService: void selectRouteWithRouter2(android.media.IMediaRouter2,java.lang.String,android.media.MediaRoute2Info)>
<android.media.IMediaRouterService: void requestCreateSessionWithManager(android.media.IMediaRouter2Manager,int,android.media.RoutingSessionInfo,android.media.MediaRoute2Info)>
<android.companion.ICompanionDeviceDiscoveryService: void startDiscovery(android.companion.AssociationRequest,java.lang.String,android.companion.IAssociationRequestCallback,com.android.internal.infra.AndroidFuture)>
<android.companion.ICompanionDeviceDiscoveryService: void onAssociationCreated()>
<com.samsung.android.multiwindow.IFreeformCallback: void onMinimized(android.content.ComponentName,int,int,int,int,boolean)>
<com.samsung.android.multiwindow.IFreeformCallback: void onTaskMoveEnded(int,android.os.IRemoteCallback)>
<com.samsung.android.multiwindow.IFreeformCallback: void onMinimizeAnimationEnd(int)>
<com.samsung.android.multiwindow.IFreeformCallback: void onTaskMoveStarted(int,android.graphics.Point)>
<com.samsung.android.multiwindow.IFreeformCallback: void onUnminimized(int)>
<android.app.time.ITimeDetectorListener: void onChange()>
<android.nfc.cardemulation.ISeSettingsService: void setSeacActive(android.content.ComponentName,boolean)>
<android.hardware.camera2.extension.ICaptureProcessorImpl: void onImageFormatUpdate(int)>
<android.hardware.camera2.extension.ICaptureProcessorImpl: void onPostviewOutputSurface(android.view.Surface)>
<android.hardware.camera2.extension.ICaptureProcessorImpl: void onOutputSurface(android.view.Surface,int)>
<android.hardware.camera2.extension.ICaptureProcessorImpl: void process(java.util.List,android.hardware.camera2.extension.IProcessResultImpl,boolean)>
<android.hardware.camera2.extension.ICaptureProcessorImpl: void onResolutionUpdate(android.hardware.camera2.extension.Size,android.hardware.camera2.extension.Size)>
<com.android.internal.widget.ICheckCredentialProgressCallback: void onCredentialVerified()>
<android.content.rollback.IRollbackManager: void commitRollback(int,android.content.pm.ParceledListSlice,java.lang.String,android.content.IntentSender)>
<android.content.rollback.IRollbackManager: void reloadPersistedData()>
<android.content.rollback.IRollbackManager: int notifyStagedSession(int)>
<android.content.rollback.IRollbackManager: void expireRollbackForPackage(java.lang.String)>
<android.content.rollback.IRollbackManager: android.content.pm.ParceledListSlice getAvailableRollbacks()>
<android.content.rollback.IRollbackManager: android.content.pm.ParceledListSlice getRecentlyCommittedRollbacks()>
<android.content.rollback.IRollbackManager: void blockRollbackManager(long)>
<android.content.rollback.IRollbackManager: void snapshotAndRestoreUserData(java.lang.String,int[],int,long,java.lang.String,int)>
<android.os.IExternalVibrationController: boolean unmute()>
<android.os.IExternalVibrationController: boolean mute()>
<android.content.pm.IPackageDataObserver: void onRemoveCompleted(java.lang.String,boolean)>
<android.media.musicrecognition.IMusicRecognitionService: void getAttributionTag(android.media.musicrecognition.IMusicRecognitionAttributionTagCallback)>
<android.media.musicrecognition.IMusicRecognitionService: void onAudioStreamStarted(android.os.ParcelFileDescriptor,android.media.AudioFormat,android.media.musicrecognition.IMusicRecognitionServiceCallback)>
<android.content.pm.IDataLoaderManager: boolean bindToDataLoader(int,android.content.pm.DataLoaderParamsParcel,long,android.content.pm.IDataLoaderStatusListener)>
<android.content.pm.IDataLoaderManager: android.content.pm.IDataLoader getDataLoader(int)>
<android.content.pm.IDataLoaderManager: void unbindFromDataLoader(int)>
<com.android.internal.app.IHotwordRecognitionStatusCallback: void onRejected(android.service.voice.HotwordRejectedResult)>
<com.android.internal.app.IHotwordRecognitionStatusCallback: void onStatusReported(int)>
<com.android.internal.app.IHotwordRecognitionStatusCallback: void onProcessRestarted()>
<com.android.internal.app.IHotwordRecognitionStatusCallback: void onRecognitionResumed()>
<com.android.internal.app.IHotwordRecognitionStatusCallback: void onGenericSoundTriggerDetected(android.hardware.soundtrigger.SoundTrigger$GenericRecognitionEvent)>
<com.android.internal.app.IHotwordRecognitionStatusCallback: void onSoundTriggerFailure(android.service.voice.SoundTriggerFailure)>
<com.android.internal.app.IHotwordRecognitionStatusCallback: void onUnknownFailure(java.lang.String)>
<com.android.internal.app.IHotwordRecognitionStatusCallback: void onKeyphraseDetected(android.hardware.soundtrigger.SoundTrigger$KeyphraseRecognitionEvent,android.service.voice.HotwordDetectedResult)>
<com.android.internal.app.IHotwordRecognitionStatusCallback: void onVisualQueryDetectionServiceFailure(android.service.voice.VisualQueryDetectionServiceFailure)>
<com.android.internal.app.IHotwordRecognitionStatusCallback: void onHotwordDetectionServiceFailure(android.service.voice.HotwordDetectionServiceFailure)>
<com.android.internal.app.IHotwordRecognitionStatusCallback: void onRecognitionPaused()>
<android.credentials.IPrepareGetCredentialCallback: void onError(java.lang.String,java.lang.String)>
<android.credentials.IPrepareGetCredentialCallback: void onResponse(android.credentials.PrepareGetCredentialResponseInternal)>
<android.app.search.ISearchCallback: void onResult(android.content.pm.ParceledListSlice)>
<com.samsung.android.remoteappmode.IRemoteAppModeListener: void onRemoteAppModeStateChanged(boolean)>
<android.app.IScreenCaptureObserver: void onScreenCaptured()>
<com.android.internal.inputmethod.IRemoteAccessibilityInputConnection: void sendKeyEvent(com.android.internal.inputmethod.InputConnectionCommandHeader,android.view.KeyEvent)>
<com.android.internal.inputmethod.IRemoteAccessibilityInputConnection: void setSelection(com.android.internal.inputmethod.InputConnectionCommandHeader,int,int)>
<com.android.internal.inputmethod.IRemoteAccessibilityInputConnection: void getSurroundingText(com.android.internal.inputmethod.InputConnectionCommandHeader,int,int,int,com.android.internal.infra.AndroidFuture)>
<com.android.internal.inputmethod.IRemoteAccessibilityInputConnection: void clearMetaKeyStates(com.android.internal.inputmethod.InputConnectionCommandHeader,int)>
<com.android.internal.inputmethod.IRemoteAccessibilityInputConnection: void deleteSurroundingText(com.android.internal.inputmethod.InputConnectionCommandHeader,int,int)>
<com.android.internal.inputmethod.IRemoteAccessibilityInputConnection: void performContextMenuAction(com.android.internal.inputmethod.InputConnectionCommandHeader,int)>
<com.android.internal.inputmethod.IRemoteAccessibilityInputConnection: void performEditorAction(com.android.internal.inputmethod.InputConnectionCommandHeader,int)>
<com.android.internal.inputmethod.IRemoteAccessibilityInputConnection: void commitText(com.android.internal.inputmethod.InputConnectionCommandHeader,java.lang.CharSequence,int,android.view.inputmethod.TextAttribute)>
<com.android.internal.inputmethod.IRemoteAccessibilityInputConnection: void getCursorCapsMode(com.android.internal.inputmethod.InputConnectionCommandHeader,int,com.android.internal.infra.AndroidFuture)>
<android.media.IAudioPolicyServiceClient: void onDynamicPolicyMixStateUpdate(java.lang.String,int)>
<android.media.IAudioPolicyServiceClient: void onRecordingConfigurationUpdate(int,android.media.RecordClientInfo,android.media.audio.common.AudioConfigBase,android.media.EffectDescriptor[],android.media.audio.common.AudioConfigBase,android.media.EffectDescriptor[],int,int)>
<android.media.IAudioPolicyServiceClient: void onAudioPatchListUpdate()>
<android.media.IAudioPolicyServiceClient: void onAudioPortListUpdate()>
<android.media.IAudioPolicyServiceClient: void onVolumeRangeInitRequest()>
<android.media.IAudioPolicyServiceClient: void onRoutingUpdated()>
<android.media.IAudioPolicyServiceClient: void onAudioVolumeGroupChanged(int,int)>
<android.hardware.vibrator.IVibratorCallback: java.lang.String getInterfaceHash()>
<android.hardware.vibrator.IVibratorCallback: void onComplete()>
<android.hardware.vibrator.IVibratorCallback: int getInterfaceVersion()>
<com.samsung.android.content.clipboard.IOnClipboardEventListener: void onClipboardEvent(int,com.samsung.android.content.clipboard.data.SemClipData)>
<com.samsung.android.content.clipboard.IOnClipboardEventListener: void onUpdateFilter(int)>
<com.samsung.android.sepunion.IUnionManager: void setDumpEnabled(java.lang.String,java.lang.String)>
<com.samsung.android.sepunion.IUnionManager: android.os.IBinder getSemSystemService(java.lang.String,android.os.Bundle)>
<android.service.dreams.IDreamManager: void awaken()>
<android.service.dreams.IDreamManager: void registerDreamOverlayService(android.content.ComponentName)>
<android.service.dreams.IDreamManager: void stopDozing(android.os.IBinder)>
<android.service.dreams.IDreamManager: void finishSelf(android.os.IBinder,boolean)>
<android.service.dreams.IDreamManager: void forceAmbientDisplayEnabled(boolean)>
<android.service.dreams.IDreamManager: boolean isDreamingOrInPreview()>
<android.service.dreams.IDreamManager: void startDozing(android.os.IBinder,int,int)>
<android.service.dreams.IDreamManager: void dream()>
<android.service.dreams.IDreamManager: void setDreamComponents(android.content.ComponentName[])>
<android.service.dreams.IDreamManager: android.content.ComponentName getDefaultDreamComponentForUser(int)>
<android.service.dreams.IDreamManager: void testDream(int,android.content.ComponentName)>
<android.service.dreams.IDreamManager: void semStartDozing(android.os.IBinder,int,int,int,boolean)>
<android.service.dreams.IDreamManager: android.content.ComponentName[] getDreamComponentsForUser(int)>
<android.service.dreams.IDreamManager: void setSystemDreamComponent(android.content.ComponentName)>
<android.service.dreams.IDreamManager: android.content.ComponentName[] getDreamComponents()>
<android.service.dreams.IDreamManager: boolean isDreaming()>
<android.service.dreams.IDreamManager: void setDreamComponentsForUser(int,android.content.ComponentName[])>
<android.hardware.vibrator.IVibratorManager: int getInterfaceVersion()>
<android.hardware.vibrator.IVibratorManager: void prepareSynced(int[])>
<android.hardware.vibrator.IVibratorManager: void triggerSynced(android.hardware.vibrator.IVibratorCallback)>
<android.hardware.vibrator.IVibratorManager: void cancelSynced()>
<android.hardware.vibrator.IVibratorManager: int[] getVibratorIds()>
<android.hardware.vibrator.IVibratorManager: int getCapabilities()>
<android.hardware.vibrator.IVibratorManager: java.lang.String getInterfaceHash()>
<android.hardware.vibrator.IVibratorManager: android.hardware.vibrator.IVibrator getVibrator(int)>
<android.app.slice.ISliceListener: void onSliceUpdated(android.app.slice.Slice)>
<android.view.autofill.IAugmentedAutofillManagerClient: void autofill(int,java.util.List,java.util.List,boolean)>
<android.view.autofill.IAugmentedAutofillManagerClient: boolean requestAutofill(int,android.view.autofill.AutofillId)>
<android.view.autofill.IAugmentedAutofillManagerClient: android.graphics.Rect getViewCoordinates(android.view.autofill.AutofillId)>
<android.view.autofill.IAugmentedAutofillManagerClient: void requestHideFillUi(int,android.view.autofill.AutofillId)>
<android.view.autofill.IAugmentedAutofillManagerClient: android.app.assist.AssistStructure$ViewNodeParcelable getViewNodeParcelable(android.view.autofill.AutofillId)>
<android.view.autofill.IAugmentedAutofillManagerClient: void requestShowFillUi(int,android.view.autofill.AutofillId,int,int,android.graphics.Rect,android.view.autofill.IAutofillWindowPresenter)>
<android.hardware.ISensorPrivacyManager: boolean isToggleSensorPrivacyEnabled(int,int)>
<android.hardware.ISensorPrivacyManager: void setToggleSensorPrivacy(int,int,int,boolean)>
<android.hardware.ISensorPrivacyManager: boolean supportsSensorToggle(int,int)>
<android.hardware.ISensorPrivacyManager: void addSensorPrivacyListener(android.hardware.ISensorPrivacyListener)>
<android.hardware.ISensorPrivacyManager: boolean requiresAuthentication()>
<android.hardware.ISensorPrivacyManager: void setToggleSensorPrivacyForProfileGroup(int,int,int,boolean)>
<android.hardware.ISensorPrivacyManager: void showSensorUseDialog(int)>
<android.hardware.ISensorPrivacyManager: void suppressToggleSensorPrivacyReminders(int,int,android.os.IBinder,boolean)>
<android.hardware.ISensorPrivacyManager: void removeSensorPrivacyListener(android.hardware.ISensorPrivacyListener)>
<android.hardware.ISensorPrivacyManager: boolean isCombinedToggleSensorPrivacyEnabled(int)>
<android.hardware.ISensorPrivacyManager: void setSensorPrivacy(boolean)>
<android.hardware.ISensorPrivacyManager: void addToggleSensorPrivacyListener(android.hardware.ISensorPrivacyListener)>
<android.hardware.ISensorPrivacyManager: void removeToggleSensorPrivacyListener(android.hardware.ISensorPrivacyListener)>
<android.hardware.ISensorPrivacyManager: boolean isSensorPrivacyEnabled()>
<android.hardware.ISensorPrivacyManager: void setToggleSensorPrivacyForProfileGroupWithConfirmPopup(int,int,int,boolean)>
<android.spay.ITAController: boolean clearDeviceCertificates(java.lang.String)>
<android.spay.ITAController: android.spay.TACommandResponse processTACommand(android.spay.TACommandRequest)>
<android.spay.ITAController: void unloadTA()>
<android.spay.ITAController: boolean loadTA(android.os.ParcelFileDescriptor,long,long)>
<android.spay.ITAController: android.spay.CertInfo checkCertInfo(java.util.List)>
<android.spay.ITAController: boolean makeSystemCall(int)>
<android.hardware.vibrator.IVibrator: void compose(android.hardware.vibrator.CompositeEffect[],android.hardware.vibrator.IVibratorCallback)>
<android.hardware.vibrator.IVibrator: float getResonantFrequency()>
<android.hardware.vibrator.IVibrator: int perform(int,byte,android.hardware.vibrator.IVibratorCallback)>
<android.hardware.vibrator.IVibrator: int[] getSupportedAlwaysOnEffects()>
<android.hardware.vibrator.IVibrator: int getPrimitiveDuration(int)>
<android.hardware.vibrator.IVibrator: void alwaysOnEnable(int,int,byte)>
<android.hardware.vibrator.IVibrator: int getInterfaceVersion()>
<android.hardware.vibrator.IVibrator: void setExternalControl(boolean)>
<android.hardware.vibrator.IVibrator: void composePwle(android.hardware.vibrator.PrimitivePwle[],android.hardware.vibrator.IVibratorCallback)>
<android.hardware.vibrator.IVibrator: float[] getBandwidthAmplitudeMap()>
<android.hardware.vibrator.IVibrator: int getCompositionSizeMax()>
<android.hardware.vibrator.IVibrator: int[] getSupportedEffects()>
<android.hardware.vibrator.IVibrator: void alwaysOnDisable(int)>
<android.hardware.vibrator.IVibrator: int[] getSupportedPrimitives()>
<android.hardware.vibrator.IVibrator: int getCapabilities()>
<android.hardware.vibrator.IVibrator: void on(int,android.hardware.vibrator.IVibratorCallback)>
<android.hardware.vibrator.IVibrator: float getFrequencyMinimum()>
<android.hardware.vibrator.IVibrator: int[] getSupportedBraking()>
<android.hardware.vibrator.IVibrator: int getCompositionDelayMax()>
<android.hardware.vibrator.IVibrator: float getFrequencyResolution()>
<android.hardware.vibrator.IVibrator: float getQFactor()>
<android.hardware.vibrator.IVibrator: int getPwleCompositionSizeMax()>
<android.hardware.vibrator.IVibrator: int getPwlePrimitiveDurationMax()>
<android.hardware.vibrator.IVibrator: java.lang.String getInterfaceHash()>
<android.hardware.vibrator.IVibrator: void setAmplitude(float)>
<android.hardware.vibrator.IVibrator: void off()>
<com.android.internal.policy.IKeyguardDrawnCallback: void onDrawn()>
<android.service.oemlock.IOemLockService: boolean isOemUnlockAllowed()>
<android.service.oemlock.IOemLockService: boolean isDeviceOemUnlocked()>
<android.service.oemlock.IOemLockService: void setOemUnlockAllowedByCarrier(boolean,byte[])>
<android.service.oemlock.IOemLockService: boolean isOemUnlockAllowedByCarrier()>
<android.service.oemlock.IOemLockService: void setOemUnlockAllowedByUser(boolean)>
<android.service.oemlock.IOemLockService: java.lang.String getLockName()>
<android.service.oemlock.IOemLockService: boolean isOemUnlockAllowedByUser()>
<com.samsung.android.core.IFoldStarManager: void setFrontScreenOnWhenAppContinuityMode(boolean)>
<com.samsung.android.core.IFoldStarManager: java.util.Map getDisplayCompatPackages(int,int,java.util.Map)>
<com.samsung.android.core.IFoldStarManager: void initAppContinuityValueWhenReset(boolean,boolean)>
<com.samsung.android.core.IFoldStarManager: void unregisterFoldStarCallback(com.samsung.android.core.IFoldStarCallback)>
<com.samsung.android.core.IFoldStarManager: void setFixedAspectRatioPackages(int,java.util.Map,boolean)>
<com.samsung.android.core.IFoldStarManager: void setDisplayCompatPackages(int,java.util.Map,boolean)>
<com.samsung.android.core.IFoldStarManager: void registerFoldStarCallback(com.samsung.android.core.IFoldStarCallback)>
<com.samsung.android.core.IFoldStarManager: void setAppContinuityMode(java.lang.String,int,boolean)>
<com.samsung.android.core.IFoldStarManager: java.util.Map getFixedAspectRatioPackages(int,int,java.util.Map)>
<com.samsung.android.core.IFoldStarManager: void setAllAppContinuityMode(int,boolean)>
<android.media.ISpatializerHeadTrackingModeCallback: void dispatchSpatializerDesiredHeadTrackingModeChanged(int)>
<android.media.ISpatializerHeadTrackingModeCallback: void dispatchSpatializerActualHeadTrackingModeChanged(int)>
<android.security.identity.ICredential: android.security.identity.IWritableCredential update()>
<android.security.identity.ICredential: long[] getAuthenticationDataExpirations()>
<android.security.identity.ICredential: void setReaderEphemeralPublicKey(byte[])>
<android.security.identity.ICredential: byte[] getCredentialKeyCertificateChain()>
<android.security.identity.ICredential: android.security.identity.GetEntriesResultParcel getEntries(byte[],android.security.identity.RequestNamespaceParcel[],byte[],byte[],boolean,boolean,boolean)>
<android.security.identity.ICredential: void setAvailableAuthenticationKeys(int,int,long)>
<android.security.identity.ICredential: byte[] deleteCredential()>
<android.security.identity.ICredential: int[] getAuthenticationDataUsageCount()>
<android.security.identity.ICredential: void storeStaticAuthenticationData(android.security.identity.AuthKeyParcel,byte[])>
<android.security.identity.ICredential: long selectAuthKey(boolean,boolean,boolean)>
<android.security.identity.ICredential: byte[] createEphemeralKeyPair()>
<android.security.identity.ICredential: byte[] proveOwnership(byte[])>
<android.security.identity.ICredential: byte[] deleteWithChallenge(byte[])>
<android.security.identity.ICredential: void storeStaticAuthenticationDataWithExpiration(android.security.identity.AuthKeyParcel,long,byte[])>
<android.security.identity.ICredential: android.security.identity.AuthKeyParcel[] getAuthKeysNeedingCertification()>
<vendor.samsung.hardware.radio.network.ISehRadioNetworkResponse: int getInterfaceVersion()>
<vendor.samsung.hardware.radio.network.ISehRadioNetworkResponse: void emergencyControlResponse(vendor.samsung.hardware.radio.SehRadioResponseInfo)>
<vendor.samsung.hardware.radio.network.ISehRadioNetworkResponse: void emergencySearchResponse(vendor.samsung.hardware.radio.SehRadioResponseInfo,int)>
<vendor.samsung.hardware.radio.network.ISehRadioNetworkResponse: void setRoamingNetworkInfoViaBLEResponse(vendor.samsung.hardware.radio.SehRadioResponseInfo)>
<vendor.samsung.hardware.radio.network.ISehRadioNetworkResponse: void getNrIconTypeResponse(vendor.samsung.hardware.radio.SehRadioResponseInfo,int)>
<vendor.samsung.hardware.radio.network.ISehRadioNetworkResponse: void sendRequestStringsResponse(vendor.samsung.hardware.radio.SehRadioResponseInfo,java.lang.String[])>
<vendor.samsung.hardware.radio.network.ISehRadioNetworkResponse: void getDisable2gResponse(vendor.samsung.hardware.radio.SehRadioResponseInfo,int)>
<vendor.samsung.hardware.radio.network.ISehRadioNetworkResponse: void setScanResultViaBLEResponse(vendor.samsung.hardware.radio.SehRadioResponseInfo)>
<vendor.samsung.hardware.radio.network.ISehRadioNetworkResponse: void getCnapResponse(vendor.samsung.hardware.radio.SehRadioResponseInfo,int)>
<vendor.samsung.hardware.radio.network.ISehRadioNetworkResponse: void setDisable2gResponse(vendor.samsung.hardware.radio.SehRadioResponseInfo)>
<vendor.samsung.hardware.radio.network.ISehRadioNetworkResponse: void sendEncodedUssdResponse(vendor.samsung.hardware.radio.SehRadioResponseInfo)>
<vendor.samsung.hardware.radio.network.ISehRadioNetworkResponse: void setCurrentNetworkInfoViaBLEResponse(vendor.samsung.hardware.radio.SehRadioResponseInfo)>
<vendor.samsung.hardware.radio.network.ISehRadioNetworkResponse: void sendRequestRawResponse(vendor.samsung.hardware.radio.SehRadioResponseInfo,byte[])>
<vendor.samsung.hardware.radio.network.ISehRadioNetworkResponse: void getVendorSpecificConfigurationResponse(vendor.samsung.hardware.radio.SehRadioResponseInfo,vendor.samsung.hardware.radio.network.SehVendorConfiguration[])>
<vendor.samsung.hardware.radio.network.ISehRadioNetworkResponse: java.lang.String getInterfaceHash()>
<vendor.samsung.hardware.radio.network.ISehRadioNetworkResponse: void setNrModeResponse(vendor.samsung.hardware.radio.SehRadioResponseInfo)>
<vendor.samsung.hardware.radio.network.ISehRadioNetworkResponse: void setImsCallListResponse(vendor.samsung.hardware.radio.SehRadioResponseInfo)>
<vendor.samsung.hardware.radio.network.ISehRadioNetworkResponse: void getCsgListResponse(vendor.samsung.hardware.radio.SehRadioResponseInfo,vendor.samsung.hardware.radio.network.SehCsgInfo[])>
<vendor.samsung.hardware.radio.network.ISehRadioNetworkResponse: void selectCsgManualResponse(vendor.samsung.hardware.radio.SehRadioResponseInfo)>
<vendor.samsung.hardware.radio.network.ISehRadioNetworkResponse: void setVendorSpecificConfigurationResponse(vendor.samsung.hardware.radio.SehRadioResponseInfo)>
<vendor.samsung.hardware.radio.network.ISehRadioNetworkResponse: void getPreferredNetworkListResponse(vendor.samsung.hardware.radio.SehRadioResponseInfo,vendor.samsung.hardware.radio.network.SehPreferredNetworkInfo[])>
<vendor.samsung.hardware.radio.network.ISehRadioNetworkResponse: void setPreferredNetworkListResponse(vendor.samsung.hardware.radio.SehRadioResponseInfo)>
<vendor.samsung.hardware.radio.network.ISehRadioNetworkResponse: void getNrModeResponse(vendor.samsung.hardware.radio.SehRadioResponseInfo,int)>
<vendor.samsung.hardware.radio.network.ISehRadioNetworkResponse: void getAvailableNetworksResponse(vendor.samsung.hardware.radio.SehRadioResponseInfo,vendor.samsung.hardware.radio.network.SehOperatorInfo[])>
<vendor.samsung.hardware.radio.network.ISehRadioNetworkResponse: void getRoamingNetworkInfoViaBLEResponse(vendor.samsung.hardware.radio.SehRadioResponseInfo,vendor.samsung.hardware.radio.network.SehRoamingNetworkInfo[])>
<com.android.internal.inputmethod.IInlineSuggestionsResponseCallback: void onInlineSuggestionsResponse(android.view.autofill.AutofillId,android.view.inputmethod.InlineSuggestionsResponse)>
<android.hardware.gnss.measurement_corrections.IMeasurementCorrectionsCallback: int getInterfaceVersion()>
<android.hardware.gnss.measurement_corrections.IMeasurementCorrectionsCallback: java.lang.String getInterfaceHash()>
<android.hardware.gnss.measurement_corrections.IMeasurementCorrectionsCallback: void setCapabilitiesCb(int)>
<android.hardware.face.IFaceAuthenticatorsRegisteredCallback: void onAllAuthenticatorsRegistered(java.util.List)>
<android.hardware.gnss.visibility_control.IGnssVisibilityControl: void setCallback(android.hardware.gnss.visibility_control.IGnssVisibilityControlCallback)>
<android.hardware.gnss.visibility_control.IGnssVisibilityControl: java.lang.String getInterfaceHash()>
<android.hardware.gnss.visibility_control.IGnssVisibilityControl: int getInterfaceVersion()>
<android.hardware.gnss.visibility_control.IGnssVisibilityControl: void enableNfwLocationAccess(java.lang.String[])>
<android.view.translation.ITranslationManager: void onTranslationFinished(boolean,android.os.IBinder,android.content.ComponentName,int)>
<android.view.translation.ITranslationManager: void unregisterTranslationCapabilityCallback(android.os.IRemoteCallback,int)>
<android.view.translation.ITranslationManager: void updateUiTranslationState(int,android.view.translation.TranslationSpec,android.view.translation.TranslationSpec,java.util.List,android.os.IBinder,int,android.view.translation.UiTranslationSpec,int)>
<android.view.translation.ITranslationManager: void unregisterUiTranslationStateCallback(android.os.IRemoteCallback,int)>
<android.view.translation.ITranslationManager: void onSessionCreated(android.view.translation.TranslationContext,int,com.android.internal.os.IResultReceiver,int)>
<android.view.translation.ITranslationManager: void registerTranslationCapabilityCallback(android.os.IRemoteCallback,int)>
<android.view.translation.ITranslationManager: void getServiceSettingsActivity(com.android.internal.os.IResultReceiver,int)>
<android.view.translation.ITranslationManager: void registerUiTranslationStateCallback(android.os.IRemoteCallback,int)>
<android.view.translation.ITranslationManager: void onTranslationCapabilitiesRequest(int,int,android.os.ResultReceiver,int)>
<android.os.IZtd: int startMonitoringFiles(int,int[],java.util.List,java.util.List,android.os.IZtdListener)>
<android.os.IZtd: void startTracing(int,int,long,android.os.IZtdListener)>
<android.os.IZtd: int startMonitoringDomains(int,int[],java.util.List,android.os.IZtdListener)>
<android.os.IZtd: int stopMonitoringDomains(int)>
<android.os.IZtd: void stopTracing(int,int)>
<android.os.IZtd: int stopMonitoringFiles(int)>
<android.apphibernation.IAppHibernationService: boolean isHibernatingForUser(java.lang.String,int)>
<android.apphibernation.IAppHibernationService: void setHibernatingForUser(java.lang.String,int,boolean)>
<android.apphibernation.IAppHibernationService: java.util.List getHibernatingPackagesForUser(int)>
<android.apphibernation.IAppHibernationService: java.util.Map getHibernationStatsForUser(java.util.List,int)>
<android.apphibernation.IAppHibernationService: void setHibernatingGlobally(java.lang.String,boolean)>
<android.apphibernation.IAppHibernationService: boolean isOatArtifactDeletionEnabled()>
<android.apphibernation.IAppHibernationService: boolean isHibernatingGlobally(java.lang.String)>
<android.content.pm.IPackageMoveObserver: void onStatusChanged(int,int,long)>
<android.content.pm.IPackageMoveObserver: void onCreated(int,android.os.Bundle)>
<com.samsung.android.multicontrol.IInputFilterInstallListener: void onInstalled()>
<com.samsung.android.multicontrol.IInputFilterInstallListener: void onUninstalled()>
<com.android.internal.telephony.euicc.IPrepareDownloadCallback: void onComplete(int,byte[])>
<android.hardware.radio.messaging.IRadioMessaging: void getCdmaBroadcastConfig(int)>
<android.hardware.radio.messaging.IRadioMessaging: void writeSmsToRuim(int,android.hardware.radio.messaging.CdmaSmsWriteArgs)>
<android.hardware.radio.messaging.IRadioMessaging: void sendSms(int,android.hardware.radio.messaging.GsmSmsMessage)>
<android.hardware.radio.messaging.IRadioMessaging: void sendCdmaSmsExpectMore(int,android.hardware.radio.messaging.CdmaSmsMessage)>
<android.hardware.radio.messaging.IRadioMessaging: void setResponseFunctions(android.hardware.radio.messaging.IRadioMessagingResponse,android.hardware.radio.messaging.IRadioMessagingIndication)>
<android.hardware.radio.messaging.IRadioMessaging: void responseAcknowledgement()>
<android.hardware.radio.messaging.IRadioMessaging: void reportSmsMemoryStatus(int,boolean)>
<android.hardware.radio.messaging.IRadioMessaging: void getSmscAddress(int)>
<android.hardware.radio.messaging.IRadioMessaging: void setGsmBroadcastActivation(int,boolean)>
<android.hardware.radio.messaging.IRadioMessaging: void acknowledgeIncomingGsmSmsWithPdu(int,boolean,java.lang.String)>
<android.hardware.radio.messaging.IRadioMessaging: int getInterfaceVersion()>
<android.hardware.radio.messaging.IRadioMessaging: void acknowledgeLastIncomingGsmSms(int,boolean,int)>
<android.hardware.radio.messaging.IRadioMessaging: void deleteSmsOnSim(int,int)>
<android.hardware.radio.messaging.IRadioMessaging: void setCdmaBroadcastConfig(int,android.hardware.radio.messaging.CdmaBroadcastSmsConfigInfo[])>
<android.hardware.radio.messaging.IRadioMessaging: void writeSmsToSim(int,android.hardware.radio.messaging.SmsWriteArgs)>
<android.hardware.radio.messaging.IRadioMessaging: void setSmscAddress(int,java.lang.String)>
<android.hardware.radio.messaging.IRadioMessaging: void sendCdmaSms(int,android.hardware.radio.messaging.CdmaSmsMessage)>
<android.hardware.radio.messaging.IRadioMessaging: void sendSmsExpectMore(int,android.hardware.radio.messaging.GsmSmsMessage)>
<android.hardware.radio.messaging.IRadioMessaging: void setGsmBroadcastConfig(int,android.hardware.radio.messaging.GsmBroadcastSmsConfigInfo[])>
<android.hardware.radio.messaging.IRadioMessaging: java.lang.String getInterfaceHash()>
<android.hardware.radio.messaging.IRadioMessaging: void getGsmBroadcastConfig(int)>
<android.hardware.radio.messaging.IRadioMessaging: void sendImsSms(int,android.hardware.radio.messaging.ImsSmsMessage)>
<android.hardware.radio.messaging.IRadioMessaging: void setCdmaBroadcastActivation(int,boolean)>
<android.hardware.radio.messaging.IRadioMessaging: void deleteSmsOnRuim(int,int)>
<android.hardware.radio.messaging.IRadioMessaging: void acknowledgeLastIncomingCdmaSms(int,android.hardware.radio.messaging.CdmaSmsAck)>
<android.app.ISearchManagerCallback: void onCancel()>
<android.app.ISearchManagerCallback: void onDismiss()>
<com.android.internal.inputmethod.IAccessibilityInputMethodSessionCallback: void sessionCreated(com.android.internal.inputmethod.IAccessibilityInputMethodSession,int)>
<android.telephony.ims.aidl.ISipDelegateStateCallback: void onDestroyed(int)>
<android.telephony.ims.aidl.ISipDelegateStateCallback: void onConfigurationChanged(android.telephony.ims.SipDelegateConfiguration)>
<android.telephony.ims.aidl.ISipDelegateStateCallback: void onFeatureTagRegistrationChanged(android.telephony.ims.DelegateRegistrationState)>
<android.telephony.ims.aidl.ISipDelegateStateCallback: void onImsConfigurationChanged(android.telephony.ims.SipDelegateImsConfiguration)>
<android.telephony.ims.aidl.ISipDelegateStateCallback: void onCreated(android.telephony.ims.aidl.ISipDelegate,java.util.List)>
<android.sec.clipboard.data.IClipboardDataList: int size()>
<android.sec.clipboard.data.IClipboardDataList: boolean updateData(int,com.samsung.android.content.clipboard.data.SemClipData)>
<android.sec.clipboard.data.IClipboardDataList: com.samsung.android.content.clipboard.data.SemClipData getClipByID(java.lang.String)>
<android.sec.clipboard.data.IClipboardDataList: com.samsung.android.content.clipboard.data.SemClipData getItem(int)>
<android.sec.clipboard.data.IClipboardDataList: boolean removeData(int)>
<android.service.games.IGameServiceController: void createGameSession(int)>
<android.media.IRemoteVolumeObserver: void dispatchRemoteVolumeUpdate(int,int)>
<android.net.wifi.nl80211.IApInterfaceEventCallback: void onSoftApChannelSwitched(int,int)>
<android.net.wifi.nl80211.IApInterfaceEventCallback: void onConnectedClientsChanged(android.net.wifi.nl80211.NativeWifiClient,boolean)>
<android.media.session.IActiveSessionsListener: void onActiveSessionsChanged(java.util.List)>
<android.companion.IAssociationRequestCallback: void onFailure(java.lang.CharSequence)>
<android.companion.IAssociationRequestCallback: void onAssociationCreated(android.companion.AssociationInfo)>
<android.companion.IAssociationRequestCallback: void onAssociationPending(android.app.PendingIntent)>
<com.samsung.android.ims.SemImsDmConfigListener: void onChangeDmValue(java.lang.String,boolean)>
<android.content.pm.permission.IRuntimePermissionPresenter: void getAppPermissions(java.lang.String,android.os.RemoteCallback)>
<android.speech.IRecognitionServiceManagerCallback: void onSuccess(android.speech.IRecognitionService)>
<android.speech.IRecognitionServiceManagerCallback: void onError(int)>
<android.os.IHardwarePropertiesManager: android.os.CpuUsageInfo[] getCpuUsages(java.lang.String)>
<android.os.IHardwarePropertiesManager: float[] getFanSpeeds(java.lang.String)>
<android.os.IHardwarePropertiesManager: float[] getDeviceTemperatures(java.lang.String,int,int)>
<android.hardware.input.IInputDeviceBatteryListener: void onBatteryStateChanged(android.hardware.input.IInputDeviceBatteryState)>
<com.samsung.android.wifi.ISemMobileWipsPacketSender: boolean sendTcp(int,byte[],byte[],java.lang.String)>
<com.samsung.android.wifi.ISemMobileWipsPacketSender: int sendDhcp(int,byte[],int,java.lang.String)>
<com.samsung.android.wifi.ISemMobileWipsPacketSender: java.util.List sendIcmp(int,byte[],byte[],java.lang.String)>
<com.samsung.android.wifi.ISemMobileWipsPacketSender: byte[] sendDns(long[],byte[],byte[],byte[],java.lang.String,boolean)>
<com.samsung.android.wifi.ISemMobileWipsPacketSender: java.util.List sendArp(int,byte[],byte[],java.lang.String)>
<com.samsung.android.wifi.ISemMobileWipsPacketSender: boolean pingTcp(byte[],byte[],int,int,int)>
<com.samsung.android.wifi.ISemMobileWipsPacketSender: java.util.List sendArpToSniffing(int,byte[],byte[],java.lang.String)>
<com.samsung.android.wifi.ISemMobileWipsPacketSender: boolean sendDnsQueries(long[],byte[],byte[],java.lang.String,java.util.List,int)>
<android.app.wearable.IWearableSensingManager: void provideData(android.os.PersistableBundle,android.os.SharedMemory,android.os.RemoteCallback)>
<android.app.wearable.IWearableSensingManager: void provideDataStream(android.os.ParcelFileDescriptor,android.os.RemoteCallback)>
<android.location.INSLocationCallback: void sendLogToHqm(java.lang.String,java.lang.String,java.lang.String)>
<android.location.INSLocationCallback: android.os.Bundle getActiveRequests(java.lang.String)>
<android.location.INSLocationCallback: android.os.Bundle getUidState(int,int)>
<android.location.INSLocationCallback: void updateBackgroundThrottlingAllowlist(java.util.List)>
<android.location.INSLocationCallback: void registerDeviceActivityDetector(int,int,boolean)>
<android.location.INSLocationCallback: void setMotionPowerSaveMode(boolean)>
<android.location.INSLocationCallback: void unregisterDeviceActivityDetector()>
<android.location.INSLocationCallback: void requestToUpdateDeviceActivityDetector()>
<android.location.INSLocationCallback: void writeUtLog(int,java.lang.String,java.lang.String)>
<android.location.INSLocationCallback: void noteGpsOp(int,int)>
<android.location.INSLocationCallback: boolean isProviderEnabled(java.lang.String,int)>
<android.location.INSLocationCallback: boolean setFeatureDeviceActivity(boolean)>
<android.location.INSLocationCallback: boolean isLocationEnabled(int)>
<android.hardware.tv.tuner.IDvr: void close()>
<android.hardware.tv.tuner.IDvr: void getQueueDesc(android.hardware.common.fmq.MQDescriptor)>
<android.hardware.tv.tuner.IDvr: void setStatusCheckIntervalHint(long)>
<android.hardware.tv.tuner.IDvr: void start()>
<android.hardware.tv.tuner.IDvr: java.lang.String getInterfaceHash()>
<android.hardware.tv.tuner.IDvr: void detachFilter(android.hardware.tv.tuner.IFilter)>
<android.hardware.tv.tuner.IDvr: void flush()>
<android.hardware.tv.tuner.IDvr: void attachFilter(android.hardware.tv.tuner.IFilter)>
<android.hardware.tv.tuner.IDvr: void configure(android.hardware.tv.tuner.DvrSettings)>
<android.hardware.tv.tuner.IDvr: void stop()>
<android.hardware.tv.tuner.IDvr: int getInterfaceVersion()>
<android.os.IExternalVibratorService: void onExternalVibrationStop(android.os.ExternalVibration)>
<android.os.IExternalVibratorService: boolean shouldIgnoreExternalVibrationLocked(int,int,int,int)>
<android.os.IExternalVibratorService: int onExternalVibrationStart(android.os.ExternalVibration)>
<android.companion.ISystemDataTransferCallback: void onResult()>
<android.companion.ISystemDataTransferCallback: void onError(java.lang.String)>
<vendor.samsung.hardware.radio.network.ISehRadioNetworkIndication: void imsPreferenceChanged(int,int[])>
<vendor.samsung.hardware.radio.network.ISehRadioNetworkIndication: void roamingNetworkScanIsRequested(int,byte[])>
<vendor.samsung.hardware.radio.network.ISehRadioNetworkIndication: void execute(int,java.lang.String)>
<vendor.samsung.hardware.radio.network.ISehRadioNetworkIndication: void nrNetworkTypeAdded(int,int)>
<vendor.samsung.hardware.radio.network.ISehRadioNetworkIndication: void callDetailsChanged(int,vendor.samsung.hardware.radio.network.SehCallDetails[])>
<vendor.samsung.hardware.radio.network.ISehRadioNetworkIndication: int getInterfaceVersion()>
<vendor.samsung.hardware.radio.network.ISehRadioNetworkIndication: void signalLevelInfoChanged(int,vendor.samsung.hardware.radio.network.SehSignalBar)>
<vendor.samsung.hardware.radio.network.ISehRadioNetworkIndication: java.lang.String getInterfaceHash()>
<vendor.samsung.hardware.radio.network.ISehRadioNetworkIndication: void csFallback(int,int)>
<vendor.samsung.hardware.radio.network.ISehRadioNetworkIndication: void eriInfoReceived(int,vendor.samsung.hardware.radio.network.SehEriInfo)>
<vendor.samsung.hardware.radio.network.ISehRadioNetworkIndication: void vendorConfigurationChanged(int,vendor.samsung.hardware.radio.network.SehVendorConfiguration[])>
<vendor.samsung.hardware.radio.network.ISehRadioNetworkIndication: void needTurnOnRadioIndication(int)>
<vendor.samsung.hardware.radio.network.ISehRadioNetworkIndication: void acbInfoChanged(int,int[])>
<vendor.samsung.hardware.radio.network.ISehRadioNetworkIndication: void nrBearerAllocationChanged(int,int)>
<vendor.samsung.hardware.radio.network.ISehRadioNetworkIndication: void nrIconTypeChanged(int,int)>
<vendor.samsung.hardware.radio.network.ISehRadioNetworkIndication: void currentNetworkScanIsRequested(int,byte)>
<vendor.samsung.hardware.radio.network.ISehRadioNetworkIndication: void extendedRegistrationState(int,vendor.samsung.hardware.radio.network.SehExtendedRegStateResult)>
<android.service.dreams.IDreamOverlayClient: void startDream(android.view.WindowManager$LayoutParams,android.service.dreams.IDreamOverlayCallback,java.lang.String,boolean)>
<android.service.dreams.IDreamOverlayClient: void endDream()>
<android.service.dreams.IDreamOverlayClient: void wakeUp()>
<android.companion.virtual.IVirtualDeviceSoundEffectListener: void onPlaySoundEffect(int)>
<android.app.IWindowToken: void onConfigurationChanged(android.content.res.Configuration,int)>
<android.app.IWindowToken: void onWindowTokenRemoved()>
<android.os.epic.IEpicObject: boolean acquire_lock()>
<android.os.epic.IEpicObject: boolean hint_release(java.lang.String)>
<android.os.epic.IEpicObject: boolean release_lock()>
<android.os.epic.IEpicObject: boolean acquire_lock_conditional(java.lang.String)>
<android.os.epic.IEpicObject: boolean acquire_lock_option_multi(int[],int[])>
<android.os.epic.IEpicObject: boolean acquire_lock_option(int,int)>
<android.os.epic.IEpicObject: boolean release_lock_conditional(java.lang.String)>
<android.os.epic.IEpicObject: boolean perf_hint(java.lang.String)>
<com.android.internal.policy.IShortcutService: void notifyShortcutKeyPressed(long)>
<android.content.pm.IMemorySaverPackageMoveObserver: void onStatusChanged(int,int,long)>
<android.content.pm.IMemorySaverPackageMoveObserver: void onCreated(java.lang.String)>
<android.service.euicc.IGetEuiccInfoCallback: void onSuccess(android.telephony.euicc.EuiccInfo)>
<android.media.INativeSpatializerCallback: void onLevelChanged(byte)>
<android.media.INativeSpatializerCallback: void onOutputChanged(int)>
<com.sec.android.allshare.iface.ISubscriber: java.lang.String getServiceVersion()>
<com.sec.android.allshare.iface.ISubscriber: boolean requestCVAsync(java.lang.String,com.sec.android.allshare.iface.CVMessage)>
<com.sec.android.allshare.iface.ISubscriber: boolean subscribeEvent(java.lang.String,com.sec.android.allshare.iface.CVMessage)>
<com.sec.android.allshare.iface.ISubscriber: com.sec.android.allshare.iface.CVMessage requestCVSync(java.lang.String,com.sec.android.allshare.iface.CVMessage)>
<com.sec.android.allshare.iface.ISubscriber: void unsubscribeEvent(java.lang.String,com.sec.android.allshare.iface.CVMessage)>
<com.sec.android.allshare.iface.ISubscriber: java.lang.String getCaptionFilePathFromURI(java.lang.String)>
<com.samsung.android.core.IFoldStarCallback: void onBoundsCompatPackageAppeared(int,java.lang.String)>
<com.samsung.android.desktopmode.IBleAdvertiserService: boolean needToKeepBinding()>
<android.hardware.gnss.visibility_control.IGnssVisibilityControlCallback: java.lang.String getInterfaceHash()>
<android.hardware.gnss.visibility_control.IGnssVisibilityControlCallback: int getInterfaceVersion()>
<android.hardware.gnss.visibility_control.IGnssVisibilityControlCallback: void nfwNotifyCb(android.hardware.gnss.visibility_control.IGnssVisibilityControlCallback$NfwNotification)>
<android.hardware.gnss.visibility_control.IGnssVisibilityControlCallback: boolean isInEmergencySession()>
<com.android.internal.statusbar.IStatusBar: void hideRecentApps(boolean,boolean)>
<com.android.internal.statusbar.IStatusBar: void showAssistDisclosure()>
<com.android.internal.statusbar.IStatusBar: void showMediaOutputSwitcher(java.lang.String)>
<com.android.internal.statusbar.IStatusBar: void goToFullscreenFromSplit()>
<com.android.internal.statusbar.IStatusBar: void showPinningEscapeToast()>
<com.android.internal.statusbar.IStatusBar: void setBiometicContextListener(android.hardware.biometrics.IBiometricContextListener)>
<com.android.internal.statusbar.IStatusBar: void passThroughShellCommand(java.lang.String[],android.os.ParcelFileDescriptor)>
<com.android.internal.statusbar.IStatusBar: void showToast(int,java.lang.String,android.os.IBinder,java.lang.CharSequence,android.os.IBinder,int,android.app.ITransientNotificationCallback,int)>
<com.android.internal.statusbar.IStatusBar: void appTransitionFinished(int)>
<com.android.internal.statusbar.IStatusBar: void hideAuthenticationDialog(long)>
<com.android.internal.statusbar.IStatusBar: void animateCollapsePanels()>
<com.android.internal.statusbar.IStatusBar: void sendThreeFingerGestureKeyEvent(android.view.KeyEvent)>
<com.android.internal.statusbar.IStatusBar: void enterStageSplitFromRunningApp(boolean)>
<com.android.internal.statusbar.IStatusBar: void resetScheduleAutoHide()>
<com.android.internal.statusbar.IStatusBar: void onProposedRotationChanged(int,boolean)>
<com.android.internal.statusbar.IStatusBar: void showPinningEnterExitToast(boolean)>
<com.android.internal.statusbar.IStatusBar: void remQsTile(android.content.ComponentName)>
<com.android.internal.statusbar.IStatusBar: void showPictureInPictureMenu()>
<com.android.internal.statusbar.IStatusBar: void startTracing()>
<com.android.internal.statusbar.IStatusBar: void requestTileServiceListeningState(android.content.ComponentName)>
<com.android.internal.statusbar.IStatusBar: void showInattentiveSleepWarning()>
<com.android.internal.statusbar.IStatusBar: void setTopAppHidesStatusBar(boolean)>
<com.android.internal.statusbar.IStatusBar: void preloadRecentApps()>
<com.android.internal.statusbar.IStatusBar: void setIcon(java.lang.String,com.android.internal.statusbar.StatusBarIcon)>
<com.android.internal.statusbar.IStatusBar: void onCameraLaunchGestureDetected(int)>
<com.android.internal.statusbar.IStatusBar: void clickQsTile(android.content.ComponentName)>
<com.android.internal.statusbar.IStatusBar: void toggleRecentApps()>
<com.android.internal.statusbar.IStatusBar: void appTransitionPending(int)>
<com.android.internal.statusbar.IStatusBar: void disable(int,int,int)>
<com.android.internal.statusbar.IStatusBar: void onSystemBarAttributesChanged(int,int,com.android.internal.view.AppearanceRegion[],boolean,int,int,java.lang.String,com.android.internal.statusbar.LetterboxDetails[])>
<com.android.internal.statusbar.IStatusBar: void showShutdownUi(boolean,java.lang.String)>
<com.android.internal.statusbar.IStatusBar: void setUdfpsRefreshRateCallback(android.hardware.fingerprint.IUdfpsRefreshRateRequestCallback)>
<com.android.internal.statusbar.IStatusBar: void animateExpandSettingsPanel(java.lang.String)>
<com.android.internal.statusbar.IStatusBar: void handleSystemKey(android.view.KeyEvent)>
<com.android.internal.statusbar.IStatusBar: void onDisplayReady(int)>
<com.android.internal.statusbar.IStatusBar: void onFocusedDisplayChanged(int)>
<com.android.internal.statusbar.IStatusBar: void showScreenPinningRequest(int)>
<com.android.internal.statusbar.IStatusBar: void onBiometricAuthenticated(int)>
<com.android.internal.statusbar.IStatusBar: void removeIcon(java.lang.String)>
<com.android.internal.statusbar.IStatusBar: void animateExpandNotificationsPanel()>
<com.android.internal.statusbar.IStatusBar: void dismissInattentiveSleepWarning(boolean)>
<com.android.internal.statusbar.IStatusBar: void hideToast(java.lang.String,android.os.IBinder)>
<com.android.internal.statusbar.IStatusBar: void unregisterNearbyMediaDevicesProvider(android.media.INearbyMediaDevicesProvider)>
<com.android.internal.statusbar.IStatusBar: void requestWindowMagnificationConnection(boolean)>
<com.android.internal.statusbar.IStatusBar: void updateMediaTapToTransferReceiverDisplay(int,android.media.MediaRoute2Info,android.graphics.drawable.Icon,java.lang.CharSequence)>
<com.android.internal.statusbar.IStatusBar: void togglePanel()>
<com.android.internal.statusbar.IStatusBar: void suppressAmbientDisplay(boolean)>
<com.android.internal.statusbar.IStatusBar: void onEmergencyActionLaunchGestureDetected()>
<com.android.internal.statusbar.IStatusBar: void registerNearbyMediaDevicesProvider(android.media.INearbyMediaDevicesProvider)>
<com.android.internal.statusbar.IStatusBar: void showTransient(int,int,boolean)>
<com.android.internal.statusbar.IStatusBar: void showWirelessChargingAnimation(int)>
<com.android.internal.statusbar.IStatusBar: void requestAddTile(android.content.ComponentName,java.lang.CharSequence,java.lang.CharSequence,android.graphics.drawable.Icon,com.android.internal.statusbar.IAddTileResultCallback)>
<com.android.internal.statusbar.IStatusBar: void showRecentApps(boolean)>
<com.android.internal.statusbar.IStatusBar: void addQsTile(android.content.ComponentName)>
<com.android.internal.statusbar.IStatusBar: void notifySamsungPayInfo(int,boolean,android.graphics.Rect)>
<com.android.internal.statusbar.IStatusBar: void sendKeyEventToDesktopTaskbar(android.view.KeyEvent)>
<com.android.internal.statusbar.IStatusBar: void toggleKeyboardShortcutsMenu(int)>
<com.android.internal.statusbar.IStatusBar: void onBiometricError(int,int,int)>
<com.android.internal.statusbar.IStatusBar: void setBlueLightFilter(boolean,int)>
<com.android.internal.statusbar.IStatusBar: void setImeWindowStatus(int,android.os.IBinder,int,int,boolean)>
<com.android.internal.statusbar.IStatusBar: void stopTracing()>
<com.android.internal.statusbar.IStatusBar: void appTransitionStarting(int,long,long)>
<com.android.internal.statusbar.IStatusBar: void onRecentsAnimationStateChanged(boolean)>
<com.android.internal.statusbar.IStatusBar: void setNavigationBarShortcut(java.lang.String,android.widget.RemoteViews,int,int)>
<com.android.internal.statusbar.IStatusBar: void cancelRequestAddTile(java.lang.String)>
<com.android.internal.statusbar.IStatusBar: void toggleSplitScreen()>
<com.android.internal.statusbar.IStatusBar: void showRearDisplayDialog(int)>
<com.android.internal.statusbar.IStatusBar: void dismissKeyboardShortcutsMenu()>
<com.android.internal.statusbar.IStatusBar: void toggleTaskbar()>
<com.android.internal.statusbar.IStatusBar: void dumpProto(java.lang.String[],android.os.ParcelFileDescriptor)>
<com.android.internal.statusbar.IStatusBar: void setNavigationBarLumaSamplingEnabled(int,boolean)>
<com.android.internal.statusbar.IStatusBar: void showAuthenticationDialog(android.hardware.biometrics.PromptInfo,android.hardware.biometrics.IBiometricSysuiReceiver,int[],boolean,boolean,int,long,java.lang.String,long)>
<com.android.internal.statusbar.IStatusBar: void cancelPreloadRecentApps()>
<com.android.internal.statusbar.IStatusBar: void updateMediaTapToTransferSenderDisplay(int,android.media.MediaRoute2Info,com.android.internal.statusbar.IUndoMediaTransferCallback)>
<com.android.internal.statusbar.IStatusBar: void onBiometricHelp(int,java.lang.String)>
<com.android.internal.statusbar.IStatusBar: void runGcForTest()>
<com.android.internal.statusbar.IStatusBar: void showGlobalActionsMenu(int)>
<com.android.internal.statusbar.IStatusBar: void notifyRequestedGameToolsWin(boolean)>
<com.android.internal.statusbar.IStatusBar: void abortTransient(int,int)>
<com.android.internal.statusbar.IStatusBar: void notifyRequestedSystemKey(boolean,boolean)>
<com.android.internal.statusbar.IStatusBar: void appTransitionCancelled(int)>
<com.android.internal.statusbar.IStatusBar: void setWindowState(int,int,int)>
<com.android.internal.statusbar.IStatusBar: void startAssist(android.os.Bundle)>
<android.hardware.radio.ICloseHandle: void close()>
<android.hardware.IRemoteDevice: android.hardware.camera2.impl.CameraMetadataNative getCameraCharacteristic()>
<android.hardware.IRemoteDevice: void setCallback(android.hardware.IRemoteDeviceCallback)>
<android.hardware.IRemoteDevice: android.hardware.camera2.impl.CameraMetadataNative createDefaultRequest()>
<android.hardware.IRemoteDevice: void deleteStream(int)>
<android.hardware.IRemoteDevice: void submitRequest(android.hardware.camera2.impl.CameraMetadataNative,int[],boolean)>
<android.hardware.IRemoteDevice: void close()>
<android.hardware.IRemoteDevice: int createStream(android.hardware.camera2.params.OutputConfiguration)>
<android.hardware.IRemoteDevice: java.lang.String open(java.lang.String,int)>
<android.hardware.IRemoteDevice: void clearRequest()>
<android.system.suspend.internal.ISuspendControlServiceInternal: android.system.suspend.internal.WakeLockInfo[] getWakeLockStats()>
<android.system.suspend.internal.ISuspendControlServiceInternal: android.system.suspend.internal.SuspendInfo getSuspendStats()>
<android.system.suspend.internal.ISuspendControlServiceInternal: boolean enableAutosuspend(android.os.IBinder)>
<android.system.suspend.internal.ISuspendControlServiceInternal: boolean forceSuspend()>
<android.system.suspend.internal.ISuspendControlServiceInternal: android.system.suspend.internal.WakeupInfo[] getWakeupStats()>
<com.android.internal.view.inline.IInlineContentProvider: void requestSurfacePackage()>
<com.android.internal.view.inline.IInlineContentProvider: void provideContent(int,int,com.android.internal.view.inline.IInlineContentCallback)>
<com.android.internal.view.inline.IInlineContentProvider: void onSurfacePackageReleased()>
<com.android.internal.app.IBatteryStats: void noteResetVideo()>
<com.android.internal.app.IBatteryStats: void noteBleScanReset()>
<com.android.internal.app.IBatteryStats: void noteBluetoothControllerActivity(android.bluetooth.BluetoothActivityEnergyInfo)>
<com.android.internal.app.IBatteryStats: void noteGpsSignalQuality(int)>
<com.android.internal.app.IBatteryStats: void noteResetGps()>
<com.android.internal.app.IBatteryStats: boolean registerBatteryStatsCallback(com.android.internal.app.IBatteryStatsCallback)>
<com.android.internal.app.IBatteryStats: void resetBattery(boolean)>
<com.android.internal.app.IBatteryStats: void noteWifiControllerActivity(android.os.connectivity.WifiActivityEnergyInfo)>
<com.android.internal.app.IBatteryStats: android.os.BluetoothBatteryStats getBluetoothBatteryStats()>
<com.android.internal.app.IBatteryStats: void noteUserActivity(int,int)>
<com.android.internal.app.IBatteryStats: void noteSyncFinish(java.lang.String,int)>
<com.android.internal.app.IBatteryStats: void noteDualScreenBrightness(int,int,int)>
<com.android.internal.app.IBatteryStats: void noteWakeUp(java.lang.String,int)>
<com.android.internal.app.IBatteryStats: void noteWifiScanStoppedFromSource(android.os.WorkSource)>
<com.android.internal.app.IBatteryStats: void noteStartCamera(int)>
<com.android.internal.app.IBatteryStats: void noteWifiMulticastDisabled(int)>
<com.android.internal.app.IBatteryStats: void noteLongPartialWakelockFinishFromSource(java.lang.String,java.lang.String,android.os.WorkSource)>
<com.android.internal.app.IBatteryStats: long computeBatteryScreenOffRealtimeMs()>
<com.android.internal.app.IBatteryStats: void noteSyncStart(java.lang.String,int)>
<com.android.internal.app.IBatteryStats: void noteGpsChanged(android.os.WorkSource,android.os.WorkSource)>
<com.android.internal.app.IBatteryStats: void noteBleScanStopped(android.os.WorkSource,boolean)>
<com.android.internal.app.IBatteryStats: void noteScreenState(int)>
<com.android.internal.app.IBatteryStats: void noteWifiBatchedScanStoppedFromSource(android.os.WorkSource)>
<com.android.internal.app.IBatteryStats: void noteVibratorOn(int,long)>
<com.android.internal.app.IBatteryStats: void noteWifiBatchedScanStartedFromSource(android.os.WorkSource,int)>
<com.android.internal.app.IBatteryStats: void noteFullWifiLockReleasedFromSource(android.os.WorkSource)>
<com.android.internal.app.IBatteryStats: java.util.List getBatteryUsageStats(java.util.List)>
<com.android.internal.app.IBatteryStats: void noteWifiRadioPowerState(int,long,int)>
<com.android.internal.app.IBatteryStats: void suspendBatteryInput()>
<com.android.internal.app.IBatteryStats: void setChargerAcOnline(boolean,boolean)>
<com.android.internal.app.IBatteryStats: void unplugBattery(boolean)>
<com.android.internal.app.IBatteryStats: void setBatteryLevel(int,boolean)>
<com.android.internal.app.IBatteryStats: android.os.connectivity.GpsBatteryStats getGpsBatteryStats()>
<com.android.internal.app.IBatteryStats: void noteWifiMulticastEnabled(int)>
<com.android.internal.app.IBatteryStats: void setDeviceBatteryInfo(java.lang.String,com.samsung.android.os.SemCompanionDeviceBatteryInfo)>
<com.android.internal.app.IBatteryStats: void noteFullWifiLockReleased(int)>
<com.android.internal.app.IBatteryStats: void noteNetworkInterfaceForTransports(java.lang.String,int[])>
<com.android.internal.app.IBatteryStats: void noteStartVideo(int)>
<com.android.internal.app.IBatteryStats: void noteLongPartialWakelockStartFromSource(java.lang.String,java.lang.String,android.os.WorkSource)>
<com.android.internal.app.IBatteryStats: void notePhoneOff()>
<com.android.internal.app.IBatteryStats: boolean setChargingStateUpdateDelayMillis(int)>
<com.android.internal.app.IBatteryStats: void registerDeviceBatteryInfoChanged(java.lang.String)>
<com.android.internal.app.IBatteryStats: void notePhoneOn()>
<com.android.internal.app.IBatteryStats: void noteStopGps(int)>
<com.android.internal.app.IBatteryStats: void noteStopSensor(int,int)>
<com.android.internal.app.IBatteryStats: void noteWifiOn()>
<com.android.internal.app.IBatteryStats: void noteScreenBrightness(int)>
<com.android.internal.app.IBatteryStats: void noteStartWakelockFromSource(android.os.WorkSource,int,java.lang.String,java.lang.String,int,boolean)>
<com.android.internal.app.IBatteryStats: void noteStopWakelockFromSource(android.os.WorkSource,int,java.lang.String,java.lang.String,int)>
<com.android.internal.app.IBatteryStats: void noteInteractive(boolean)>
<com.android.internal.app.IBatteryStats: void noteJobStart(java.lang.String,int)>
<com.android.internal.app.IBatteryStats: void noteStopTxPowerSharing()>
<com.android.internal.app.IBatteryStats: void noteFullWifiLockAcquired(int)>
<com.android.internal.app.IBatteryStats: long getAwakeTimeBattery()>
<com.android.internal.app.IBatteryStats: void noteDualScreenState(int,int,int)>
<com.android.internal.app.IBatteryStats: android.os.SemBatterySipper getSemBatteryUsageStats()>
<com.android.internal.app.IBatteryStats: long getScreenOffDischargeMah()>
<com.android.internal.app.IBatteryStats: void noteStartSensor(int,int)>
<com.android.internal.app.IBatteryStats: void noteDeviceIdleMode(int,java.lang.String,int)>
<com.android.internal.app.IBatteryStats: android.os.WakeLockStats getWakeLockStats()>
<com.android.internal.app.IBatteryStats: com.samsung.android.os.SemCompanionDeviceBatteryInfo getDeviceBatteryInfo(java.lang.String)>
<com.android.internal.app.IBatteryStats: void noteStopWakelock(int,int,java.lang.String,java.lang.String,int)>
<com.android.internal.app.IBatteryStats: void noteVibratorOff(int)>
<com.android.internal.app.IBatteryStats: android.os.connectivity.WifiBatteryStats getWifiBatteryStats()>
<com.android.internal.app.IBatteryStats: void noteWifiSupplicantStateChanged(int,boolean)>
<com.android.internal.app.IBatteryStats: void noteFlashlightOn(int)>
<com.android.internal.app.IBatteryStats: void noteWifiScanStarted(int)>
<com.android.internal.app.IBatteryStats: void notePhoneDataConnectionState(int,boolean,int,int)>
<com.android.internal.app.IBatteryStats: boolean unregisterBatteryStatsCallback(com.android.internal.app.IBatteryStatsCallback)>
<com.android.internal.app.IBatteryStats: void setTemperatureNCurrent(int,int,int,int,int)>
<com.android.internal.app.IBatteryStats: void noteWakeupSensorEvent(long,int,int)>
<com.android.internal.app.IBatteryStats: android.os.health.HealthStatsParceler[] takeUidSnapshots(int[])>
<com.android.internal.app.IBatteryStats: void noteWifiRunning(android.os.WorkSource)>
<com.android.internal.app.IBatteryStats: void noteResetCamera()>
<com.android.internal.app.IBatteryStats: long computeBatteryTimeRemaining()>
<com.android.internal.app.IBatteryStats: void noteBleDutyScanStarted(android.os.WorkSource,boolean,int)>
<com.android.internal.app.IBatteryStats: void noteConnectivityChanged(int,java.lang.String)>
<com.android.internal.app.IBatteryStats: boolean isCharging()>
<com.android.internal.app.IBatteryStats: void notePhoneState(int)>
<com.android.internal.app.IBatteryStats: void updateSpeakerOutEnergyInfo(android.os.SpeakerOutEnergyInfo)>
<com.android.internal.app.IBatteryStats: long computeChargeTimeRemaining()>
<com.android.internal.app.IBatteryStats: void noteStartGps(int)>
<com.android.internal.app.IBatteryStats: void noteWifiOff()>
<com.android.internal.app.IBatteryStats: void updateSemModemActivityInfo(android.os.SemModemActivityInfo)>
<com.android.internal.app.IBatteryStats: void updateForegroundAppEnergyInfo(java.util.List)>
<com.android.internal.app.IBatteryStats: void noteWifiRssiChanged(int)>
<com.android.internal.app.IBatteryStats: void noteFullWifiLockAcquiredFromSource(android.os.WorkSource)>
<com.android.internal.app.IBatteryStats: void noteWifiStopped(android.os.WorkSource)>
<com.android.internal.app.IBatteryStats: android.os.connectivity.CellularBatteryStats getCellularBatteryStats()>
<com.android.internal.app.IBatteryStats: boolean isCpuClusterAvailable()>
<com.android.internal.app.IBatteryStats: void noteLongPartialWakelockFinish(java.lang.String,java.lang.String,int)>
<com.android.internal.app.IBatteryStats: void noteStopVideo(int)>
<com.android.internal.app.IBatteryStats: android.os.health.HealthStatsParceler takeUidSnapshot(int)>
<com.android.internal.app.IBatteryStats: boolean isCpuFrequencyAvailable()>
<com.android.internal.app.IBatteryStats: void unsetDeviceBatteryInfo(java.lang.String)>
<com.android.internal.app.IBatteryStats: void noteResetAudio()>
<com.android.internal.app.IBatteryStats: void setBatteryState(int,int,int,int,int,int,int,int,long,int,int,int,int,boolean)>
<com.android.internal.app.IBatteryStats: void notePhoneSignalStrength(android.telephony.SignalStrength)>
<com.android.internal.app.IBatteryStats: void noteStartAudio(int)>
<com.android.internal.app.IBatteryStats: void noteBleDutyScanStopped(android.os.WorkSource,boolean,int)>
<com.android.internal.app.IBatteryStats: long getAwakeTimePlugged()>
<com.android.internal.app.IBatteryStats: void noteBleScanResults(android.os.WorkSource,int)>
<com.android.internal.app.IBatteryStats: void noteStartTxPowerSharing()>
<com.android.internal.app.IBatteryStats: void noteJobFinish(java.lang.String,int,int)>
<com.android.internal.app.IBatteryStats: void noteResetFlashlight()>
<com.android.internal.app.IBatteryStats: void noteBleScanStarted(android.os.WorkSource,boolean)>
<com.android.internal.app.IBatteryStats: void noteNetworkStatsEnabled()>
<com.android.internal.app.IBatteryStats: void unRegisterDeviceBatteryInfoChanged(java.lang.String)>
<com.android.internal.app.IBatteryStats: void noteUpdateNetworkStats(java.lang.String)>
<com.android.internal.app.IBatteryStats: void noteWifiRunningChanged(android.os.WorkSource,android.os.WorkSource)>
<com.android.internal.app.IBatteryStats: void noteChangeWakelockFromSource(android.os.WorkSource,int,java.lang.String,java.lang.String,int,android.os.WorkSource,int,java.lang.String,java.lang.String,int,boolean)>
<com.android.internal.app.IBatteryStats: void noteWifiScanStopped(int)>
<com.android.internal.app.IBatteryStats: void noteLongPartialWakelockStart(java.lang.String,java.lang.String,int)>
<com.android.internal.app.IBatteryStats: void noteModemControllerActivity(android.telephony.ModemActivityInfo)>
<com.android.internal.app.IBatteryStats: void noteStopAudio(int)>
<com.android.internal.app.IBatteryStats: com.samsung.android.os.SemCompanionDeviceBatteryInfo[] getDeviceBatteryInfos()>
<com.android.internal.app.IBatteryStats: void noteStartWakelock(int,int,java.lang.String,java.lang.String,int,boolean)>
<com.android.internal.app.IBatteryStats: void noteWifiScanStartedFromSource(android.os.WorkSource)>
<com.android.internal.app.IBatteryStats: void noteWifiState(int,java.lang.String)>
<com.android.internal.app.IBatteryStats: void noteStopCamera(int)>
<com.android.internal.app.IBatteryStats: void noteFlashlightOff(int)>
<com.android.internal.app.IBatteryStats: void noteMobileRadioPowerState(int,long,int)>
<com.android.internal.app.IBatteryStats: void noteEvent(int,java.lang.String,int)>
<android.net.IPacProxyManager: void addListener(android.net.IPacProxyInstalledListener)>
<android.net.IPacProxyManager: void removeListener(android.net.IPacProxyInstalledListener)>
<android.net.IPacProxyManager: void setCurrentProxyScriptUrl(android.net.ProxyInfo)>
<android.net.INetworkManagementEventObserver: void interfaceStatusChanged(java.lang.String,boolean)>
<android.net.INetworkManagementEventObserver: void routeUpdated(android.net.RouteInfo)>
<android.net.INetworkManagementEventObserver: void addressRemoved(java.lang.String,android.net.LinkAddress)>
<android.net.INetworkManagementEventObserver: void addressUpdated(java.lang.String,android.net.LinkAddress)>
<android.net.INetworkManagementEventObserver: void interfaceAdded(java.lang.String)>
<android.net.INetworkManagementEventObserver: void interfaceRemoved(java.lang.String)>
<android.net.INetworkManagementEventObserver: void interfaceLinkStateChanged(java.lang.String,boolean)>
<android.net.INetworkManagementEventObserver: void interfaceClassDataActivityChanged(int,boolean,long,int)>
<android.net.INetworkManagementEventObserver: void interfaceDnsServerInfo(java.lang.String,long,java.lang.String[])>
<android.net.INetworkManagementEventObserver: void routeRemoved(android.net.RouteInfo)>
<android.net.INetworkManagementEventObserver: void limitReached(java.lang.String,java.lang.String)>
<android.location.IGnssStatusListener: void onSvStatusChanged(android.location.GnssStatus)>
<android.location.IGnssStatusListener: void onGnssStarted()>
<android.location.IGnssStatusListener: void onFirstFix(int)>
<android.location.IGnssStatusListener: void onGnssStopped()>
<android.media.soundtrigger_middleware.ISoundTriggerInjection: void onClientAttached(android.os.IBinder,android.media.soundtrigger_middleware.IInjectGlobalEvent)>
<android.media.soundtrigger_middleware.ISoundTriggerInjection: void onRestarted(android.media.soundtrigger_middleware.IInjectGlobalEvent)>
<android.media.soundtrigger_middleware.ISoundTriggerInjection: void onSoundModelUnloaded(android.media.soundtrigger_middleware.IInjectModelEvent)>
<android.media.soundtrigger_middleware.ISoundTriggerInjection: void onRecognitionStarted(int,android.media.soundtrigger.RecognitionConfig,android.media.soundtrigger_middleware.IInjectRecognitionEvent,android.media.soundtrigger_middleware.IInjectModelEvent)>
<android.media.soundtrigger_middleware.ISoundTriggerInjection: void onPreempted()>
<android.media.soundtrigger_middleware.ISoundTriggerInjection: void onClientDetached(android.os.IBinder)>
<android.media.soundtrigger_middleware.ISoundTriggerInjection: void onParamSet(int,int,android.media.soundtrigger_middleware.IInjectModelEvent)>
<android.media.soundtrigger_middleware.ISoundTriggerInjection: void registerGlobalEventInjection(android.media.soundtrigger_middleware.IInjectGlobalEvent)>
<android.media.soundtrigger_middleware.ISoundTriggerInjection: void onFrameworkDetached(android.media.soundtrigger_middleware.IInjectGlobalEvent)>
<android.media.soundtrigger_middleware.ISoundTriggerInjection: void onSoundModelLoaded(android.media.soundtrigger.SoundModel,android.media.soundtrigger.Phrase[],android.media.soundtrigger_middleware.IInjectModelEvent,android.media.soundtrigger_middleware.IInjectGlobalEvent)>
<android.media.soundtrigger_middleware.ISoundTriggerInjection: void onRecognitionStopped(android.media.soundtrigger_middleware.IInjectRecognitionEvent)>
<android.window.ITaskOrganizer: void resetStashedFreeform(int,boolean)>
<android.window.ITaskOrganizer: void copySplashScreenView(int)>
<android.window.ITaskOrganizer: void onKeepScreenOnChanged(int,boolean)>
<android.window.ITaskOrganizer: void onTaskAppeared(android.app.ActivityManager$RunningTaskInfo,android.view.SurfaceControl)>
<android.window.ITaskOrganizer: void onImeDrawnOnTask(int)>
<android.window.ITaskOrganizer: void removeStartingWindow(android.window.StartingWindowRemovalInfo)>
<android.window.ITaskOrganizer: void preloadSplashScreenAppIcon(android.content.pm.ActivityInfo,int,android.content.res.Configuration)>
<android.window.ITaskOrganizer: void onAppSplashScreenViewRemoved(int)>
<android.window.ITaskOrganizer: void onNewDexImmersiveModeChanged(int,boolean)>
<android.window.ITaskOrganizer: void onBackPressedOnTaskRoot(android.app.ActivityManager$RunningTaskInfo)>
<android.window.ITaskOrganizer: void addStartingWindow(android.window.StartingWindowInfo)>
<android.window.ITaskOrganizer: void onImmersiveModeChanged(int,boolean)>
<android.window.ITaskOrganizer: void onTaskInfoChanged(android.app.ActivityManager$RunningTaskInfo)>
<android.window.ITaskOrganizer: void onTaskVanished(android.app.ActivityManager$RunningTaskInfo)>
<android.window.ITaskOrganizer: void onSplitLayoutChangeRequested(android.app.ActivityManager$RunningTaskInfo,android.os.Bundle)>
<android.service.quickaccesswallet.IQuickAccessWalletService: void onWalletCardSelected(android.service.quickaccesswallet.SelectWalletCardRequest)>
<android.service.quickaccesswallet.IQuickAccessWalletService: void onWalletDismissed()>
<android.service.quickaccesswallet.IQuickAccessWalletService: void unregisterWalletServiceEventListener(android.service.quickaccesswallet.WalletServiceEventListenerRequest)>
<android.service.quickaccesswallet.IQuickAccessWalletService: void onTargetActivityIntentRequested(android.service.quickaccesswallet.IQuickAccessWalletServiceCallbacks)>
<android.service.quickaccesswallet.IQuickAccessWalletService: void registerWalletServiceEventListener(android.service.quickaccesswallet.WalletServiceEventListenerRequest,android.service.quickaccesswallet.IQuickAccessWalletServiceCallbacks)>
<android.service.quickaccesswallet.IQuickAccessWalletService: void onWalletCardsRequested(android.service.quickaccesswallet.GetWalletCardsRequest,android.service.quickaccesswallet.IQuickAccessWalletServiceCallbacks)>
<android.os.IUpdateLock: void releaseUpdateLock(android.os.IBinder)>
<android.os.IUpdateLock: void acquireUpdateLock(android.os.IBinder,java.lang.String)>
<com.android.internal.telephony.ISemPhoneSubInfo: int getDataServiceState()>
<com.android.internal.telephony.ISemPhoneSubInfo: boolean setUwbTimers(int[])>
<com.android.internal.telephony.ISemPhoneSubInfo: boolean setDrxMode(int)>
<com.android.internal.telephony.ISemPhoneSubInfo: int getDefaultCycleForKodiak()>
<com.android.internal.telephony.ISemPhoneSubInfo: int[] getSupportedModesForKodiak()>
<com.android.internal.telephony.ISemPhoneSubInfo: int getCurrentModeForKodiak()>
<com.android.internal.telephony.ISemPhoneSubInfo: int getCurrentCycle(int)>
<com.android.internal.telephony.ISemPhoneSubInfo: int[] getUwbTimers()>
<com.android.internal.telephony.ISemPhoneSubInfo: boolean changeDRXForKodiak(int,int)>
<com.android.internal.telephony.ISemPhoneSubInfo: int getDrxMode()>
<com.android.internal.telephony.ISemPhoneSubInfo: int[] getSupportedCycles(int)>
<com.android.internal.telephony.ISemPhoneSubInfo: boolean changeDRX(int,int,int)>
<com.android.internal.telephony.ISemPhoneSubInfo: int getDefaultCycle(int)>
<com.android.internal.telephony.ISemPhoneSubInfo: boolean hasCall(java.lang.String)>
<com.android.internal.telephony.ISemPhoneSubInfo: int getDataServiceStateUsingSubId(int)>
<android.window.IRemoteTransition: void mergeAnimation(android.os.IBinder,android.window.TransitionInfo,android.view.SurfaceControl$Transaction,android.os.IBinder,android.window.IRemoteTransitionFinishedCallback)>
<android.window.IRemoteTransition: void startAnimation(android.os.IBinder,android.window.TransitionInfo,android.view.SurfaceControl$Transaction,android.window.IRemoteTransitionFinishedCallback)>
<com.android.internal.telecom.IInternalServiceRetriever: com.android.internal.telecom.IDeviceIdleControllerAdapter getDeviceIdleController()>
<android.app.backup.IRestoreSession: int restoreAll(long,android.app.backup.IRestoreObserver,android.app.backup.IBackupManagerMonitor)>
<android.app.backup.IRestoreSession: int restorePackages(long,android.app.backup.IRestoreObserver,java.lang.String[],android.app.backup.IBackupManagerMonitor)>
<android.app.backup.IRestoreSession: int restorePackage(java.lang.String,android.app.backup.IRestoreObserver,android.app.backup.IBackupManagerMonitor)>
<android.app.backup.IRestoreSession: void endRestoreSession()>
<android.app.backup.IRestoreSession: int getAvailableRestoreSets(android.app.backup.IRestoreObserver,android.app.backup.IBackupManagerMonitor)>
<com.samsung.android.knox.tima.attestation.IEnhancedAttestation: void enhancedAttestation(java.lang.String,java.lang.String,com.samsung.android.knox.tima.attestation.IEnhancedAttestationPolicyCallback,boolean)>
<android.net.ITetheringStatsProvider: void setInterfaceQuota(java.lang.String,long)>
<android.net.ITetheringStatsProvider: android.net.NetworkStats getTetherStats(int)>
<android.app.usage.ICacheQuotaService: void computeCacheQuotaHints(android.os.RemoteCallback,java.util.List)>
<android.media.IAudioService: int requestAudioFocus(android.media.AudioAttributes,int,android.os.IBinder,android.media.IAudioFocusDispatcher,java.lang.String,java.lang.String,java.lang.String,int,android.media.audiopolicy.IAudioPolicyCallback,int)>
<android.media.IAudioService: void adjustVolumeGroupVolume(int,int,int,java.lang.String)>
<android.media.IAudioService: java.util.List getPreferredDevicesForStrategy(int)>
<android.media.IAudioService: void registerModeDispatcher(android.media.IAudioModeDispatcher)>
<android.media.IAudioService: int getStreamVolumeForDevice(int,int)>
<android.media.IAudioService: boolean setSurroundFormatEnabled(int,boolean)>
<android.media.IAudioService: void playerAttributes(int,android.media.AudioAttributes)>
<android.media.IAudioService: void setAppMute(int,boolean,java.lang.String)>
<android.media.IAudioService: void unregisterPreferredMixerAttributesDispatcher(android.media.IPreferredMixerAttributesDispatcher)>
<android.media.IAudioService: void setMultiSoundOn(boolean,boolean)>
<android.media.IAudioService: void setVolumeGroupVolumeIndex(int,int,int,java.lang.String,java.lang.String)>
<android.media.IAudioService: boolean sendFocusLoss(android.media.AudioFocusInfo,android.media.audiopolicy.IAudioPolicyCallback)>
<android.media.IAudioService: int setDeviceAsNonDefaultForStrategy(int,android.media.AudioDeviceAttributes)>
<android.media.IAudioService: void reloadAudioSettings()>
<android.media.IAudioService: void setVolumePolicy(android.media.VolumePolicy)>
<android.media.IAudioService: void setStreamVolume(int,int,int,java.lang.String)>
<android.media.IAudioService: java.lang.String[] getSelectedAppList()>
<android.media.IAudioService: int getVolumeGroupVolumeIndex(int)>
<android.media.IAudioService: int setAllowedCapturePolicy(int)>
<android.media.IAudioService: int setFocusPropertiesForPolicy(int,android.media.audiopolicy.IAudioPolicyCallback)>
<android.media.IAudioService: int getDesiredHeadTrackingMode()>
<android.media.IAudioService: void stopBluetoothSco(android.os.IBinder)>
<android.media.IAudioService: boolean isSpatializerAvailableForDevice(android.media.AudioDeviceAttributes)>
<android.media.IAudioService: void setOutputRs2UpperBound(float)>
<android.media.IAudioService: float getCsd()>
<android.media.IAudioService: void registerStreamAliasingDispatcher(android.media.IStreamAliasingDispatcher,boolean)>
<android.media.IAudioService: void setRingtonePlayer(android.media.IRingtonePlayer)>
<android.media.IAudioService: int setUserIdDeviceAffinity(android.media.audiopolicy.IAudioPolicyCallback,int,int[],java.lang.String[])>
<android.media.IAudioService: android.media.AudioDeviceAttributes getMutingExpectedDevice()>
<android.media.IAudioService: int requestAudioFocusForTest(android.media.AudioAttributes,int,android.os.IBinder,android.media.IAudioFocusDispatcher,java.lang.String,java.lang.String,int,int,int)>
<android.media.IAudioService: boolean isForceSpeakerOn()>
<android.media.IAudioService: int getSpatializerImmersiveAudioLevel()>
<android.media.IAudioService: boolean isValidRingerMode(int)>
<android.media.IAudioService: void disableSafeMediaVolume(java.lang.String)>
<android.media.IAudioService: void addOnDevicesForAttributesChangedListener(android.media.AudioAttributes,android.media.IDevicesForAttributesCallback)>
<android.media.IAudioService: android.media.VolumeInfo getDeviceVolume(android.media.VolumeInfo,android.media.AudioDeviceAttributes,java.lang.String)>
<android.media.IAudioService: int getVolumeGroupMaxVolumeIndex(int)>
<android.media.IAudioService: int setPreferredDevicesForCapturePreset(int,java.util.List)>
<android.media.IAudioService: boolean canBeSpatialized(android.media.AudioAttributes,android.media.AudioFormat)>
<android.media.IAudioService: void setWiredDeviceConnectionState(android.media.AudioDeviceAttributes,int,java.lang.String)>
<android.media.IAudioService: void registerSpatializerCallback(android.media.ISpatializerCallback)>
<android.media.IAudioService: int getPrevRingerMode()>
<android.media.IAudioService: int trackPlayer(android.media.PlayerBase$PlayerIdCard)>
<android.media.IAudioService: int setPreferredDevicesForStrategy(int,java.util.List)>
<android.media.IAudioService: java.util.List getAudioVolumeGroups()>
<android.media.IAudioService: int getRingerModeInternal()>
<android.media.IAudioService: boolean isHeadTrackerEnabled(android.media.AudioDeviceAttributes)>
<android.media.IAudioService: void setAppDevice(int,int,boolean)>
<android.media.IAudioService: void adjustStreamVolumeForUid(int,int,int,java.lang.String,int,int,android.os.UserHandle,int)>
<android.media.IAudioService: boolean isStreamAffectedByMute(int)>
<android.media.IAudioService: java.lang.String getCurrentAudioFocusPackageName()>
<android.media.IAudioService: java.lang.String registerAudioPolicy(android.media.audiopolicy.AudioPolicyConfig,android.media.audiopolicy.IAudioPolicyCallback,boolean,boolean,boolean,boolean,android.media.projection.IMediaProjection)>
<android.media.IAudioService: int removePreferredDevicesForStrategy(int)>
<android.media.IAudioService: void setMicrophoneMute(boolean,java.lang.String,int,java.lang.String)>
<android.media.IAudioService: android.media.AudioRoutesInfo startWatchingRoutes(android.media.IAudioRoutesObserver)>
<android.media.IAudioService: int addMixForPolicy(android.media.audiopolicy.AudioPolicyConfig,android.media.audiopolicy.IAudioPolicyCallback)>
<android.media.IAudioService: boolean loadSoundEffects()>
<android.media.IAudioService: void setForceSpeakerOn(boolean)>
<android.media.IAudioService: int getEncodedSurroundMode(int)>
<android.media.IAudioService: boolean isPstnCallAudioInterceptable()>
<android.media.IAudioService: java.util.List getIndependentStreamTypes()>
<android.media.IAudioService: boolean hasHapticChannels(android.net.Uri)>
<android.media.IAudioService: int secGetActiveStreamType(int)>
<android.media.IAudioService: float getOutputRs2UpperBound()>
<android.media.IAudioService: boolean isStreamMute(int)>
<android.media.IAudioService: int removeUserIdDeviceAffinity(android.media.audiopolicy.IAudioPolicyCallback,int)>
<android.media.IAudioService: void portEvent(int,int,android.os.PersistableBundle)>
<android.media.IAudioService: void removePackageForName(java.lang.String)>
<android.media.IAudioService: void setBluetoothVariableLatencyEnabled(boolean)>
<android.media.IAudioService: int getLastAudibleVolumeForVolumeGroup(int)>
<android.media.IAudioService: int getAppDevice(int)>
<android.media.IAudioService: boolean isVolumeFixed()>
<android.media.IAudioService: void registerPlaybackCallbackWithPackage(android.media.IPlaybackConfigDispatcher,java.lang.String)>
<android.media.IAudioService: void startBluetoothSco(android.os.IBinder,int)>
<android.media.IAudioService: void forceRemoteSubmixFullVolume(boolean,android.os.IBinder)>
<android.media.IAudioService: java.util.List getPreferredDevicesForCapturePreset(int)>
<android.media.IAudioService: void lowerVolumeToRs1(java.lang.String)>
<android.media.IAudioService: int[] getMediaVolumeSteps()>
<android.media.IAudioService: void registerAudioServerStateDispatcher(android.media.IAudioServerStateDispatcher)>
<android.media.IAudioService: void dismissVolumePanel()>
<android.media.IAudioService: int getActualHeadTrackingMode()>
<android.media.IAudioService: void registerSpatializerOutputCallback(android.media.ISpatializerOutputCallback)>
<android.media.IAudioService: void unregisterSpatializerCallback(android.media.ISpatializerCallback)>
<android.media.IAudioService: int setHdmiSystemAudioSupported(boolean)>
<android.media.IAudioService: void unregisterPlaybackCallback(android.media.IPlaybackConfigDispatcher)>
<android.media.IAudioService: boolean areNavigationRepeatSoundEffectsEnabled()>
<android.media.IAudioService: boolean isBluetoothScoOn()>
<android.media.IAudioService: void registerCapturePresetDevicesRoleDispatcher(android.media.ICapturePresetDevicesRoleDispatcher)>
<android.media.IAudioService: java.util.List getExcludedRingtoneTitles(int)>
<android.media.IAudioService: void setRingerModeExternal(int,java.lang.String)>
<android.media.IAudioService: void setStreamVolumeForUid(int,int,int,java.lang.String,int,int,android.os.UserHandle,int)>
<android.media.IAudioService: void setSpeakerphoneOn(android.os.IBinder,boolean)>
<android.media.IAudioService: int getMuteInterval()>
<android.media.IAudioService: void notifySafetyVolumeDialogVisible(android.media.IVolumeController,boolean)>
<android.media.IAudioService: int removeUidDeviceAffinity(android.media.audiopolicy.IAudioPolicyCallback,int)>
<android.media.IAudioService: void unregisterRecordingCallback(android.media.IRecordingConfigDispatcher)>
<android.media.IAudioService: int[] getActiveAssistantServiceUids()>
<android.media.IAudioService: int getStreamMaxVolume(int)>
<android.media.IAudioService: void setA2dpDeviceVolume(android.bluetooth.BluetoothDevice,int,int,int,java.lang.String)>
<android.media.IAudioService: boolean supportsBluetoothVariableLatency()>
<android.media.IAudioService: java.util.List getNonDefaultDevicesForStrategy(int)>
<android.media.IAudioService: int getVibrateSetting(int)>
<android.media.IAudioService: float[] getFloatVolumeTable()>
<android.media.IAudioService: int setDeviceToForceByUser(int,java.lang.String,boolean)>
<android.media.IAudioService: void addSpatializerCompatibleAudioDevice(android.media.AudioDeviceAttributes)>
<android.media.IAudioService: boolean isHdmiSystemAudioSupported()>
<android.media.IAudioService: void setVibrateSetting(int,int)>
<android.media.IAudioService: int[] getAvailableCommunicationDeviceIds()>
<android.media.IAudioService: boolean isSpatializerAvailable()>
<android.media.IAudioService: void startBluetoothScoVirtualCall(android.os.IBinder)>
<android.media.IAudioService: void setRadioOutputPath(int)>
<android.media.IAudioService: boolean shouldShowRingtoneVolume()>
<android.media.IAudioService: void playerSessionId(int,int)>
<android.media.IAudioService: java.util.List getActiveRecordingConfigurations()>
<android.media.IAudioService: void setStreamVolumeForDeviceWithAttribution(int,int,int,java.lang.String,java.lang.String,int)>
<android.media.IAudioService: void unregisterModeDispatcher(android.media.IAudioModeDispatcher)>
<android.media.IAudioService: int dispatchFocusChange(android.media.AudioFocusInfo,int,android.media.audiopolicy.IAudioPolicyCallback)>
<android.media.IAudioService: void setFocusRequestResultFromExtPolicy(android.media.AudioFocusInfo,int,android.media.audiopolicy.IAudioPolicyCallback)>
<android.media.IAudioService: void setNotifAliasRingForTest(boolean)>
<android.media.IAudioService: boolean isSpatializerEnabled()>
<android.media.IAudioService: void setSpatializerEnabled(boolean)>
<android.media.IAudioService: void unregisterAudioPolicy(android.media.audiopolicy.IAudioPolicyCallback)>
<android.media.IAudioService: boolean setMediaVolumeSteps(int[])>
<android.media.IAudioService: void addPackage(int,java.lang.String)>
<android.media.IAudioService: int getA2dpDeviceVolume(android.bluetooth.BluetoothDevice,int)>
<android.media.IAudioService: void setA2dpSuspended(boolean)>
<android.media.IAudioService: void registerDeviceVolumeBehaviorDispatcher(boolean,android.media.IDeviceVolumeBehaviorDispatcher)>
<android.media.IAudioService: void handleVolumeKey(android.view.KeyEvent,boolean,java.lang.String,java.lang.String)>
<android.media.IAudioService: boolean isAlreadyInDB(java.lang.String)>
<android.media.IAudioService: boolean isSurroundFormatEnabled(int)>
<android.media.IAudioService: void registerMuteAwaitConnectionDispatcher(android.media.IMuteAwaitConnectionCallback,boolean)>
<android.media.IAudioService: void forceComputeCsdOnAllDevices(boolean)>
<android.media.IAudioService: void setHomeSoundEffectEnabled(boolean)>
<android.media.IAudioService: void setAudioServiceConfig(java.lang.String)>
<android.media.IAudioService: boolean hasHeadTracker(android.media.AudioDeviceAttributes)>
<android.media.IAudioService: boolean isStreamAffectedByRingerMode(int)>
<android.media.IAudioService: void unregisterAudioServerStateDispatcher(android.media.IAudioServerStateDispatcher)>
<android.media.IAudioService: void setSoundSettingEventBroadcastIntent(int,android.app.PendingIntent)>
<android.media.IAudioService: long getAdditionalOutputDeviceDelay(android.media.AudioDeviceAttributes)>
<android.media.IAudioService: boolean isMicrophoneMuted()>
<android.media.IAudioService: void registerPlaybackCallback(android.media.IPlaybackConfigDispatcher)>
<android.media.IAudioService: boolean isSafeMediaVolumeStateActive()>
<android.media.IAudioService: void setCsd(float)>
<android.media.IAudioService: void forceUseFrameworkMel(boolean)>
<android.media.IAudioService: boolean isAudioServerRunning()>
<android.media.IAudioService: boolean setCommunicationDevice(android.os.IBinder,int)>
<android.media.IAudioService: android.media.IVolumeController getVolumeController()>
<android.media.IAudioService: void setMasterMute(boolean,int,java.lang.String,int,java.lang.String)>
<android.media.IAudioService: java.lang.String getAudioServiceConfig(java.lang.String)>
<android.media.IAudioService: java.util.List getActivePlaybackConfigurations()>
<android.media.IAudioService: boolean isMusicActive(boolean)>
<android.media.IAudioService: boolean isCameraSoundForced()>
<android.media.IAudioService: boolean isSpeakerphoneOn()>
<android.media.IAudioService: int abandonAudioFocus(android.media.IAudioFocusDispatcher,java.lang.String,android.media.AudioAttributes,java.lang.String)>
<android.media.IAudioService: int getAllowedCapturePolicy()>
<android.media.IAudioService: void unregisterSpatializerHeadTrackingCallback(android.media.ISpatializerHeadTrackingModeCallback)>
<android.media.IAudioService: void unregisterHeadToSoundstagePoseCallback(android.media.ISpatializerHeadToSoundStagePoseCallback)>
<android.media.IAudioService: void setSupportedSystemUsages(int[])>
<android.media.IAudioService: int[] getSupportedHeadTrackingModes()>
<android.media.IAudioService: int getStreamMinVolume(int)>
<android.media.IAudioService: int[] getSupportedSystemUsages()>
<android.media.IAudioService: int getUidForDevice(int)>
<android.media.IAudioService: void nativeEvent(java.lang.String,java.lang.String,int)>
<android.media.IAudioService: int setPreferredMixerAttributes(android.media.AudioAttributes,int,android.media.AudioMixerAttributes)>
<android.media.IAudioService: int removeMixForPolicy(android.media.audiopolicy.AudioPolicyConfig,android.media.audiopolicy.IAudioPolicyCallback)>
<android.media.IAudioService: void setMultiAudioFocusEnabled(boolean)>
<android.media.IAudioService: int getDeviceMaskForStream(int)>
<android.media.IAudioService: boolean isMasterMute()>
<android.media.IAudioService: void unloadSoundEffects()>
<android.media.IAudioService: boolean isInAllowedList(java.lang.String)>
<android.media.IAudioService: int getFineVolume(int,int)>
<android.media.IAudioService: void handleBluetoothActiveDeviceChanged(android.bluetooth.BluetoothDevice,android.bluetooth.BluetoothDevice,android.media.BluetoothProfileConnectionInfo)>
<android.media.IAudioService: int getRadioOutputPath()>
<android.media.IAudioService: void unregisterStrategyPreferredDevicesDispatcher(android.media.IStrategyPreferredDevicesDispatcher)>
<android.media.IAudioService: int getUiSoundsStreamType()>
<android.media.IAudioService: void setDeviceVolume(android.media.VolumeInfo,android.media.AudioDeviceAttributes,java.lang.String)>
<android.media.IAudioService: int getCurrentAudioFocus()>
<android.media.IAudioService: void registerRecordingCallback(android.media.IRecordingConfigDispatcher)>
<android.media.IAudioService: boolean isMultiSoundOn()>
<android.media.IAudioService: long getFadeOutDurationOnFocusLossMillis(android.media.AudioAttributes)>
<android.media.IAudioService: java.util.List getAudioProductStrategies()>
<android.media.IAudioService: int getCommunicationDevice()>
<android.media.IAudioService: void setMicrophoneMuteFromSwitch(boolean)>
<android.media.IAudioService: void unregisterSpatializerOutputCallback(android.media.ISpatializerOutputCallback)>
<android.media.IAudioService: void adjustStreamVolume(int,int,int,java.lang.String)>
<android.media.IAudioService: void cancelMuteAwaitConnection(android.media.AudioDeviceAttributes)>
<android.media.IAudioService: void registerStrategyPreferredDevicesDispatcher(android.media.IStrategyPreferredDevicesDispatcher)>
<android.media.IAudioService: void removeSpatializerCompatibleAudioDevice(android.media.AudioDeviceAttributes)>
<android.media.IAudioService: void recorderEvent(int,int)>
<android.media.IAudioService: void setMuteInterval(int,java.lang.String)>
<android.media.IAudioService: void registerSpatializerHeadTrackingCallback(android.media.ISpatializerHeadTrackingModeCallback)>
<android.media.IAudioService: boolean isHeadTrackerAvailable()>
<android.media.IAudioService: void unregisterCapturePresetDevicesRoleDispatcher(android.media.ICapturePresetDevicesRoleDispatcher)>
<android.media.IAudioService: void setRemoteMic(boolean)>
<android.media.IAudioService: android.media.VolumeInfo getDefaultVolumeInfo()>
<android.media.IAudioService: void setStreamVolumeWithAttribution(int,int,int,java.lang.String,java.lang.String)>
<android.media.IAudioService: void recenterHeadTracker()>
<android.media.IAudioService: void playSoundEffect(int,int)>
<android.media.IAudioService: void unregisterCommunicationDeviceDispatcher(android.media.ICommunicationDeviceDispatcher)>
<android.media.IAudioService: boolean isUsingAudio(int)>
<android.media.IAudioService: int getFocusRampTimeMs(int,android.media.AudioAttributes)>
<android.media.IAudioService: void releaseRecorder(int)>
<android.media.IAudioService: void setTestDeviceConnectionState(android.media.AudioDeviceAttributes,boolean)>
<android.media.IAudioService: int getStreamTypeAlias(int)>
<android.media.IAudioService: int removeDeviceAsNonDefaultForStrategy(int,android.media.AudioDeviceAttributes)>
<android.media.IAudioService: void setFineVolume(int,int,int,int,java.lang.String)>
<android.media.IAudioService: int trackRecorder(android.os.IBinder)>
<android.media.IAudioService: java.util.List getDevicesForAttributesUnprotected(android.media.AudioAttributes)>
<android.media.IAudioService: int getRemainingMuteIntervalMs()>
<android.media.IAudioService: boolean isBluetoothVariableLatencyEnabled()>
<android.media.IAudioService: void unregisterAudioFocusClient(java.lang.String)>
<android.media.IAudioService: int clearPreferredMixerAttributes(android.media.AudioAttributes,int)>
<android.media.IAudioService: boolean setEncodedSurroundMode(int)>
<android.media.IAudioService: java.util.List getDevicesForAttributes(android.media.AudioAttributes)>
<android.media.IAudioService: int getVolumeGroupMinVolumeIndex(int)>
<android.media.IAudioService: boolean isAppMute(int)>
<android.media.IAudioService: int getAppVolume(int)>
<android.media.IAudioService: java.lang.String getPinAppInfo(int)>
<android.media.IAudioService: void removeOnDevicesForAttributesChangedListener(android.media.IDevicesForAttributesCallback)>
<android.media.IAudioService: java.util.List getSpatializerCompatibleAudioDevices()>
<android.media.IAudioService: void playSoundEffectVolume(int,float)>
<android.media.IAudioService: void recordRingtoneChanger(java.lang.String)>
<android.media.IAudioService: boolean setAdditionalOutputDeviceDelay(android.media.AudioDeviceAttributes,long)>
<android.media.IAudioService: void setBtOffloadEnable(int)>
<android.media.IAudioService: int setUidDeviceAffinity(android.media.audiopolicy.IAudioPolicyCallback,int,int[],java.lang.String[])>
<android.media.IAudioService: java.util.List getFocusStack()>
<android.media.IAudioService: int getRingerModeExternal()>
<android.media.IAudioService: void unregisterAudioPolicyAsync(android.media.audiopolicy.IAudioPolicyCallback)>
<android.media.IAudioService: int getDeviceVolumeBehavior(android.media.AudioDeviceAttributes)>
<android.media.IAudioService: void unregisterStrategyNonDefaultDevicesDispatcher(android.media.IStrategyNonDefaultDevicesDispatcher)>
<android.media.IAudioService: boolean isCsdEnabled()>
<android.media.IAudioService: void setRingerModeInternal(int,java.lang.String)>
<android.media.IAudioService: void registerStrategyNonDefaultDevicesDispatcher(android.media.IStrategyNonDefaultDevicesDispatcher)>
<android.media.IAudioService: boolean isUltrasoundSupported()>
<android.media.IAudioService: void addAssistantServicesUids(int[])>
<android.media.IAudioService: boolean isVolumeGroupMuted(int)>
<android.media.IAudioService: void forceVolumeControlStream(int,android.os.IBinder)>
<android.media.IAudioService: void setHeadTrackerEnabled(boolean,android.media.AudioDeviceAttributes)>
<android.media.IAudioService: void registerSpatializerHeadTrackerAvailableCallback(android.media.ISpatializerHeadTrackerAvailableCallback,boolean)>
<android.media.IAudioService: void setActiveAssistantServiceUids(int[])>
<android.media.IAudioService: void muteAwaitConnection(int[],android.media.AudioDeviceAttributes,long)>
<android.media.IAudioService: void setNavigationRepeatSoundEffectsEnabled(boolean)>
<android.media.IAudioService: void setRttEnabled(boolean)>
<android.media.IAudioService: java.util.Map getSurroundFormats()>
<android.media.IAudioService: int clearPreferredDevicesForCapturePreset(int)>
<android.media.IAudioService: int getMode()>
<android.media.IAudioService: int getSpatializerOutput()>
<android.media.IAudioService: void setSpatializerParameter(int,byte[])>
<android.media.IAudioService: void setVolumeController(android.media.IVolumeController)>
<android.media.IAudioService: void setMode(int,android.os.IBinder,java.lang.String)>
<android.media.IAudioService: java.util.List getReportedSurroundFormats()>
<android.media.IAudioService: int getLastAudibleStreamVolume(int)>
<android.media.IAudioService: void releasePlayer(int)>
<android.media.IAudioService: void setDeviceVolumeBehavior(android.media.AudioDeviceAttributes,int,java.lang.String)>
<android.media.IAudioService: void setSpatializerGlobalTransform(float[])>
<android.media.IAudioService: int abandonAudioFocusForTest(android.media.IAudioFocusDispatcher,java.lang.String,android.media.AudioAttributes,java.lang.String)>
<android.media.IAudioService: void adjustStreamVolumeWithAttribution(int,int,int,java.lang.String,java.lang.String)>
<android.media.IAudioService: void removeAssistantServicesUids(int[])>
<android.media.IAudioService: boolean isCallScreeningModeSupported()>
<android.media.IAudioService: int getStreamVolume(int)>
<android.media.IAudioService: int getModeInternal()>
<android.media.IAudioService: void setDesiredHeadTrackingMode(int)>
<android.media.IAudioService: int[] getAssistantServicesUids()>
<android.media.IAudioService: void setLeAudioSuspended(boolean)>
<android.media.IAudioService: boolean isBluetoothA2dpOn()>
<android.media.IAudioService: void registerCommunicationDeviceDispatcher(android.media.ICommunicationDeviceDispatcher)>
<android.media.IAudioService: boolean isVolumeControlUsingVolumeGroups()>
<android.media.IAudioService: void setAppVolume(int,int,java.lang.String)>
<android.media.IAudioService: void getSpatializerParameter(int,byte[])>
<android.media.IAudioService: boolean isHotwordStreamSupported(boolean)>
<android.media.IAudioService: long getMaxAdditionalOutputDeviceDelay(android.media.AudioDeviceAttributes)>
<android.media.IAudioService: void registerDeviceVolumeDispatcherForAbsoluteVolume(boolean,android.media.IAudioDeviceVolumeDispatcher,java.lang.String,android.media.AudioDeviceAttributes,java.util.List,boolean,int)>
<android.media.IAudioService: void adjustSuggestedStreamVolumeForUid(int,int,int,java.lang.String,int,int,android.os.UserHandle,int)>
<android.media.IAudioService: boolean hasRegisteredDynamicPolicy()>
<android.media.IAudioService: int getPinDevice()>
<android.media.IAudioService: void registerPreferredMixerAttributesDispatcher(android.media.IPreferredMixerAttributesDispatcher)>
<android.media.IAudioService: void playerHasOpPlayAudio(int,boolean)>
<android.media.IAudioService: void setBluetoothScoOn(boolean)>
<android.media.IAudioService: void registerHeadToSoundstagePoseCallback(android.media.ISpatializerHeadToSoundStagePoseCallback)>
<android.media.IAudioService: void notifyVolumeControllerVisible(android.media.IVolumeController,boolean)>
<android.media.IAudioService: void playerEvent(int,int,int)>
<android.media.IAudioService: boolean shouldVibrate(int)>
<android.media.IAudioService: boolean isHomeSoundEffectEnabled()>
<android.media.IAudioService: android.media.AudioHalVersionInfo getHalVersion()>
<android.media.IAudioService: void setBluetoothA2dpOn(boolean)>
<android.media.IAudioService: android.media.IRingtonePlayer getRingtonePlayer()>
<com.samsung.android.hardware.display.IRefreshRateToken: void release()>
<android.app.backup.IRestoreObserver: void onUpdate(int,java.lang.String)>
<android.app.backup.IRestoreObserver: void restoreSetsAvailable(android.app.backup.RestoreSet[])>
<android.app.backup.IRestoreObserver: void restoreFinished(int)>
<android.app.backup.IRestoreObserver: void restoreStarting(int)>
<android.hardware.ICameraServiceListener: void onCameraDeviceStateChanged(java.lang.String,int,int,java.lang.String,int,int)>
<android.hardware.ICameraServiceListener: void onStatusChanged(int,java.lang.String)>
<android.hardware.ICameraServiceListener: void onCameraClosed(java.lang.String)>
<android.hardware.ICameraServiceListener: void onCameraOpened(java.lang.String,java.lang.String)>
<android.hardware.ICameraServiceListener: void onPhysicalCameraStatusChanged(int,java.lang.String,java.lang.String)>
<android.hardware.ICameraServiceListener: void onTorchStatusChanged(int,java.lang.String)>
<android.hardware.ICameraServiceListener: void onCameraAccessPrioritiesChanged()>
<android.hardware.ICameraServiceListener: void onTorchStrengthLevelChanged(java.lang.String,int)>
<android.service.credentials.IBeginCreateCredentialCallback: void onSuccess(android.service.credentials.BeginCreateCredentialResponse)>
<android.service.credentials.IBeginCreateCredentialCallback: void onCancellable(android.os.ICancellationSignal)>
<android.service.credentials.IBeginCreateCredentialCallback: void onFailure(java.lang.String,java.lang.CharSequence)>
<android.permission.IPermissionManager: boolean removeAllowlistedRestrictedPermission(java.lang.String,java.lang.String,int,int)>
<android.permission.IPermissionManager: boolean addAllowlistedRestrictedPermission(java.lang.String,java.lang.String,int,int)>
<android.permission.IPermissionManager: java.util.List getAutoRevokeExemptionGrantedPackages(int)>
<android.permission.IPermissionManager: void grantRuntimePermission(java.lang.String,java.lang.String,int)>
<android.permission.IPermissionManager: boolean isRegisteredAttributionSource(android.content.AttributionSourceState)>
<android.permission.IPermissionManager: java.util.List getSplitPermissions()>
<android.permission.IPermissionManager: void updatePermissionFlagsForAllApps(int,int,int)>
<android.permission.IPermissionManager: boolean addPermission(android.content.pm.PermissionInfo,boolean)>
<android.permission.IPermissionManager: void revokePostNotificationPermissionWithoutKillForTest(java.lang.String,int)>
<android.permission.IPermissionManager: void updatePermissionFlags(java.lang.String,java.lang.String,int,int,boolean,int)>
<android.permission.IPermissionManager: void removePermission(java.lang.String)>
<android.permission.IPermissionManager: boolean shouldShowRequestPermissionRationale(java.lang.String,java.lang.String,int)>
<android.permission.IPermissionManager: android.content.pm.ParceledListSlice getAllPermissionGroups(int)>
<android.permission.IPermissionManager: void registerAttributionSource(android.content.AttributionSourceState)>
<android.permission.IPermissionManager: void removeOnPermissionsChangeListener(android.permission.IOnPermissionsChangeListener)>
<android.permission.IPermissionManager: void stopOneTimePermissionSession(java.lang.String,int)>
<android.permission.IPermissionManager: java.util.List getAllowlistedRestrictedPermissions(java.lang.String,int,int)>
<android.permission.IPermissionManager: int getPermissionFlags(java.lang.String,java.lang.String,int)>
<android.permission.IPermissionManager: void startOneTimePermissionSession(java.lang.String,int,long,long)>
<android.permission.IPermissionManager: android.content.pm.ParceledListSlice queryPermissionsByGroup(java.lang.String,int)>
<android.permission.IPermissionManager: boolean setAutoRevokeExempted(java.lang.String,boolean,int)>
<android.permission.IPermissionManager: void revokeRuntimePermission(java.lang.String,java.lang.String,int,java.lang.String)>
<android.permission.IPermissionManager: android.content.pm.PermissionInfo getPermissionInfo(java.lang.String,java.lang.String,int)>
<android.permission.IPermissionManager: boolean isAutoRevokeExempted(java.lang.String,int)>
<android.permission.IPermissionManager: java.util.List getAutoRevokeExemptionRequestedPackages(int)>
<android.permission.IPermissionManager: boolean isPermissionRevokedByPolicy(java.lang.String,java.lang.String,int)>
<android.permission.IPermissionManager: android.content.pm.PermissionGroupInfo getPermissionGroupInfo(java.lang.String,int)>
<android.permission.IPermissionManager: void addOnPermissionsChangeListener(android.permission.IOnPermissionsChangeListener)>
<com.samsung.android.media.codec.IVideoTranscodingServiceCallback: void onStarted()>
<com.samsung.android.media.codec.IVideoTranscodingServiceCallback: void onError()>
<com.samsung.android.media.codec.IVideoTranscodingServiceCallback: void onReady()>
<com.samsung.android.media.codec.IVideoTranscodingServiceCallback: void onProgressChanged(int)>
<com.samsung.android.media.codec.IVideoTranscodingServiceCallback: void onCompleted()>
<android.nfc.INfcTag: int[] getTechList(int)>
<android.nfc.INfcTag: int connect(int,int)>
<android.nfc.INfcTag: android.nfc.NdefMessage ndefRead(int)>
<android.nfc.INfcTag: int ndefWrite(int,android.nfc.NdefMessage)>
<android.nfc.INfcTag: android.nfc.Tag rediscover(int)>
<android.nfc.INfcTag: boolean isNdef(int)>
<android.nfc.INfcTag: int ndefMakeReadOnly(int)>
<android.nfc.INfcTag: android.nfc.TransceiveResult transceive(int,byte[],boolean)>
<android.nfc.INfcTag: boolean canMakeReadOnly(int)>
<android.nfc.INfcTag: int formatNdef(int,byte[])>
<android.nfc.INfcTag: boolean ndefIsWritable(int)>
<android.nfc.INfcTag: int setTimeout(int,int)>
<android.nfc.INfcTag: boolean getExtendedLengthApdusSupported()>
<android.nfc.INfcTag: int reconnect(int)>
<android.nfc.INfcTag: boolean isTagUpToDate(long)>
<android.nfc.INfcTag: int getTimeout(int)>
<android.nfc.INfcTag: int getMaxTransceiveLength(int)>
<android.nfc.INfcTag: void resetTimeouts()>
<android.nfc.INfcTag: boolean isPresent(int)>
<android.window.IDisplayAreaOrganizer: void onDisplayAreaAppeared(android.window.DisplayAreaInfo,android.view.SurfaceControl)>
<android.window.IDisplayAreaOrganizer: void onDisplayAreaInfoChanged(android.window.DisplayAreaInfo)>
<android.window.IDisplayAreaOrganizer: void onDisplayAreaVanished(android.window.DisplayAreaInfo)>
<com.samsung.android.edge.IEdgeManager: void bindEdgeLightingService(android.os.IBinder,int,android.content.ComponentName)>
<com.samsung.android.edge.IEdgeManager: void startEdgeLighting(java.lang.String,com.samsung.android.edge.SemEdgeLightingInfo,android.os.IBinder)>
<com.samsung.android.edge.IEdgeManager: void updateEdgeLightingPolicy(java.lang.String,com.samsung.android.edge.EdgeLightingPolicy)>
<com.samsung.android.edge.IEdgeManager: void cancelNotification(java.lang.String,java.lang.String,int,int,java.lang.String)>
<com.samsung.android.edge.IEdgeManager: int getEdgeLightingState()>
<com.samsung.android.edge.IEdgeManager: void disable(int,java.lang.String,android.os.IBinder)>
<com.samsung.android.edge.IEdgeManager: void cancelNotificationByGroupKey(java.lang.String,java.lang.String,int,int,java.lang.String,java.lang.String)>
<com.samsung.android.edge.IEdgeManager: boolean isPackageEnabled(java.lang.String,int)>
<com.samsung.android.edge.IEdgeManager: void unbindEdgeLightingService(android.os.IBinder,java.lang.String)>
<com.samsung.android.edge.IEdgeManager: void unregisterEdgeLightingListener(android.os.IBinder,java.lang.String)>
<com.samsung.android.edge.IEdgeManager: void updateEdgeLightingPackageList(java.lang.String,java.util.List)>
<com.samsung.android.edge.IEdgeManager: boolean isEdgeLightingNotificationAllowed(java.lang.String)>
<com.samsung.android.edge.IEdgeManager: void disableEdgeLightingNotification(java.lang.String,boolean)>
<com.samsung.android.edge.IEdgeManager: void registerEdgeLightingListener(android.os.IBinder,android.content.ComponentName)>
<com.samsung.android.edge.IEdgeManager: void stopEdgeLighting(java.lang.String,android.os.IBinder)>
<android.content.IRCPInterfaceCallback: void onDone(java.lang.String,int)>
<android.content.IRCPInterfaceCallback: void onProgress(java.lang.String,int,int)>
<android.content.IRCPInterfaceCallback: void onComplete(java.util.List,int,int)>
<android.content.IRCPInterfaceCallback: void onFail(java.lang.String,int,int)>
<android.os.IThermalService: float getThermalHeadroom(int)>
<android.os.IThermalService: boolean registerThermalEventListenerWithType(android.os.IThermalEventListener,int)>
<android.os.IThermalService: boolean registerThermalStatusListener(android.os.IThermalStatusListener)>
<android.os.IThermalService: android.os.Temperature[] getCurrentTemperatures()>
<android.os.IThermalService: boolean unregisterThermalEventListener(android.os.IThermalEventListener)>
<android.os.IThermalService: android.os.CoolingDevice[] getCurrentCoolingDevicesWithType(int)>
<android.os.IThermalService: boolean unregisterThermalStatusListener(android.os.IThermalStatusListener)>
<android.os.IThermalService: int getCurrentThermalStatus()>
<android.os.IThermalService: android.os.Temperature[] getCurrentTemperaturesWithType(int)>
<android.os.IThermalService: android.os.CoolingDevice[] getCurrentCoolingDevices()>
<android.os.IThermalService: boolean registerThermalEventListener(android.os.IThermalEventListener)>
<android.hardware.camera2.extension.IImageCaptureExtenderImpl: int getMaxCaptureStage()>
<android.hardware.camera2.extension.IImageCaptureExtenderImpl: int getSessionType()>
<android.hardware.camera2.extension.IImageCaptureExtenderImpl: void init(java.lang.String,android.hardware.camera2.impl.CameraMetadataNative)>
<android.hardware.camera2.extension.IImageCaptureExtenderImpl: android.hardware.camera2.extension.CaptureStageImpl onPresetSession()>
<android.hardware.camera2.extension.IImageCaptureExtenderImpl: android.hardware.camera2.extension.CaptureStageImpl onDisableSession()>
<android.hardware.camera2.extension.IImageCaptureExtenderImpl: java.util.List getSupportedPostviewResolutions(android.hardware.camera2.extension.Size)>
<android.hardware.camera2.extension.IImageCaptureExtenderImpl: java.util.List getSupportedResolutions()>
<android.hardware.camera2.extension.IImageCaptureExtenderImpl: boolean isCaptureProcessProgressAvailable()>
<android.hardware.camera2.extension.IImageCaptureExtenderImpl: void onDeInit(android.os.IBinder)>
<android.hardware.camera2.extension.IImageCaptureExtenderImpl: android.hardware.camera2.extension.LatencyPair getRealtimeCaptureLatency()>
<android.hardware.camera2.extension.IImageCaptureExtenderImpl: boolean isPostviewAvailable()>
<android.hardware.camera2.extension.IImageCaptureExtenderImpl: android.hardware.camera2.extension.LatencyRange getEstimatedCaptureLatencyRange(android.hardware.camera2.extension.Size)>
<android.hardware.camera2.extension.IImageCaptureExtenderImpl: android.hardware.camera2.extension.ICaptureProcessorImpl getCaptureProcessor()>
<android.hardware.camera2.extension.IImageCaptureExtenderImpl: android.hardware.camera2.impl.CameraMetadataNative getAvailableCaptureRequestKeys()>
<android.hardware.camera2.extension.IImageCaptureExtenderImpl: void onInit(android.os.IBinder,java.lang.String,android.hardware.camera2.impl.CameraMetadataNative)>
<android.hardware.camera2.extension.IImageCaptureExtenderImpl: android.hardware.camera2.impl.CameraMetadataNative getAvailableCaptureResultKeys()>
<android.hardware.camera2.extension.IImageCaptureExtenderImpl: boolean isExtensionAvailable(java.lang.String,android.hardware.camera2.impl.CameraMetadataNative)>
<android.hardware.camera2.extension.IImageCaptureExtenderImpl: android.hardware.camera2.extension.CaptureStageImpl onEnableSession()>
<android.hardware.camera2.extension.IImageCaptureExtenderImpl: java.util.List getCaptureStages()>
<com.samsung.android.wifi.ISemWifiManager: java.lang.String getWifiVersions()>
<com.samsung.android.wifi.ISemWifiManager: void clearAutoHotspotLists()>
<com.samsung.android.wifi.ISemWifiManager: java.util.Map getCtlFeatureState()>
<com.samsung.android.wifi.ISemWifiManager: boolean setWesModeEnabled(boolean)>
<com.samsung.android.wifi.ISemWifiManager: void setWifiApGuestPassword(java.lang.String)>
<com.samsung.android.wifi.ISemWifiManager: boolean setFactoryMacAddress(java.lang.String)>
<com.samsung.android.wifi.ISemWifiManager: int getWifiIconVisibility()>
<com.samsung.android.wifi.ISemWifiManager: boolean setOptimizerForceControlMode(int)>
<com.samsung.android.wifi.ISemWifiManager: java.lang.String getAutoShareDump()>
<com.samsung.android.wifi.ISemWifiManager: java.util.Map getConfiguredNetworkLocations()>
<com.samsung.android.wifi.ISemWifiManager: void startIssueMonitoring(android.os.Bundle)>
<com.samsung.android.wifi.ISemWifiManager: boolean setRoamScanChannels(java.lang.String[])>
<com.samsung.android.wifi.ISemWifiManager: void setWifiApIsolate(boolean)>
<com.samsung.android.wifi.ISemWifiManager: int setWifiUwbCoexEnabled(int,boolean)>
<com.samsung.android.wifi.ISemWifiManager: void startTimerForWifiOffload()>
<com.samsung.android.wifi.ISemWifiManager: int startMcfClientMHSDiscovery(boolean)>
<com.samsung.android.wifi.ISemWifiManager: boolean saveFwDump()>
<com.samsung.android.wifi.ISemWifiManager: void set5GmmWaveSarBackoffEnabled(boolean)>
<com.samsung.android.wifi.ISemWifiManager: void enableHotspotTsfInfo(boolean)>
<com.samsung.android.wifi.ISemWifiManager: boolean setWifiApEnabled(android.net.wifi.SoftApConfiguration,boolean)>
<com.samsung.android.wifi.ISemWifiManager: void unregisterWifiApSmartCallback(int)>
<com.samsung.android.wifi.ISemWifiManager: boolean isGripSensorMonitorEnabled()>
<com.samsung.android.wifi.ISemWifiManager: void setWifiApClientDataPaused(java.lang.String,boolean)>
<com.samsung.android.wifi.ISemWifiManager: void setVerboseLoggingEnabled(boolean)>
<com.samsung.android.wifi.ISemWifiManager: void registerClientDataUsageCallback(android.os.IBinder,com.samsung.android.wifi.ISemWifiApClientUpdateCallback,int,java.lang.String)>
<com.samsung.android.wifi.ISemWifiManager: int getMcfConnectedStatus(java.lang.String)>
<com.samsung.android.wifi.ISemWifiManager: void setTestSettings(int,android.os.Bundle)>
<com.samsung.android.wifi.ISemWifiManager: void setWifiApConfigurationToDefault()>
<com.samsung.android.wifi.ISemWifiManager: void setImsCallEstablished(boolean)>
<com.samsung.android.wifi.ISemWifiManager: void triggerBackoffRoutine(boolean)>
<com.samsung.android.wifi.ISemWifiManager: java.util.Map getQoSScores(java.util.List)>
<com.samsung.android.wifi.ISemWifiManager: boolean disconnectApBlockAutojoin(boolean)>
<com.samsung.android.wifi.ISemWifiManager: int getIndoorStatus()>
<com.samsung.android.wifi.ISemWifiManager: boolean canAutoHotspotBeEnabled()>
<com.samsung.android.wifi.ISemWifiManager: void registerPasswordCallback(java.lang.String,com.samsung.android.wifi.ISemSharedPasswordCallback)>
<com.samsung.android.wifi.ISemWifiManager: void setLoopbackTestSettings(android.os.Bundle)>
<com.samsung.android.wifi.ISemWifiManager: boolean setProvisionSuccess(boolean)>
<com.samsung.android.wifi.ISemWifiManager: int getWifiApState()>
<com.samsung.android.wifi.ISemWifiManager: void setWifiSettingsForegroundState(int)>
<com.samsung.android.wifi.ISemWifiManager: void setAdvancedAutohotspotConnectSettings(int)>
<com.samsung.android.wifi.ISemWifiManager: void setConnectionAttemptInfo(int,boolean,java.lang.String)>
<com.samsung.android.wifi.ISemWifiManager: java.lang.String getFrameburstInfo()>
<com.samsung.android.wifi.ISemWifiManager: boolean wifiApBleD2DMhsRole(boolean)>
<com.samsung.android.wifi.ISemWifiManager: boolean isWifiSharingLiteSupported()>
<com.samsung.android.wifi.ISemWifiManager: void wifiApRestoreClientDataUsageSettingsInfo(java.lang.String)>
<com.samsung.android.wifi.ISemWifiManager: void unRegisterWifiApDataUsageCallback(int)>
<com.samsung.android.wifi.ISemWifiManager: boolean setTdlsEnabled(boolean)>
<com.samsung.android.wifi.ISemWifiManager: java.util.Map getNetworkLastUpdatedTimeMap()>
<com.samsung.android.wifi.ISemWifiManager: int getRoamScanPeriod()>
<com.samsung.android.wifi.ISemWifiManager: void setMaxDtimInSuspendMode(boolean)>
<com.samsung.android.wifi.ISemWifiManager: void restoreSemConfigurationsBackupData(java.lang.String)>
<com.samsung.android.wifi.ISemWifiManager: java.lang.String getStationInfo(java.lang.String)>
<com.samsung.android.wifi.ISemWifiManager: boolean isWifiApGuestModeIsolationEnabled()>
<com.samsung.android.wifi.ISemWifiManager: int getAdvancedAutohotspotConnectSettings()>
<com.samsung.android.wifi.ISemWifiManager: void setWifiApClientTimeLimit(java.lang.String,long)>
<com.samsung.android.wifi.ISemWifiManager: java.lang.String getTcpMonitorSocketForegroundHistory(int)>
<com.samsung.android.wifi.ISemWifiManager: boolean isOverAllMhsDataLimitReached()>
<com.samsung.android.wifi.ISemWifiManager: java.lang.String getCountryCode()>
<com.samsung.android.wifi.ISemWifiManager: android.os.Bundle getWifiRouterInfo(java.lang.String)>
<com.samsung.android.wifi.ISemWifiManager: boolean wifiApBleClientRole(boolean)>
<com.samsung.android.wifi.ISemWifiManager: int getWcmEverQualityTested()>
<com.samsung.android.wifi.ISemWifiManager: void reportIssue(int,android.os.Bundle)>
<com.samsung.android.wifi.ISemWifiManager: int getValidState()>
<com.samsung.android.wifi.ISemWifiManager: int getNumOfWifiAnt()>
<com.samsung.android.wifi.ISemWifiManager: void externalTwtInterface(int,java.lang.String)>
<com.samsung.android.wifi.ISemWifiManager: int[] getSoftApBands()>
<com.samsung.android.wifi.ISemWifiManager: boolean isWifiApGuestClient(java.lang.String)>
<com.samsung.android.wifi.ISemWifiManager: java.util.Map setTasPolicy(int,int)>
<com.samsung.android.wifi.ISemWifiManager: boolean connectToSmartD2DClient(java.lang.String,java.lang.String,com.samsung.android.wifi.ISemWifiApSmartCallback)>
<com.samsung.android.wifi.ISemWifiManager: java.lang.String getPsmInfo()>
<com.samsung.android.wifi.ISemWifiManager: boolean setUploadModeEnabled(boolean)>
<com.samsung.android.wifi.ISemWifiManager: boolean setLocalOnlyHotspotEnabled(boolean,java.lang.String,java.lang.String,int)>
<com.samsung.android.wifi.ISemWifiManager: void setWifiApMacAclMode(int)>
<com.samsung.android.wifi.ISemWifiManager: int getProvisionSuccess()>
<com.samsung.android.wifi.ISemWifiManager: java.lang.String getWifiStaInfo()>
<com.samsung.android.wifi.ISemWifiManager: java.lang.String getCountryRev()>
<com.samsung.android.wifi.ISemWifiManager: int getSmartMHSLockStatus()>
<com.samsung.android.wifi.ISemWifiManager: boolean setPktlogFilter(java.lang.String,java.lang.String)>
<com.samsung.android.wifi.ISemWifiManager: int getOptimizerForceControlMode()>
<com.samsung.android.wifi.ISemWifiManager: void reportHotspotDumpLogs(java.lang.String)>
<com.samsung.android.wifi.ISemWifiManager: void setAutohotspotToastMessage(int)>
<com.samsung.android.wifi.ISemWifiManager: void setWifiApGuestModeIsolationEnabled(boolean)>
<com.samsung.android.wifi.ISemWifiManager: android.os.Bundle getCurrentWifiRouterInfo()>
<com.samsung.android.wifi.ISemWifiManager: int getWifiApLOHSState()>
<com.samsung.android.wifi.ISemWifiManager: java.lang.String getWifiSupportedFeatureSet()>
<com.samsung.android.wifi.ISemWifiManager: int[] getOptimizerState()>
<com.samsung.android.wifi.ISemWifiManager: int getChannelUtilization()>
<com.samsung.android.wifi.ISemWifiManager: java.lang.String getConnectivityLog(java.lang.String)>
<com.samsung.android.wifi.ISemWifiManager: void setWifiApDailyDataLimit(long)>
<com.samsung.android.wifi.ISemWifiManager: void setPowerSavingTime(int)>
<com.samsung.android.wifi.ISemWifiManager: boolean setDcxoCalibrationData(java.lang.String)>
<com.samsung.android.wifi.ISemWifiManager: void registerWifiApSmartCallback(android.os.IBinder,com.samsung.android.wifi.ISemWifiApSmartCallback,int)>
<com.samsung.android.wifi.ISemWifiManager: void wifiApRestoreDailyHotspotDataLimit(long)>
<com.samsung.android.wifi.ISemWifiManager: void blockFccChannelBackoff(boolean)>
<com.samsung.android.wifi.ISemWifiManager: int getWifiApWarningActivityRunningState()>
<com.samsung.android.wifi.ISemWifiManager: java.util.List getWifiApBleD2DScanDetail()>
<com.samsung.android.wifi.ISemWifiManager: boolean connectToSmartMHS(java.lang.String,int,int,int,java.lang.String,java.lang.String,int,boolean)>
<com.samsung.android.wifi.ISemWifiManager: java.util.List getWifiApBleScanDetail()>
<com.samsung.android.wifi.ISemWifiManager: void runAutoShareForCurrent(java.util.List)>
<com.samsung.android.wifi.ISemWifiManager: void setSoftApConfiguration(android.net.wifi.SoftApConfiguration)>
<com.samsung.android.wifi.ISemWifiManager: void setWifiAiServiceNsdResult(int[],int[],int[],java.lang.String[])>
<com.samsung.android.wifi.ISemWifiManager: void setWifiAiServiceState(boolean,int[],int[])>
<com.samsung.android.wifi.ISemWifiManager: void setConnectivityCheckDisabled(boolean)>
<com.samsung.android.wifi.ISemWifiManager: boolean wifiApBleD2DClientRole(boolean)>
<com.samsung.android.wifi.ISemWifiManager: boolean isWifiSharingEnabled()>
<com.samsung.android.wifi.ISemWifiManager: void resetTotalPriorityDataConsumedValues()>
<com.samsung.android.wifi.ISemWifiManager: java.lang.String setMHSConfig(java.lang.String)>
<com.samsung.android.wifi.ISemWifiManager: long getWifiApDailyDataLimit()>
<com.samsung.android.wifi.ISemWifiManager: void setRVFmodeStatus(int)>
<com.samsung.android.wifi.ISemWifiManager: void setDtimInSuspendMode(int)>
<com.samsung.android.wifi.ISemWifiManager: long[] getNetworkUsageInfo(java.lang.String)>
<com.samsung.android.wifi.ISemWifiManager: int getCurrentStatusMode()>
<com.samsung.android.wifi.ISemWifiManager: int getMaxTdlsSession()>
<com.samsung.android.wifi.ISemWifiManager: boolean supportWifiAp6GBasedOnCountry()>
<com.samsung.android.wifi.ISemWifiManager: boolean setRoamDelta(int)>
<com.samsung.android.wifi.ISemWifiManager: java.util.List getTotalAndTop3ClientsDataUsageBetweenGivenDates(long,long)>
<com.samsung.android.wifi.ISemWifiManager: java.util.List getMHSClientTrafficDetails()>
<com.samsung.android.wifi.ISemWifiManager: boolean isWifiApWpa3Supported()>
<com.samsung.android.wifi.ISemWifiManager: boolean wifiApBleMhsRole(boolean)>
<com.samsung.android.wifi.ISemWifiManager: java.util.Map getTasAverage()>
<com.samsung.android.wifi.ISemWifiManager: boolean isOverAllMhsDataLimitSet()>
<com.samsung.android.wifi.ISemWifiManager: boolean isWifiApEnabled()>
<com.samsung.android.wifi.ISemWifiManager: boolean setRoamScanEnabled(boolean)>
<com.samsung.android.wifi.ISemWifiManager: void allowAutojoinPasspoint(java.lang.String,boolean)>
<com.samsung.android.wifi.ISemWifiManager: java.util.List getTopHotspotClientsToday(int,int)>
<com.samsung.android.wifi.ISemWifiManager: void removeExcludedNetwork(int)>
<com.samsung.android.wifi.ISemWifiManager: java.lang.String getFactoryMacAddress()>
<com.samsung.android.wifi.ISemWifiManager: java.util.List readWifiApMacAclList(int)>
<com.samsung.android.wifi.ISemWifiManager: int getMcfConnectedStatusFromScanResult(java.lang.String)>
<com.samsung.android.wifi.ISemWifiManager: void setGripSensorMonitorEnabled(boolean)>
<com.samsung.android.wifi.ISemWifiManager: java.lang.String getWifiUsabilityStatsEntry(int)>
<com.samsung.android.wifi.ISemWifiManager: void setWifiApWarningActivityRunning(int)>
<com.samsung.android.wifi.ISemWifiManager: boolean sendVendorSpecificActionFrame(java.lang.String,int,int,java.lang.String)>
<com.samsung.android.wifi.ISemWifiManager: int getWifiApMaxClientFromFramework()>
<com.samsung.android.wifi.ISemWifiManager: boolean setPsmInfo(java.lang.String)>
<com.samsung.android.wifi.ISemWifiManager: void unregisterTasPolicyChangedListener(com.samsung.android.wifi.SemTasPolicyListener)>
<com.samsung.android.wifi.ISemWifiManager: boolean isSupportedAutoWifi()>
<com.samsung.android.wifi.ISemWifiManager: long[] getDataConsumedValues()>
<com.samsung.android.wifi.ISemWifiManager: void setIWCQTables(java.lang.String)>
<com.samsung.android.wifi.ISemWifiManager: void setMhsAiServiceState(boolean,int[],int[])>
<com.samsung.android.wifi.ISemWifiManager: int connectToMcfMHS(java.lang.String,int,int,int,java.lang.String,java.lang.String,int)>
<com.samsung.android.wifi.ISemWifiManager: int getAdvancedAutohotspotLCDSettings()>
<com.samsung.android.wifi.ISemWifiManager: java.lang.String getWifiApGuestPassword()>
<com.samsung.android.wifi.ISemWifiManager: void setKeepConnection(boolean,boolean)>
<com.samsung.android.wifi.ISemWifiManager: boolean hasConfiguredNetworkLocations(java.lang.String)>
<com.samsung.android.wifi.ISemWifiManager: void setWifiApGuestModeEnabled(boolean)>
<com.samsung.android.wifi.ISemWifiManager: boolean addOrUpdateNetwork(com.samsung.android.wifi.SemWifiConfiguration)>
<com.samsung.android.wifi.ISemWifiManager: void setUserConfirmForSharingPassword(boolean,java.lang.String)>
<com.samsung.android.wifi.ISemWifiManager: void setKeepConnectionBigData(int)>
<com.samsung.android.wifi.ISemWifiManager: void setWifiApMaxClient(int)>
<com.samsung.android.wifi.ISemWifiManager: void setAdvancedAutohotspotLCDSettings(int)>
<com.samsung.android.wifi.ISemWifiManager: java.lang.String getProfileShareDump()>
<com.samsung.android.wifi.ISemWifiManager: java.lang.String getSilentRoamingDump(int)>
<com.samsung.android.wifi.ISemWifiManager: java.lang.String getWifiRouterInfoBestEffort(java.lang.String)>
<com.samsung.android.wifi.ISemWifiManager: void setWifiApMaxClientToFramework(int)>
<com.samsung.android.wifi.ISemWifiManager: void unregisterPasswordCallback(com.samsung.android.wifi.ISemSharedPasswordCallback)>
<com.samsung.android.wifi.ISemWifiManager: void updateIWCHintCard(long)>
<com.samsung.android.wifi.ISemWifiManager: boolean isWifiDeveloperModeEnabled()>
<com.samsung.android.wifi.ISemWifiManager: boolean setRoamBand(int)>
<com.samsung.android.wifi.ISemWifiManager: int getNRTTrafficbandwidth()>
<com.samsung.android.wifi.ISemWifiManager: void requestStopAutohotspotAdvertisement(boolean)>
<com.samsung.android.wifi.ISemWifiManager: void setKeepConnectionAlways(boolean)>
<com.samsung.android.wifi.ISemWifiManager: void disableRandomMac()>
<com.samsung.android.wifi.ISemWifiManager: boolean getWifiApIsolate()>
<com.samsung.android.wifi.ISemWifiManager: boolean isAvailableTdls()>
<com.samsung.android.wifi.ISemWifiManager: void setFccChannelBackoffEnabled(java.lang.String,boolean)>
<com.samsung.android.wifi.ISemWifiManager: java.util.List getDiagnosisResults()>
<com.samsung.android.wifi.ISemWifiManager: int getNumOfTdlsSession()>
<com.samsung.android.wifi.ISemWifiManager: int getSmartApConnectedStatus(java.lang.String)>
<com.samsung.android.wifi.ISemWifiManager: void addOrUpdateWifiControlHistory(java.lang.String,boolean)>
<com.samsung.android.wifi.ISemWifiManager: void notifyReachabilityLost()>
<com.samsung.android.wifi.ISemWifiManager: java.lang.String getTcpMonitorAllSocketHistory(int)>
<com.samsung.android.wifi.ISemWifiManager: boolean isAvailableAutoWifiScan()>
<com.samsung.android.wifi.ISemWifiManager: boolean setLatencyCritical(java.lang.String,int)>
<com.samsung.android.wifi.ISemWifiManager: java.lang.String getMHSConfig(java.lang.String)>
<com.samsung.android.wifi.ISemWifiManager: boolean setWifiSharingEnabled(boolean)>
<com.samsung.android.wifi.ISemWifiManager: int getSmartApConnectedStatusFromScanResult(java.lang.String)>
<com.samsung.android.wifi.ISemWifiManager: int getWifiApMacAclMode()>
<com.samsung.android.wifi.ISemWifiManager: int setSmartMHSLocked(int)>
<com.samsung.android.wifi.ISemWifiManager: int[] getServiceDetectionResult()>
<com.samsung.android.wifi.ISemWifiManager: boolean setVendorWlanDriverProp(java.lang.String,java.lang.String)>
<com.samsung.android.wifi.ISemWifiManager: int getHotspotAntMode()>
<com.samsung.android.wifi.ISemWifiManager: int getRoamTrigger()>
<com.samsung.android.wifi.ISemWifiManager: void setWifiApClientEditedName(java.lang.String,java.lang.String)>
<com.samsung.android.wifi.ISemWifiManager: java.lang.String getWifiFirmwareVersion()>
<com.samsung.android.wifi.ISemWifiManager: boolean isSupportedProfileRequest()>
<com.samsung.android.wifi.ISemWifiManager: void requestPassword(boolean)>
<com.samsung.android.wifi.ISemWifiManager: java.lang.String getVendorWlanDriverProp(java.lang.String)>
<com.samsung.android.wifi.ISemWifiManager: void resetDeveloperOptionsSettings()>
<com.samsung.android.wifi.ISemWifiManager: boolean isWifiSharingSupported()>
<com.samsung.android.wifi.ISemWifiManager: boolean isUploadModeEnabled()>
<com.samsung.android.wifi.ISemWifiManager: java.lang.String retrieveSemWifiConfigsBackupData()>
<com.samsung.android.wifi.ISemWifiManager: int getWifiApChannel()>
<com.samsung.android.wifi.ISemWifiManager: void isClientAcceptedWifiProfileSharing(boolean)>
<com.samsung.android.wifi.ISemWifiManager: java.lang.String getTcpMonitorDnsHistory(int)>
<com.samsung.android.wifi.ISemWifiManager: java.lang.String getWifiRouterInfoPresentable(java.lang.String)>
<com.samsung.android.wifi.ISemWifiManager: int startMcfMHSAdvertisement(boolean)>
<com.samsung.android.wifi.ISemWifiManager: java.lang.String getWifiCid()>
<com.samsung.android.wifi.ISemWifiManager: boolean setFrameburstInfo(java.lang.String)>
<com.samsung.android.wifi.ISemWifiManager: boolean startScan(java.lang.String)>
<com.samsung.android.wifi.ISemWifiManager: java.util.List getWifiApStaListDetail()>
<com.samsung.android.wifi.ISemWifiManager: boolean getWifiApWpsPbc()>
<com.samsung.android.wifi.ISemWifiManager: java.lang.String wifiApBackUpClientDataUsageSettingsInfo()>
<com.samsung.android.wifi.ISemWifiManager: boolean setAntInfo(java.lang.String)>
<com.samsung.android.wifi.ISemWifiManager: void setWifiApWpsPbc(boolean)>
<com.samsung.android.wifi.ISemWifiManager: int manageWifiApMacAclList(java.lang.String,java.lang.String,int,int)>
<com.samsung.android.wifi.ISemWifiManager: android.content.pm.ParceledListSlice getConfiguredNetworks()>
<com.samsung.android.wifi.ISemWifiManager: boolean isWesModeEnabled()>
<com.samsung.android.wifi.ISemWifiManager: void setAllowWifiScan(boolean,java.lang.String)>
<com.samsung.android.wifi.ISemWifiManager: void updateGuiderFeature(android.os.Bundle)>
<com.samsung.android.wifi.ISemWifiManager: java.lang.String getAutoWifiDump()>
<com.samsung.android.wifi.ISemWifiManager: void notifyConnect(int,java.lang.String)>
<com.samsung.android.wifi.ISemWifiManager: android.net.wifi.SoftApConfiguration getSoftApConfiguration()>
<com.samsung.android.wifi.ISemWifiManager: long getWifiApTodaysTotalDataUsage()>
<com.samsung.android.wifi.ISemWifiManager: java.lang.String getWifiApInterfaceName()>
<com.samsung.android.wifi.ISemWifiManager: int getWifiApFreq()>
<com.samsung.android.wifi.ISemWifiManager: int getWifiApMaxClient()>
<com.samsung.android.wifi.ISemWifiManager: boolean removeNetwork(java.lang.String)>
<com.samsung.android.wifi.ISemWifiManager: boolean setNCHOModeEnabled(boolean)>
<com.samsung.android.wifi.ISemWifiManager: boolean supportWifiAp5GBasedOnCountry()>
<com.samsung.android.wifi.ISemWifiManager: void setTCRule(boolean,java.lang.String,int)>
<com.samsung.android.wifi.ISemWifiManager: boolean sendReassociationRequestFrame(java.lang.String,int)>
<com.samsung.android.wifi.ISemWifiManager: int canSmartMHSLocked()>
<com.samsung.android.wifi.ISemWifiManager: boolean isSwitchToMobileDataDefaultOff()>
<com.samsung.android.wifi.ISemWifiManager: java.util.Map getEasySetupScanSettings()>
<com.samsung.android.wifi.ISemWifiManager: java.lang.String getIWCQTables()>
<com.samsung.android.wifi.ISemWifiManager: java.util.List getMcfScanDetail()>
<com.samsung.android.wifi.ISemWifiManager: java.lang.String getTopHotspotClientsTodayAsString(int,int)>
<com.samsung.android.wifi.ISemWifiManager: boolean removeFactoryMacAddress()>
<com.samsung.android.wifi.ISemWifiManager: boolean isWiderBandwidthTdlsSupported()>
<com.samsung.android.wifi.ISemWifiManager: void reportBigData(java.lang.String,java.lang.String)>
<com.samsung.android.wifi.ISemWifiManager: java.lang.String getIssueDetectorDump(int)>
<com.samsung.android.wifi.ISemWifiManager: void restoreIWCSettingsValue(int,int)>
<com.samsung.android.wifi.ISemWifiManager: boolean isIndividualAppSupported()>
<com.samsung.android.wifi.ISemWifiManager: void updateHostapdMacList(int)>
<com.samsung.android.wifi.ISemWifiManager: void setAntMode(int)>
<com.samsung.android.wifi.ISemWifiManager: void setWifiDeveloperModeEnabled(boolean)>
<com.samsung.android.wifi.ISemWifiManager: java.lang.String getWifiEnableHistory()>
<com.samsung.android.wifi.ISemWifiManager: void setMhsAiServiceNsdResult(int[],java.lang.String[])>
<com.samsung.android.wifi.ISemWifiManager: void factoryReset()>
<com.samsung.android.wifi.ISemWifiManager: java.lang.String getCurrentStateAndEnterTime()>
<com.samsung.android.wifi.ISemWifiManager: int getWifiApConnectedStationCount()>
<com.samsung.android.wifi.ISemWifiManager: java.lang.String getWifiApStaList()>
<com.samsung.android.wifi.ISemWifiManager: void registerTasPolicyChangedListener(com.samsung.android.wifi.SemTasPolicyListener)>
<com.samsung.android.wifi.ISemWifiManager: void unregisterClientListDataUsageCallback(int)>
<com.samsung.android.wifi.ISemWifiManager: java.lang.String runIptablesRulesCommand(java.lang.String)>
<com.samsung.android.wifi.ISemWifiManager: java.lang.String getDcxoCalibrationData()>
<com.samsung.android.wifi.ISemWifiManager: boolean setRoamScanPeriod(int)>
<com.samsung.android.wifi.ISemWifiManager: boolean setRoamTrigger(int)>
<com.samsung.android.wifi.ISemWifiManager: boolean isP2pConnected()>
<com.samsung.android.wifi.ISemWifiManager: int getRoamBand()>
<com.samsung.android.wifi.ISemWifiManager: void setHotspotAntMode(int)>
<com.samsung.android.wifi.ISemWifiManager: boolean isSupportedQoSProvider()>
<com.samsung.android.wifi.ISemWifiManager: boolean isNCHOModeEnabled()>
<com.samsung.android.wifi.ISemWifiManager: boolean isWifiApGuestModeEnabled()>
<com.samsung.android.wifi.ISemWifiManager: void registerClientListDataUsageCallback(android.os.IBinder,com.samsung.android.wifi.ISemWifiApClientListUpdateCallback,int,int,int)>
<com.samsung.android.wifi.ISemWifiManager: boolean setCountryRev(java.lang.String)>
<com.samsung.android.wifi.ISemWifiManager: boolean isMCFClientAutohotspotSupported()>
<com.samsung.android.wifi.ISemWifiManager: boolean isWifiApMacAclEnabled()>
<com.samsung.android.wifi.ISemWifiManager: int getRVFModeStatus()>
<com.samsung.android.wifi.ISemWifiManager: void setWifiApMacAclEnable(boolean)>
<com.samsung.android.wifi.ISemWifiManager: void registerWifiApDataUsageCallback(android.os.IBinder,com.samsung.android.wifi.ISemWifiApDataUsageCallback,int)>
<com.samsung.android.wifi.ISemWifiManager: void setIWCMockAction(int)>
<com.samsung.android.wifi.ISemWifiManager: int getRssi(java.lang.String)>
<com.samsung.android.wifi.ISemWifiManager: void resetSoftAp(android.os.Message)>
<com.samsung.android.wifi.ISemWifiManager: void unregisterClientDataUsageCallback(int)>
<com.samsung.android.wifi.ISemWifiManager: int[] getTWTParams()>
<com.samsung.android.wifi.ISemWifiManager: java.lang.String getDailyUsageInfo(int)>
<com.samsung.android.wifi.ISemWifiManager: java.util.List getMonthlyDataUsage()>
<com.samsung.android.wifi.ISemWifiManager: void wifiApDisassocSta(java.lang.String)>
<com.samsung.android.wifi.ISemWifiManager: boolean removePktlogFilter(java.lang.String,java.lang.String)>
<com.samsung.android.wifi.ISemWifiManager: void setWifiApClientMobileDataLimit(java.lang.String,long)>
<com.samsung.android.wifi.ISemWifiManager: void checkAppForWiFiOffloading(java.lang.String)>
<com.samsung.android.wifi.ISemWifiManager: int getRoamDelta()>
<com.samsung.android.wifi.ISemWifiManager: int getSmartD2DClientConnectedStatus(java.lang.String)>
<com.samsung.android.wifi.ISemWifiManager: boolean isScanningEnabled()>
<com.samsung.android.wifi.ISemWifiManager: void setArdkPowerSaveMode(boolean)>
<com.samsung.android.wifi.ISemWifiManager: boolean isWifiApEnabledWithDualBand()>
<com.samsung.android.wifi.ISemWifiManager: com.samsung.android.wifi.SemWifiApClientDetails getWifiApClientDetails(java.lang.String)>
<com.samsung.android.wifi.ISemWifiManager: java.lang.String getAntInfo()>
<com.samsung.android.wifi.ISemWifiManager: boolean linkQosQuery(long,long,long,int,long)>
<com.samsung.android.wifi.ISemWifiManager: void setEasySetupScanSettings(java.lang.String,com.samsung.android.wifi.SemEasySetupWifiScanSettings)>
<android.content.pm.IASKSManager: java.util.List getUnknownAppList()>
<android.content.pm.IASKSManager: java.lang.String[] checkASKSTarget(int)>
<android.content.pm.IASKSManager: byte[] getSEInfo(java.lang.String)>
<android.content.pm.IASKSManager: boolean isUnknownApps(java.lang.String,android.content.pm.Signature[])>
<android.content.pm.IASKSManager: int checkSecurityEnabled()>
<android.content.pm.IASKSManager: int verifyASKStokenForPackage(java.lang.String,java.lang.String,long,android.content.pm.Signature[],java.lang.String,java.lang.String,boolean)>
<android.content.pm.IASKSManager: void clearASKSruleForRemovedPackage(java.lang.String)>
<android.content.pm.IASKSManager: java.lang.String readASKSFiles(java.lang.String,java.lang.String)>
<android.content.pm.IASKSManager: int checkUnknownSourcePackage(java.lang.String,java.lang.String[],java.lang.String[],java.lang.String,android.content.pm.Signature[],java.lang.String,java.lang.String,java.lang.String,int,java.lang.String,java.lang.String,int)>
<android.content.pm.IASKSManager: void checkDeletableListForASKS()>
<android.content.pm.IASKSManager: void postASKSsetup(java.lang.String,java.lang.String,int)>
<android.content.pm.IASKSManager: void applyScpmPolicyFromApp()>
<android.content.pm.IASKSManager: void systemReady()>
<android.content.pm.IASKSManager: int checkRestrictedPermission(java.lang.String,java.lang.String)>
<android.content.pm.IASKSManager: boolean isTrustedStore(java.lang.String,int)>
<android.content.pm.IASKSManager: java.util.List getIMEIList()>
<android.content.pm.IASKSManager: java.lang.String getUNvalueForASKS()>
<android.content.pm.IASKSManager: void setTrustTimebyStatusChanged()>
<android.content.pm.IASKSManager: boolean checkFollowingLegitimateWay(java.lang.String,int)>
<android.service.voice.IDspHotwordDetectionCallback: void onRejected(android.service.voice.HotwordRejectedResult)>
<android.service.voice.IDspHotwordDetectionCallback: void onDetected(android.service.voice.HotwordDetectedResult)>
<android.view.IScrollCaptureResponseListener: void onScrollCaptureResponse(android.view.ScrollCaptureResponse)>
<android.hardware.face.IFaceServiceReceiver: void onEnrollResult(android.hardware.face.Face,int)>
<android.hardware.face.IFaceServiceReceiver: void onSemAuthenticationSucceededWithBundle(android.hardware.face.Face,int,boolean,android.os.Bundle)>
<android.hardware.face.IFaceServiceReceiver: void onAuthenticationFrame(android.hardware.face.FaceAuthenticationFrame)>
<android.hardware.face.IFaceServiceReceiver: void onAcquired(int,int)>
<android.hardware.face.IFaceServiceReceiver: void onFaceDetected(int,int,boolean)>
<android.hardware.face.IFaceServiceReceiver: void onChallengeGenerated(int,int,long)>
<android.hardware.face.IFaceServiceReceiver: void onError(int,int)>
<android.hardware.face.IFaceServiceReceiver: void onAuthenticationSucceeded(android.hardware.face.Face,int,boolean)>
<android.hardware.face.IFaceServiceReceiver: void onFeatureSet(boolean,int)>
<android.hardware.face.IFaceServiceReceiver: void onSemAuthenticationSucceeded(android.hardware.face.Face,int,boolean,byte[])>
<android.hardware.face.IFaceServiceReceiver: void onEnrollmentFrame(android.hardware.face.FaceEnrollFrame)>
<android.hardware.face.IFaceServiceReceiver: void onSemImageProcessed(byte[],int,int,int,int,android.os.Bundle)>
<android.hardware.face.IFaceServiceReceiver: void onFeatureGet(boolean,int[],boolean[])>
<android.hardware.face.IFaceServiceReceiver: void onRemoved(android.hardware.face.Face,int)>
<android.hardware.face.IFaceServiceReceiver: void onSemStatusUpdate(int,java.lang.String)>
<android.hardware.face.IFaceServiceReceiver: void onAuthenticationFailed()>
<com.android.internal.telecom.IPhoneAccountSuggestionCallback: void suggestPhoneAccounts(java.lang.String,java.util.List)>
<android.print.IPrintSpooler: void onCustomPrinterIconLoaded(android.print.PrinterId,android.graphics.drawable.Icon,android.print.IPrintSpoolerCallbacks,int)>
<android.print.IPrintSpooler: void createPrintJob(android.print.PrintJobInfo)>
<android.print.IPrintSpooler: void setStatus(android.print.PrintJobId,java.lang.CharSequence)>
<android.print.IPrintSpooler: void writePrintJobData(android.os.ParcelFileDescriptor,android.print.PrintJobId)>
<android.print.IPrintSpooler: void setPrintJobState(android.print.PrintJobId,int,java.lang.String,android.print.IPrintSpoolerCallbacks,int)>
<android.print.IPrintSpooler: void setProgress(android.print.PrintJobId,float)>
<android.print.IPrintSpooler: void clearCustomPrinterIconCache(android.print.IPrintSpoolerCallbacks,int)>
<android.print.IPrintSpooler: void setClient(android.print.IPrintSpoolerClient)>
<android.print.IPrintSpooler: void getCustomPrinterIcon(android.print.PrinterId,android.print.IPrintSpoolerCallbacks,int)>
<android.print.IPrintSpooler: void setPrintJobTag(android.print.PrintJobId,java.lang.String,android.print.IPrintSpoolerCallbacks,int)>
<android.print.IPrintSpooler: void pruneApprovedPrintServices(java.util.List)>
<android.print.IPrintSpooler: void removeObsoletePrintJobs()>
<android.print.IPrintSpooler: void setPrintJobCancelling(android.print.PrintJobId,boolean)>
<android.print.IPrintSpooler: void setStatusRes(android.print.PrintJobId,int,java.lang.CharSequence)>
<android.print.IPrintSpooler: void getPrintJobInfo(android.print.PrintJobId,android.print.IPrintSpoolerCallbacks,int,int)>
<android.print.IPrintSpooler: void getPrintJobInfos(android.print.IPrintSpoolerCallbacks,android.content.ComponentName,int,int,int)>
<android.nfc.INfcFCardEmulation: boolean disableNfcFForegroundService()>
<android.nfc.INfcFCardEmulation: int getMaxNumOfRegisterableSystemCodes()>
<android.nfc.INfcFCardEmulation: java.lang.String getSystemCodeForService(int,android.content.ComponentName)>
<android.nfc.INfcFCardEmulation: boolean registerSystemCodeForService(int,android.content.ComponentName,java.lang.String)>
<android.nfc.INfcFCardEmulation: boolean setNfcid2ForService(int,android.content.ComponentName,java.lang.String)>
<android.nfc.INfcFCardEmulation: boolean enableNfcFForegroundService(android.content.ComponentName)>
<android.nfc.INfcFCardEmulation: java.util.List getNfcFServices(int)>
<android.nfc.INfcFCardEmulation: java.lang.String getNfcid2ForService(int,android.content.ComponentName)>
<android.nfc.INfcFCardEmulation: boolean removeSystemCodeForService(int,android.content.ComponentName)>
<android.os.ILogd: void decline(int,int,int,int)>
<android.os.ILogd: void approve(int,int,int,int)>
<com.android.internal.telecom.IConnectionServiceAdapter: void setOnHold(java.lang.String,android.telecom.Logging.Session$Info)>
<com.android.internal.telecom.IConnectionServiceAdapter: void setDisconnected(java.lang.String,android.telecom.DisconnectCause,android.telecom.Logging.Session$Info)>
<com.android.internal.telecom.IConnectionServiceAdapter: void queryLocation(java.lang.String,long,java.lang.String,android.os.ResultReceiver,android.telecom.Logging.Session$Info)>
<com.android.internal.telecom.IConnectionServiceAdapter: void removeExtras(java.lang.String,java.util.List,android.telecom.Logging.Session$Info)>
<com.android.internal.telecom.IConnectionServiceAdapter: void queryRemoteConnectionServices(com.android.internal.telecom.RemoteServiceCallback,java.lang.String,android.telecom.Logging.Session$Info)>
<com.android.internal.telecom.IConnectionServiceAdapter: void addConferenceCall(java.lang.String,android.telecom.ParcelableConference,android.telecom.Logging.Session$Info)>
<com.android.internal.telecom.IConnectionServiceAdapter: void setConferenceState(java.lang.String,boolean,android.telecom.Logging.Session$Info)>
<com.android.internal.telecom.IConnectionServiceAdapter: void setCallerDisplayName(java.lang.String,java.lang.String,int,android.telecom.Logging.Session$Info)>
<com.android.internal.telecom.IConnectionServiceAdapter: void resetConnectionTime(java.lang.String,android.telecom.Logging.Session$Info)>
<com.android.internal.telecom.IConnectionServiceAdapter: void setConferenceableConnections(java.lang.String,java.util.List,android.telecom.Logging.Session$Info)>
<com.android.internal.telecom.IConnectionServiceAdapter: void setIsVoipAudioMode(java.lang.String,boolean,android.telecom.Logging.Session$Info)>
<com.android.internal.telecom.IConnectionServiceAdapter: void onRttSessionRemotelyTerminated(java.lang.String,android.telecom.Logging.Session$Info)>
<com.android.internal.telecom.IConnectionServiceAdapter: void onRemoteRttRequest(java.lang.String,android.telecom.Logging.Session$Info)>
<com.android.internal.telecom.IConnectionServiceAdapter: void setCallDirection(java.lang.String,int,android.telecom.Logging.Session$Info)>
<com.android.internal.telecom.IConnectionServiceAdapter: void onConnectionServiceFocusReleased(android.telecom.Logging.Session$Info)>
<com.android.internal.telecom.IConnectionServiceAdapter: void requestCallEndpointChange(java.lang.String,android.telecom.CallEndpoint,android.os.ResultReceiver,android.telecom.Logging.Session$Info)>
<com.android.internal.telecom.IConnectionServiceAdapter: void setPulling(java.lang.String,android.telecom.Logging.Session$Info)>
<com.android.internal.telecom.IConnectionServiceAdapter: void putExtras(java.lang.String,android.os.Bundle,android.telecom.Logging.Session$Info)>
<com.android.internal.telecom.IConnectionServiceAdapter: void setConnectionProperties(java.lang.String,int,android.telecom.Logging.Session$Info)>
<com.android.internal.telecom.IConnectionServiceAdapter: void setActive(java.lang.String,android.telecom.Logging.Session$Info)>
<com.android.internal.telecom.IConnectionServiceAdapter: void onPostDialWait(java.lang.String,java.lang.String,android.telecom.Logging.Session$Info)>
<com.android.internal.telecom.IConnectionServiceAdapter: void onPhoneAccountChanged(java.lang.String,android.telecom.PhoneAccountHandle,android.telecom.Logging.Session$Info)>
<com.android.internal.telecom.IConnectionServiceAdapter: void setAudioRoute(java.lang.String,int,java.lang.String,android.telecom.Logging.Session$Info)>
<com.android.internal.telecom.IConnectionServiceAdapter: void setVideoState(java.lang.String,int,android.telecom.Logging.Session$Info)>
<com.android.internal.telecom.IConnectionServiceAdapter: void setAddress(java.lang.String,android.net.Uri,int,android.telecom.Logging.Session$Info)>
<com.android.internal.telecom.IConnectionServiceAdapter: void setStatusHints(java.lang.String,android.telecom.StatusHints,android.telecom.Logging.Session$Info)>
<com.android.internal.telecom.IConnectionServiceAdapter: void addExistingConnection(java.lang.String,android.telecom.ParcelableConnection,android.telecom.Logging.Session$Info)>
<com.android.internal.telecom.IConnectionServiceAdapter: void setRinging(java.lang.String,android.telecom.Logging.Session$Info)>
<com.android.internal.telecom.IConnectionServiceAdapter: void setVideoProvider(java.lang.String,com.android.internal.telecom.IVideoProvider,android.telecom.Logging.Session$Info)>
<com.android.internal.telecom.IConnectionServiceAdapter: void setIsConferenced(java.lang.String,java.lang.String,android.telecom.Logging.Session$Info)>
<com.android.internal.telecom.IConnectionServiceAdapter: void onRttInitiationFailure(java.lang.String,int,android.telecom.Logging.Session$Info)>
<com.android.internal.telecom.IConnectionServiceAdapter: void onRttInitiationSuccess(java.lang.String,android.telecom.Logging.Session$Info)>
<com.android.internal.telecom.IConnectionServiceAdapter: void removeCall(java.lang.String,android.telecom.Logging.Session$Info)>
<com.android.internal.telecom.IConnectionServiceAdapter: void handleCreateConferenceComplete(java.lang.String,android.telecom.ConnectionRequest,android.telecom.ParcelableConference,android.telecom.Logging.Session$Info)>
<com.android.internal.telecom.IConnectionServiceAdapter: void onPostDialChar(java.lang.String,char,android.telecom.Logging.Session$Info)>
<com.android.internal.telecom.IConnectionServiceAdapter: void setConnectionCapabilities(java.lang.String,int,android.telecom.Logging.Session$Info)>
<com.android.internal.telecom.IConnectionServiceAdapter: void setDialing(java.lang.String,android.telecom.Logging.Session$Info)>
<com.android.internal.telecom.IConnectionServiceAdapter: void handleCreateConnectionComplete(java.lang.String,android.telecom.ConnectionRequest,android.telecom.ParcelableConnection,android.telecom.Logging.Session$Info)>
<com.android.internal.telecom.IConnectionServiceAdapter: void setConferenceMergeFailed(java.lang.String,android.telecom.Logging.Session$Info)>
<com.android.internal.telecom.IConnectionServiceAdapter: void setRingbackRequested(java.lang.String,boolean,android.telecom.Logging.Session$Info)>
<com.android.internal.telecom.IConnectionServiceAdapter: void onConnectionEvent(java.lang.String,java.lang.String,android.os.Bundle,android.telecom.Logging.Session$Info)>
<android.service.euicc.IEraseSubscriptionsCallback: void onComplete(int)>
<android.service.euicc.IEuiccService: void dump(android.service.euicc.IEuiccServiceDumpResultCallback)>
<android.service.euicc.IEuiccService: void switchToSubscription(int,int,java.lang.String,boolean,android.service.euicc.ISwitchToSubscriptionCallback,boolean)>
<android.service.euicc.IEuiccService: void getEuiccProfileInfoList(int,android.service.euicc.IGetEuiccProfileInfoListCallback)>
<android.service.euicc.IEuiccService: void eraseSubscriptionsWithOptions(int,int,android.service.euicc.IEraseSubscriptionsCallback)>
<android.service.euicc.IEuiccService: void getEuiccInfo(int,android.service.euicc.IGetEuiccInfoCallback)>
<android.service.euicc.IEuiccService: void downloadSubscription(int,int,android.telephony.euicc.DownloadableSubscription,boolean,boolean,android.os.Bundle,android.service.euicc.IDownloadSubscriptionCallback)>
<android.service.euicc.IEuiccService: void startOtaIfNecessary(int,android.service.euicc.IOtaStatusChangedCallback)>
<android.service.euicc.IEuiccService: void getEid(int,android.service.euicc.IGetEidCallback)>
<android.service.euicc.IEuiccService: void retainSubscriptionsForFactoryReset(int,android.service.euicc.IRetainSubscriptionsForFactoryResetCallback)>
<android.service.euicc.IEuiccService: void updateSubscriptionNickname(int,java.lang.String,java.lang.String,android.service.euicc.IUpdateSubscriptionNicknameCallback)>
<android.service.euicc.IEuiccService: void eraseSubscriptions(int,android.service.euicc.IEraseSubscriptionsCallback)>
<android.service.euicc.IEuiccService: void getDefaultDownloadableSubscriptionList(int,boolean,android.service.euicc.IGetDefaultDownloadableSubscriptionListCallback)>
<android.service.euicc.IEuiccService: void getDownloadableSubscriptionMetadata(int,int,android.telephony.euicc.DownloadableSubscription,boolean,boolean,android.service.euicc.IGetDownloadableSubscriptionMetadataCallback)>
<android.service.euicc.IEuiccService: void deleteSubscription(int,java.lang.String,android.service.euicc.IDeleteSubscriptionCallback)>
<android.service.euicc.IEuiccService: void getOtaStatus(int,android.service.euicc.IGetOtaStatusCallback)>
<com.android.internal.inputmethod.IInputMethodSession: void updateCursor(android.graphics.Rect)>
<com.android.internal.inputmethod.IInputMethodSession: void viewClicked(boolean)>
<com.android.internal.inputmethod.IInputMethodSession: void updateExtractedText(int,android.view.inputmethod.ExtractedText)>
<com.android.internal.inputmethod.IInputMethodSession: void updateSelection(int,int,int,int,int,int)>
<com.android.internal.inputmethod.IInputMethodSession: void finishSession()>
<com.android.internal.inputmethod.IInputMethodSession: void removeImeSurface()>
<com.android.internal.inputmethod.IInputMethodSession: void updateCursorAnchorInfo(android.view.inputmethod.CursorAnchorInfo)>
<com.android.internal.inputmethod.IInputMethodSession: void finishInput()>
<com.android.internal.inputmethod.IInputMethodSession: void showSideSyncSoftInput(int)>
<com.android.internal.inputmethod.IInputMethodSession: void appPrivateCommand(java.lang.String,android.os.Bundle)>
<com.android.internal.inputmethod.IInputMethodSession: void invalidateInput(android.view.inputmethod.EditorInfo,com.android.internal.inputmethod.IRemoteInputConnection,int)>
<com.android.internal.inputmethod.IInputMethodSession: void displayCompletions(android.view.inputmethod.CompletionInfo[])>
<android.media.session.ISession: void setExtras(android.os.Bundle)>
<android.media.session.ISession: android.os.IBinder getBinderForSetQueue()>
<android.media.session.ISession: void setCurrentVolume(int)>
<android.media.session.ISession: void setFlags(int)>
<android.media.session.ISession: void setPlaybackState(android.media.session.PlaybackState)>
<android.media.session.ISession: void destroySession()>
<android.media.session.ISession: void setQueueTitle(java.lang.CharSequence)>
<android.media.session.ISession: void setLaunchPendingIntent(android.app.PendingIntent)>
<android.media.session.ISession: void setPlaybackToLocal(android.media.AudioAttributes)>
<android.media.session.ISession: void sendEvent(java.lang.String,android.os.Bundle)>
<android.media.session.ISession: void setRatingType(int)>
<android.media.session.ISession: void setMediaButtonBroadcastReceiver(android.content.ComponentName)>
<android.media.session.ISession: void setActive(boolean)>
<android.media.session.ISession: void setMetadata(android.media.MediaMetadata,long,java.lang.String)>
<android.media.session.ISession: void resetQueue()>
<android.media.session.ISession: void setMediaButtonReceiver(android.app.PendingIntent)>
<android.media.session.ISession: android.media.session.ISessionController getController()>
<android.media.session.ISession: void setPlaybackToRemote(int,int,java.lang.String)>
<com.samsung.android.net.IExtendedEthernetManager: android.net.IpConfiguration getConfiguration(java.lang.String)>
<android.gsi.IProgressCallback: void onProgress(long,long)>
<com.android.internal.telephony.euicc.IGetAllProfilesCallback: void onComplete(int,android.service.euicc.EuiccProfileInfo[])>
<com.android.internal.telecom.IInCallAdapter: void turnOnProximitySensor()>
<com.android.internal.telecom.IInCallAdapter: void conference(java.lang.String,java.lang.String)>
<com.android.internal.telecom.IInCallAdapter: void pullExternalCall(java.lang.String)>
<com.android.internal.telecom.IInCallAdapter: void sendRttRequest(java.lang.String)>
<com.android.internal.telecom.IInCallAdapter: void swapConference(java.lang.String)>
<com.android.internal.telecom.IInCallAdapter: void consultativeTransfer(java.lang.String,java.lang.String)>
<com.android.internal.telecom.IInCallAdapter: void setAudioRoute(int,java.lang.String)>
<com.android.internal.telecom.IInCallAdapter: void disconnectCall(java.lang.String)>
<com.android.internal.telecom.IInCallAdapter: void playDtmfTone(java.lang.String,char)>
<com.android.internal.telecom.IInCallAdapter: void rejectCall(java.lang.String,boolean,java.lang.String)>
<com.android.internal.telecom.IInCallAdapter: void respondToRttRequest(java.lang.String,int,boolean)>
<com.android.internal.telecom.IInCallAdapter: void mergeConference(java.lang.String)>
<com.android.internal.telecom.IInCallAdapter: void enterBackgroundAudioProcessing(java.lang.String)>
<com.android.internal.telecom.IInCallAdapter: void postDialContinue(java.lang.String,boolean)>
<com.android.internal.telecom.IInCallAdapter: void splitFromConference(java.lang.String)>
<com.android.internal.telecom.IInCallAdapter: void rejectCallWithReason(java.lang.String,int)>
<com.android.internal.telecom.IInCallAdapter: void phoneAccountSelected(java.lang.String,android.telecom.PhoneAccountHandle,boolean)>
<com.android.internal.telecom.IInCallAdapter: void exitBackgroundAudioProcessing(java.lang.String,boolean)>
<com.android.internal.telecom.IInCallAdapter: void putExtras(java.lang.String,android.os.Bundle)>
<com.android.internal.telecom.IInCallAdapter: void answerCall(java.lang.String,int)>
<com.android.internal.telecom.IInCallAdapter: void removeExtras(java.lang.String,java.util.List)>
<com.android.internal.telecom.IInCallAdapter: void mute(boolean)>
<com.android.internal.telecom.IInCallAdapter: void requestCallEndpointChange(android.telecom.CallEndpoint,android.os.ResultReceiver)>
<com.android.internal.telecom.IInCallAdapter: void transferCall(java.lang.String,android.net.Uri,boolean)>
<com.android.internal.telecom.IInCallAdapter: void turnOffProximitySensor(boolean)>
<com.android.internal.telecom.IInCallAdapter: void holdCall(java.lang.String)>
<com.android.internal.telecom.IInCallAdapter: void stopDtmfTone(java.lang.String)>
<com.android.internal.telecom.IInCallAdapter: void unholdCall(java.lang.String)>
<com.android.internal.telecom.IInCallAdapter: void addConferenceParticipants(java.lang.String,java.util.List)>
<com.android.internal.telecom.IInCallAdapter: void sendCallEvent(java.lang.String,java.lang.String,int,android.os.Bundle)>
<com.android.internal.telecom.IInCallAdapter: void setRttMode(java.lang.String,int)>
<com.android.internal.telecom.IInCallAdapter: void stopRtt(java.lang.String)>
<com.android.internal.telecom.IInCallAdapter: void deflectCall(java.lang.String,android.net.Uri)>
<com.android.internal.telecom.IInCallAdapter: void handoverTo(java.lang.String,android.telecom.PhoneAccountHandle,int,android.os.Bundle)>
<com.samsung.android.gesture.IMotionRecognitionCallback: java.lang.String getListenerInfo()>
<com.samsung.android.gesture.IMotionRecognitionCallback: java.lang.String getListenerPackageName()>
<com.samsung.android.gesture.IMotionRecognitionCallback: void motionCallback(com.samsung.android.gesture.SemMotionRecognitionEvent)>
<com.android.internal.os.IShellCallback: android.os.ParcelFileDescriptor openFile(java.lang.String,java.lang.String,java.lang.String)>
<android.media.IStreamAliasingDispatcher: void dispatchStreamAliasingChanged()>
<android.media.IMediaRoute2ProviderServiceCallback: void notifySessionsUpdated(java.util.List)>
<android.media.IMediaRoute2ProviderServiceCallback: void notifyProviderUpdated(android.media.MediaRoute2ProviderInfo)>
<android.media.IMediaRoute2ProviderServiceCallback: void notifySessionReleased(android.media.RoutingSessionInfo)>
<android.media.IMediaRoute2ProviderServiceCallback: void notifyRequestFailed(long,int)>
<android.media.IMediaRoute2ProviderServiceCallback: void notifySessionCreated(long,android.media.RoutingSessionInfo)>
<android.telephony.ims.aidl.IImsRegistration: void addRegistrationCallback(android.telephony.ims.aidl.IImsRegistrationCallback)>
<android.telephony.ims.aidl.IImsRegistration: void triggerSipDelegateDeregistration()>
<android.telephony.ims.aidl.IImsRegistration: int getRegistrationTechnology()>
<android.telephony.ims.aidl.IImsRegistration: void removeRegistrationCallback(android.telephony.ims.aidl.IImsRegistrationCallback)>
<android.telephony.ims.aidl.IImsRegistration: void triggerDeregistration(int)>
<android.telephony.ims.aidl.IImsRegistration: void triggerFullNetworkRegistration(int,java.lang.String)>
<android.telephony.ims.aidl.IImsRegistration: void triggerUpdateSipDelegateRegistration()>
<com.android.internal.telephony.euicc.IEuiccCardController: void disableProfile(java.lang.String,java.lang.String,java.lang.String,boolean,com.android.internal.telephony.euicc.IDisableProfileCallback)>
<com.android.internal.telephony.euicc.IEuiccCardController: void retrieveNotification(java.lang.String,java.lang.String,int,com.android.internal.telephony.euicc.IRetrieveNotificationCallback)>
<com.android.internal.telephony.euicc.IEuiccCardController: void switchToProfile(java.lang.String,java.lang.String,java.lang.String,int,boolean,com.android.internal.telephony.euicc.ISwitchToProfileCallback)>
<com.android.internal.telephony.euicc.IEuiccCardController: void prepareDownload(java.lang.String,java.lang.String,byte[],byte[],byte[],byte[],com.android.internal.telephony.euicc.IPrepareDownloadCallback)>
<com.android.internal.telephony.euicc.IEuiccCardController: void loadBoundProfilePackage(java.lang.String,java.lang.String,byte[],com.android.internal.telephony.euicc.ILoadBoundProfilePackageCallback)>
<com.android.internal.telephony.euicc.IEuiccCardController: void getEuiccInfo2(java.lang.String,java.lang.String,com.android.internal.telephony.euicc.IGetEuiccInfo2Callback)>
<com.android.internal.telephony.euicc.IEuiccCardController: void getSmdsAddress(java.lang.String,java.lang.String,com.android.internal.telephony.euicc.IGetSmdsAddressCallback)>
<com.android.internal.telephony.euicc.IEuiccCardController: void authenticateServer(java.lang.String,java.lang.String,java.lang.String,byte[],byte[],byte[],byte[],com.android.internal.telephony.euicc.IAuthenticateServerCallback)>
<com.android.internal.telephony.euicc.IEuiccCardController: void removeNotificationFromList(java.lang.String,java.lang.String,int,com.android.internal.telephony.euicc.IRemoveNotificationFromListCallback)>
<com.android.internal.telephony.euicc.IEuiccCardController: void deleteProfile(java.lang.String,java.lang.String,java.lang.String,com.android.internal.telephony.euicc.IDeleteProfileCallback)>
<com.android.internal.telephony.euicc.IEuiccCardController: void setNickname(java.lang.String,java.lang.String,java.lang.String,java.lang.String,com.android.internal.telephony.euicc.ISetNicknameCallback)>
<com.android.internal.telephony.euicc.IEuiccCardController: void retrieveNotificationList(java.lang.String,java.lang.String,int,com.android.internal.telephony.euicc.IRetrieveNotificationListCallback)>
<com.android.internal.telephony.euicc.IEuiccCardController: void getDefaultSmdpAddress(java.lang.String,java.lang.String,com.android.internal.telephony.euicc.IGetDefaultSmdpAddressCallback)>
<com.android.internal.telephony.euicc.IEuiccCardController: void getEnabledProfile(java.lang.String,java.lang.String,int,com.android.internal.telephony.euicc.IGetProfileCallback)>
<com.android.internal.telephony.euicc.IEuiccCardController: void cancelSession(java.lang.String,java.lang.String,byte[],int,com.android.internal.telephony.euicc.ICancelSessionCallback)>
<com.android.internal.telephony.euicc.IEuiccCardController: void getAllProfiles(java.lang.String,java.lang.String,com.android.internal.telephony.euicc.IGetAllProfilesCallback)>
<com.android.internal.telephony.euicc.IEuiccCardController: void listNotifications(java.lang.String,java.lang.String,int,com.android.internal.telephony.euicc.IListNotificationsCallback)>
<com.android.internal.telephony.euicc.IEuiccCardController: void getEuiccChallenge(java.lang.String,java.lang.String,com.android.internal.telephony.euicc.IGetEuiccChallengeCallback)>
<com.android.internal.telephony.euicc.IEuiccCardController: void getEuiccInfo1(java.lang.String,java.lang.String,com.android.internal.telephony.euicc.IGetEuiccInfo1Callback)>
<com.android.internal.telephony.euicc.IEuiccCardController: void getRulesAuthTable(java.lang.String,java.lang.String,com.android.internal.telephony.euicc.IGetRulesAuthTableCallback)>
<com.android.internal.telephony.euicc.IEuiccCardController: void getProfile(java.lang.String,java.lang.String,java.lang.String,com.android.internal.telephony.euicc.IGetProfileCallback)>
<com.android.internal.telephony.euicc.IEuiccCardController: void resetMemory(java.lang.String,java.lang.String,int,com.android.internal.telephony.euicc.IResetMemoryCallback)>
<com.android.internal.telephony.euicc.IEuiccCardController: void setDefaultSmdpAddress(java.lang.String,java.lang.String,java.lang.String,com.android.internal.telephony.euicc.ISetDefaultSmdpAddressCallback)>
<android.os.incremental.IIncrementalServiceConnector: int setStorageParams(boolean)>
<android.window.ISurfaceSyncGroup: boolean onAddedToSyncGroup(android.os.IBinder,boolean)>
<android.window.ISurfaceSyncGroup: boolean addToSync(android.window.ISurfaceSyncGroup,boolean)>
<com.android.internal.telecom.ICallScreeningService: void screenCall(com.android.internal.telecom.ICallScreeningAdapter,android.telecom.ParcelableCall)>
<android.media.musicrecognition.IMusicRecognitionManagerCallback: void onRecognitionFailed(int)>
<android.media.musicrecognition.IMusicRecognitionManagerCallback: void onRecognitionSucceeded(android.media.MediaMetadata,android.os.Bundle)>
<android.media.musicrecognition.IMusicRecognitionManagerCallback: void onAudioStreamClosed()>
<android.app.timedetector.ITimeDetectorService: void suggestTelephonyTime(android.app.timedetector.TelephonyTimeSuggestion)>
<android.app.timedetector.ITimeDetectorService: boolean setManualTime(android.app.timedetector.ManualTimeSuggestion)>
<android.app.timedetector.ITimeDetectorService: boolean updateConfiguration(android.app.time.TimeConfiguration)>
<android.app.timedetector.ITimeDetectorService: void addListener(android.app.time.ITimeDetectorListener)>
<android.app.timedetector.ITimeDetectorService: void suggestExternalTime(android.app.time.ExternalTimeSuggestion)>
<android.app.timedetector.ITimeDetectorService: android.app.time.TimeCapabilitiesAndConfig getCapabilitiesAndConfig()>
<android.app.timedetector.ITimeDetectorService: boolean suggestManualTime(android.app.timedetector.ManualTimeSuggestion)>
<android.app.timedetector.ITimeDetectorService: android.app.time.UnixEpochTime latestNetworkTime()>
<android.app.timedetector.ITimeDetectorService: boolean confirmTime(android.app.time.UnixEpochTime)>
<android.app.timedetector.ITimeDetectorService: void removeListener(android.app.time.ITimeDetectorListener)>
<android.app.timedetector.ITimeDetectorService: android.app.time.TimeState getTimeState()>
<android.media.soundtrigger.ISoundTriggerDetectionServiceClient: void onOpFinished(int)>
<android.media.IDeviceVolumeBehaviorDispatcher: void dispatchDeviceVolumeBehaviorChanged(android.media.AudioDeviceAttributes,int)>
<android.service.wallpaper.IWallpaperEngine: void setZoomOut(float)>
<android.service.wallpaper.IWallpaperEngine: android.view.SurfaceControl mirrorSurfaceControl()>
<android.service.wallpaper.IWallpaperEngine: void requestWallpaperColors()>
<android.service.wallpaper.IWallpaperEngine: void setInAmbientMode(boolean,long)>
<android.service.wallpaper.IWallpaperEngine: void applyDimming(float)>
<android.service.wallpaper.IWallpaperEngine: void setDesiredSize(int,int)>
<android.service.wallpaper.IWallpaperEngine: void setVisibility(boolean)>
<android.service.wallpaper.IWallpaperEngine: void setWallpaperFlags(int)>
<android.service.wallpaper.IWallpaperEngine: void setSurfaceAlpha(float)>
<android.service.wallpaper.IWallpaperEngine: void addLocalColorsAreas(java.util.List)>
<android.service.wallpaper.IWallpaperEngine: void onScreenTurningOn()>
<android.service.wallpaper.IWallpaperEngine: void removeLocalColorsAreas(java.util.List)>
<android.service.wallpaper.IWallpaperEngine: void setDisplayPadding(android.graphics.Rect)>
<android.service.wallpaper.IWallpaperEngine: void destroy()>
<android.service.wallpaper.IWallpaperEngine: void dispatchPointer(android.view.MotionEvent)>
<android.service.wallpaper.IWallpaperEngine: void onScreenTurnedOn()>
<android.service.wallpaper.IWallpaperEngine: void resizePreview(android.graphics.Rect)>
<android.service.wallpaper.IWallpaperEngine: void dispatchWallpaperCommand(java.lang.String,int,int,int,android.os.Bundle)>
<android.media.session.ISessionControllerCallback: void onVolumeInfoChanged(android.media.session.MediaController$PlaybackInfo)>
<android.media.session.ISessionControllerCallback: void onQueueTitleChanged(java.lang.CharSequence)>
<android.media.session.ISessionControllerCallback: void onSessionDestroyed()>
<android.media.session.ISessionControllerCallback: void onEvent(java.lang.String,android.os.Bundle)>
<android.media.session.ISessionControllerCallback: void onMetadataChanged(android.media.MediaMetadata)>
<android.media.session.ISessionControllerCallback: void onQueueChanged(android.content.pm.ParceledListSlice)>
<android.media.session.ISessionControllerCallback: void onExtrasChanged(android.os.Bundle)>
<android.media.session.ISessionControllerCallback: void onPlaybackStateChanged(android.media.session.PlaybackState)>
<com.samsung.android.remoteappmode.IStartActivityInterceptListener: void onStartActivityIntercepted(android.content.Intent,android.os.Bundle,android.content.pm.ActivityInfo,int,boolean,int,int,int)>
<vendor.samsung.hardware.thermal.ISehThermalChangedCallback: void notifyTemperatures(vendor.samsung.hardware.thermal.SehTemperature[])>
<vendor.samsung.hardware.thermal.ISehThermalChangedCallback: java.lang.String getInterfaceHash()>
<vendor.samsung.hardware.thermal.ISehThermalChangedCallback: int getInterfaceVersion()>
<android.app.IUserSwitchObserver: void onUserSwitching(int,android.os.IRemoteCallback)>
<android.app.IUserSwitchObserver: void onBeforeUserSwitching(int)>
<android.app.IUserSwitchObserver: void onLockedBootComplete(int)>
<android.app.IUserSwitchObserver: void onUserSwitchComplete(int)>
<android.app.IUserSwitchObserver: void onForegroundProfileSwitch(int)>
<android.content.pm.IPackageInstallObserver2: void onUserActionRequired(android.content.Intent)>
<android.content.pm.IPackageInstallObserver2: void onPackageInstalled(java.lang.String,int,java.lang.String,android.os.Bundle)>
<android.app.IServiceConnection: void connected(android.content.ComponentName,android.os.IBinder,boolean)>
<android.telephony.satellite.ISatelliteStateCallback: void onSatelliteModemStateChanged(int)>
<com.samsung.android.smartface.ISmartFaceClient: void onInfo(int,com.samsung.android.smartface.FaceInfo,int)>
<android.os.IRecoverySystem: boolean isLskfCaptured(java.lang.String)>
<android.os.IRecoverySystem: boolean clearLskf(java.lang.String)>
<android.os.IRecoverySystem: int rebootWithLskf(java.lang.String,java.lang.String,boolean)>
<android.os.IRecoverySystem: int rebootWithLskfAssumeSlotSwitch(java.lang.String,java.lang.String)>
<android.os.IRecoverySystem: boolean uncrypt(java.lang.String,android.os.IRecoverySystemProgressListener)>
<android.os.IRecoverySystem: boolean clearBcb()>
<android.os.IRecoverySystem: boolean requestLskf(java.lang.String,android.content.IntentSender)>
<android.os.IRecoverySystem: boolean setupBcb(java.lang.String)>
<android.os.IRecoverySystem: boolean allocateSpaceForUpdate(java.lang.String)>
<android.os.IRecoverySystem: void rebootRecoveryWithCommand(java.lang.String)>
<com.samsung.android.ims.options.SemCapabilityServiceEventListener: void onCapabilityAndAvailabilityPublished(int)>
<com.samsung.android.ims.options.SemCapabilityServiceEventListener: void onOwnCapabilitiesChanged()>
<com.samsung.android.ims.options.SemCapabilityServiceEventListener: void onMultipleCapabilitiesChanged(java.util.List,java.util.List)>
<com.samsung.android.ims.options.SemCapabilityServiceEventListener: void onCapabilitiesChanged(com.samsung.android.ims.util.SemImsUri,com.samsung.android.ims.options.SemCapabilities)>
<android.security.identity.IWritableCredential: byte[] personalize(android.security.identity.AccessControlProfileParcel[],android.security.identity.EntryNamespaceParcel[],long)>
<android.security.identity.IWritableCredential: byte[] getCredentialKeyCertificateChain(byte[])>
<android.view.contentcapture.IContentCaptureOptionsCallback: void setContentCaptureOptions(android.content.ContentCaptureOptions)>
<com.sec.android.iaft.callback.IIAFTCallback: void traceResult(java.lang.String,int,int,int,int)>
<android.hardware.gnss.IGnssMeasurementCallback: int getInterfaceVersion()>
<android.hardware.gnss.IGnssMeasurementCallback: void gnssMeasurementCb(android.hardware.gnss.GnssData)>
<android.hardware.gnss.IGnssMeasurementCallback: java.lang.String getInterfaceHash()>
<android.hardware.input.IPointerIconChangedListener: void onPointerIconChanged(int,android.view.PointerIcon)>
<com.android.internal.textservice.ISpellCheckerService: void getISpellCheckerSession(java.lang.String,com.android.internal.textservice.ISpellCheckerSessionListener,android.os.Bundle,int,com.android.internal.textservice.ISpellCheckerServiceCallback)>
<android.window.IOnBackInvokedCallback: void onBackInvoked()>
<android.window.IOnBackInvokedCallback: void onBackCancelled()>
<android.window.IOnBackInvokedCallback: void onBackProgressed(android.window.BackMotionEvent)>
<android.window.IOnBackInvokedCallback: void onBackStarted(android.window.BackMotionEvent)>
<android.content.integrity.IAppIntegrityManager: android.content.pm.ParceledListSlice getCurrentRules()>
<android.content.integrity.IAppIntegrityManager: void updateRuleSet(java.lang.String,android.content.pm.ParceledListSlice,android.content.IntentSender)>
<android.content.integrity.IAppIntegrityManager: java.lang.String getCurrentRuleSetVersion()>
<android.content.integrity.IAppIntegrityManager: java.util.List getWhitelistedRuleProviders()>
<android.content.integrity.IAppIntegrityManager: java.lang.String getCurrentRuleSetProvider()>
<com.android.internal.os.IParcelFileDescriptorFactory: android.os.ParcelFileDescriptor open(java.lang.String,int)>
<android.spay.IPaymentManager: byte[] getMeasurementFile()>
<android.spay.IPaymentManager: android.spay.PaymentTZServiceCommnInfo registerSPayFW(android.spay.PaymentTZServiceConfig)>
<android.view.IRotationWatcher: void onRotationChanged(int)>
<android.os.IHintSession: void sendHint(int)>
<android.os.IHintSession: void close()>
<android.os.IHintSession: void reportActualWorkDuration(long[],long[])>
<android.os.IHintSession: void updateTargetWorkDuration(long)>
<android.tracing.ITracingServiceProxy: void notifyTraceSessionEnded(boolean)>
<android.tracing.ITracingServiceProxy: void reportTrace(android.tracing.TraceReportParams)>
<android.view.IWindow: void updatePointerIcon(float,float)>
<android.view.IWindow: void dispatchLetterboxDirectionChanged(int)>
<android.view.IWindow: void requestScrollCapture(android.view.IScrollCaptureResponseListener)>
<android.view.IWindow: void hideInsets(int,boolean,android.view.inputmethod.ImeTracker$Token)>
<android.view.IWindow: void dispatchDragEventUpdated(android.view.DragEvent)>
<android.view.IWindow: void dispatchWallpaperOffsets(float,float,float,float,float,boolean)>
<android.view.IWindow: void dispatchWindowShown()>
<android.view.IWindow: void insetsControlChanged(android.view.InsetsState,android.view.InsetsSourceControl[])>
<android.view.IWindow: void resized(android.window.ClientWindowFrames,boolean,android.util.MergedConfiguration,android.view.InsetsState,boolean,boolean,int,int,boolean)>
<android.view.IWindow: void showInsets(int,boolean,android.view.inputmethod.ImeTracker$Token)>
<android.view.IWindow: void dispatchGetNewSurface()>
<android.view.IWindow: void dispatchSmartClipRemoteRequest(com.samsung.android.content.smartclip.SmartClipRemoteRequestInfo)>
<android.view.IWindow: void moved(int,int)>
<android.view.IWindow: void dispatchSPenGestureEvent(android.view.InputEvent[])>
<android.view.IWindow: void dispatchWallpaperCommand(java.lang.String,int,int,int,android.os.Bundle,boolean)>
<android.view.IWindow: void closeSystemDialogs(java.lang.String)>
<android.view.IWindow: void windowFocusInTaskChanged(boolean)>
<android.view.IWindow: void dispatchAppVisibility(boolean)>
<android.view.IWindow: void dispatchDragEvent(android.view.DragEvent)>
<android.view.IWindow: void requestAppKeyboardShortcuts(com.android.internal.os.IResultReceiver,int)>
<android.view.IWindow: void executeCommand(java.lang.String,java.lang.String,android.os.ParcelFileDescriptor)>
<com.samsung.android.sepunion.ISemExclusiveTaskManager: java.util.List getExclusiveTaskList(java.lang.String)>
<android.content.IContentProvider: java.lang.String getType(android.content.AttributionSource,android.net.Uri)>
<android.content.IContentProvider: android.net.Uri insert(android.content.AttributionSource,android.net.Uri,android.content.ContentValues,android.os.Bundle)>
<android.content.IContentProvider: int update(android.content.AttributionSource,android.net.Uri,android.content.ContentValues,android.os.Bundle)>
<android.content.IContentProvider: android.os.Bundle call(android.content.AttributionSource,java.lang.String,java.lang.String,java.lang.String,android.os.Bundle)>
<android.content.IContentProvider: void uncanonicalizeAsync(android.content.AttributionSource,android.net.Uri,android.os.RemoteCallback)>
<android.content.IContentProvider: android.content.ContentProviderResult[] applyBatch(android.content.AttributionSource,java.lang.String,java.util.ArrayList)>
<android.content.IContentProvider: int bulkInsert(android.content.AttributionSource,android.net.Uri,android.content.ContentValues[])>
<android.content.IContentProvider: android.net.Uri canonicalize(android.content.AttributionSource,android.net.Uri)>
<android.content.IContentProvider: boolean refresh(android.content.AttributionSource,android.net.Uri,android.os.Bundle,android.os.ICancellationSignal)>
<android.content.IContentProvider: void getTypeAnonymousAsync(android.net.Uri,android.os.RemoteCallback)>
<android.content.IContentProvider: void getTypeAsync(android.content.AttributionSource,android.net.Uri,android.os.RemoteCallback)>
<android.content.IContentProvider: android.content.res.AssetFileDescriptor openAssetFile(android.content.AttributionSource,android.net.Uri,java.lang.String,android.os.ICancellationSignal)>
<android.content.IContentProvider: android.os.ParcelFileDescriptor openFile(android.content.AttributionSource,android.net.Uri,java.lang.String,android.os.ICancellationSignal)>
<android.content.IContentProvider: void canonicalizeAsync(android.content.AttributionSource,android.net.Uri,android.os.RemoteCallback)>
<android.content.IContentProvider: int checkUriPermission(android.content.AttributionSource,android.net.Uri,int,int)>
<android.content.IContentProvider: android.content.res.AssetFileDescriptor openTypedAssetFile(android.content.AttributionSource,android.net.Uri,java.lang.String,android.os.Bundle,android.os.ICancellationSignal)>
<android.content.IContentProvider: int delete(android.content.AttributionSource,android.net.Uri,android.os.Bundle)>
<android.content.IContentProvider: android.database.Cursor query(android.content.AttributionSource,android.net.Uri,java.lang.String[],android.os.Bundle,android.os.ICancellationSignal)>
<android.content.IContentProvider: android.os.ICancellationSignal createCancellationSignal()>
<android.content.IContentProvider: android.net.Uri uncanonicalize(android.content.AttributionSource,android.net.Uri)>
<android.content.IContentProvider: java.lang.String[] getStreamTypes(android.content.AttributionSource,android.net.Uri,java.lang.String)>
<com.android.ims.internal.IImsExternalCallStateListener: void onImsExternalCallStateUpdate(java.util.List)>
<com.samsung.android.continuity.ISemContinuitySimpleListener: void onNotify(android.os.Bundle)>
<android.view.autofill.IAutoFillManagerClient: void requestShowSoftInput(android.view.autofill.AutofillId)>
<android.view.autofill.IAutoFillManagerClient: void authenticate(int,int,android.content.IntentSender,android.content.Intent,boolean)>
<android.view.autofill.IAutoFillManagerClient: void requestShowFillUi(int,android.view.autofill.AutofillId,int,int,android.graphics.Rect,android.view.autofill.IAutofillWindowPresenter)>
<android.view.autofill.IAutoFillManagerClient: void setTrackedViews(int,android.view.autofill.AutofillId[],boolean,boolean,android.view.autofill.AutofillId[],android.view.autofill.AutofillId)>
<android.view.autofill.IAutoFillManagerClient: void setSaveUiState(int,boolean)>
<android.view.autofill.IAutoFillManagerClient: void autofillContent(int,android.view.autofill.AutofillId,android.content.ClipData)>
<android.view.autofill.IAutoFillManagerClient: void notifyFillUiHidden(int,android.view.autofill.AutofillId)>
<android.view.autofill.IAutoFillManagerClient: void notifyDisableAutofill(long,android.content.ComponentName)>
<android.view.autofill.IAutoFillManagerClient: void getAugmentedAutofillClient(com.android.internal.os.IResultReceiver)>
<android.view.autofill.IAutoFillManagerClient: void notifyFillDialogTriggerIds(java.util.List)>
<android.view.autofill.IAutoFillManagerClient: void setState(int)>
<android.view.autofill.IAutoFillManagerClient: void dispatchUnhandledKey(int,android.view.autofill.AutofillId,android.view.KeyEvent)>
<android.view.autofill.IAutoFillManagerClient: void setSessionFinished(int,java.util.List)>
<android.view.autofill.IAutoFillManagerClient: void requestHideFillUi(int,android.view.autofill.AutofillId)>
<android.view.autofill.IAutoFillManagerClient: void autofill(int,java.util.List,java.util.List,boolean)>
<android.view.autofill.IAutoFillManagerClient: void notifyNoFillUi(int,android.view.autofill.AutofillId,int)>
<android.view.autofill.IAutoFillManagerClient: void startIntentSender(android.content.IntentSender,android.content.Intent)>
<android.view.autofill.IAutoFillManagerClient: void notifyFillUiShown(int,android.view.autofill.AutofillId)>
<com.samsung.android.service.HermesService.IHermesService: int hermesProvisioning()>
<com.samsung.android.service.HermesService.IHermesService: byte[] hermesUpdateCryptoFW()>
<com.samsung.android.service.HermesService.IHermesService: byte[] hermesSelftest()>
<com.samsung.android.service.HermesService.IHermesService: byte[] hermesGetSecureHWInfo()>
<com.samsung.android.service.HermesService.IHermesService: int hermesVerifyProvisioning()>
<com.samsung.android.service.HermesService.IHermesService: int hermesTerminateService()>
<com.skms.android.agent.ISkpmService: int SkpmServiceReleaseGetKeySession()>
<com.skms.android.agent.ISkpmService: int SkpmReadInjectedKeyUID(byte,byte,java.lang.String,byte[])>
<com.skms.android.agent.ISkpmService: int SkpmChangeOtaServer(java.lang.String,java.lang.String)>
<com.skms.android.agent.ISkpmService: int SkpmServiceCreateGetKeySession(byte,java.lang.String,byte[],byte)>
<com.skms.android.agent.ISkpmService: int SkpmServiceKeyInjection(byte,byte,java.lang.String,byte[],byte)>
<com.skms.android.agent.ISkpmService: int SkpmServiceInjectedKeyVerification(byte,byte,java.lang.String)>
<android.service.carrier.IApnSourceService: android.content.ContentValues[] getApns(int)>
<com.android.internal.telephony.ICarrierConfigLoader: void updateConfigForPhoneId(int,java.lang.String)>
<com.android.internal.telephony.ICarrierConfigLoader: void overrideConfig(int,android.os.PersistableBundle,boolean)>
<com.android.internal.telephony.ICarrierConfigLoader: android.os.PersistableBundle getConfigSubsetForSubIdWithFeature(int,java.lang.String,java.lang.String,java.lang.String[])>
<com.android.internal.telephony.ICarrierConfigLoader: java.lang.String getDefaultCarrierServicePackageName()>
<com.android.internal.telephony.ICarrierConfigLoader: android.os.PersistableBundle getConfigForSubId(int,java.lang.String)>
<com.android.internal.telephony.ICarrierConfigLoader: void notifyConfigChangedForSubId(int)>
<com.android.internal.telephony.ICarrierConfigLoader: android.os.PersistableBundle getConfigForSubIdWithFeature(int,java.lang.String,java.lang.String)>
<android.print.IPrintSpoolerCallbacks: void onGetPrintJobInfoResult(android.print.PrintJobInfo,int)>
<android.print.IPrintSpoolerCallbacks: void onSetPrintJobTagResult(boolean,int)>
<android.print.IPrintSpoolerCallbacks: void onCustomPrinterIconCached(int)>
<android.print.IPrintSpoolerCallbacks: void onGetPrintJobInfosResult(java.util.List,int)>
<android.print.IPrintSpoolerCallbacks: void customPrinterIconCacheCleared(int)>
<android.print.IPrintSpoolerCallbacks: void onGetCustomPrinterIconResult(android.graphics.drawable.Icon,int)>
<android.print.IPrintSpoolerCallbacks: void onSetPrintJobStateResult(boolean,int)>
<android.print.IPrintSpoolerCallbacks: void onCancelPrintJobResult(boolean,int)>
<android.hardware.biometrics.IBiometricEnabledOnKeyguardCallback: void onChanged(boolean,int)>
<android.media.IVolumeController: void displayVolumeLimiterToast()>
<android.media.IVolumeController: void setA11yMode(int)>
<android.media.IVolumeController: void dismiss()>
<android.media.IVolumeController: void displaySafeVolumeWarning(int)>
<android.media.IVolumeController: void displayCsdWarning(int,int)>
<android.media.IVolumeController: void masterMuteChanged(int)>
<android.media.IVolumeController: void setLayoutDirection(int)>
<android.media.IVolumeController: void volumeChanged(int,int)>
<android.os.IProgressListener: void onProgress(int,int,android.os.Bundle)>
<android.os.IProgressListener: void onStarted(int,android.os.Bundle)>
<android.os.IProgressListener: void onFinished(int,android.os.Bundle)>
<android.content.pm.IPackageInstallerCallback: void onSessionProgressChanged(int,float)>
<android.content.pm.IPackageInstallerCallback: void onSessionActiveChanged(int,boolean)>
<android.content.pm.IPackageInstallerCallback: void onSessionBadgingChanged(int)>
<android.content.pm.IPackageInstallerCallback: void onSessionCreated(int)>
<android.content.pm.IPackageInstallerCallback: void onSessionFinished(int,boolean)>
<android.hardware.radio.ITunerCallback: void onTrafficAnnouncement(boolean)>
<android.hardware.radio.ITunerCallback: void onAntennaState(boolean)>
<android.hardware.radio.ITunerCallback: void onParametersUpdated(java.util.Map)>
<android.hardware.radio.ITunerCallback: void onProgramListUpdated(android.hardware.radio.ProgramList$Chunk)>
<android.hardware.radio.ITunerCallback: void onConfigurationChanged(android.hardware.radio.RadioManager$BandConfig)>
<android.hardware.radio.ITunerCallback: void onTuneFailed(int,android.hardware.radio.ProgramSelector)>
<android.hardware.radio.ITunerCallback: void onError(int)>
<android.hardware.radio.ITunerCallback: void onBackgroundScanComplete()>
<android.hardware.radio.ITunerCallback: void onCurrentProgramInfoChanged(android.hardware.radio.RadioManager$ProgramInfo)>
<android.hardware.radio.ITunerCallback: void onBackgroundScanAvailabilityChange(boolean)>
<android.hardware.radio.ITunerCallback: void onEmergencyAnnouncement(boolean)>
<android.hardware.radio.ITunerCallback: void onProgramListChanged()>
<android.hardware.radio.ITunerCallback: void onConfigFlagUpdated(int,boolean)>
<android.hardware.cas.ICas: int getInterfaceVersion()>
<android.hardware.cas.ICas: void sendSessionEvent(byte[],int,int,byte[])>
<android.hardware.cas.ICas: void provision(java.lang.String)>
<android.hardware.cas.ICas: void refreshEntitlements(int,byte[])>
<android.hardware.cas.ICas: void setPrivateData(byte[])>
<android.hardware.cas.ICas: void closeSession(byte[])>
<android.hardware.cas.ICas: java.lang.String getInterfaceHash()>
<android.hardware.cas.ICas: void processEcm(byte[],byte[])>
<android.hardware.cas.ICas: void processEmm(byte[])>
<android.hardware.cas.ICas: void release()>
<android.hardware.cas.ICas: void sendEvent(int,int,byte[])>
<android.hardware.cas.ICas: byte[] openSession(int,int)>
<android.hardware.cas.ICas: byte[] openSessionDefault()>
<android.hardware.cas.ICas: void setSessionPrivateData(byte[],byte[])>
<android.media.IAudioFocusDispatcher: void dispatchAudioFocusChange(int,java.lang.String)>
<android.media.IAudioFocusDispatcher: void dispatchFocusResultFromExtPolicy(int,java.lang.String)>
<android.credentials.ISetEnabledProvidersCallback: void onError(java.lang.String,java.lang.String)>
<android.credentials.ISetEnabledProvidersCallback: void onResponse()>
<android.hardware.biometrics.IBiometricStateListener: void onBiometricAction(int)>
<android.hardware.biometrics.IBiometricStateListener: void onStateChanged(int)>
<android.hardware.biometrics.IBiometricStateListener: void onEnrollmentsChanged(int,int,boolean)>
<com.samsung.android.app.ISemExecuteManager: void unRegisterChangedCallback(java.lang.String,android.app.PendingIntent,android.os.UserHandle)>
<com.samsung.android.app.ISemExecuteManager: boolean hasShortcutHostPermission(java.lang.String)>
<com.samsung.android.app.ISemExecuteManager: android.os.ParcelFileDescriptor getShortcutIconFd(java.lang.String,java.lang.String,java.lang.String,java.lang.String,int)>
<com.samsung.android.app.ISemExecuteManager: void registerChangedCallback(java.lang.String,android.app.PendingIntent,android.os.UserHandle)>
<com.samsung.android.app.ISemExecuteManager: android.content.pm.ParceledListSlice getShortcuts(java.lang.String,java.lang.String,long,java.lang.String,java.util.List,android.content.ComponentName,int,android.os.UserHandle)>
<com.samsung.android.app.ISemExecuteManager: android.content.pm.ApplicationInfo getApplicationInfo(java.lang.String,java.lang.String,int,android.os.UserHandle)>
<com.samsung.android.app.ISemExecuteManager: java.util.List getExecutableInfos()>
<com.samsung.android.app.ISemExecuteManager: com.samsung.android.app.SemExecutableInfo getExecutableInfo(java.lang.String)>
<com.samsung.android.app.ISemExecuteManager: boolean startShortcut(java.lang.String,java.lang.String,java.lang.String,java.lang.String,android.graphics.Rect,android.os.Bundle,int)>
<android.window.IWindowContainerTransactionCallback: void onTransactionReady(int,android.view.SurfaceControl$Transaction)>
<android.hardware.thermal.IThermal: void registerThermalChangedCallbackWithType(android.hardware.thermal.IThermalChangedCallback,int)>
<android.hardware.thermal.IThermal: android.hardware.thermal.CoolingDevice[] getCoolingDevicesWithType(int)>
<android.hardware.thermal.IThermal: android.hardware.thermal.Temperature[] getTemperaturesWithType(int)>
<android.hardware.thermal.IThermal: android.hardware.thermal.TemperatureThreshold[] getTemperatureThresholds()>
<android.hardware.thermal.IThermal: android.hardware.thermal.CoolingDevice[] getCoolingDevices()>
<android.hardware.thermal.IThermal: void registerThermalChangedCallback(android.hardware.thermal.IThermalChangedCallback)>
<android.hardware.thermal.IThermal: int getInterfaceVersion()>
<android.hardware.thermal.IThermal: android.hardware.thermal.TemperatureThreshold[] getTemperatureThresholdsWithType(int)>
<android.hardware.thermal.IThermal: void unregisterThermalChangedCallback(android.hardware.thermal.IThermalChangedCallback)>
<android.hardware.thermal.IThermal: java.lang.String getInterfaceHash()>
<android.hardware.thermal.IThermal: android.hardware.thermal.Temperature[] getTemperatures()>
<android.gsi.IImageService: boolean backingImageExists(java.lang.String)>
<android.gsi.IImageService: boolean isImageMapped(java.lang.String)>
<android.gsi.IImageService: void removeDisabledImages()>
<android.gsi.IImageService: java.util.List getAllBackingImages()>
<android.gsi.IImageService: void createBackingImage(java.lang.String,long,int,android.gsi.IProgressCallback)>
<android.gsi.IImageService: void disableImage(java.lang.String)>
<android.gsi.IImageService: void unmapImageDevice(java.lang.String)>
<android.gsi.IImageService: void mapImageDevice(java.lang.String,int,android.gsi.MappedImage)>
<android.gsi.IImageService: void deleteBackingImage(java.lang.String)>
<android.gsi.IImageService: void zeroFillNewImage(java.lang.String,long)>
<android.gsi.IImageService: void removeAllImages()>
<android.gsi.IImageService: boolean isImageDisabled(java.lang.String)>
<android.gsi.IImageService: int getAvbPublicKey(java.lang.String,android.gsi.AvbPublicKey)>
<android.gsi.IImageService: java.lang.String getMappedImageDevice(java.lang.String)>
<android.media.tv.ITvInputSession: void removeBroadcastInfo(int)>
<android.media.tv.ITvInputSession: void resumeRecording(android.os.Bundle)>
<android.media.tv.ITvInputSession: void notifyTvMessage(int,android.os.Bundle)>
<android.media.tv.ITvInputSession: void setInteractiveAppNotificationEnabled(boolean)>
<android.media.tv.ITvInputSession: void setMain(boolean)>
<android.media.tv.ITvInputSession: void timeShiftSeekTo(long)>
<android.media.tv.ITvInputSession: void pauseRecording(android.os.Bundle)>
<android.media.tv.ITvInputSession: void setCaptionEnabled(boolean)>
<android.media.tv.ITvInputSession: void timeShiftPause()>
<android.media.tv.ITvInputSession: void dispatchSurfaceChanged(int,int,int)>
<android.media.tv.ITvInputSession: void notifyAdBufferReady(android.media.tv.AdBuffer)>
<android.media.tv.ITvInputSession: void selectAudioPresentation(int,int)>
<android.media.tv.ITvInputSession: void setTvMessageEnabled(int,boolean)>
<android.media.tv.ITvInputSession: void release()>
<android.media.tv.ITvInputSession: void appPrivateCommand(java.lang.String,android.os.Bundle)>
<android.media.tv.ITvInputSession: void removeOverlayView()>
<android.media.tv.ITvInputSession: void relayoutOverlayView(android.graphics.Rect)>
<android.media.tv.ITvInputSession: void createOverlayView(android.os.IBinder,android.graphics.Rect)>
<android.media.tv.ITvInputSession: void timeShiftEnablePositionTracking(boolean)>
<android.media.tv.ITvInputSession: void stopRecording()>
<android.media.tv.ITvInputSession: void timeShiftPlay(android.net.Uri)>
<android.media.tv.ITvInputSession: void timeShiftSetMode(int)>
<android.media.tv.ITvInputSession: void selectTrack(int,java.lang.String)>
<android.media.tv.ITvInputSession: void timeShiftResume()>
<android.media.tv.ITvInputSession: void setSurface(android.view.Surface)>
<android.media.tv.ITvInputSession: void setVolume(float)>
<android.media.tv.ITvInputSession: void unblockContent(java.lang.String)>
<android.media.tv.ITvInputSession: void requestAd(android.media.tv.AdRequest)>
<android.media.tv.ITvInputSession: void tune(android.net.Uri,android.os.Bundle)>
<android.media.tv.ITvInputSession: void timeShiftSetPlaybackParams(android.media.PlaybackParams)>
<android.media.tv.ITvInputSession: void startRecording(android.net.Uri,android.os.Bundle)>
<android.media.tv.ITvInputSession: void requestBroadcastInfo(android.media.tv.BroadcastInfoRequest)>
<com.android.ims.internal.IImsVideoCallCallback: void changePeerDimensions(int,int)>
<com.android.ims.internal.IImsVideoCallCallback: void changeCameraCapabilities(android.telecom.VideoProfile$CameraCapabilities)>
<com.android.ims.internal.IImsVideoCallCallback: void changeCallDataUsage(long)>
<com.android.ims.internal.IImsVideoCallCallback: void changeVideoQuality(int)>
<com.android.ims.internal.IImsVideoCallCallback: void receiveSessionModifyResponse(int,android.telecom.VideoProfile,android.telecom.VideoProfile)>
<com.android.ims.internal.IImsVideoCallCallback: void handleCallSessionEvent(int)>
<com.android.ims.internal.IImsVideoCallCallback: void receiveSessionModifyRequest(android.telecom.VideoProfile)>
<android.hardware.gnss.IGnssAntennaInfoCallback: void gnssAntennaInfoCb(android.hardware.gnss.IGnssAntennaInfoCallback$GnssAntennaInfo[])>
<android.hardware.gnss.IGnssAntennaInfoCallback: java.lang.String getInterfaceHash()>
<android.hardware.gnss.IGnssAntennaInfoCallback: int getInterfaceVersion()>
<android.media.ISpatializerHeadTrackingCallback: void onHeadToSoundStagePoseUpdated(float[])>
<android.media.ISpatializerHeadTrackingCallback: void onHeadTrackingModeChanged(byte)>
<com.samsung.android.biometrics.ISemBiometricSysUiDisplayStateCallback: void onStart(int,int,int)>
<com.samsung.android.biometrics.ISemBiometricSysUiDisplayStateCallback: void onFinish(int,int,int)>
<android.app.backup.IFullBackupRestoreObserver: void onRestorePackage(java.lang.String)>
<android.app.backup.IFullBackupRestoreObserver: void onStartRestore()>
<android.app.backup.IFullBackupRestoreObserver: void onTimeout()>
<android.app.backup.IFullBackupRestoreObserver: void onBackupPackage(java.lang.String)>
<android.app.backup.IFullBackupRestoreObserver: void onEndBackup()>
<android.app.backup.IFullBackupRestoreObserver: void onEndRestore()>
<android.app.backup.IFullBackupRestoreObserver: void onStartBackup()>
<com.samsung.android.gamesdk.IGameSDKListener: void onRefreshRateChanged()>
<com.samsung.android.gamesdk.IGameSDKListener: void onReleasedByTimeout()>
<com.samsung.android.gamesdk.IGameSDKListener: void onHighTempWarning(int)>
<com.samsung.android.gamesdk.IGameSDKListener: void onReleasedCpuBoost()>
<com.samsung.android.gamesdk.IGameSDKListener: void onReleasedGpuBoost()>
<com.samsung.android.knox.IContainerService: android.os.Bundle onMessage(java.lang.String,android.os.Bundle)>
<android.service.translation.ITranslationService: void onDisconnected()>
<android.service.translation.ITranslationService: void onCreateTranslationSession(android.view.translation.TranslationContext,int,com.android.internal.os.IResultReceiver)>
<android.service.translation.ITranslationService: void onTranslationCapabilitiesRequest(int,int,android.os.ResultReceiver)>
<android.service.translation.ITranslationService: void onConnected(android.os.IBinder)>
<android.speech.IModelDownloadListener: void onScheduled()>
<android.speech.IModelDownloadListener: void onProgress(int)>
<android.speech.IModelDownloadListener: void onSuccess()>
<android.speech.IModelDownloadListener: void onError(int)>
<com.android.internal.textservice.ISpellCheckerSession: void onClose()>
<com.android.internal.textservice.ISpellCheckerSession: void onGetSuggestionsMultiple(android.view.textservice.TextInfo[],int,boolean)>
<com.android.internal.textservice.ISpellCheckerSession: void onGetSentenceSuggestionsMultiple(android.view.textservice.TextInfo[],int)>
<com.android.internal.textservice.ISpellCheckerSession: void onCancel()>
<android.app.slice.ISliceManager: android.app.slice.SliceSpec[] getPinnedSpecs(android.net.Uri,java.lang.String)>
<android.app.slice.ISliceManager: void pinSlice(java.lang.String,android.net.Uri,android.app.slice.SliceSpec[],android.os.IBinder)>
<android.app.slice.ISliceManager: void applyRestore(byte[],int)>
<android.app.slice.ISliceManager: void grantSlicePermission(java.lang.String,java.lang.String,android.net.Uri)>
<android.app.slice.ISliceManager: void grantPermissionFromUser(android.net.Uri,java.lang.String,java.lang.String,boolean)>
<android.app.slice.ISliceManager: android.net.Uri[] getPinnedSlices(java.lang.String)>
<android.app.slice.ISliceManager: int checkSlicePermission(android.net.Uri,java.lang.String,int,int,java.lang.String[])>
<android.app.slice.ISliceManager: boolean hasSliceAccess(java.lang.String)>
<android.app.slice.ISliceManager: void unpinSlice(java.lang.String,android.net.Uri,android.os.IBinder)>
<android.app.slice.ISliceManager: byte[] getBackupPayload(int)>
<android.app.slice.ISliceManager: void revokeSlicePermission(java.lang.String,java.lang.String,android.net.Uri)>
<com.samsung.android.media.fmradio.internal.IFMEventListener: void onRadioDataSystemDisabled()>
<com.samsung.android.media.fmradio.internal.IFMEventListener: void onScanStarted()>
<com.samsung.android.media.fmradio.internal.IFMEventListener: void onProgrammeIdentificationExtendedCountryCodesReceived(int,int)>
<com.samsung.android.media.fmradio.internal.IFMEventListener: void onRadioTextPlusReceived(int,int,int,int,int,int)>
<com.samsung.android.media.fmradio.internal.IFMEventListener: void onScanFinished(long[])>
<com.samsung.android.media.fmradio.internal.IFMEventListener: void onChannelFound(long)>
<com.samsung.android.media.fmradio.internal.IFMEventListener: void onHeadsetDisconnected()>
<com.samsung.android.media.fmradio.internal.IFMEventListener: void onRadioEnabled()>
<com.samsung.android.media.fmradio.internal.IFMEventListener: void onAlternateFrequencyReceived(long)>
<com.samsung.android.media.fmradio.internal.IFMEventListener: void onRadioDataSystemEnabled()>
<com.samsung.android.media.fmradio.internal.IFMEventListener: void onScanStopped(long[])>
<com.samsung.android.media.fmradio.internal.IFMEventListener: void onAlternateFrequencyStarted()>
<com.samsung.android.media.fmradio.internal.IFMEventListener: void onRadioDataSystemReceived(long,java.lang.String,java.lang.String)>
<com.samsung.android.media.fmradio.internal.IFMEventListener: void onHeadsetConnected()>
<com.samsung.android.media.fmradio.internal.IFMEventListener: void onTuned(long)>
<com.samsung.android.media.fmradio.internal.IFMEventListener: void onRecordingFinished()>
<com.samsung.android.media.fmradio.internal.IFMEventListener: void onVolumeLocked()>
<com.samsung.android.media.fmradio.internal.IFMEventListener: void onRadioDisabled(int)>
<android.companion.virtual.audio.IAudioRoutingCallback: void onAppsNeedingAudioRoutingChanged(int[])>
<android.media.session.IOnVolumeKeyLongPressListener: void onVolumeKeyLongPress(android.view.KeyEvent)>
<android.media.soundtrigger_middleware.ISoundTriggerModule: android.os.IBinder startRecognition(int,android.media.soundtrigger.RecognitionConfig)>
<android.media.soundtrigger_middleware.ISoundTriggerModule: android.media.soundtrigger.ModelParameterRange queryModelParameterSupport(int,int)>
<android.media.soundtrigger_middleware.ISoundTriggerModule: int getModelParameter(int,int)>
<android.media.soundtrigger_middleware.ISoundTriggerModule: void setModelParameter(int,int,int)>
<android.media.soundtrigger_middleware.ISoundTriggerModule: void unloadModel(int)>
<android.media.soundtrigger_middleware.ISoundTriggerModule: void detach()>
<android.media.soundtrigger_middleware.ISoundTriggerModule: void forceRecognitionEvent(int)>
<android.media.soundtrigger_middleware.ISoundTriggerModule: void stopRecognition(int)>
<android.media.soundtrigger_middleware.ISoundTriggerModule: int loadModel(android.media.soundtrigger.SoundModel)>
<android.media.soundtrigger_middleware.ISoundTriggerModule: int loadPhraseModel(android.media.soundtrigger.PhraseSoundModel)>
<android.view.IInputFilter: void filterInputEvent(android.view.InputEvent,int)>
<android.view.IInputFilter: void install(android.view.IInputFilterHost)>
<android.view.IInputFilter: void uninstall()>
<android.os.IIdmap2: java.lang.String createIdmap(java.lang.String,java.lang.String,java.lang.String,int,boolean,int)>
<android.os.IIdmap2: boolean verifyIdmap(java.lang.String,java.lang.String,java.lang.String,int,boolean,int)>
<android.os.IIdmap2: int acquireFabricatedOverlayIterator()>
<android.os.IIdmap2: android.os.FabricatedOverlayInfo createFabricatedOverlay(android.os.FabricatedOverlayInternal)>
<android.os.IIdmap2: boolean deleteFabricatedOverlay(java.lang.String)>
<android.os.IIdmap2: java.lang.String dumpIdmap(java.lang.String)>
<android.os.IIdmap2: java.lang.String getTargetPath(java.lang.String)>
<android.os.IIdmap2: void releaseFabricatedOverlayIterator(int)>
<android.os.IIdmap2: java.lang.String getIdmapPath(java.lang.String,int)>
<android.os.IIdmap2: boolean removeIdmap(java.lang.String,int)>
<android.os.IIdmap2: java.util.List nextFabricatedOverlayInfos(int)>
<com.android.ims.internal.ISecImsMmTelEventListener: void onIncomingCall(int,android.os.Bundle)>
<com.android.ims.internal.ISecImsMmTelEventListener: void onCdpnInfo(java.lang.String,int)>
<com.samsung.android.knox.dar.ddar.proxy.IProxyAgent: boolean terminateSecureSession(int,java.lang.String,java.lang.String)>
<com.samsung.android.knox.dar.ddar.proxy.IProxyAgent: java.lang.String initializeSecureSession(int,java.lang.String,java.lang.String,java.lang.String)>
<com.samsung.android.knox.dar.ddar.proxy.IProxyAgent: void onAgentReconnected()>
<com.samsung.android.knox.dar.ddar.proxy.IProxyAgent: android.os.Bundle onMessage(int,java.lang.String,java.lang.String,android.os.Bundle)>
<android.media.IRingtonePlayer: void stopAsync()>
<android.media.IRingtonePlayer: android.os.ParcelFileDescriptor openRingtone(android.net.Uri)>
<android.media.IRingtonePlayer: void play(android.os.IBinder,android.net.Uri,android.media.AudioAttributes,float,boolean)>
<android.media.IRingtonePlayer: java.lang.String getTitle(android.net.Uri)>
<android.media.IRingtonePlayer: void fadeinRingtone(android.os.IBinder)>
<android.media.IRingtonePlayer: void fadeoutRingtone(android.os.IBinder,int,float)>
<android.media.IRingtonePlayer: void playAsync(android.net.Uri,android.os.UserHandle,boolean,android.media.AudioAttributes)>
<android.media.IRingtonePlayer: void playWithVolumeShaping(android.os.IBinder,android.net.Uri,android.media.AudioAttributes,float,boolean,android.media.VolumeShaper$Configuration)>
<android.media.IRingtonePlayer: void stop(android.os.IBinder)>
<android.media.IRingtonePlayer: boolean isPlaying(android.os.IBinder)>
<android.media.IRingtonePlayer: android.os.IBinder setOnCompletionListener(android.app.INotificationPlayerOnCompletionListener)>
<android.media.IRingtonePlayer: void setPlaybackProperties(android.os.IBinder,float,boolean,boolean)>
<android.security.rkp.IGetRegistrationCallback: void onCancel()>
<android.security.rkp.IGetRegistrationCallback: void onSuccess(android.security.rkp.IRegistration)>
<android.security.rkp.IGetRegistrationCallback: void onError(java.lang.String)>
<android.security.legacykeystore.ILegacyKeystore: void put(java.lang.String,int,byte[])>
<android.security.legacykeystore.ILegacyKeystore: void remove(java.lang.String,int)>
<android.security.legacykeystore.ILegacyKeystore: byte[] get(java.lang.String,int)>
<android.security.legacykeystore.ILegacyKeystore: java.lang.String[] list(java.lang.String,int)>
<android.content.ISyncStatusObserver: void onStatusChanged(int)>
<android.hardware.radio.sim.IRadioSimResponse: void supplySimDepersonalizationResponse(android.hardware.radio.RadioResponseInfo,int,int)>
<android.hardware.radio.sim.IRadioSimResponse: void sendEnvelopeWithStatusResponse(android.hardware.radio.RadioResponseInfo,android.hardware.radio.sim.IccIoResult)>
<android.hardware.radio.sim.IRadioSimResponse: void setFacilityLockForAppResponse(android.hardware.radio.RadioResponseInfo,int)>
<android.hardware.radio.sim.IRadioSimResponse: void requestIccSimAuthenticationResponse(android.hardware.radio.RadioResponseInfo,android.hardware.radio.sim.IccIoResult)>
<android.hardware.radio.sim.IRadioSimResponse: void updateSimPhonebookRecordsResponse(android.hardware.radio.RadioResponseInfo,int)>
<android.hardware.radio.sim.IRadioSimResponse: void iccIoForAppResponse(android.hardware.radio.RadioResponseInfo,android.hardware.radio.sim.IccIoResult)>
<android.hardware.radio.sim.IRadioSimResponse: void getSimPhonebookRecordsResponse(android.hardware.radio.RadioResponseInfo)>
<android.hardware.radio.sim.IRadioSimResponse: void sendTerminalResponseToSimResponse(android.hardware.radio.RadioResponseInfo)>
<android.hardware.radio.sim.IRadioSimResponse: void getFacilityLockForAppResponse(android.hardware.radio.RadioResponseInfo,int)>
<android.hardware.radio.sim.IRadioSimResponse: void setSimCardPowerResponse(android.hardware.radio.RadioResponseInfo)>
<android.hardware.radio.sim.IRadioSimResponse: void iccCloseLogicalChannelResponse(android.hardware.radio.RadioResponseInfo)>
<android.hardware.radio.sim.IRadioSimResponse: void sendEnvelopeResponse(android.hardware.radio.RadioResponseInfo,java.lang.String)>
<android.hardware.radio.sim.IRadioSimResponse: void reportStkServiceIsRunningResponse(android.hardware.radio.RadioResponseInfo)>
<android.hardware.radio.sim.IRadioSimResponse: void getImsiForAppResponse(android.hardware.radio.RadioResponseInfo,java.lang.String)>
<android.hardware.radio.sim.IRadioSimResponse: void supplyIccPinForAppResponse(android.hardware.radio.RadioResponseInfo,int)>
<android.hardware.radio.sim.IRadioSimResponse: void setCarrierInfoForImsiEncryptionResponse(android.hardware.radio.RadioResponseInfo)>
<android.hardware.radio.sim.IRadioSimResponse: void changeIccPinForAppResponse(android.hardware.radio.RadioResponseInfo,int)>
<android.hardware.radio.sim.IRadioSimResponse: void getCdmaSubscriptionSourceResponse(android.hardware.radio.RadioResponseInfo,int)>
<android.hardware.radio.sim.IRadioSimResponse: int getInterfaceVersion()>
<android.hardware.radio.sim.IRadioSimResponse: void setAllowedCarriersResponse(android.hardware.radio.RadioResponseInfo)>
<android.hardware.radio.sim.IRadioSimResponse: void getAllowedCarriersResponse(android.hardware.radio.RadioResponseInfo,android.hardware.radio.sim.CarrierRestrictions,int)>
<android.hardware.radio.sim.IRadioSimResponse: void getIccCardStatusResponse(android.hardware.radio.RadioResponseInfo,android.hardware.radio.sim.CardStatus)>
<android.hardware.radio.sim.IRadioSimResponse: void iccTransmitApduLogicalChannelResponse(android.hardware.radio.RadioResponseInfo,android.hardware.radio.sim.IccIoResult)>
<android.hardware.radio.sim.IRadioSimResponse: void iccTransmitApduBasicChannelResponse(android.hardware.radio.RadioResponseInfo,android.hardware.radio.sim.IccIoResult)>
<android.hardware.radio.sim.IRadioSimResponse: void acknowledgeRequest(int)>
<android.hardware.radio.sim.IRadioSimResponse: void supplyIccPuk2ForAppResponse(android.hardware.radio.RadioResponseInfo,int)>
<android.hardware.radio.sim.IRadioSimResponse: void getCdmaSubscriptionResponse(android.hardware.radio.RadioResponseInfo,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
<android.hardware.radio.sim.IRadioSimResponse: void iccOpenLogicalChannelResponse(android.hardware.radio.RadioResponseInfo,int,byte[])>
<android.hardware.radio.sim.IRadioSimResponse: void iccCloseLogicalChannelWithSessionInfoResponse(android.hardware.radio.RadioResponseInfo)>
<android.hardware.radio.sim.IRadioSimResponse: java.lang.String getInterfaceHash()>
<android.hardware.radio.sim.IRadioSimResponse: void changeIccPin2ForAppResponse(android.hardware.radio.RadioResponseInfo,int)>
<android.hardware.radio.sim.IRadioSimResponse: void supplyIccPukForAppResponse(android.hardware.radio.RadioResponseInfo,int)>
<android.hardware.radio.sim.IRadioSimResponse: void enableUiccApplicationsResponse(android.hardware.radio.RadioResponseInfo)>
<android.hardware.radio.sim.IRadioSimResponse: void areUiccApplicationsEnabledResponse(android.hardware.radio.RadioResponseInfo,boolean)>
<android.hardware.radio.sim.IRadioSimResponse: void setUiccSubscriptionResponse(android.hardware.radio.RadioResponseInfo)>
<android.hardware.radio.sim.IRadioSimResponse: void supplyIccPin2ForAppResponse(android.hardware.radio.RadioResponseInfo,int)>
<android.hardware.radio.sim.IRadioSimResponse: void getSimPhonebookCapacityResponse(android.hardware.radio.RadioResponseInfo,android.hardware.radio.sim.PhonebookCapacity)>
<android.hardware.radio.sim.IRadioSimResponse: void setCdmaSubscriptionSourceResponse(android.hardware.radio.RadioResponseInfo)>
<android.accessibilityservice.IAccessibilityServiceClient: void onAccessibilityEvent(android.view.accessibility.AccessibilityEvent,boolean)>
<android.accessibilityservice.IAccessibilityServiceClient: void onMotionEvent(android.view.MotionEvent)>
<android.accessibilityservice.IAccessibilityServiceClient: void onMagnificationChanged(int,android.graphics.Region,android.accessibilityservice.MagnificationConfig)>
<android.accessibilityservice.IAccessibilityServiceClient: void unbindInput()>
<android.accessibilityservice.IAccessibilityServiceClient: void onSoftKeyboardShowModeChanged(int)>
<android.accessibilityservice.IAccessibilityServiceClient: void onPerformGestureResult(int,boolean)>
<android.accessibilityservice.IAccessibilityServiceClient: void onAccessibilityButtonAvailabilityChanged(boolean)>
<android.accessibilityservice.IAccessibilityServiceClient: void onTouchStateChanged(int,int)>
<android.accessibilityservice.IAccessibilityServiceClient: void createImeSession(com.android.internal.inputmethod.IAccessibilityInputMethodSessionCallback)>
<android.accessibilityservice.IAccessibilityServiceClient: void onGesture(android.accessibilityservice.AccessibilityGestureEvent)>
<android.accessibilityservice.IAccessibilityServiceClient: void onInterrupt()>
<android.accessibilityservice.IAccessibilityServiceClient: void onKeyEvent(android.view.KeyEvent,int)>
<android.accessibilityservice.IAccessibilityServiceClient: void bindInput()>
<android.accessibilityservice.IAccessibilityServiceClient: void onFingerprintCapturingGesturesChanged(boolean)>
<android.accessibilityservice.IAccessibilityServiceClient: void onSystemActionsChanged()>
<android.accessibilityservice.IAccessibilityServiceClient: void init(android.accessibilityservice.IAccessibilityServiceConnection,int,android.os.IBinder)>
<android.accessibilityservice.IAccessibilityServiceClient: void onAccessibilityButtonClicked(int)>
<android.accessibilityservice.IAccessibilityServiceClient: void startInput(com.android.internal.inputmethod.IRemoteAccessibilityInputConnection,android.view.inputmethod.EditorInfo,boolean)>
<android.accessibilityservice.IAccessibilityServiceClient: void clearAccessibilityCache()>
<android.accessibilityservice.IAccessibilityServiceClient: void onFingerprintGesture(int)>
<android.accessibilityservice.IAccessibilityServiceClient: void setImeSessionEnabled(com.android.internal.inputmethod.IAccessibilityInputMethodSession,boolean)>
<android.media.session.ISession2TokensListener: void onSession2TokensChanged(java.util.List)>
<android.gsi.IGsiService: boolean isGsiRunning()>
<android.gsi.IGsiService: boolean setGsiAshmem(android.os.ParcelFileDescriptor,long)>
<android.gsi.IGsiService: java.lang.String getActiveDsuSlot()>
<android.gsi.IGsiService: void enableGsiAsync(boolean,java.lang.String,android.gsi.IGsiServiceCallback)>
<android.gsi.IGsiService: boolean disableGsi()>
<android.gsi.IGsiService: int createPartition(java.lang.String,long,boolean)>
<android.gsi.IGsiService: boolean removeGsi()>
<android.gsi.IGsiService: int closeInstall()>
<android.gsi.IGsiService: java.lang.String getInstalledGsiImageDir()>
<android.gsi.IGsiService: android.gsi.IImageService openImageService(java.lang.String)>
<android.gsi.IGsiService: java.util.List getInstalledDsuSlots()>
<android.gsi.IGsiService: void removeGsiAsync(android.gsi.IGsiServiceCallback)>
<android.gsi.IGsiService: int closePartition()>
<android.gsi.IGsiService: int zeroPartition(java.lang.String)>
<android.gsi.IGsiService: int enableGsi(boolean,java.lang.String)>
<android.gsi.IGsiService: boolean commitGsiChunkFromAshmem(long)>
<android.gsi.IGsiService: int getAvbPublicKey(android.gsi.AvbPublicKey)>
<android.gsi.IGsiService: boolean cancelGsiInstall()>
<android.gsi.IGsiService: android.gsi.GsiProgress getInstallProgress()>
<android.gsi.IGsiService: boolean isGsiInstalled()>
<android.gsi.IGsiService: boolean isGsiInstallInProgress()>
<android.gsi.IGsiService: boolean commitGsiChunkFromStream(android.os.ParcelFileDescriptor,long)>
<android.gsi.IGsiService: int openInstall(java.lang.String)>
<android.gsi.IGsiService: java.lang.String dumpDeviceMapperDevices()>
<android.gsi.IGsiService: boolean isGsiEnabled()>
<android.gsi.IGsiService: long suggestScratchSize()>
<android.window.ITransitionMetricsReporter: void reportAnimationStart(android.os.IBinder,long)>
<android.security.authorization.IKeystoreAuthorization: void addAuthToken(android.hardware.security.keymint.HardwareAuthToken)>
<android.security.authorization.IKeystoreAuthorization: void onLockScreenEvent(int,int,byte[],long[])>
<android.security.authorization.IKeystoreAuthorization: android.security.authorization.AuthorizationTokens getAuthTokensForCredStore(long,long,long)>
<com.samsung.android.pass.IPassChecker: java.lang.String hasPermission(java.lang.String)>
<android.hardware.display.IVirtualDisplayCallback: void onStopped()>
<android.hardware.display.IVirtualDisplayCallback: void onResumed()>
<android.hardware.display.IVirtualDisplayCallback: void onPaused()>
<android.app.IActivityPendingResult: boolean sendResult(int,java.lang.String,android.os.Bundle)>
<android.accounts.IAccountManagerResponse: void onError(int,java.lang.String)>
<android.accounts.IAccountManagerResponse: void onResult(android.os.Bundle)>
<android.hardware.display.IDisplayManagerCallback: void onDisplayVolumeEvent(int,android.os.Bundle)>
<android.hardware.display.IDisplayManagerCallback: void onDeviceEvent(android.os.Bundle,int)>
<android.hardware.display.IDisplayManagerCallback: void onWifiDisplayParameterEvent(int,java.util.List)>
<android.hardware.display.IDisplayManagerCallback: void onDisplayEvent(int,int)>
<android.hardware.display.IDisplayManagerCallback: void onDisplayVolumeKeyEvent(int)>
<android.app.admin.IKeyguardCallback: void onDismiss()>
<android.app.admin.IKeyguardCallback: void onRemoteContentReady(android.view.SurfaceControlViewHost$SurfacePackage)>
<android.hardware.camera2.ICameraOfflineSession: void disconnect()>
<vendor.samsung.hardware.radio.network.ISehRadioNetwork: void selectCsgManual(int,vendor.samsung.hardware.radio.network.SehCsgInfo)>
<vendor.samsung.hardware.radio.network.ISehRadioNetwork: void getCsgList(int)>
<vendor.samsung.hardware.radio.network.ISehRadioNetwork: void setImsCallList(int,vendor.samsung.hardware.radio.network.SehImsCall[])>
<vendor.samsung.hardware.radio.network.ISehRadioNetwork: void getAvailableNetworks(int)>
<vendor.samsung.hardware.radio.network.ISehRadioNetwork: java.lang.String getInterfaceHash()>
<vendor.samsung.hardware.radio.network.ISehRadioNetwork: void sendRequestStrings(int,java.lang.String[])>
<vendor.samsung.hardware.radio.network.ISehRadioNetwork: void setNrMode(int,int,boolean)>
<vendor.samsung.hardware.radio.network.ISehRadioNetwork: void emergencyControl(int,int)>
<vendor.samsung.hardware.radio.network.ISehRadioNetwork: void getRoamingNetworkInfoViaBLE(int,byte,java.lang.String)>
<vendor.samsung.hardware.radio.network.ISehRadioNetwork: void sendEncodedUssd(int,vendor.samsung.hardware.radio.network.SehEncodedUssd)>
<vendor.samsung.hardware.radio.network.ISehRadioNetwork: void getNrIconType(int)>
<vendor.samsung.hardware.radio.network.ISehRadioNetwork: void getVendorSpecificConfiguration(int)>
<vendor.samsung.hardware.radio.network.ISehRadioNetwork: void setDisable2g(int,int)>
<vendor.samsung.hardware.radio.network.ISehRadioNetwork: void sendRequestRaw(int,byte[])>
<vendor.samsung.hardware.radio.network.ISehRadioNetwork: void getDisable2g(int)>
<vendor.samsung.hardware.radio.network.ISehRadioNetwork: void getPreferredNetworkList(int)>
<vendor.samsung.hardware.radio.network.ISehRadioNetwork: void getNrMode(int)>
<vendor.samsung.hardware.radio.network.ISehRadioNetwork: void getCnap(int)>
<vendor.samsung.hardware.radio.network.ISehRadioNetwork: void setRoamingNetworkInfoViaBLE(int,vendor.samsung.hardware.radio.network.SehRoamingNetworkInfo[])>
<vendor.samsung.hardware.radio.network.ISehRadioNetwork: void emergencySearch(int)>
<vendor.samsung.hardware.radio.network.ISehRadioNetwork: void setPreferredNetworkList(int,vendor.samsung.hardware.radio.network.SehPreferredNetworkInfo)>
<vendor.samsung.hardware.radio.network.ISehRadioNetwork: int getInterfaceVersion()>
<vendor.samsung.hardware.radio.network.ISehRadioNetwork: void setVendorSpecificConfiguration(int,vendor.samsung.hardware.radio.network.SehVendorConfiguration[])>
<vendor.samsung.hardware.radio.network.ISehRadioNetwork: void setCurrentNetworkInfoViaBLE(int,vendor.samsung.hardware.radio.network.SehCurrentNetworkInfo[])>
<vendor.samsung.hardware.radio.network.ISehRadioNetwork: void setResponseFunctions(vendor.samsung.hardware.radio.network.ISehRadioNetworkResponse,vendor.samsung.hardware.radio.network.ISehRadioNetworkIndication)>
<vendor.samsung.hardware.radio.network.ISehRadioNetwork: void setScanResultViaBLE(int,byte,byte)>
<android.blockchain.ITAController: android.blockchain.TACommandResponse processTACommand(android.blockchain.TACommandRequest)>
<android.blockchain.ITAController: boolean loadTA(android.os.ParcelFileDescriptor,long,long)>
<android.blockchain.ITAController: void unloadTA()>
<com.android.internal.telephony.ITransportSelectorResultCallback: void onCompleted(com.android.internal.telephony.IWwanSelectorCallback)>
<android.service.resolver.IResolverRankerResult: void sendResult(java.util.List)>
<android.os.ISchedulingPolicyService: int requestPriority(int,int,int,boolean)>
<android.os.ISchedulingPolicyService: int requestCpusetBoost(boolean,android.os.IBinder)>
<android.net.INetworkPolicyListener: void onBlockedReasonChanged(int,int,int)>
<android.net.INetworkPolicyListener: void onRestrictBackgroundChanged(boolean)>
<android.net.INetworkPolicyListener: void onUidPoliciesChanged(int,int)>
<android.net.INetworkPolicyListener: void onMeteredIfacesChanged(java.lang.String[])>
<android.net.INetworkPolicyListener: void onSubscriptionPlansChanged(int,android.telephony.SubscriptionPlan[])>
<android.net.INetworkPolicyListener: void onUidRulesChanged(int,int)>
<android.net.INetworkPolicyListener: void onSubscriptionOverride(int,int,int,int[])>
<android.media.tv.ITvInputHardwareCallback: void onStreamConfigChanged(android.media.tv.TvStreamConfig[])>
<android.media.tv.ITvInputHardwareCallback: void onReleased()>
<android.media.metrics.IMediaMetricsManager: java.lang.String getPlaybackSessionId(int)>
<android.media.metrics.IMediaMetricsManager: java.lang.String getTranscodingSessionId(int)>
<android.media.metrics.IMediaMetricsManager: void reportTrackChangeEvent(java.lang.String,android.media.metrics.TrackChangeEvent,int)>
<android.media.metrics.IMediaMetricsManager: void reportPlaybackMetrics(java.lang.String,android.media.metrics.PlaybackMetrics,int)>
<android.media.metrics.IMediaMetricsManager: void reportPlaybackStateEvent(java.lang.String,android.media.metrics.PlaybackStateEvent,int)>
<android.media.metrics.IMediaMetricsManager: java.lang.String getBundleSessionId(int)>
<android.media.metrics.IMediaMetricsManager: void reportBundleMetrics(java.lang.String,android.os.PersistableBundle,int)>
<android.media.metrics.IMediaMetricsManager: java.lang.String getEditingSessionId(int)>
<android.media.metrics.IMediaMetricsManager: java.lang.String getRecordingSessionId(int)>
<android.media.metrics.IMediaMetricsManager: void reportNetworkEvent(java.lang.String,android.media.metrics.NetworkEvent,int)>
<android.media.metrics.IMediaMetricsManager: void reportPlaybackErrorEvent(java.lang.String,android.media.metrics.PlaybackErrorEvent,int)>
<android.media.metrics.IMediaMetricsManager: void releaseSessionId(java.lang.String,int)>
<com.samsung.android.app.ISemDualAppManager: boolean isInstalledWhitelistedPackage(java.lang.String)>
<com.samsung.android.app.ISemDualAppManager: java.lang.String[] getAllWhitelistedPackages()>
<com.samsung.android.app.ISemDualAppManager: android.os.Bundle updateDualAppData(java.lang.String,int,android.os.Bundle)>
<com.samsung.android.app.ISemDualAppManager: java.util.List getAllInstalledWhitelistedPackages()>
<android.hardware.tv.tuner.IFilter: void close()>
<android.hardware.tv.tuner.IFilter: void releaseAvHandle(android.hardware.common.NativeHandle,long)>
<android.hardware.tv.tuner.IFilter: long getId64Bit()>
<android.hardware.tv.tuner.IFilter: int getInterfaceVersion()>
<android.hardware.tv.tuner.IFilter: void setDataSource(android.hardware.tv.tuner.IFilter)>
<android.hardware.tv.tuner.IFilter: void setDelayHint(android.hardware.tv.tuner.FilterDelayHint)>
<android.hardware.tv.tuner.IFilter: void configureAvStreamType(android.hardware.tv.tuner.AvStreamType)>
<android.hardware.tv.tuner.IFilter: void configureIpCid(int)>
<android.hardware.tv.tuner.IFilter: long getAvSharedHandle(android.hardware.common.NativeHandle)>
<android.hardware.tv.tuner.IFilter: void configure(android.hardware.tv.tuner.DemuxFilterSettings)>
<android.hardware.tv.tuner.IFilter: void configureMonitorEvent(int)>
<android.hardware.tv.tuner.IFilter: void start()>
<android.hardware.tv.tuner.IFilter: void flush()>
<android.hardware.tv.tuner.IFilter: java.lang.String getInterfaceHash()>
<android.hardware.tv.tuner.IFilter: void getQueueDesc(android.hardware.common.fmq.MQDescriptor)>
<android.hardware.tv.tuner.IFilter: int getId()>
<android.hardware.tv.tuner.IFilter: void stop()>
<android.telephony.ims.aidl.IRcsUcePublishStateCallback: void onPublishUpdated(android.telephony.ims.PublishAttributes)>
<com.android.internal.inputmethod.IAccessibilityInputMethodSession: void finishInput()>
<com.android.internal.inputmethod.IAccessibilityInputMethodSession: void finishSession()>
<com.android.internal.inputmethod.IAccessibilityInputMethodSession: void updateSelection(int,int,int,int,int,int)>
<com.android.internal.inputmethod.IAccessibilityInputMethodSession: void invalidateInput(android.view.inputmethod.EditorInfo,com.android.internal.inputmethod.IRemoteAccessibilityInputConnection,int)>
<android.hardware.IDeviceInjectorCallback: void onInjectionPendingStopped(java.lang.String,java.lang.String)>
<android.hardware.IDeviceInjectorCallback: void onSessionCreated(android.hardware.IDeviceInjectorSession)>
<android.hardware.IDeviceInjectorCallback: void onError(int)>
<android.hardware.IDeviceInjectorCallback: void onInjectionStopped(java.lang.String,java.lang.String,java.lang.String)>
<android.hardware.IDeviceInjectorCallback: void onInjectionStarted(java.lang.String,java.lang.String,java.lang.String)>
<android.hardware.IDeviceInjectorCallback: void onInjectionPendingStarted(java.lang.String,java.lang.String)>
<android.hardware.gnss.IGnssPsds: void setCallback(android.hardware.gnss.IGnssPsdsCallback)>
<android.hardware.gnss.IGnssPsds: void injectPsdsData(int,byte[])>
<android.hardware.gnss.IGnssPsds: java.lang.String getInterfaceHash()>
<android.hardware.gnss.IGnssPsds: int getInterfaceVersion()>
<com.android.internal.widget.IWeakEscrowTokenActivatedListener: void onWeakEscrowTokenActivated(long,int)>
<com.samsung.cmfa.AuthTouch.IAuthTouchEnableListener: void notifyTouchEventEnabled(boolean,boolean)>
<com.samsung.android.game.IGameManagerCallback: void onGameFocusOut(java.lang.String)>
<com.samsung.android.game.IGameManagerCallback: void onGameFocusIn(java.lang.String)>
<com.android.internal.telecom.ICallScreeningAdapter: void onScreeningResponse(java.lang.String,android.content.ComponentName,android.telecom.CallScreeningService$ParcelableCallResponse)>
<com.android.internal.telephony.IWwanSelectorCallback: void onRequestEmergencyNetworkScan(int[],int,com.android.internal.telephony.IWwanSelectorResultCallback)>
<com.android.internal.telephony.IWwanSelectorCallback: void onDomainSelected(int,boolean)>
<com.android.internal.telephony.IWwanSelectorCallback: void onCancel()>
<android.printservice.IPrintServiceClient: void onCustomPrinterIconLoaded(android.print.PrinterId,android.graphics.drawable.Icon)>
<android.printservice.IPrintServiceClient: void onPrintersAdded(android.content.pm.ParceledListSlice)>
<android.printservice.IPrintServiceClient: boolean setPrintJobState(android.print.PrintJobId,int,java.lang.String)>
<android.printservice.IPrintServiceClient: void writePrintJobData(android.os.ParcelFileDescriptor,android.print.PrintJobId)>
<android.printservice.IPrintServiceClient: boolean setPrintJobTag(android.print.PrintJobId,java.lang.String)>
<android.printservice.IPrintServiceClient: java.util.List getPrintJobInfos()>
<android.printservice.IPrintServiceClient: android.print.PrintJobInfo getPrintJobInfo(android.print.PrintJobId)>
<android.printservice.IPrintServiceClient: void setProgress(android.print.PrintJobId,float)>
<android.printservice.IPrintServiceClient: void onPrintersRemoved(android.content.pm.ParceledListSlice)>
<android.printservice.IPrintServiceClient: void setStatus(android.print.PrintJobId,java.lang.CharSequence)>
<android.printservice.IPrintServiceClient: void setStatusRes(android.print.PrintJobId,int,java.lang.CharSequence)>
<android.location.IFusedGeofenceHardware: void removeGeofences(int[])>
<android.location.IFusedGeofenceHardware: void addGeofences(android.hardware.location.GeofenceHardwareRequestParcelable[])>
<android.location.IFusedGeofenceHardware: void pauseMonitoringGeofence(int)>
<android.location.IFusedGeofenceHardware: void resumeMonitoringGeofence(int,int)>
<android.location.IFusedGeofenceHardware: void modifyGeofenceOptions(int,int,int,int,int,int)>
<android.location.IFusedGeofenceHardware: boolean isSupported()>
<android.os.storage.IObbActionListener: void onObbResult(java.lang.String,int,int)>
<com.android.internal.telephony.ISemTelephony: java.lang.String getActivationDay(java.lang.String,java.lang.String)>
<com.android.internal.telephony.ISemTelephony: boolean getSupportedNrca(int)>
<com.android.internal.telephony.ISemTelephony: int getNetworkStatusDisplayOption(java.lang.String,java.lang.String)>
<com.android.internal.telephony.ISemTelephony: boolean isSimFDNEnabledForSubscriber(int)>
<com.android.internal.telephony.ISemTelephony: java.lang.String getCdmaMinForOtasp(int)>
<com.android.internal.telephony.ISemTelephony: int getNrMode(int)>
<com.android.internal.telephony.ISemTelephony: boolean setNrMode(int,int,boolean,java.lang.String)>
<com.android.internal.telephony.ISemTelephony: void setGbaBootstrappingParams(int,byte[],java.lang.String,java.lang.String)>
<com.android.internal.telephony.ISemTelephony: boolean getIccUsimPersoEnabled()>
<com.android.internal.telephony.ISemTelephony: boolean getSdnAvailable()>
<com.android.internal.telephony.ISemTelephony: void dialForSubscriber(int,java.lang.String)>
<com.android.internal.telephony.ISemTelephony: int getDisable2g()>
<com.android.internal.telephony.ISemTelephony: int sendRequestToRIL(byte[],byte[],int,int)>
<com.android.internal.telephony.ISemTelephony: boolean isSupportLteCapaOptionC(int)>
<com.android.internal.telephony.ISemTelephony: boolean getIccUsimPersoEnabledForSubId(int)>
<com.android.internal.telephony.ISemTelephony: byte[] sms_NSRI_decryptsms(int,byte[])>
<com.android.internal.telephony.ISemTelephony: boolean isMmiForSubscriber(int,java.lang.String)>
<com.android.internal.telephony.ISemTelephony: boolean isEmergencyNumberBySubId(int,java.lang.String,boolean)>
<com.android.internal.telephony.ISemTelephony: android.telephony.VendorConfigurationState getVendorConfigState(int)>
<com.android.internal.telephony.ISemTelephony: boolean setTransmitPowerExt(long,boolean)>
<com.android.internal.telephony.ISemTelephony: java.lang.String getUaUap(java.lang.String)>
<com.android.internal.telephony.ISemTelephony: boolean isVideoCall()>
<com.android.internal.telephony.ISemTelephony: void reloadTestEmergencyNumber()>
<com.android.internal.telephony.ISemTelephony: android.telephony.CellIdentity getCellLocationBySubId(int,java.lang.String,java.lang.String)>
<com.android.internal.telephony.ISemTelephony: void setAllowDataDuringCall(int)>
<com.android.internal.telephony.ISemTelephony: boolean setIccSimPersoEnabledForSubId(int,boolean,java.lang.String)>
<com.android.internal.telephony.ISemTelephony: java.lang.String getEuimid()>
<com.android.internal.telephony.ISemTelephony: void sendVolteState(int,boolean)>
<com.android.internal.telephony.ISemTelephony: boolean setVoNRMode(int,int)>
<com.android.internal.telephony.ISemTelephony: boolean setSimOnOffForSlot(int,int)>
<com.android.internal.telephony.ISemTelephony: byte[] NSRI_requestProc(int,byte[])>
<com.android.internal.telephony.ISemTelephony: void setEPSLOCI(byte[])>
<com.android.internal.telephony.ISemTelephony: byte[] getCurrentUATI()>
<com.android.internal.telephony.ISemTelephony: boolean setTransmitPowerWithFlag(int,boolean)>
<com.android.internal.telephony.ISemTelephony: boolean setDisable2g(int)>
<com.android.internal.telephony.ISemTelephony: boolean getDataRoamingEnabled()>
<com.android.internal.telephony.ISemTelephony: int getVoNRMode(int)>
<com.android.internal.telephony.ISemTelephony: int invokeOemRilRequestRawForSubscriber(int,byte[],byte[])>
<com.android.internal.telephony.ISemTelephony: int checkNSRIUSIMstate_int()>
<com.android.internal.telephony.ISemTelephony: java.util.List getAllCellInfoBySubId(int,java.lang.String,java.lang.String)>
<com.android.internal.telephony.ISemTelephony: java.lang.String getMobileQualityInformation(int,java.lang.String,java.lang.String)>
<com.android.internal.telephony.ISemTelephony: void requestModemActivityInfo(android.os.ResultReceiver,java.lang.String)>
<com.android.internal.telephony.ISemTelephony: byte[] sms_NSRI_decryptsmsintxside(int,java.lang.String,byte[])>
<com.android.internal.telephony.ISemTelephony: boolean getFDNavailable(int)>
<com.android.internal.telephony.ISemTelephony: int getSimPinRetryForSubscriber(int)>
<com.android.internal.telephony.ISemTelephony: byte[] getAtr(int)>
<com.android.internal.telephony.ISemTelephony: int getSimPukRetryForSubscriber(int)>
<com.android.internal.telephony.ISemTelephony: java.lang.String checkCallControl(int,java.lang.String)>
<com.android.internal.telephony.ISemTelephony: boolean supplyPerso(java.lang.String)>
<com.android.internal.telephony.ISemTelephony: boolean changeIccSimPersoPassword(java.lang.String,java.lang.String)>
<com.android.internal.telephony.ISemTelephony: boolean changeIccSimPersoPasswordForSubId(int,java.lang.String,java.lang.String)>
<com.android.internal.telephony.ISemTelephony: android.telephony.ServiceState getServiceStateForPhoneId(int,java.lang.String,java.lang.String)>
<com.android.internal.telephony.ISemTelephony: byte[] sms_NSRI_encryptsms(int,java.lang.String,byte[])>
<com.android.internal.telephony.ISemTelephony: boolean setIccSimPersoEnabled(boolean,java.lang.String)>
<com.android.internal.telephony.ISemTelephony: boolean supplyPersoForSubId(int,java.lang.String)>
<com.android.internal.telephony.ISemTelephony: java.lang.String getSecondaryImei(java.lang.String,java.lang.String)>
<com.android.internal.telephony.ISemTelephony: java.lang.String getIpAddressFromLinkProp(java.lang.String)>
<android.net.wifi.nl80211.IInterfaceEventCallback: void OnClientInterfaceReady(android.net.wifi.nl80211.IClientInterface)>
<android.net.wifi.nl80211.IInterfaceEventCallback: void OnClientTorndownEvent(android.net.wifi.nl80211.IClientInterface)>
<android.net.wifi.nl80211.IInterfaceEventCallback: void OnApInterfaceReady(android.net.wifi.nl80211.IApInterface)>
<android.net.wifi.nl80211.IInterfaceEventCallback: void OnApTorndownEvent(android.net.wifi.nl80211.IApInterface)>
<android.hardware.gnss.IGnssPowerIndicationCallback: java.lang.String getInterfaceHash()>
<android.hardware.gnss.IGnssPowerIndicationCallback: void gnssPowerStatsCb(android.hardware.gnss.GnssPowerStats)>
<android.hardware.gnss.IGnssPowerIndicationCallback: int getInterfaceVersion()>
<android.hardware.gnss.IGnssPowerIndicationCallback: void setCapabilitiesCb(int)>
<com.sec.android.iaft.IIAFDService: boolean IAFDParse(java.lang.String,java.lang.String,int,int,int,java.lang.String,java.lang.String,java.lang.String)>
<com.sec.android.iaft.IIAFDService: void IAFDShow(int,int,java.lang.String)>
<com.android.internal.telecom.IStreamingCallAdapter: void setStreamingState(int)>
<android.security.rkp.IRegistration: void cancelGetKey(android.security.rkp.IGetKeyCallback)>
<android.security.rkp.IRegistration: void getKey(int,android.security.rkp.IGetKeyCallback)>
<android.security.rkp.IRegistration: void storeUpgradedKeyAsync(byte[],byte[],android.security.rkp.IStoreUpgradedKeyCallback)>
<android.system.keystore2.IKeystoreService: android.system.keystore2.KeyDescriptor grant(android.system.keystore2.KeyDescriptor,int,int)>
<android.system.keystore2.IKeystoreService: java.lang.String getInterfaceHash()>
<android.system.keystore2.IKeystoreService: int getInterfaceVersion()>
<android.system.keystore2.IKeystoreService: android.system.keystore2.KeyDescriptor[] listEntries(int,long)>
<android.system.keystore2.IKeystoreService: android.system.keystore2.IKeystoreSecurityLevel getSecurityLevel(int)>
<android.system.keystore2.IKeystoreService: android.system.keystore2.KeyEntryResponse getKeyEntry(android.system.keystore2.KeyDescriptor)>
<android.system.keystore2.IKeystoreService: void deleteKey(android.system.keystore2.KeyDescriptor)>
<android.system.keystore2.IKeystoreService: int getNumberOfEntries(int,long)>
<android.system.keystore2.IKeystoreService: void ungrant(android.system.keystore2.KeyDescriptor,int)>
<android.system.keystore2.IKeystoreService: android.system.keystore2.KeyDescriptor[] listEntriesBatched(int,long,java.lang.String)>
<android.system.keystore2.IKeystoreService: void updateSubcomponent(android.system.keystore2.KeyDescriptor,byte[],byte[])>
<android.hardware.radio.IRadioService: android.hardware.radio.ITuner openTuner(int,android.hardware.radio.RadioManager$BandConfig,boolean,android.hardware.radio.ITunerCallback)>
<android.hardware.radio.IRadioService: android.hardware.radio.ICloseHandle addAnnouncementListener(int[],android.hardware.radio.IAnnouncementListener)>
<android.hardware.radio.IRadioService: java.util.List listModules()>
<android.content.pm.IPackageManager: android.content.pm.ChangedPackages getChangedPackages(int,int)>
<android.content.pm.IPackageManager: java.lang.String[] currentToCanonicalPackageNames(java.lang.String[])>
<android.content.pm.IPackageManager: android.content.pm.ParceledListSlice queryIntentActivityOptions(android.content.ComponentName,android.content.Intent[],java.lang.String[],android.content.Intent,java.lang.String,long,int)>
<android.content.pm.IPackageManager: void setApplicationCategoryHint(java.lang.String,int,java.lang.String)>
<android.content.pm.IPackageManager: void restoreDefaultApps(byte[],int)>
<android.content.pm.IPackageManager: byte[] getDomainVerificationBackup(int)>
<android.content.pm.IPackageManager: void getPackageSizeInfo(java.lang.String,int,android.content.pm.IPackageStatsObserver)>
<android.content.pm.IPackageManager: boolean activitySupportsIntentAsUser(android.content.ComponentName,android.content.Intent,java.lang.String,int)>
<android.content.pm.IPackageManager: boolean setApplicationHiddenSettingAsUser(java.lang.String,boolean,int)>
<android.content.pm.IPackageManager: int getComponentEnabledSetting(android.content.ComponentName,int)>
<android.content.pm.IPackageManager: void removePermission(java.lang.String)>
<android.content.pm.IPackageManager: java.lang.String[] canonicalToCurrentPackageNames(java.lang.String[])>
<android.content.pm.IPackageManager: android.content.pm.ParceledListSlice getDeclaredSharedLibraries(java.lang.String,long,int)>
<android.content.pm.IPackageManager: android.content.pm.ParceledListSlice queryIntentContentProviders(android.content.Intent,java.lang.String,long,int)>
<android.content.pm.IPackageManager: void restoreLabelAndIcon(android.content.ComponentName,int)>
<android.content.pm.IPackageManager: void freeStorage(java.lang.String,long,int,android.content.IntentSender)>
<android.content.pm.IPackageManager: void makeProviderVisible(int,java.lang.String)>
<android.content.pm.IPackageManager: int performDexOptForADCP(java.lang.String,boolean)>
<android.content.pm.IPackageManager: android.content.pm.ServiceInfo getServiceInfo(android.content.ComponentName,long,int)>
<android.content.pm.IPackageManager: boolean[] canPackageQuery(java.lang.String,java.lang.String[],int)>
<android.content.pm.IPackageManager: java.lang.String[] getUnsuspendablePackagesForUser(java.lang.String[],int)>
<android.content.pm.IPackageManager: java.lang.String[] checkASKSTarget(int)>
<android.content.pm.IPackageManager: void enterSafeMode()>
<android.content.pm.IPackageManager: java.util.List getRequestedRuntimePermissionsForMDM(java.lang.String)>
<android.content.pm.IPackageManager: boolean removeEncPkgDir(int,java.lang.String)>
<android.content.pm.IPackageManager: void clearPersistentPreferredActivity(android.content.IntentFilter,int)>
<android.content.pm.IPackageManager: android.content.pm.ActivityInfo getReceiverInfo(android.content.ComponentName,long,int)>
<android.content.pm.IPackageManager: void changeMonetizationBadgeState(java.lang.String,java.lang.String)>
<android.content.pm.IPackageManager: android.content.pm.InstallSourceInfo getInstallSourceInfo(java.lang.String,int)>
<android.content.pm.IPackageManager: boolean hasSystemFeature(java.lang.String,int)>
<android.content.pm.IPackageManager: void relinquishUpdateOwnership(java.lang.String)>
<android.content.pm.IPackageManager: boolean getMetadataForIconTray(java.lang.String,java.lang.String,int,java.util.List)>
<android.content.pm.IPackageManager: boolean isFirstBoot()>
<android.content.pm.IPackageManager: boolean removeCrossProfileIntentFilter(android.content.IntentFilter,java.lang.String,int,int,int)>
<android.content.pm.IPackageManager: android.content.pm.ModuleInfo getModuleInfo(java.lang.String,int)>
<android.content.pm.IPackageManager: android.content.pm.ParceledListSlice getPersistentApplications(int)>
<android.content.pm.IPackageManager: java.lang.String getSystemCaptionsServicePackageName()>
<android.content.pm.IPackageManager: boolean isAutoRevokeWhitelisted(java.lang.String)>
<android.content.pm.IPackageManager: void verifyIntentFilter(int,int,java.util.List)>
<android.content.pm.IPackageManager: java.lang.String getSdkSandboxPackageName()>
<android.content.pm.IPackageManager: android.content.pm.ParceledListSlice getInstalledPackages(long,int)>
<android.content.pm.IPackageManager: void extendVerificationTimeout(int,int,long)>
<android.content.pm.IPackageManager: void setTrustTimebyStatusChanged()>
<android.content.pm.IPackageManager: android.content.pm.ProviderInfo getProviderInfo(android.content.ComponentName,long,int)>
<android.content.pm.IPackageManager: android.os.Bundle getSuspendedPackageAppExtras(java.lang.String,int)>
<android.content.pm.IPackageManager: boolean isStorageLow()>
<android.content.pm.IPackageManager: void checkPackageStartable(java.lang.String,int)>
<android.content.pm.IPackageManager: int getInstallLocation()>
<android.content.pm.IPackageManager: boolean setRequiredForSystemUser(java.lang.String,boolean)>
<android.content.pm.IPackageManager: boolean getApplicationHiddenSettingAsUser(java.lang.String,int)>
<android.content.pm.IPackageManager: boolean shouldAppSupportBadgeIcon(java.lang.String)>
<android.content.pm.IPackageManager: boolean hasUidSigningCertificate(int,byte[],int)>
<android.content.pm.IPackageManager: boolean createEncAppData(java.lang.String,int)>
<android.content.pm.IPackageManager: byte[] getInstantAppCookie(java.lang.String,int)>
<android.content.pm.IPackageManager: android.content.pm.ParceledListSlice getInstalledApplications(long,int)>
<android.content.pm.IPackageManager: boolean performDexOptMode(java.lang.String,boolean,java.lang.String,boolean,boolean,java.lang.String)>
<android.content.pm.IPackageManager: void finishPackageInstall(int,boolean)>
<android.content.pm.IPackageManager: android.content.pm.ParceledListSlice queryIntentActivities(android.content.Intent,java.lang.String,long,int)>
<android.content.pm.IPackageManager: void resetApplicationPreferences(int)>
<android.content.pm.IPackageManager: android.content.ComponentName getInstantAppResolverComponent()>
<android.content.pm.IPackageManager: void setApplicationEnabledSetting(java.lang.String,int,int,int,java.lang.String)>
<android.content.pm.IPackageManager: int getProgressionOfPackageChanged()>
<android.content.pm.IPackageManager: java.lang.String getAppPredictionServicePackageName()>
<android.content.pm.IPackageManager: boolean getBlockUninstallForUser(java.lang.String,int)>
<android.content.pm.IPackageManager: void restoreDomainVerification(byte[],int)>
<android.content.pm.IPackageManager: void setKeepUninstalledPackages(java.util.List)>
<android.content.pm.IPackageManager: void checkDeletableListForASKS()>
<android.content.pm.IPackageManager: int getUidForSharedUser(java.lang.String)>
<android.content.pm.IPackageManager: android.content.pm.PermissionGroupInfo getPermissionGroupInfo(java.lang.String,int)>
<android.content.pm.IPackageManager: boolean isPackageAvailable(java.lang.String,int)>
<android.content.pm.IPackageManager: android.content.pm.PackageManager$Property getPropertyAsUser(java.lang.String,java.lang.String,java.lang.String,int)>
<android.content.pm.IPackageManager: void clearPackagePreferredActivitiesAsUserForMDM(java.lang.String,int)>
<android.content.pm.IPackageManager: boolean isUnknownSourcePackage(java.lang.String)>
<android.content.pm.IPackageManager: android.content.pm.ParceledListSlice queryIntentServices(android.content.Intent,java.lang.String,long,int)>
<android.content.pm.IPackageManager: int movePrimaryStorage(java.lang.String)>
<android.content.pm.IPackageManager: java.lang.String getSetupWizardPackageName()>
<android.content.pm.IPackageManager: android.content.pm.ParceledListSlice getSharedLibraries(java.lang.String,long,int)>
<android.content.pm.IPackageManager: boolean updateIntentVerificationStatus(java.lang.String,int,int)>
<android.content.pm.IPackageManager: int installExistingPackageAsUser(java.lang.String,int,int,int,java.util.List)>
<android.content.pm.IPackageManager: boolean isSystemCompressedPackage(java.lang.String,int)>
<android.content.pm.IPackageManager: android.content.pm.ParceledListSlice queryProperty(java.lang.String,int)>
<android.content.pm.IPackageManager: boolean setInstantAppCookie(java.lang.String,byte[],int)>
<android.content.pm.IPackageManager: void deletePreloadsFileCache()>
<android.content.pm.IPackageManager: void requestPackageChecksums(java.lang.String,boolean,int,int,java.util.List,android.content.pm.IOnChecksumsReadyListener,int)>
<android.content.pm.IPackageManager: void flushPackageRestrictionsAsUser(int)>
<android.content.pm.IPackageManager: java.lang.String getSystemTextClassifierPackageName()>
<android.content.pm.IPackageManager: java.lang.String getRotationResolverPackageName()>
<android.content.pm.IPackageManager: boolean isPackageSuspendedForUser(java.lang.String,int)>
<android.content.pm.IPackageManager: java.lang.String getAttentionServicePackageName()>
<android.content.pm.IPackageManager: boolean addPermission(android.content.pm.PermissionInfo)>
<android.content.pm.IPackageManager: java.lang.String getUNvalueForASKS()>
<android.content.pm.IPackageManager: void addCrossProfileIntentFilter(android.content.IntentFilter,java.lang.String,int,int,int)>
<android.content.pm.IPackageManager: android.content.IntentSender getLaunchIntentSenderForPackage(java.lang.String,java.lang.String,java.lang.String,int)>
<android.content.pm.IPackageManager: android.content.pm.ParceledListSlice queryInstrumentationAsUser(java.lang.String,int,int)>
<android.content.pm.IPackageManager: android.content.pm.KeySet getSigningKeySet(java.lang.String)>
<android.content.pm.IPackageManager: java.lang.String getServicesSystemSharedLibraryPackageName()>
<android.content.pm.IPackageManager: boolean isPackageAutoDisabled(java.lang.String,int)>
<android.content.pm.IPackageManager: boolean isSafeMode()>
<android.content.pm.IPackageManager: android.content.ComponentName getInstantAppResolverSettingsComponent()>
<android.content.pm.IPackageManager: android.content.pm.ParceledListSlice getInstantApps(int)>
<android.content.pm.IPackageManager: void setLastChosenActivity(android.content.Intent,java.lang.String,int,android.content.IntentFilter,int,android.content.ComponentName)>
<android.content.pm.IPackageManager: void verifyPendingInstall(int,int)>
<android.content.pm.IPackageManager: boolean isInstantApp(java.lang.String,int)>
<android.content.pm.IPackageManager: android.content.pm.InstrumentationInfo getInstrumentationInfoAsUser(android.content.ComponentName,int,int)>
<android.content.pm.IPackageManager: android.content.pm.PackageInfo getPackageInfoVersioned(android.content.pm.VersionedPackage,long,int)>
<android.content.pm.IPackageManager: boolean canForwardTo(android.content.Intent,java.lang.String,int,int)>
<android.content.pm.IPackageManager: byte[] getPreferredActivityBackup(int)>
<android.content.pm.IPackageManager: void clearPackagePersistentPreferredActivities(java.lang.String,int)>
<android.content.pm.IPackageManager: void registerMoveCallback(android.content.pm.IPackageMoveObserver)>
<android.content.pm.IPackageManager: void setApplicationEnabledSettingWithList(java.util.List,int,int,boolean,boolean,int,java.lang.String)>
<android.content.pm.IPackageManager: void notifyPackageUse(java.lang.String,int)>
<android.content.pm.IPackageManager: void replacePreferredActivity(android.content.IntentFilter,int,android.content.ComponentName[],android.content.ComponentName,int)>
<android.content.pm.IPackageManager: void restorePreferredActivities(byte[],int)>
<android.content.pm.IPackageManager: boolean applyRuntimePermissionsForAllApplicationsForMDM(int,int)>
<android.content.pm.IPackageManager: android.content.pm.ActivityInfo getActivityInfo(android.content.ComponentName,long,int)>
<android.content.pm.IPackageManager: void addPreferredActivity(android.content.IntentFilter,int,android.content.ComponentName[],android.content.ComponentName,int,boolean)>
<android.content.pm.IPackageManager: android.content.pm.ResolveInfo resolveIntent(android.content.Intent,java.lang.String,long,int)>
<android.content.pm.IPackageManager: android.content.pm.ParceledListSlice queryIntentReceivers(android.content.Intent,java.lang.String,long,int)>
<android.content.pm.IPackageManager: java.lang.String[] getNamesForUids(int[])>
<android.content.pm.IPackageManager: android.content.pm.ResolveInfo resolveService(android.content.Intent,java.lang.String,long,int)>
<android.content.pm.IPackageManager: android.content.pm.ParceledListSlice getIntentFilterVerifications(java.lang.String)>
<android.content.pm.IPackageManager: java.lang.String[] getSystemSharedLibraryNames()>
<android.content.pm.IPackageManager: void notifyPackagesReplacedReceived(java.lang.String[])>
<android.content.pm.IPackageManager: android.content.pm.ResolveInfo findPersistentPreferredActivity(android.content.Intent,int)>
<android.content.pm.IPackageManager: java.lang.String getInstantAppAndroidId(java.lang.String,int)>
<android.content.pm.IPackageManager: void grantRuntimePermission(java.lang.String,java.lang.String,int)>
<android.content.pm.IPackageManager: boolean isPackageSignedByKeySetExactly(java.lang.String,android.content.pm.KeySet)>
<android.content.pm.IPackageManager: boolean hasSigningCertificate(java.lang.String,byte[],int)>
<android.content.pm.IPackageManager: java.lang.String getPermissionControllerPackageName()>
<android.content.pm.IPackageManager: android.content.pm.ApplicationInfo getApplicationInfo(java.lang.String,long,int)>
<android.content.pm.IPackageManager: int getApplicationEnabledSetting(java.lang.String,int)>
<android.content.pm.IPackageManager: android.graphics.Bitmap getInstantAppIcon(java.lang.String,int)>
<android.content.pm.IPackageManager: boolean setBlockUninstallForUser(java.lang.String,boolean,int)>
<android.content.pm.IPackageManager: boolean isPackageStateProtected(java.lang.String,int)>
<android.content.pm.IPackageManager: boolean performDexOptSecondary(java.lang.String,java.lang.String,boolean)>
<android.content.pm.IPackageManager: java.lang.String getInstallerPackageName(java.lang.String)>
<android.content.pm.IPackageManager: boolean isPackageSignedByKeySet(java.lang.String,android.content.pm.KeySet)>
<android.content.pm.IPackageManager: boolean hasSystemUidErrors()>
<android.content.pm.IPackageManager: byte[] getDefaultAppsBackup(int)>
<android.content.pm.IPackageManager: void clearApplicationUserData(java.lang.String,android.content.pm.IPackageDataObserver,int)>
<android.content.pm.IPackageManager: android.content.pm.KeySet getKeySetByAlias(java.lang.String,java.lang.String)>
<android.content.pm.IPackageManager: void deletePackageAsUser(java.lang.String,int,android.content.pm.IPackageDeleteObserver,int,int)>
<android.content.pm.IPackageManager: void setMimeGroup(java.lang.String,java.lang.String,java.util.List)>
<android.content.pm.IPackageManager: java.lang.String[] setDistractingPackageRestrictionsAsUser(java.lang.String[],int,int)>
<android.content.pm.IPackageManager: boolean isDeviceUpgrading()>
<android.content.pm.IPackageManager: java.util.List getPackageListForDualDarPolicy(java.lang.String)>
<android.content.pm.IPackageManager: int checkUidSignatures(int,int)>
<android.content.pm.IPackageManager: void deletePackageVersioned(android.content.pm.VersionedPackage,android.content.pm.IPackageDeleteObserver2,int,int)>
<android.content.pm.IPackageManager: void cancelEMPHandlerSendPendingBroadcast()>
<android.content.pm.IPackageManager: void setSystemAppHiddenUntilInstalled(java.lang.String,boolean)>
<android.content.pm.IPackageManager: java.util.List getInstalledModules(int)>
<android.content.pm.IPackageManager: java.util.List getMimeGroup(java.lang.String,java.lang.String)>
<android.content.pm.IPackageManager: int getPackageUid(java.lang.String,long,int)>
<android.content.pm.IPackageManager: boolean isPackageDeviceAdminOnAnyUser(java.lang.String)>
<android.content.pm.IPackageManager: android.content.pm.ProviderInfo resolveContentProvider(java.lang.String,long,int)>
<android.content.pm.IPackageManager: void deleteApplicationCacheFiles(java.lang.String,android.content.pm.IPackageDataObserver)>
<android.content.pm.IPackageManager: java.util.List getInitialNonStoppedSystemPackages()>
<android.content.pm.IPackageManager: void querySyncProviders(java.util.List,java.util.List)>
<android.content.pm.IPackageManager: boolean setSystemAppInstallState(java.lang.String,boolean,int)>
<android.content.pm.IPackageManager: java.lang.String getSplashScreenTheme(java.lang.String,int)>
<android.content.pm.IPackageManager: int[] getPackageGids(java.lang.String,long,int)>
<android.content.pm.IPackageManager: boolean canRequestPackageInstalls(java.lang.String,int)>
<android.content.pm.IPackageManager: int checkPermission(java.lang.String,java.lang.String,int)>
<android.content.pm.IPackageManager: void clearCrossProfileIntentFilters(int,java.lang.String)>
<android.content.pm.IPackageManager: int getFlagsForUid(int)>
<android.content.pm.IPackageManager: android.content.pm.ParceledListSlice getSystemAvailableFeatures()>
<android.content.pm.IPackageManager: void registerDexModule(java.lang.String,java.lang.String,boolean,android.content.pm.IDexModuleRegisterCallback)>
<android.content.pm.IPackageManager: android.content.ComponentName getHomeActivities(java.util.List)>
<android.content.pm.IPackageManager: android.content.pm.ParceledListSlice getUnknownSourcePackagesAsUser(long,int)>
<android.content.pm.IPackageManager: boolean semIsPermissionRevokedByUserFixed(java.lang.String,java.lang.String,int)>
<android.content.pm.IPackageManager: void setSplashScreenTheme(java.lang.String,java.lang.String,int)>
<android.content.pm.IPackageManager: int getRuntimePermissionsVersion(int)>
<android.content.pm.IPackageManager: void setComponentEnabledSettings(java.util.List,int,java.lang.String)>
<android.content.pm.IPackageManager: android.content.ComponentName getInstantAppInstallerComponent()>
<android.content.pm.IPackageManager: java.lang.String getSharedSystemSharedLibraryPackageName()>
<android.content.pm.IPackageManager: android.content.pm.VerifierDeviceIdentity getVerifierDeviceIdentity()>
<android.content.pm.IPackageManager: boolean isProtectedBroadcast(java.lang.String)>
<android.content.pm.IPackageManager: int setLicensePermissionsForMDM(java.lang.String)>
<android.content.pm.IPackageManager: boolean setInstallLocation(int)>
<android.content.pm.IPackageManager: android.os.IBinder getHoldLockToken()>
<android.content.pm.IPackageManager: android.content.pm.ParceledListSlice getPackagesHoldingPermissions(java.lang.String[],long,int)>
<android.content.pm.IPackageManager: void setHomeActivity(android.content.ComponentName,int)>
<android.content.pm.IPackageManager: java.lang.String getIncidentReportApproverPackageName()>
<android.content.pm.IPackageManager: int checkSignatures(java.lang.String,java.lang.String,int)>
<android.content.pm.IPackageManager: int movePackageToSd(java.lang.String,java.lang.String,android.content.pm.IMemorySaverPackageMoveObserver)>
<android.content.pm.IPackageManager: void setComponentEnabledSetting(android.content.ComponentName,int,int,int,java.lang.String)>
<android.content.pm.IPackageManager: void clearApplicationProfileData(java.lang.String)>
<android.content.pm.IPackageManager: android.content.pm.ParceledListSlice getAllIntentFilters(java.lang.String)>
<android.content.pm.IPackageManager: int getPreferredActivities(java.util.List,java.util.List,java.lang.String)>
<android.content.pm.IPackageManager: int getTargetSdkVersion(java.lang.String)>
<android.content.pm.IPackageManager: java.lang.String getWellbeingPackageName()>
<android.content.pm.IPackageManager: java.lang.String[] getAppOpPermissionPackages(java.lang.String,int)>
<android.content.pm.IPackageManager: void deleteExistingPackageAsUser(android.content.pm.VersionedPackage,android.content.pm.IPackageDeleteObserver2,int)>
<android.content.pm.IPackageManager: android.content.pm.PackageInfo getPackageInfo(java.lang.String,long,int)>
<android.content.pm.IPackageManager: android.content.pm.dex.IArtManager getArtManager()>
<android.content.pm.IPackageManager: boolean removeEncUserDir(int)>
<android.content.pm.IPackageManager: java.util.List getAllPackages()>
<android.content.pm.IPackageManager: java.lang.String getDefaultTextClassifierPackageName()>
<android.content.pm.IPackageManager: java.util.List getPackageGrantedPermissionsForMDM(java.lang.String)>
<android.content.pm.IPackageManager: java.lang.CharSequence getHarmfulAppWarning(java.lang.String,int)>
<android.content.pm.IPackageManager: android.content.pm.ParceledListSlice queryContentProviders(java.lang.String,int,long,java.lang.String)>
<android.content.pm.IPackageManager: void deleteApplicationCacheFilesAsUser(java.lang.String,int,android.content.pm.IPackageDataObserver)>
<android.content.pm.IPackageManager: void sendDeviceCustomizationReadyBroadcast()>
<android.content.pm.IPackageManager: int getInstallReason(java.lang.String,int)>
<android.content.pm.IPackageManager: void makeUidVisible(int,int)>
<android.content.pm.IPackageManager: boolean isUidPrivileged(int)>
<android.content.pm.IPackageManager: boolean waitForHandler(long,boolean)>
<android.content.pm.IPackageManager: android.content.pm.ResolveInfo getLastChosenActivity(android.content.Intent,java.lang.String,int)>
<android.content.pm.IPackageManager: java.lang.String getNameForUid(int)>
<android.content.pm.IPackageManager: java.lang.String[] getPackagesForUid(int)>
<android.content.pm.IPackageManager: int getIntentVerificationStatus(java.lang.String,int)>
<android.content.pm.IPackageManager: void setHarmfulAppWarning(java.lang.String,java.lang.CharSequence,int)>
<android.content.pm.IPackageManager: void setInstallerPackageName(java.lang.String,java.lang.String)>
<android.content.pm.IPackageManager: void clearPackagePreferredActivities(java.lang.String)>
<android.content.pm.IPackageManager: android.content.pm.IPackageInstaller getPackageInstaller()>
<android.content.pm.IPackageManager: void logAppProcessStartIfNeeded(java.lang.String,java.lang.String,int,java.lang.String,java.lang.String,int)>
<android.content.pm.IPackageManager: android.os.ParcelFileDescriptor getAppMetadataFd(java.lang.String,int)>
<android.content.pm.IPackageManager: void addPersistentPreferredActivity(android.content.IntentFilter,android.content.ComponentName,int)>
<android.content.pm.IPackageManager: void setPackageStoppedState(java.lang.String,boolean,int)>
<android.content.pm.IPackageManager: void holdLock(android.os.IBinder,int)>
<android.content.pm.IPackageManager: java.lang.String[] setPackagesSuspendedAsUser(java.lang.String[],boolean,android.os.PersistableBundle,android.os.PersistableBundle,android.content.pm.SuspendDialogInfo,java.lang.String,int)>
<android.content.pm.IPackageManager: java.util.List getGrantedPermissionsForMDM(java.lang.String)>
<android.content.pm.IPackageManager: void freeStorageAndNotify(java.lang.String,long,int,android.content.pm.IPackageDataObserver)>
<android.content.pm.IPackageManager: void notifyDexLoad(java.lang.String,java.util.Map,java.lang.String)>
<android.content.pm.IPackageManager: void overrideLabelAndIcon(android.content.ComponentName,java.lang.String,int,int)>
<android.content.pm.IPackageManager: int checkUidPermission(java.lang.String,int)>
<android.content.pm.IPackageManager: boolean addPermissionAsync(android.content.pm.PermissionInfo)>
<android.content.pm.IPackageManager: void unregisterMoveCallback(android.content.pm.IPackageMoveObserver)>
<android.content.pm.IPackageManager: void setUpdateAvailable(java.lang.String,boolean)>
<android.content.pm.IPackageManager: int getMoveStatus(int)>
<android.content.pm.IPackageManager: int movePackage(java.lang.String,java.lang.String)>
<android.content.pm.IPackageManager: boolean applyRuntimePermissionsForMDM(java.lang.String,java.util.List,int,int)>
<android.content.pm.IPackageManager: int getPrivateFlagsForUid(int)>
<android.content.pm.IPackageManager: void setRuntimePermissionsVersion(int,int)>
<vendor.samsung.hardware.radio.sim.ISehRadioSimResponse: void getUsimPhonebookCapabilityResponse(vendor.samsung.hardware.radio.SehRadioResponseInfo,int[])>
<vendor.samsung.hardware.radio.sim.ISehRadioSimResponse: void supplyIccPersonalizationResponse(vendor.samsung.hardware.radio.SehRadioResponseInfo)>
<vendor.samsung.hardware.radio.sim.ISehRadioSimResponse: void getSimLockInfoResponse(vendor.samsung.hardware.radio.SehRadioResponseInfo,vendor.samsung.hardware.radio.sim.SehSimLockInfo)>
<vendor.samsung.hardware.radio.sim.ISehRadioSimResponse: void changeIccPersonalizationResponse(vendor.samsung.hardware.radio.SehRadioResponseInfo)>
<vendor.samsung.hardware.radio.sim.ISehRadioSimResponse: void getPhonebookStorageInfoResponse(vendor.samsung.hardware.radio.SehRadioResponseInfo,vendor.samsung.hardware.radio.sim.SehPhonebookInfo)>
<vendor.samsung.hardware.radio.sim.ISehRadioSimResponse: void getAtrResponse(vendor.samsung.hardware.radio.SehRadioResponseInfo,java.lang.String)>
<vendor.samsung.hardware.radio.sim.ISehRadioSimResponse: void accessPhonebookEntryResponse(vendor.samsung.hardware.radio.SehRadioResponseInfo,int)>
<vendor.samsung.hardware.radio.sim.ISehRadioSimResponse: java.lang.String getInterfaceHash()>
<vendor.samsung.hardware.radio.sim.ISehRadioSimResponse: void getPhonebookEntryResponse(vendor.samsung.hardware.radio.SehRadioResponseInfo,vendor.samsung.hardware.radio.sim.SehSimPhonebookResponse)>
<vendor.samsung.hardware.radio.sim.ISehRadioSimResponse: int getInterfaceVersion()>
<vendor.samsung.hardware.radio.sim.ISehRadioSimResponse: void setSimOnOffResponse(vendor.samsung.hardware.radio.SehRadioResponseInfo)>
<vendor.samsung.hardware.radio.sim.ISehRadioSimResponse: void supplyNetworkDepersonalizationResponse(vendor.samsung.hardware.radio.SehRadioResponseInfo,int)>
<vendor.samsung.hardware.radio.sim.ISehRadioSimResponse: void setSimInitEventResponse(vendor.samsung.hardware.radio.SehRadioResponseInfo)>
<vendor.samsung.hardware.radio.sim.ISehRadioSimResponse: void getIccCardStatusResponse(vendor.samsung.hardware.radio.SehRadioResponseInfo,vendor.samsung.hardware.radio.sim.SehCardStatus)>
<android.hardware.biometrics.fingerprint.ISession: void close()>
<android.hardware.biometrics.fingerprint.ISession: android.hardware.biometrics.common.ICancellationSignal authenticateWithContext(long,android.hardware.biometrics.common.OperationContext)>
<android.hardware.biometrics.fingerprint.ISession: void revokeChallenge(long)>
<android.hardware.biometrics.fingerprint.ISession: android.hardware.biometrics.common.ICancellationSignal authenticate(long)>
<android.hardware.biometrics.fingerprint.ISession: android.hardware.biometrics.common.ICancellationSignal enrollWithContext(android.hardware.keymaster.HardwareAuthToken,android.hardware.biometrics.common.OperationContext)>
<android.hardware.biometrics.fingerprint.ISession: android.hardware.biometrics.common.ICancellationSignal enroll(android.hardware.keymaster.HardwareAuthToken)>
<android.hardware.biometrics.fingerprint.ISession: void getAuthenticatorId()>
<android.hardware.biometrics.fingerprint.ISession: void onPointerDown(int,int,int,float,float)>
<android.hardware.biometrics.fingerprint.ISession: void enumerateEnrollments()>
<android.hardware.biometrics.fingerprint.ISession: void removeEnrollments(int[])>
<android.hardware.biometrics.fingerprint.ISession: android.hardware.biometrics.common.ICancellationSignal detectInteractionWithContext(android.hardware.biometrics.common.OperationContext)>
<android.hardware.biometrics.fingerprint.ISession: void onPointerUpWithContext(android.hardware.biometrics.fingerprint.PointerContext)>
<android.hardware.biometrics.fingerprint.ISession: void onPointerDownWithContext(android.hardware.biometrics.fingerprint.PointerContext)>
<android.hardware.biometrics.fingerprint.ISession: void generateChallenge()>
<android.hardware.biometrics.fingerprint.ISession: void onContextChanged(android.hardware.biometrics.common.OperationContext)>
<android.hardware.biometrics.fingerprint.ISession: void invalidateAuthenticatorId()>
<android.hardware.biometrics.fingerprint.ISession: android.hardware.biometrics.common.ICancellationSignal detectInteraction()>
<android.hardware.biometrics.fingerprint.ISession: void resetLockout(android.hardware.keymaster.HardwareAuthToken)>
<android.hardware.biometrics.fingerprint.ISession: int getInterfaceVersion()>
<android.hardware.biometrics.fingerprint.ISession: void onPointerUp(int)>
<android.hardware.biometrics.fingerprint.ISession: void onUiReady()>
<android.hardware.biometrics.fingerprint.ISession: void setIgnoreDisplayTouches(boolean)>
<android.hardware.biometrics.fingerprint.ISession: java.lang.String getInterfaceHash()>
<android.hardware.biometrics.fingerprint.ISession: void onPointerCancelWithContext(android.hardware.biometrics.fingerprint.PointerContext)>
<android.telephony.ims.aidl.IImsServiceControllerListener: void onUpdateSupportedImsFeatures(android.telephony.ims.stub.ImsFeatureConfiguration)>
<android.hardware.radio.ims.IRadioIms: void setSrvccCallInfo(int,android.hardware.radio.ims.SrvccCall[])>
<android.hardware.radio.ims.IRadioIms: void stopImsTraffic(int,int)>
<android.hardware.radio.ims.IRadioIms: void setResponseFunctions(android.hardware.radio.ims.IRadioImsResponse,android.hardware.radio.ims.IRadioImsIndication)>
<android.hardware.radio.ims.IRadioIms: void updateImsCallStatus(int,android.hardware.radio.ims.ImsCall[])>
<android.hardware.radio.ims.IRadioIms: int getInterfaceVersion()>
<android.hardware.radio.ims.IRadioIms: void sendAnbrQuery(int,int,int,int)>
<android.hardware.radio.ims.IRadioIms: void startImsTraffic(int,int,int,int,int)>
<android.hardware.radio.ims.IRadioIms: void updateImsRegistrationInfo(int,android.hardware.radio.ims.ImsRegistration)>
<android.hardware.radio.ims.IRadioIms: void triggerEpsFallback(int,int)>
<android.hardware.radio.ims.IRadioIms: java.lang.String getInterfaceHash()>
<com.samsung.android.location.ISLocationLMSHook: boolean isUidForeground(int)>
<com.samsung.android.location.ISLocationLMSHook: boolean isProviderEnabledForUser(java.lang.String,int)>
<com.samsung.android.location.ISLocationLMSHook: void updateRequestInfo(boolean,int,int,java.lang.String,java.lang.String,boolean,int)>
<com.samsung.android.location.ISLocationLMSHook: android.location.IGpsGeofenceHardware getHWGeofence()>
<android.telephony.mbms.vendor.IMbmsDownloadService: int removeProgressListener(android.telephony.mbms.DownloadRequest,android.telephony.mbms.IDownloadProgressListener)>
<android.telephony.mbms.vendor.IMbmsDownloadService: int addServiceAnnouncement(int,byte[])>
<android.telephony.mbms.vendor.IMbmsDownloadService: int addStatusListener(android.telephony.mbms.DownloadRequest,android.telephony.mbms.IDownloadStatusListener)>
<android.telephony.mbms.vendor.IMbmsDownloadService: int addProgressListener(android.telephony.mbms.DownloadRequest,android.telephony.mbms.IDownloadProgressListener)>
<android.telephony.mbms.vendor.IMbmsDownloadService: int requestUpdateFileServices(int,java.util.List)>
<android.telephony.mbms.vendor.IMbmsDownloadService: int initialize(int,android.telephony.mbms.IMbmsDownloadSessionCallback)>
<android.telephony.mbms.vendor.IMbmsDownloadService: int removeStatusListener(android.telephony.mbms.DownloadRequest,android.telephony.mbms.IDownloadStatusListener)>
<android.telephony.mbms.vendor.IMbmsDownloadService: int download(android.telephony.mbms.DownloadRequest)>
<android.telephony.mbms.vendor.IMbmsDownloadService: int requestDownloadState(android.telephony.mbms.DownloadRequest,android.telephony.mbms.FileInfo)>
<android.telephony.mbms.vendor.IMbmsDownloadService: int setTempFileRootDirectory(int,java.lang.String)>
<android.telephony.mbms.vendor.IMbmsDownloadService: int cancelDownload(android.telephony.mbms.DownloadRequest)>
<android.telephony.mbms.vendor.IMbmsDownloadService: java.util.List listPendingDownloads(int)>
<android.telephony.mbms.vendor.IMbmsDownloadService: void dispose(int)>
<android.telephony.mbms.vendor.IMbmsDownloadService: int resetDownloadKnowledge(android.telephony.mbms.DownloadRequest)>
<android.hardware.location.IGeofenceHardware: boolean removeGeofence(int,int)>
<android.hardware.location.IGeofenceHardware: int getStatusOfMonitoringType(int)>
<android.hardware.location.IGeofenceHardware: void setGpsGeofenceHardware(android.location.IGpsGeofenceHardware)>
<android.hardware.location.IGeofenceHardware: boolean addCircularFence(int,android.hardware.location.GeofenceHardwareRequestParcelable,android.hardware.location.IGeofenceHardwareCallback)>
<android.hardware.location.IGeofenceHardware: boolean pauseGeofence(int,int)>
<android.hardware.location.IGeofenceHardware: void setFusedGeofenceHardware(android.location.IFusedGeofenceHardware)>
<android.hardware.location.IGeofenceHardware: boolean registerForMonitorStateChangeCallback(int,android.hardware.location.IGeofenceHardwareMonitorCallback)>
<android.hardware.location.IGeofenceHardware: boolean resumeGeofence(int,int,int)>
<android.hardware.location.IGeofenceHardware: boolean unregisterForMonitorStateChangeCallback(int,android.hardware.location.IGeofenceHardwareMonitorCallback)>
<android.hardware.location.IGeofenceHardware: int[] getMonitoringTypes()>
<android.location.ILocationListener: void onProviderEnabledChanged(java.lang.String,boolean)>
<android.location.ILocationListener: void onLocationChanged(java.util.List,android.os.IRemoteCallback)>
<android.location.ILocationListener: void onFlushComplete(int)>
<android.service.textclassifier.ITextClassifierCallback: void onFailure()>
<android.service.textclassifier.ITextClassifierCallback: void onSuccess(android.os.Bundle)>
<android.hardware.radio.ims.IRadioImsIndication: void triggerImsDeregistration(int,int)>
<android.hardware.radio.ims.IRadioImsIndication: int getInterfaceVersion()>
<android.hardware.radio.ims.IRadioImsIndication: java.lang.String getInterfaceHash()>
<android.hardware.radio.ims.IRadioImsIndication: void notifyAnbr(int,int,int,int)>
<android.hardware.radio.ims.IRadioImsIndication: void onConnectionSetupFailure(int,int,android.hardware.radio.ims.ConnectionFailureInfo)>
<android.os.ISystemConfig: java.util.Map getDisabledUntilUsedPreinstalledCarrierAssociatedAppEntries()>
<android.os.ISystemConfig: java.util.List getEnabledComponentOverrides(java.lang.String)>
<android.os.ISystemConfig: java.util.List getDefaultVrComponents()>
<android.os.ISystemConfig: java.util.List getDisabledUntilUsedPreinstalledCarrierApps()>
<android.os.ISystemConfig: java.util.Map getDisabledUntilUsedPreinstalledCarrierAssociatedApps()>
<android.os.ISystemConfig: int[] getSystemPermissionUids(java.lang.String)>
<android.hardware.location.IActivityRecognitionHardwareSink: void onActivityChanged(android.hardware.location.ActivityChangedEvent)>
<android.hardware.camera2.extension.IRequestUpdateProcessorImpl: void onImageFormatUpdate(int)>
<android.hardware.camera2.extension.IRequestUpdateProcessorImpl: void onOutputSurface(android.view.Surface,int)>
<android.hardware.camera2.extension.IRequestUpdateProcessorImpl: void onResolutionUpdate(android.hardware.camera2.extension.Size)>
<android.hardware.camera2.extension.IRequestUpdateProcessorImpl: android.hardware.camera2.extension.CaptureStageImpl process(android.hardware.camera2.impl.CameraMetadataNative,int)>
<android.service.euicc.IDownloadSubscriptionCallback: void onComplete(android.service.euicc.DownloadSubscriptionResult)>
<android.telephony.ims.aidl.ISipDelegateMessageCallback: void onMessageSent(java.lang.String)>
<android.telephony.ims.aidl.ISipDelegateMessageCallback: void onMessageReceived(android.telephony.ims.SipMessage)>
<android.telephony.ims.aidl.ISipDelegateMessageCallback: void onMessageSendFailure(java.lang.String,int)>
<com.samsung.android.displayquality.ISemDisplayQualityManager: void enhanceDisplayOutdoorVisibilityByLux(int)>
<com.samsung.android.displayquality.ISemDisplayQualityManager: void setAdaptiveSync(boolean)>
<android.hardware.cas.IDescrambler: int descramble(int,android.hardware.cas.SubSample[],android.hardware.cas.SharedBuffer,long,android.hardware.cas.DestinationBuffer,long)>
<android.hardware.cas.IDescrambler: void release()>
<android.hardware.cas.IDescrambler: boolean requiresSecureDecoderComponent(java.lang.String)>
<android.hardware.cas.IDescrambler: void setMediaCasSession(byte[])>
<android.hardware.cas.IDescrambler: int getInterfaceVersion()>
<android.hardware.cas.IDescrambler: java.lang.String getInterfaceHash()>
<vendor.samsung.hardware.radio.data.ISehRadioDataResponse: void setDataAllowedResponse(vendor.samsung.hardware.radio.SehRadioResponseInfo)>
<vendor.samsung.hardware.radio.data.ISehRadioDataResponse: void setMobileDataSettingResponse(vendor.samsung.hardware.radio.SehRadioResponseInfo)>
<vendor.samsung.hardware.radio.data.ISehRadioDataResponse: java.lang.String getInterfaceHash()>
<vendor.samsung.hardware.radio.data.ISehRadioDataResponse: int getInterfaceVersion()>
<com.samsung.android.media.fmradio.internal.IFMPlayer: void setSpeakerOn(boolean)>
<com.samsung.android.media.fmradio.internal.IFMPlayer: boolean isDeviceSpeakerEnabled()>
<com.samsung.android.media.fmradio.internal.IFMPlayer: void enableRDS()>
<com.samsung.android.media.fmradio.internal.IFMPlayer: boolean isSeeking()>
<com.samsung.android.media.fmradio.internal.IFMPlayer: long searchDown()>
<com.samsung.android.media.fmradio.internal.IFMPlayer: void setStringTunningParameter(java.lang.String,java.lang.String)>
<com.samsung.android.media.fmradio.internal.IFMPlayer: void setBand(int)>
<com.samsung.android.media.fmradio.internal.IFMPlayer: long searchUp()>
<com.samsung.android.media.fmradio.internal.IFMPlayer: void cancelSeek()>
<com.samsung.android.media.fmradio.internal.IFMPlayer: boolean isScanning()>
<com.samsung.android.media.fmradio.internal.IFMPlayer: long[] getLastScanResult()>
<com.samsung.android.media.fmradio.internal.IFMPlayer: boolean isBatteryLow()>
<com.samsung.android.media.fmradio.internal.IFMPlayer: long getLongTunningParameter(java.lang.String,long)>
<com.samsung.android.media.fmradio.internal.IFMPlayer: long seekUp()>
<com.samsung.android.media.fmradio.internal.IFMPlayer: void setListener(com.samsung.android.media.fmradio.internal.IFMEventListener)>
<com.samsung.android.media.fmradio.internal.IFMPlayer: void setVolume(long)>
<com.samsung.android.media.fmradio.internal.IFMPlayer: void removeListener(com.samsung.android.media.fmradio.internal.IFMEventListener)>
<com.samsung.android.media.fmradio.internal.IFMPlayer: void tune(long)>
<com.samsung.android.media.fmradio.internal.IFMPlayer: long getVolume()>
<com.samsung.android.media.fmradio.internal.IFMPlayer: void cancelAFSwitching()>
<com.samsung.android.media.fmradio.internal.IFMPlayer: boolean isHeadsetPlugged()>
<com.samsung.android.media.fmradio.internal.IFMPlayer: long seekDown()>
<com.samsung.android.media.fmradio.internal.IFMPlayer: int getIntegerTunningParameter(java.lang.String,int)>
<com.samsung.android.media.fmradio.internal.IFMPlayer: boolean isRDSEnable()>
<com.samsung.android.media.fmradio.internal.IFMPlayer: void setMono()>
<com.samsung.android.media.fmradio.internal.IFMPlayer: boolean getSoftMuteMode()>
<com.samsung.android.media.fmradio.internal.IFMPlayer: void setIntegerTunningParameter(java.lang.String,int)>
<com.samsung.android.media.fmradio.internal.IFMPlayer: boolean on()>
<com.samsung.android.media.fmradio.internal.IFMPlayer: boolean off()>
<com.samsung.android.media.fmradio.internal.IFMPlayer: boolean cancelScan()>
<com.samsung.android.media.fmradio.internal.IFMPlayer: void setStereo()>
<com.samsung.android.media.fmradio.internal.IFMPlayer: long searchAll()>
<com.samsung.android.media.fmradio.internal.IFMPlayer: void setSoftmute(boolean)>
<com.samsung.android.media.fmradio.internal.IFMPlayer: boolean isOn()>
<com.samsung.android.media.fmradio.internal.IFMPlayer: void setFMIntenna(boolean)>
<com.samsung.android.media.fmradio.internal.IFMPlayer: boolean isAFEnable()>
<com.samsung.android.media.fmradio.internal.IFMPlayer: void scan()>
<com.samsung.android.media.fmradio.internal.IFMPlayer: long getCurrentChannel()>
<com.samsung.android.media.fmradio.internal.IFMPlayer: void setLongTunningParameter(java.lang.String,long)>
<com.samsung.android.media.fmradio.internal.IFMPlayer: void disableRDS()>
<com.samsung.android.media.fmradio.internal.IFMPlayer: long getPlayedFreq()>
<com.samsung.android.media.fmradio.internal.IFMPlayer: boolean isAirPlaneMode()>
<com.samsung.android.media.fmradio.internal.IFMPlayer: long getMaxVolume()>
<com.samsung.android.media.fmradio.internal.IFMPlayer: boolean on_in_testmode()>
<com.samsung.android.media.fmradio.internal.IFMPlayer: int isBusy()>
<com.samsung.android.media.fmradio.internal.IFMPlayer: void mute(boolean)>
<com.samsung.android.media.fmradio.internal.IFMPlayer: boolean isTvOutPlugged()>
<com.samsung.android.media.fmradio.internal.IFMPlayer: void setChannelSpacing(int)>
<com.samsung.android.media.fmradio.internal.IFMPlayer: void setRecordMode(boolean)>
<com.samsung.android.media.fmradio.internal.IFMPlayer: void enableAF()>
<com.samsung.android.media.fmradio.internal.IFMPlayer: void disableAF()>
<com.samsung.android.media.fmradio.internal.IFMPlayer: java.lang.String getStringTunningParameter(java.lang.String,java.lang.String)>
<com.android.internal.policy.IKeyguardService: void onStartedWakingUp(int,boolean)>
<com.android.internal.policy.IKeyguardService: void onSystemKeyPressed(int)>
<com.android.internal.policy.IKeyguardService: void onShortPowerPressedGoHome()>
<com.android.internal.policy.IKeyguardService: void setCoverOccluded(boolean)>
<com.android.internal.policy.IKeyguardService: void onDreamingStopped()>
<com.android.internal.policy.IKeyguardService: void onFinishedBootAnim()>
<com.android.internal.policy.IKeyguardService: void onFinishedGoingToSleep(int,boolean)>
<com.android.internal.policy.IKeyguardService: void setKeyguardEnabled(boolean)>
<com.android.internal.policy.IKeyguardService: void onStartedGoingToSleep(int)>
<com.android.internal.policy.IKeyguardService: void setPendingIntentAfterUnlock(android.app.PendingIntent,android.content.Intent)>
<com.android.internal.policy.IKeyguardService: void onDreamingStarted()>
<com.android.internal.policy.IKeyguardService: void setSwitchingUser(boolean)>
<com.android.internal.policy.IKeyguardService: void onSystemReady()>
<com.android.internal.policy.IKeyguardService: void onScreenTurnedOn()>
<com.android.internal.policy.IKeyguardService: void startKeyguardExitAnimation(long,long)>
<com.android.internal.policy.IKeyguardService: void dismissKeyguardToLaunch(android.content.Intent)>
<com.android.internal.policy.IKeyguardService: void setDexOccluded(boolean)>
<com.android.internal.policy.IKeyguardService: void onScreenTurningOff()>
<com.android.internal.policy.IKeyguardService: void onScreenTurningOn(com.android.internal.policy.IKeyguardDrawnCallback)>
<com.android.internal.policy.IKeyguardService: void startFingerprintAuthentication()>
<com.android.internal.policy.IKeyguardService: void updateCoverLauncherAppWidget()>
<com.android.internal.policy.IKeyguardService: void setCurrentUser(int)>
<com.android.internal.policy.IKeyguardService: void addStateMonitorCallback(com.android.internal.policy.IKeyguardStateCallback)>
<com.android.internal.policy.IKeyguardService: void doKeyguardTimeout(android.os.Bundle)>
<com.android.internal.policy.IKeyguardService: void dismiss(com.android.internal.policy.IKeyguardDismissCallback,java.lang.CharSequence)>
<com.android.internal.policy.IKeyguardService: void verifyUnlock(com.android.internal.policy.IKeyguardExitCallback)>
<com.android.internal.policy.IKeyguardService: void startedEarlyWakingUp(int)>
<com.android.internal.policy.IKeyguardService: void onScreenTurnedOff()>
<com.android.internal.policy.IKeyguardService: void onFinishedWakingUp()>
<com.android.internal.policy.IKeyguardService: void setOccluded(boolean,boolean)>
<com.android.internal.policy.IKeyguardService: void onBootCompleted()>
<android.service.voice.ISandboxedDetectionService: void updateAudioFlinger(android.os.IBinder)>
<android.service.voice.ISandboxedDetectionService: void updateState(android.os.PersistableBundle,android.os.SharedMemory,android.os.IRemoteCallback)>
<android.service.voice.ISandboxedDetectionService: void updateContentCaptureManager(android.view.contentcapture.IContentCaptureManager,android.content.ContentCaptureOptions)>
<android.service.voice.ISandboxedDetectionService: void detectFromDspSource(android.hardware.soundtrigger.SoundTrigger$KeyphraseRecognitionEvent,android.media.AudioFormat,long,android.service.voice.IDspHotwordDetectionCallback)>
<android.service.voice.ISandboxedDetectionService: void detectWithVisualSignals(android.service.voice.IDetectorSessionVisualQueryDetectionCallback)>
<android.service.voice.ISandboxedDetectionService: void ping(android.os.IRemoteCallback)>
<android.service.voice.ISandboxedDetectionService: void updateRecognitionServiceManager(android.speech.IRecognitionServiceManager)>
<android.service.voice.ISandboxedDetectionService: void detectFromMicrophoneSource(android.os.ParcelFileDescriptor,int,android.media.AudioFormat,android.os.PersistableBundle,android.service.voice.IDspHotwordDetectionCallback)>
<android.service.voice.ISandboxedDetectionService: void stopDetection()>
<android.service.translation.ITranslationCallback: void onTranslationResponse(android.view.translation.TranslationResponse)>
<android.content.IRCPInterface: long moveUnlimitedFiles(int,int,android.net.Uri,com.samsung.android.knox.SemIRCPCallback)>
<android.content.IRCPInterface: android.os.Bundle getFileInfo(java.lang.String,int)>
<android.content.IRCPInterface: int moveFile(int,java.lang.String,int,java.lang.String)>
<android.content.IRCPInterface: boolean isFileExist(java.lang.String,int)>
<android.content.IRCPInterface: long moveUnlimitedFiles2(int,int,android.net.Uri,com.samsung.android.knox.SemIRCPCallback,java.lang.String)>
<android.content.IRCPInterface: void cancel(long)>
<android.content.IRCPInterface: java.lang.String getErrorMessage(int)>
<android.content.IRCPInterface: long moveFiles2(int,java.util.List,int,java.util.List,com.samsung.android.knox.SemIRCPCallback,java.lang.String)>
<android.content.IRCPInterface: long moveUnlimitedFilesForApp(int,android.net.Uri,int,int)>
<android.content.IRCPInterface: void cancelCopyChunks(long)>
<android.content.IRCPInterface: long copyFiles(int,java.util.List,int,java.util.List,com.samsung.android.knox.SemIRCPCallback)>
<android.content.IRCPInterface: java.util.List getFiles(java.lang.String,int)>
<android.content.IRCPInterface: long moveFilesForApp(int,java.util.List,java.util.List)>
<android.content.IRCPInterface: int copyFile(int,java.lang.String,int,java.lang.String)>
<android.content.IRCPInterface: long moveFilesForAppEx(int,java.util.List,java.util.List,int)>
<android.content.IRCPInterface: int copyChunks(int,java.lang.String,int,java.lang.String,long,int,long,boolean)>
<android.content.IRCPInterface: long copyFiles2(int,java.util.List,int,java.util.List,com.samsung.android.knox.SemIRCPCallback,java.lang.String)>
<android.content.IRCPInterface: long moveFiles(int,java.util.List,int,java.util.List,com.samsung.android.knox.SemIRCPCallback)>
<com.android.internal.widget.IUpdateVerifierInterface: void requestSaGuid(com.android.internal.widget.IUpdateVerifierCallback)>
<com.android.internal.widget.IUpdateVerifierInterface: void updateVerifier(byte[],byte[])>
<android.telephony.ims.aidl.IImsConfig: void notifyIntImsConfigChanged(int,int)>
<android.telephony.ims.aidl.IImsConfig: int getConfigInt(int)>
<android.telephony.ims.aidl.IImsConfig: int setConfigString(int,java.lang.String)>
<android.telephony.ims.aidl.IImsConfig: void triggerRcsReconfiguration()>
<android.telephony.ims.aidl.IImsConfig: void notifyRcsAutoConfigurationErrorReceived(int,java.lang.String)>
<android.telephony.ims.aidl.IImsConfig: void setRcsClientConfiguration(android.telephony.ims.RcsClientConfiguration)>
<android.telephony.ims.aidl.IImsConfig: void notifyStringImsConfigChanged(int,java.lang.String)>
<android.telephony.ims.aidl.IImsConfig: java.lang.String getConfigString(int)>
<android.telephony.ims.aidl.IImsConfig: void updateImsCarrierConfigs(android.os.PersistableBundle)>
<android.telephony.ims.aidl.IImsConfig: void addRcsConfigCallback(android.telephony.ims.aidl.IRcsConfigCallback)>
<android.telephony.ims.aidl.IImsConfig: void notifyProvisionedStringValueChanged(int,java.lang.String)>
<android.telephony.ims.aidl.IImsConfig: void notifyRcsPreConfigurationReceived(byte[])>
<android.telephony.ims.aidl.IImsConfig: void notifyRcsAutoConfigurationReceived(byte[],boolean)>
<android.telephony.ims.aidl.IImsConfig: void addImsConfigCallback(android.telephony.ims.aidl.IImsConfigCallback)>
<android.telephony.ims.aidl.IImsConfig: void removeImsConfigCallback(android.telephony.ims.aidl.IImsConfigCallback)>
<android.telephony.ims.aidl.IImsConfig: void notifyRcsAutoConfigurationRemoved()>
<android.telephony.ims.aidl.IImsConfig: int setConfigInt(int,int)>
<android.telephony.ims.aidl.IImsConfig: java.lang.String getRcsClientConfiguration(int)>
<android.telephony.ims.aidl.IImsConfig: void removeRcsConfigCallback(android.telephony.ims.aidl.IRcsConfigCallback)>
<android.telephony.ims.aidl.IImsConfig: void notifyProvisionedIntValueChanged(int,int)>
<android.hardware.tv.tuner.IFrontendCallback: java.lang.String getInterfaceHash()>
<android.hardware.tv.tuner.IFrontendCallback: void onScanMessage(int,android.hardware.tv.tuner.FrontendScanMessage)>
<android.hardware.tv.tuner.IFrontendCallback: int getInterfaceVersion()>
<android.hardware.tv.tuner.IFrontendCallback: void onEvent(int)>
<android.view.ISystemGestureExclusionListener: void onSystemGestureExclusionChanged(int,android.graphics.Region,android.graphics.Region)>
<android.hardware.tv.tuner.ILnbCallback: void onDiseqcMessage(byte[])>
<android.hardware.tv.tuner.ILnbCallback: java.lang.String getInterfaceHash()>
<android.hardware.tv.tuner.ILnbCallback: int getInterfaceVersion()>
<android.hardware.tv.tuner.ILnbCallback: void onEvent(int)>
<android.media.IAudioDeviceVolumeDispatcher: void dispatchDeviceVolumeChanged(android.media.AudioDeviceAttributes,android.media.VolumeInfo)>
<android.media.IAudioDeviceVolumeDispatcher: void dispatchDeviceVolumeAdjusted(android.media.AudioDeviceAttributes,android.media.VolumeInfo,int,int)>
<com.android.internal.policy.IKeyguardExitCallback: void onKeyguardExitResult(boolean)>
<android.hardware.radio.network.IRadioNetworkIndication: void emergencyNetworkScanResult(int,android.hardware.radio.network.EmergencyRegResult)>
<android.hardware.radio.network.IRadioNetworkIndication: void registrationFailed(int,android.hardware.radio.network.CellIdentity,java.lang.String,int,int,int)>
<android.hardware.radio.network.IRadioNetworkIndication: int getInterfaceVersion()>
<android.hardware.radio.network.IRadioNetworkIndication: void nitzTimeReceived(int,java.lang.String,long,long)>
<android.hardware.radio.network.IRadioNetworkIndication: java.lang.String getInterfaceHash()>
<android.hardware.radio.network.IRadioNetworkIndication: void imsNetworkStateChanged(int)>
<android.hardware.radio.network.IRadioNetworkIndication: void suppSvcNotify(int,android.hardware.radio.network.SuppSvcNotification)>
<android.hardware.radio.network.IRadioNetworkIndication: void networkScanResult(int,android.hardware.radio.network.NetworkScanResult)>
<android.hardware.radio.network.IRadioNetworkIndication: void currentPhysicalChannelConfigs(int,android.hardware.radio.network.PhysicalChannelConfig[])>
<android.hardware.radio.network.IRadioNetworkIndication: void voiceRadioTechChanged(int,int)>
<android.hardware.radio.network.IRadioNetworkIndication: void cellInfoList(int,android.hardware.radio.network.CellInfo[])>
<android.hardware.radio.network.IRadioNetworkIndication: void restrictedStateChanged(int,int)>
<android.hardware.radio.network.IRadioNetworkIndication: void currentSignalStrength(int,android.hardware.radio.network.SignalStrength)>
<android.hardware.radio.network.IRadioNetworkIndication: void cdmaPrlChanged(int,int)>
<android.hardware.radio.network.IRadioNetworkIndication: void networkStateChanged(int)>
<android.hardware.radio.network.IRadioNetworkIndication: void currentLinkCapacityEstimate(int,android.hardware.radio.network.LinkCapacityEstimate)>
<android.hardware.radio.network.IRadioNetworkIndication: void barringInfoChanged(int,android.hardware.radio.network.CellIdentity,android.hardware.radio.network.BarringInfo[])>
<android.companion.virtual.IVirtualDeviceIntentInterceptor: void onIntentIntercepted(android.content.Intent)>
<com.android.internal.view.inline.IInlineContentCallback: void onClick()>
<com.android.internal.view.inline.IInlineContentCallback: void onContent(android.view.SurfaceControlViewHost$SurfacePackage,int,int)>
<com.android.internal.view.inline.IInlineContentCallback: void onLongClick()>
<com.samsung.android.sepunion.IOneHandService: void writeSetting(java.lang.String,java.lang.String,int)>
<com.samsung.android.sepunion.IOneHandService: void clickTile(java.lang.String)>
<com.samsung.android.sepunion.IOneHandService: void registerListener(java.lang.String,android.os.IBinder)>
<com.samsung.android.sepunion.IOneHandService: void unRegisterListener(java.lang.String,android.os.IBinder)>
<android.hardware.tv.tuner.ITimeFilter: void clearTimeStamp()>
<android.hardware.tv.tuner.ITimeFilter: long getSourceTime()>
<android.hardware.tv.tuner.ITimeFilter: void close()>
<android.hardware.tv.tuner.ITimeFilter: void setTimeStamp(long)>
<android.hardware.tv.tuner.ITimeFilter: int getInterfaceVersion()>
<android.hardware.tv.tuner.ITimeFilter: java.lang.String getInterfaceHash()>
<android.hardware.tv.tuner.ITimeFilter: long getTimeStamp()>
<android.os.storage.IStorageShutdownObserver: void onShutDownComplete(int)>
<android.telephony.ims.aidl.IRcsUceControllerCallback: void onComplete(android.telephony.ims.SipDetails)>
<android.telephony.ims.aidl.IRcsUceControllerCallback: void onCapabilitiesReceived(java.util.List)>
<android.telephony.ims.aidl.IRcsUceControllerCallback: void onError(int,long,android.telephony.ims.SipDetails)>
<android.service.appprediction.IPredictionService: void unregisterPredictionUpdates(android.app.prediction.AppPredictionSessionId,android.app.prediction.IPredictionCallback)>
<android.service.appprediction.IPredictionService: void notifyAppTargetEvent(android.app.prediction.AppPredictionSessionId,android.app.prediction.AppTargetEvent)>
<android.service.appprediction.IPredictionService: void requestPredictionUpdate(android.app.prediction.AppPredictionSessionId)>
<android.service.appprediction.IPredictionService: void sortAppTargets(android.app.prediction.AppPredictionSessionId,android.content.pm.ParceledListSlice,android.app.prediction.IPredictionCallback)>
<android.service.appprediction.IPredictionService: void registerPredictionUpdates(android.app.prediction.AppPredictionSessionId,android.app.prediction.IPredictionCallback)>
<android.service.appprediction.IPredictionService: void onDestroyPredictionSession(android.app.prediction.AppPredictionSessionId)>
<android.service.appprediction.IPredictionService: void onCreatePredictionSession(android.app.prediction.AppPredictionContext,android.app.prediction.AppPredictionSessionId)>
<android.service.appprediction.IPredictionService: void notifyLaunchLocationShown(android.app.prediction.AppPredictionSessionId,java.lang.String,android.content.pm.ParceledListSlice)>
<android.net.wifi.nl80211.IWifiScannerImpl: void unsubscribePnoScanEvents()>
<android.net.wifi.nl80211.IWifiScannerImpl: boolean scan(android.net.wifi.nl80211.SingleScanSettings)>
<android.net.wifi.nl80211.IWifiScannerImpl: int scanRequest(android.net.wifi.nl80211.SingleScanSettings)>
<android.net.wifi.nl80211.IWifiScannerImpl: boolean startPnoScan(android.net.wifi.nl80211.PnoSettings)>
<android.net.wifi.nl80211.IWifiScannerImpl: void subscribeScanEvents(android.net.wifi.nl80211.IScanEvent)>
<android.net.wifi.nl80211.IWifiScannerImpl: void abortScan()>
<android.net.wifi.nl80211.IWifiScannerImpl: android.net.wifi.nl80211.NativeScanResult[] getPnoScanResults()>
<android.net.wifi.nl80211.IWifiScannerImpl: void unsubscribeScanEvents()>
<android.net.wifi.nl80211.IWifiScannerImpl: void disableRandomMac()>
<android.net.wifi.nl80211.IWifiScannerImpl: android.net.wifi.nl80211.NativeScanResult[] getScanResults()>
<android.net.wifi.nl80211.IWifiScannerImpl: void subscribePnoScanEvents(android.net.wifi.nl80211.IPnoScanEvent)>
<android.net.wifi.nl80211.IWifiScannerImpl: int getMaxSsidsPerScan()>
<android.net.wifi.nl80211.IWifiScannerImpl: boolean stopPnoScan()>
<android.hardware.ISensorPrivacyListener: void onSensorPrivacyChanged(int,int,boolean)>
<com.android.internal.statusbar.IAddTileResultCallback: void onTileRequest(int)>
<android.telephony.INetworkServiceCallback: void onNetworkStateChanged()>
<android.telephony.INetworkServiceCallback: void onRequestNetworkRegistrationInfoComplete(int,android.telephony.NetworkRegistrationInfo)>
<com.android.internal.appwidget.IAppWidgetService: void changeHostIds(java.lang.String,int[],int)>
<com.android.internal.appwidget.IAppWidgetService: android.content.IntentSender semCreateAppWidgetConfigIntentSender(java.lang.String,int,int)>
<com.android.internal.appwidget.IAppWidgetService: android.content.pm.ParceledListSlice getInstalledProvidersForProfile(int,int,java.lang.String)>
<com.android.internal.appwidget.IAppWidgetService: void deleteAllHosts()>
<com.android.internal.appwidget.IAppWidgetService: void setAppWidgetHidden(java.lang.String,int)>
<com.android.internal.appwidget.IAppWidgetService: java.util.Map getAllWidgets(java.lang.String,int)>
<com.android.internal.appwidget.IAppWidgetService: boolean hasBindAppWidgetPermission(java.lang.String,int)>
<com.android.internal.appwidget.IAppWidgetService: int[] getAppWidgetIdsForHost(java.lang.String,int)>
<com.android.internal.appwidget.IAppWidgetService: java.util.List getAllProvidersForProfile(int,int,boolean)>
<com.android.internal.appwidget.IAppWidgetService: boolean isBoundWidgetPackage(java.lang.String,int)>
<com.android.internal.appwidget.IAppWidgetService: void updateAppWidgetProvider(android.content.ComponentName,android.widget.RemoteViews)>
<com.android.internal.appwidget.IAppWidgetService: android.content.pm.ParceledListSlice startListening(com.android.internal.appwidget.IAppWidgetHost,java.lang.String,int,int[])>
<com.android.internal.appwidget.IAppWidgetService: void stopListening(java.lang.String,int)>
<com.android.internal.appwidget.IAppWidgetService: void updateAppWidgetOptions(java.lang.String,int,android.os.Bundle)>
<com.android.internal.appwidget.IAppWidgetService: void notifyProviderInheritance(android.content.ComponentName[])>
<com.android.internal.appwidget.IAppWidgetService: boolean requestPinAppWidget(java.lang.String,android.content.ComponentName,android.os.Bundle,android.content.IntentSender)>
<com.android.internal.appwidget.IAppWidgetService: android.content.IntentSender createAppWidgetConfigIntentSender(java.lang.String,int,int)>
<com.android.internal.appwidget.IAppWidgetService: void updateAppWidgetIds(java.lang.String,int[],android.widget.RemoteViews)>
<com.android.internal.appwidget.IAppWidgetService: void noteAppWidgetTapped(java.lang.String,int)>
<com.android.internal.appwidget.IAppWidgetService: int allocateAppWidgetId(java.lang.String,int)>
<com.android.internal.appwidget.IAppWidgetService: android.os.Bundle getAppWidgetOptions(java.lang.String,int)>
<com.android.internal.appwidget.IAppWidgetService: boolean bindRemoteViewsService(java.lang.String,int,android.content.Intent,android.app.IApplicationThread,android.os.IBinder,android.app.IServiceConnection,long)>
<com.android.internal.appwidget.IAppWidgetService: void setBindAppWidgetPermission(java.lang.String,int,boolean)>
<com.android.internal.appwidget.IAppWidgetService: android.appwidget.AppWidgetProviderInfo getAppWidgetInfo(java.lang.String,int)>
<com.android.internal.appwidget.IAppWidgetService: void notifyAppWidgetViewDataChanged(java.lang.String,int[],int)>
<com.android.internal.appwidget.IAppWidgetService: void partiallyUpdateAppWidgetIds(java.lang.String,int[],android.widget.RemoteViews)>
<com.android.internal.appwidget.IAppWidgetService: boolean isRequestPinAppWidgetSupported()>
<com.android.internal.appwidget.IAppWidgetService: android.widget.RemoteViews getAppWidgetViews(java.lang.String,int)>
<com.android.internal.appwidget.IAppWidgetService: int[] getAppWidgetIds(android.content.ComponentName)>
<com.android.internal.appwidget.IAppWidgetService: boolean bindAppWidgetId(java.lang.String,int,int,android.content.ComponentName,android.os.Bundle)>
<com.android.internal.appwidget.IAppWidgetService: void updateAppWidgetProviderInfo(android.content.ComponentName,java.lang.String)>
<com.android.internal.appwidget.IAppWidgetService: void deleteAppWidgetId(java.lang.String,int)>
<com.android.internal.appwidget.IAppWidgetService: void deleteHost(java.lang.String,int)>
<android.service.voice.IVisualQueryDetectionVoiceInteractionCallback: void onQueryRejected()>
<android.service.voice.IVisualQueryDetectionVoiceInteractionCallback: void onQueryDetected(java.lang.String)>
<android.service.voice.IVisualQueryDetectionVoiceInteractionCallback: void onVisualQueryDetectionServiceFailure(android.service.voice.VisualQueryDetectionServiceFailure)>
<android.service.voice.IVisualQueryDetectionVoiceInteractionCallback: void onQueryFinished()>
<com.samsung.android.content.smartclip.IBleSpenChargeLockStateChangedListener: void onChanged(boolean)>
<android.speech.IRecognitionSupportCallback: void onError(int)>
<android.speech.IRecognitionSupportCallback: void onSupportResult(android.speech.RecognitionSupport)>
<android.media.IRecordingConfigDispatcher: void dispatchRecordingConfigChange(java.util.List)>
<com.android.internal.telephony.IOnSubscriptionsChangedListener: void onSubscriptionsChanged()>
<android.media.IStrategyNonDefaultDevicesDispatcher: void dispatchNonDefDevicesChanged(int,java.util.List)>
<android.location.IGnssAntennaInfoListener: void onGnssAntennaInfoChanged(java.util.List)>
<android.hardware.biometrics.IBiometricAuthenticator: android.hardware.biometrics.ITestSession createTestSession(android.hardware.biometrics.ITestSessionCallback,java.lang.String)>
<android.hardware.biometrics.IBiometricAuthenticator: byte[] dumpSensorServiceStateProto(boolean)>
<android.hardware.biometrics.IBiometricAuthenticator: void cancelAuthenticationFromService(android.os.IBinder,java.lang.String,long)>
<android.hardware.biometrics.IBiometricAuthenticator: boolean hasEnrolledTemplates(int,java.lang.String)>
<android.hardware.biometrics.IBiometricAuthenticator: void startPreparedClient(int)>
<android.hardware.biometrics.IBiometricAuthenticator: long getAuthenticatorId(int)>
<android.hardware.biometrics.IBiometricAuthenticator: void prepareForAuthentication(boolean,android.os.IBinder,long,int,android.hardware.biometrics.IBiometricSensorReceiver,java.lang.String,long,int,boolean)>
<android.hardware.biometrics.IBiometricAuthenticator: android.hardware.biometrics.SensorPropertiesInternal getSensorProperties(java.lang.String)>
<android.hardware.biometrics.IBiometricAuthenticator: void invalidateAuthenticatorId(int,android.hardware.biometrics.IInvalidationCallback)>
<android.hardware.biometrics.IBiometricAuthenticator: boolean isHardwareDetected(java.lang.String)>
<android.hardware.biometrics.IBiometricAuthenticator: void resetLockout(android.os.IBinder,java.lang.String,int,byte[])>
<android.hardware.biometrics.IBiometricAuthenticator: int getLockoutModeForUser(int)>
<com.samsung.android.onehandop.IOneHandOpWatcher: void onInputFilterChanged()>
<com.samsung.android.onehandop.IOneHandOpWatcher: void onMagnificationSpecChanged()>
<android.service.credentials.IBeginGetCredentialCallback: void onFailure(java.lang.String,java.lang.CharSequence)>
<android.service.credentials.IBeginGetCredentialCallback: void onCancellable(android.os.ICancellationSignal)>
<android.service.credentials.IBeginGetCredentialCallback: void onSuccess(android.service.credentials.BeginGetCredentialResponse)>
<android.window.ITaskFragmentOrganizerController: void onTransactionHandled(android.os.IBinder,android.window.WindowContainerTransaction,int,boolean)>
<android.window.ITaskFragmentOrganizerController: void unregisterOrganizer(android.window.ITaskFragmentOrganizer)>
<android.window.ITaskFragmentOrganizerController: boolean isSupportActivityEmbedded(java.lang.String)>
<android.window.ITaskFragmentOrganizerController: void unregisterRemoteAnimations(android.window.ITaskFragmentOrganizer)>
<android.window.ITaskFragmentOrganizerController: boolean isActivityEmbedded(android.os.IBinder)>
<android.window.ITaskFragmentOrganizerController: void registerRemoteAnimations(android.window.ITaskFragmentOrganizer,android.view.RemoteAnimationDefinition)>
<android.window.ITaskFragmentOrganizerController: void registerOrganizer(android.window.ITaskFragmentOrganizer)>
<android.window.ITaskFragmentOrganizerController: void applyTransaction(android.window.WindowContainerTransaction,int,boolean)>
<com.samsung.android.cover.ICoverStateListenerCallback: void onCoverAttachStateChanged(boolean)>
<com.samsung.android.cover.ICoverStateListenerCallback: void onCoverSwitchStateChanged(boolean)>
<com.samsung.android.cover.ICoverStateListenerCallback: java.lang.String getListenerInfo()>
<android.service.voice.IVoiceInteractionSession: void hide()>
<android.service.voice.IVoiceInteractionSession: void notifyVisibleActivityInfoChanged(android.service.voice.VisibleActivityInfo,int)>
<android.service.voice.IVoiceInteractionSession: void handleAssist(int,android.os.IBinder,android.os.Bundle,android.app.assist.AssistStructure,android.app.assist.AssistContent,int,int)>
<android.service.voice.IVoiceInteractionSession: void show(android.os.Bundle,int,com.android.internal.app.IVoiceInteractionSessionShowCallback)>
<android.service.voice.IVoiceInteractionSession: void taskStarted(android.content.Intent,int)>
<android.service.voice.IVoiceInteractionSession: void handleScreenshot(android.graphics.Bitmap)>
<android.service.voice.IVoiceInteractionSession: void taskFinished(android.content.Intent,int)>
<android.service.voice.IVoiceInteractionSession: void destroy()>
<android.service.voice.IVoiceInteractionSession: void closeSystemDialogs()>
<android.service.voice.IVoiceInteractionSession: void onLockscreenShown()>
<android.print.IWriteResultCallback: void onWriteStarted(android.os.ICancellationSignal,int)>
<android.print.IWriteResultCallback: void onWriteFailed(java.lang.CharSequence,int)>
<android.print.IWriteResultCallback: void onWriteFinished(android.print.PageRange[],int)>
<android.print.IWriteResultCallback: void onWriteCanceled(int)>
<com.android.internal.telephony.euicc.IRetrieveNotificationCallback: void onComplete(int,android.telephony.euicc.EuiccNotification)>
<android.app.ILocalWallpaperColorConsumer: void onColorsChanged(android.graphics.RectF,android.app.WallpaperColors)>
<android.os.IStatsBootstrapAtomService: void reportBootstrapAtom(android.os.StatsBootstrapAtom)>
<android.net.INetdEventCallback: void onPrivateDnsValidationEvent(int,java.lang.String,java.lang.String,boolean)>
<android.net.INetdEventCallback: void onConnectEvent(java.lang.String,int,long,int)>
<android.net.INetdEventCallback: void onDnsEvent(int,int,int,java.lang.String,java.lang.String[],int,long,int)>
<android.net.INetdEventCallback: void onNat64PrefixEvent(int,boolean,java.lang.String,int)>
<android.os.IVold: boolean isSensitive(java.lang.String)>
<android.os.IVold: void prepareUserStorage(java.lang.String,int,int,int)>
<android.os.IVold: void asecDestroy(java.lang.String,boolean)>
<android.os.IVold: void markBootAttempt()>
<android.os.IVold: void unlockUserKey(int,int,java.lang.String,java.lang.String)>
<android.os.IVold: void initUser0()>
<android.os.IVold: void ensureAppDirsCreated(java.lang.String[],int)>
<android.os.IVold: boolean incFsEnabled()>
<android.os.IVold: void unmountAppFuse(int,int)>
<android.os.IVold: void cpFileAtData(java.lang.String,java.lang.String,int,int,android.os.IVoldTaskListener)>
<android.os.IVold: boolean needsCheckpoint()>
<android.os.IVold: int asecGetUsedSpace(java.lang.String)>
<android.os.IVold: void setUserKeyProtection(int,java.lang.String)>
<android.os.IVold: void earlyBootEnded()>
<android.os.IVold: void asecFixperms(java.lang.String,int,java.lang.String)>
<android.os.IVold: void remountUid(int,int)>
<android.os.IVold: void startCheckpoint(int)>
<android.os.IVold: void addAppIds(java.lang.String[],int[])>
<android.os.IVold: void setStorageBindingSeed(byte[])>
<android.os.IVold: void resetCheckpoint()>
<android.os.IVold: void restoreCheckpoint(java.lang.String)>
<android.os.IVold: void reset()>
<android.os.IVold: boolean setSensitive(int,java.lang.String)>
<android.os.IVold: void forgetPartition(java.lang.String,java.lang.String)>
<android.os.IVold: void asecUnmount(java.lang.String,boolean)>
<android.os.IVold: int getWriteAmount()>
<android.os.IVold: void asecResize(java.lang.String,int,java.lang.String)>
<android.os.IVold: void prepareCheckpoint()>
<android.os.IVold: java.lang.String asecPath(java.lang.String)>
<android.os.IVold: void unmountIncFs(java.lang.String)>
<android.os.IVold: boolean supportsFileCheckpoint()>
<android.os.IVold: boolean supportsCheckpoint()>
<android.os.IVold: void abortChanges(java.lang.String,boolean)>
<android.os.IVold: void remountAppStorageDirs(int,int,java.lang.String[])>
<android.os.IVold: void destroyUserStorage(java.lang.String,int,int)>
<android.os.IVold: int getStorageLifeTime()>
<android.os.IVold: void addSandboxIds(int[],java.lang.String[])>
<android.os.IVold: boolean isCheckpointing()>
<android.os.IVold: void onUserStarted(int)>
<android.os.IVold: android.os.incremental.IncrementalFileSystemControlParcel mountIncFs(java.lang.String,java.lang.String,int,java.lang.String)>
<android.os.IVold: void setMpUidForFileSystem(int)>
<android.os.IVold: void setIncFsMountOptions(android.os.incremental.IncrementalFileSystemControlParcel,boolean,boolean,java.lang.String)>
<android.os.IVold: java.lang.String createObb(java.lang.String,int)>
<android.os.IVold: void mount(java.lang.String,int,int,android.os.IVoldMountCallback)>
<android.os.IVold: void partition(java.lang.String,int,int)>
<android.os.IVold: boolean setDualDARPolicyCmd(int,int)>
<android.os.IVold: void asecRename(java.lang.String,java.lang.String)>
<android.os.IVold: void destroySandboxForApp(java.lang.String,java.lang.String,int)>
<android.os.IVold: java.io.FileDescriptor openAppFuseFile(int,int,int,int)>
<android.os.IVold: void fbeEnable()>
<android.os.IVold: void unmount(java.lang.String)>
<android.os.IVold: void commitChanges()>
<android.os.IVold: void fixupAppDir(java.lang.String,int)>
<android.os.IVold: boolean mountSdpMediaStorageCmd(int)>
<android.os.IVold: void sdeMoveMountHidden(java.lang.String,int,int,android.os.IVoldMountCallback)>
<android.os.IVold: void destroyUserKey(int)>
<android.os.IVold: void setGCUrgentPace(int,int,float,float,int,int,int)>
<android.os.IVold: void sdeEnable(java.lang.String,int,int,boolean,android.os.IVoldTaskListener,android.os.IVoldMountCallback)>
<android.os.IVold: java.io.FileDescriptor mountAppFuse(int,int)>
<android.os.IVold: java.lang.String asecFsPath(java.lang.String)>
<android.os.IVold: int[] getUnlockedUsers()>
<android.os.IVold: void setupAppDir(java.lang.String,int)>
<android.os.IVold: void asecTrim(java.lang.String,int,java.lang.String)>
<android.os.IVold: void onUserAdded(int,int,int)>
<android.os.IVold: void moveStorage(java.lang.String,java.lang.String,android.os.IVoldTaskListener)>
<android.os.IVold: void unmountAppStorageDirs(int,int,java.lang.String[])>
<android.os.IVold: void asecFinalize(java.lang.String)>
<android.os.IVold: void mvFileAtData(java.lang.String,java.lang.String,int,int,android.os.IVoldTaskListener)>
<android.os.IVold: void asecMount(java.lang.String,java.lang.String,int,boolean)>
<android.os.IVold: void shutdown()>
<android.os.IVold: void destroyStubVolume(java.lang.String)>
<android.os.IVold: void refreshLatestWrite()>
<android.os.IVold: void lockUserKey(int)>
<android.os.IVold: void onUserStopped(int)>
<android.os.IVold: boolean setSdpPolicyToPathCmd(int,java.lang.String)>
<android.os.IVold: void encryptFstab(java.lang.String,java.lang.String,boolean,java.lang.String,java.lang.String)>
<android.os.IVold: java.lang.String createStubVolume(java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,int)>
<android.os.IVold: void mountFstab(java.lang.String,java.lang.String,java.lang.String)>
<android.os.IVold: void onUserRemoved(int)>
<android.os.IVold: void destroyDsuMetadataKey(java.lang.String)>
<android.os.IVold: boolean supportsBlockCheckpoint()>
<android.os.IVold: boolean setSdpPolicyCmd(int)>
<android.os.IVold: void abortIdleMaint(android.os.IVoldTaskListener)>
<android.os.IVold: void asecCreate(java.lang.String,int,java.lang.String,java.lang.String,int,boolean)>
<android.os.IVold: void runIdleMaint(boolean,android.os.IVoldTaskListener)>
<android.os.IVold: void restoreCheckpointPart(java.lang.String,int)>
<android.os.IVold: void fstrim(int,android.os.IVoldTaskListener)>
<android.os.IVold: void bindMount(java.lang.String,java.lang.String)>
<android.os.IVold: void abortFuse()>
<android.os.IVold: void setListener(android.os.IVoldListener)>
<android.os.IVold: void format(java.lang.String,java.lang.String)>
<android.os.IVold: void onSecureKeyguardStateChanged(boolean)>
<android.os.IVold: java.lang.String[] asecList()>
<android.os.IVold: void prepareSandboxForApp(java.lang.String,int,java.lang.String,int)>
<android.os.IVold: boolean needsRollback()>
<android.os.IVold: void benchmark(java.lang.String,android.os.IVoldTaskListener)>
<android.os.IVold: void createUserKey(int,int,boolean)>
<android.os.IVold: void setDebugForExternal(java.lang.String)>
<android.os.IVold: void destroyObb(java.lang.String)>
<android.os.IVold: void monitor()>
<android.os.IVold: long getUsedF2fsFileNode()>
<android.app.ITransientNotification: void show(android.os.IBinder)>
<android.app.ITransientNotification: void hide()>
<android.service.remotelockscreenvalidation.IRemoteLockscreenValidationService: void validateLockscreenGuess(byte[],android.service.remotelockscreenvalidation.IRemoteLockscreenValidationCallback)>
<android.os.IWakeLockCallback: void onStateChanged(boolean)>
<com.android.internal.telephony.euicc.ISwitchToProfileCallback: void onComplete(int,android.service.euicc.EuiccProfileInfo)>
<android.hardware.gnss.measurement_corrections.IMeasurementCorrectionsInterface: java.lang.String getInterfaceHash()>
<android.hardware.gnss.measurement_corrections.IMeasurementCorrectionsInterface: int getInterfaceVersion()>
<android.hardware.gnss.measurement_corrections.IMeasurementCorrectionsInterface: void setCallback(android.hardware.gnss.measurement_corrections.IMeasurementCorrectionsCallback)>
<android.hardware.gnss.measurement_corrections.IMeasurementCorrectionsInterface: void setCorrections(android.hardware.gnss.measurement_corrections.MeasurementCorrections)>
<android.hardware.security.keymint.IKeyMintDevice: int getInterfaceVersion()>
<android.hardware.security.keymint.IKeyMintDevice: android.hardware.security.keymint.BeginResult begin(int,byte[],android.hardware.security.keymint.KeyParameter[],android.hardware.security.keymint.HardwareAuthToken)>
<android.hardware.security.keymint.IKeyMintDevice: void deleteKey(byte[])>
<android.hardware.security.keymint.IKeyMintDevice: void earlyBootEnded()>
<android.hardware.security.keymint.IKeyMintDevice: android.hardware.security.keymint.KeyCharacteristics[] getKeyCharacteristics(byte[],byte[],byte[])>
<android.hardware.security.keymint.IKeyMintDevice: void destroyAttestationIds()>
<android.hardware.security.keymint.IKeyMintDevice: java.lang.String getInterfaceHash()>
<android.hardware.security.keymint.IKeyMintDevice: void sendRootOfTrust(byte[])>
<android.hardware.security.keymint.IKeyMintDevice: android.hardware.security.keymint.KeyMintHardwareInfo getHardwareInfo()>
<android.hardware.security.keymint.IKeyMintDevice: byte[] getRootOfTrustChallenge()>
<android.hardware.security.keymint.IKeyMintDevice: void deviceLocked(boolean,android.hardware.security.secureclock.TimeStampToken)>
<android.hardware.security.keymint.IKeyMintDevice: byte[] upgradeKey(byte[],android.hardware.security.keymint.KeyParameter[])>
<android.hardware.security.keymint.IKeyMintDevice: android.hardware.security.keymint.KeyCreationResult importWrappedKey(byte[],byte[],byte[],android.hardware.security.keymint.KeyParameter[],long,long)>
<android.hardware.security.keymint.IKeyMintDevice: void deleteAllKeys()>
<android.hardware.security.keymint.IKeyMintDevice: byte[] convertStorageKeyToEphemeral(byte[])>
<android.hardware.security.keymint.IKeyMintDevice: android.hardware.security.keymint.KeyCreationResult generateKey(android.hardware.security.keymint.KeyParameter[],android.hardware.security.keymint.AttestationKey)>
<android.hardware.security.keymint.IKeyMintDevice: void addRngEntropy(byte[])>
<android.hardware.security.keymint.IKeyMintDevice: byte[] getRootOfTrust(byte[])>
<android.hardware.security.keymint.IKeyMintDevice: android.hardware.security.keymint.KeyCreationResult importKey(android.hardware.security.keymint.KeyParameter[],int,byte[],android.hardware.security.keymint.AttestationKey)>
<com.samsung.android.media.codec.IVideoTranscodingService: void stopTask(java.lang.String)>
<com.samsung.android.media.codec.IVideoTranscodingService: void startTask(java.lang.String)>
<com.samsung.android.media.codec.IVideoTranscodingService: java.lang.String register(int,com.samsung.android.media.codec.IVideoTranscodingServiceCallback)>
<android.media.IPlaybackConfigDispatcher: void dispatchPlaybackConfigChange(java.util.List,boolean)>
<android.location.IGnssNavigationMessageListener: void onStatusChanged(int)>
<android.location.IGnssNavigationMessageListener: void onGnssNavigationMessageReceived(android.location.GnssNavigationMessage)>
<com.samsung.android.wifi.ISemWifiApDataUsageCallback: void onDataUsageChanged(java.lang.String)>
<com.android.internal.telecom.ICallEventCallback: void onMuteStateChanged(java.lang.String,boolean)>
<com.android.internal.telecom.ICallEventCallback: void onCallEndpointChanged(java.lang.String,android.telecom.CallEndpoint)>
<com.android.internal.telecom.ICallEventCallback: void onEvent(java.lang.String,java.lang.String,android.os.Bundle)>
<com.android.internal.telecom.ICallEventCallback: void removeCallFromTransactionalServiceWrapper(java.lang.String)>
<com.android.internal.telecom.ICallEventCallback: void onDisconnect(java.lang.String,android.telecom.DisconnectCause,android.os.ResultReceiver)>
<com.android.internal.telecom.ICallEventCallback: void onCallStreamingFailed(java.lang.String,int)>
<com.android.internal.telecom.ICallEventCallback: void onCallStreamingStarted(java.lang.String,android.os.ResultReceiver)>
<com.android.internal.telecom.ICallEventCallback: void onSetActive(java.lang.String,android.os.ResultReceiver)>
<com.android.internal.telecom.ICallEventCallback: void onAddCallControl(java.lang.String,int,com.android.internal.telecom.ICallControl,android.telecom.CallException)>
<com.android.internal.telecom.ICallEventCallback: void onAnswer(java.lang.String,int,android.os.ResultReceiver)>
<com.android.internal.telecom.ICallEventCallback: void onSetInactive(java.lang.String,android.os.ResultReceiver)>
<com.android.internal.telecom.ICallEventCallback: void onAvailableCallEndpointsChanged(java.lang.String,java.util.List)>
<android.hardware.camera2.ICameraInjectionSession: void stopInjection()>
<android.view.accessibility.IWindowMagnificationConnectionCallback: void onSourceBoundsChanged(int,android.graphics.Rect)>
<android.view.accessibility.IWindowMagnificationConnectionCallback: void onAccessibilityActionPerformed(int)>
<android.view.accessibility.IWindowMagnificationConnectionCallback: void onChangeMagnificationMode(int,int)>
<android.view.accessibility.IWindowMagnificationConnectionCallback: void onPerformScaleAction(int,float)>
<android.view.accessibility.IWindowMagnificationConnectionCallback: void onMove(int)>
<android.view.accessibility.IWindowMagnificationConnectionCallback: void onWindowMagnifierBoundsChanged(int,android.graphics.Rect)>
<com.android.internal.telephony.euicc.ISetDefaultSmdpAddressCallback: void onComplete(int)>
<com.samsung.cmfa.AuthTouch.IAuthFactorTouchService: void registerAuthTouchEnableListener(com.samsung.cmfa.AuthTouch.IAuthTouchEnableListener)>
<com.samsung.cmfa.AuthTouch.IAuthFactorTouchService: void unregisterAuthTouchEventListener(com.samsung.cmfa.AuthTouch.IAuthTouchEventListener)>
<com.samsung.cmfa.AuthTouch.IAuthFactorTouchService: void unregisterAuthTouchEnableListener(com.samsung.cmfa.AuthTouch.IAuthTouchEnableListener)>
<com.samsung.cmfa.AuthTouch.IAuthFactorTouchService: void setTouchEvent(boolean,boolean)>
<com.samsung.cmfa.AuthTouch.IAuthFactorTouchService: void onPointerEvent(android.view.MotionEvent)>
<com.samsung.cmfa.AuthTouch.IAuthFactorTouchService: void registerAuthTouchEventListener(com.samsung.cmfa.AuthTouch.IAuthTouchEventListener)>
<com.samsung.android.bio.fingerprint.ISemFingerprintRequestCallback: void onResult(int)>
<android.content.pm.ILauncherApps: void changePackageIcon(java.lang.String,int)>
<android.content.pm.ILauncherApps: android.content.pm.LauncherApps$AppUsageLimit getAppUsageLimit(java.lang.String,java.lang.String,android.os.UserHandle)>
<android.content.pm.ILauncherApps: void registerDumpCallback(android.window.IDumpCallback)>
<android.content.pm.ILauncherApps: android.os.ParcelFileDescriptor getShortcutIconFd(java.lang.String,java.lang.String,java.lang.String,int)>
<android.content.pm.ILauncherApps: void cacheShortcuts(java.lang.String,java.lang.String,java.util.List,android.os.UserHandle,int)>
<android.content.pm.ILauncherApps: android.content.pm.ParceledListSlice getShortcutConfigActivities(java.lang.String,java.lang.String,android.os.UserHandle)>
<android.content.pm.ILauncherApps: boolean hasShortcutHostPermission(java.lang.String)>
<android.content.pm.ILauncherApps: android.content.pm.ParceledListSlice getLauncherActivities(java.lang.String,java.lang.String,android.os.UserHandle)>
<android.content.pm.ILauncherApps: void removeOnAppsChangedListener(android.content.pm.IOnAppsChangedListener)>
<android.content.pm.ILauncherApps: boolean shouldHideFromSuggestions(java.lang.String,android.os.UserHandle)>
<android.content.pm.ILauncherApps: boolean isPackageEnabled(java.lang.String,java.lang.String,android.os.UserHandle)>
<android.content.pm.ILauncherApps: android.content.pm.ParceledListSlice getAllSessions(java.lang.String)>
<android.content.pm.ILauncherApps: void showAppDetailsAsUser(android.app.IApplicationThread,java.lang.String,java.lang.String,android.content.ComponentName,android.graphics.Rect,android.os.Bundle,android.os.UserHandle)>
<android.content.pm.ILauncherApps: void registerShortcutChangeCallback(java.lang.String,android.content.pm.ShortcutQueryWrapper,android.content.pm.IShortcutChangeCallback)>
<android.content.pm.ILauncherApps: void getShortcutsAsync(java.lang.String,android.content.pm.ShortcutQueryWrapper,android.os.UserHandle,com.android.internal.infra.AndroidFuture)>
<android.content.pm.ILauncherApps: boolean startShortcut(java.lang.String,java.lang.String,java.lang.String,java.lang.String,android.graphics.Rect,android.os.Bundle,int)>
<android.content.pm.ILauncherApps: void startSessionDetailsActivityAsUser(android.app.IApplicationThread,java.lang.String,java.lang.String,android.content.pm.PackageInstaller$SessionInfo,android.graphics.Rect,android.os.Bundle,android.os.UserHandle)>
<android.content.pm.ILauncherApps: android.os.Bundle getSuspendedPackageLauncherExtras(java.lang.String,android.os.UserHandle)>
<android.content.pm.ILauncherApps: void registerPackageInstallerCallback(java.lang.String,android.content.pm.IPackageInstallerCallback)>
<android.content.pm.ILauncherApps: void unregisterShortcutChangeCallback(java.lang.String,android.content.pm.IShortcutChangeCallback)>
<android.content.pm.ILauncherApps: android.content.pm.ApplicationInfo getApplicationInfo(java.lang.String,java.lang.String,int,android.os.UserHandle)>
<android.content.pm.ILauncherApps: int getShortcutIconResId(java.lang.String,java.lang.String,java.lang.String,int)>
<android.content.pm.ILauncherApps: android.content.IntentSender getShortcutConfigActivityIntent(java.lang.String,android.content.ComponentName,android.os.UserHandle)>
<android.content.pm.ILauncherApps: boolean isActivityEnabled(java.lang.String,android.content.ComponentName,android.os.UserHandle)>
<android.content.pm.ILauncherApps: java.lang.String getShortcutIconUri(java.lang.String,java.lang.String,java.lang.String,int)>
<android.content.pm.ILauncherApps: android.content.pm.LauncherActivityInfoInternal resolveLauncherActivityInternal(java.lang.String,android.content.ComponentName,android.os.UserHandle)>
<android.content.pm.ILauncherApps: void pinShortcuts(java.lang.String,java.lang.String,java.util.List,android.os.UserHandle)>
<android.content.pm.ILauncherApps: void startActivityAsUser(android.app.IApplicationThread,java.lang.String,java.lang.String,android.content.ComponentName,android.graphics.Rect,android.os.Bundle,android.os.UserHandle)>
<android.content.pm.ILauncherApps: android.app.PendingIntent getActivityLaunchIntent(java.lang.String,android.content.ComponentName,android.os.UserHandle)>
<android.content.pm.ILauncherApps: java.util.Map getActivityOverrides(java.lang.String,int)>
<android.content.pm.ILauncherApps: void addOnAppsChangedListener(java.lang.String,android.content.pm.IOnAppsChangedListener)>
<android.content.pm.ILauncherApps: void unRegisterDumpCallback(android.window.IDumpCallback)>
<android.content.pm.ILauncherApps: void uncacheShortcuts(java.lang.String,java.lang.String,java.util.List,android.os.UserHandle,int)>
<android.content.pm.ILauncherApps: android.app.PendingIntent getShortcutIntent(java.lang.String,java.lang.String,java.lang.String,android.os.Bundle,android.os.UserHandle)>
<android.content.pm.ILauncherApps: android.content.pm.ParceledListSlice getShortcuts(java.lang.String,android.content.pm.ShortcutQueryWrapper,android.os.UserHandle)>
<com.samsung.android.knox.ISemRemoteContentManager: android.content.IRCPInterface getRCPInterface()>
<com.samsung.android.knox.ISemRemoteContentManager: int copyFile(int,java.lang.String,int,java.lang.String)>
<com.samsung.android.knox.ISemRemoteContentManager: android.os.Bundle exchangeData(java.lang.String,int,android.os.Bundle)>
<com.samsung.android.knox.ISemRemoteContentManager: void cancelCopyChunks(long)>
<com.samsung.android.knox.ISemRemoteContentManager: android.os.Bundle getFileInfo(java.lang.String,int)>
<com.samsung.android.knox.ISemRemoteContentManager: boolean isFileExist(java.lang.String,int)>
<com.samsung.android.knox.ISemRemoteContentManager: void registerRCPInterface(android.content.IRCPInterface,int)>
<com.samsung.android.knox.ISemRemoteContentManager: long moveFilesForApp(int,java.util.List,java.util.List)>
<com.samsung.android.knox.ISemRemoteContentManager: long moveFilesForAppEx(int,java.util.List,java.util.List,int)>
<com.samsung.android.knox.ISemRemoteContentManager: java.util.List getFiles(java.lang.String,int)>
<com.samsung.android.knox.ISemRemoteContentManager: int moveFile(int,java.lang.String,int,java.lang.String)>
<com.samsung.android.knox.ISemRemoteContentManager: boolean deleteFile(java.lang.String,int)>
<com.samsung.android.knox.ISemRemoteContentManager: int copyChunks(int,java.lang.String,int,java.lang.String,long,int,long,boolean)>
<com.samsung.android.knox.ISemRemoteContentManager: long moveUnlimitedFiles(int,android.net.Uri,int,int)>
<com.samsung.android.knox.ISemRemoteContentManager: int copyFileInternal(int,java.lang.String,int,java.lang.String)>
<android.net.IVpnManager: void registerSystemDefaultNetworkCallback()>
<android.net.IVpnManager: void resetUidListInNetworkCapabilities(java.lang.String,int,java.lang.String)>
<android.net.IVpnManager: void updateUidRangesToUserVpnWithBlackList(java.lang.String,int,int,int[],java.lang.String)>
<android.net.IVpnManager: java.lang.String[] getDnsServerListForInterface(java.lang.String)>
<android.net.IVpnManager: int knoxVpnProfileType(java.lang.String)>
<android.net.IVpnManager: java.lang.String[] getProxyInfoForUid(int)>
<android.net.IVpnManager: boolean checkIfLocalProxyPortExists(int)>
<android.net.IVpnManager: void startLegacyKnoxVpn(int,com.android.internal.net.KnoxVpnProfile)>
<android.net.IVpnManager: void unregisterSystemDefaultNetworkCallback()>
<android.net.IVpnManager: boolean disconnectKnoxVpn(java.lang.String,int)>
<android.net.IVpnManager: boolean isAlwaysOnVpnPackageSupported(int,java.lang.String)>
<android.net.IVpnManager: java.lang.String getActiveDefaultInterface()>
<android.net.IVpnManager: void setVpnPackageAuthorization(java.lang.String,int,int)>
<android.net.IVpnManager: boolean isVpnLockdownEnabled(int)>
<android.net.IVpnManager: void stopVpnProfile(java.lang.String)>
<android.net.IVpnManager: void updateUidRangesToUserVpn(java.lang.String,int,boolean,int,java.lang.String)>
<android.net.IVpnManager: com.android.internal.net.LegacyVpnInfo getLegacyKnoxVpnInfo(int)>
<android.net.IVpnManager: void deleteVpnProfile(java.lang.String)>
<android.net.IVpnManager: boolean setAppExclusionList(int,java.lang.String,java.util.List)>
<android.net.IVpnManager: android.net.VpnProfileState getProvisionedVpnProfileState(java.lang.String)>
<android.net.IVpnManager: boolean isCallerCurrentAlwaysOnVpnLockdownApp()>
<android.net.IVpnManager: void applyBlockingRulesToUidRange(java.lang.String,int,boolean,java.lang.String)>
<android.net.IVpnManager: boolean addVpnAddress(java.lang.String,int)>
<android.net.IVpnManager: void updateUidRangesToPerAppVpn(java.lang.String,int,boolean,int[],java.lang.String)>
<android.net.IVpnManager: void removeEnterpriseVpnInstance(java.lang.String,java.lang.String,int)>
<android.net.IVpnManager: boolean setUnderlyingNetworksForVpn(android.net.Network[])>
<android.net.IVpnManager: android.os.ParcelFileDescriptor establishVpn(com.android.internal.net.VpnConfig)>
<android.net.IVpnManager: java.util.List getVpnLockdownAllowlist(int)>
<android.net.IVpnManager: void createEnterpriseVpnInstance(java.lang.String,java.lang.String,int,int)>
<android.net.IVpnManager: boolean getChainingEnabledForProfile(int)>
<android.net.IVpnManager: void updateEnterpriseVpn(java.lang.String,int,boolean)>
<android.net.IVpnManager: void startLegacyVpn(com.android.internal.net.VpnProfile)>
<android.net.IVpnManager: java.lang.String startVpnProfile(java.lang.String)>
<android.net.IVpnManager: boolean prepareVpn(java.lang.String,java.lang.String,int)>
<android.net.IVpnManager: int getNetIdforActiveDefaultInterface()>
<android.net.IVpnManager: boolean prepareEnterpriseVpnExt(java.lang.String,boolean)>
<android.net.IVpnManager: boolean provisionVpnProfile(com.android.internal.net.VpnProfile,java.lang.String)>
<android.net.IVpnManager: com.android.internal.net.LegacyVpnInfo getLegacyVpnInfo(int)>
<android.net.IVpnManager: java.lang.String getAlwaysOnVpnPackage(int)>
<android.net.IVpnManager: boolean isCallerCurrentAlwaysOnVpnApp()>
<android.net.IVpnManager: boolean removeVpnAddress(java.lang.String,int)>
<android.net.IVpnManager: void factoryReset()>
<android.net.IVpnManager: void updateLocalProxyInfo(java.lang.String,int,java.lang.String,android.net.ProxyInfo)>
<android.net.IVpnManager: boolean checkIfUidIsExempted(int)>
<android.net.IVpnManager: void stopLegacyKnoxVpn(int,java.lang.String,java.lang.String)>
<android.net.IVpnManager: java.util.List getAppExclusionList(int,java.lang.String)>
<android.net.IVpnManager: boolean isProxyConfiguredForKnoxVpn(int)>
<android.net.IVpnManager: boolean updateLockdownVpn()>
<android.net.IVpnManager: com.android.internal.net.VpnConfig getVpnConfig(int)>
<android.net.IVpnManager: android.net.Network getActiveDefaultNetwork()>
<android.net.IVpnManager: boolean setAlwaysOnVpnPackage(int,java.lang.String,boolean,java.util.List)>
<android.content.pm.IDataLoaderStatusListener: void onStatusChanged(int,int)>
<android.hardware.radio.ims.IRadioImsResponse: void updateImsRegistrationInfoResponse(android.hardware.radio.RadioResponseInfo)>
<android.hardware.radio.ims.IRadioImsResponse: void sendAnbrQueryResponse(android.hardware.radio.RadioResponseInfo)>
<android.hardware.radio.ims.IRadioImsResponse: void updateImsCallStatusResponse(android.hardware.radio.RadioResponseInfo)>
<android.hardware.radio.ims.IRadioImsResponse: void triggerEpsFallbackResponse(android.hardware.radio.RadioResponseInfo)>
<android.hardware.radio.ims.IRadioImsResponse: java.lang.String getInterfaceHash()>
<android.hardware.radio.ims.IRadioImsResponse: void stopImsTrafficResponse(android.hardware.radio.RadioResponseInfo)>
<android.hardware.radio.ims.IRadioImsResponse: void setSrvccCallInfoResponse(android.hardware.radio.RadioResponseInfo)>
<android.hardware.radio.ims.IRadioImsResponse: void startImsTrafficResponse(android.hardware.radio.RadioResponseInfo,android.hardware.radio.ims.ConnectionFailureInfo)>
<android.hardware.radio.ims.IRadioImsResponse: int getInterfaceVersion()>
<android.service.voice.IVoiceInteractionService: void prepareToShowSession(android.os.Bundle,int)>
<android.service.voice.IVoiceInteractionService: void ready()>
<android.service.voice.IVoiceInteractionService: void showSessionFailed(android.os.Bundle)>
<android.service.voice.IVoiceInteractionService: void detectorRemoteExceptionOccurred(android.os.IBinder,int)>
<android.service.voice.IVoiceInteractionService: void soundModelsChanged()>
<android.service.voice.IVoiceInteractionService: void shutdown()>
<android.service.voice.IVoiceInteractionService: void getActiveServiceSupportedActions(java.util.List,com.android.internal.app.IVoiceActionCheckCallback)>
<android.service.voice.IVoiceInteractionService: void launchVoiceAssistFromKeyguard()>
<android.os.IBatteryPropertiesRegistrar: int getProperty(int,android.os.BatteryProperty)>
<android.os.IBatteryPropertiesRegistrar: void scheduleUpdate()>
<android.accounts.IAccountManager: void hasFeatures(android.accounts.IAccountManagerResponse,android.accounts.Account,java.lang.String[],int,java.lang.String)>
<android.accounts.IAccountManager: void getAuthToken(android.accounts.IAccountManagerResponse,android.accounts.Account,java.lang.String,boolean,boolean,android.os.Bundle)>
<android.accounts.IAccountManager: android.content.IntentSender createRequestAccountAccessIntentSenderAsUser(android.accounts.Account,java.lang.String,android.os.UserHandle)>
<android.accounts.IAccountManager: void renameAccount(android.accounts.IAccountManagerResponse,android.accounts.Account,java.lang.String)>
<android.accounts.IAccountManager: boolean addAccountExplicitly(android.accounts.Account,java.lang.String,android.os.Bundle,java.lang.String)>
<android.accounts.IAccountManager: java.util.Map getAccountsAndVisibilityForPackage(java.lang.String,java.lang.String)>
<android.accounts.IAccountManager: java.lang.String getUserData(android.accounts.Account,java.lang.String)>
<android.accounts.IAccountManager: void copyAccountToUser(android.accounts.IAccountManagerResponse,android.accounts.Account,int,int)>
<android.accounts.IAccountManager: void updateCredentials(android.accounts.IAccountManagerResponse,android.accounts.Account,java.lang.String,boolean,android.os.Bundle)>
<android.accounts.IAccountManager: void onAccountAccessed(java.lang.String)>
<android.accounts.IAccountManager: java.lang.String peekAuthToken(android.accounts.Account,java.lang.String)>
<android.accounts.IAccountManager: void addAccountAsUser(android.accounts.IAccountManagerResponse,java.lang.String,java.lang.String,java.lang.String[],boolean,android.os.Bundle,int)>
<android.accounts.IAccountManager: void addSharedAccountsFromParentUser(int,int,java.lang.String)>
<android.accounts.IAccountManager: void addAccount(android.accounts.IAccountManagerResponse,java.lang.String,java.lang.String,java.lang.String[],boolean,android.os.Bundle)>
<android.accounts.IAccountManager: void editProperties(android.accounts.IAccountManagerResponse,java.lang.String,boolean)>
<android.accounts.IAccountManager: boolean addAccountExplicitlyWithVisibility(android.accounts.Account,java.lang.String,android.os.Bundle,java.util.Map,java.lang.String)>
<android.accounts.IAccountManager: boolean hasAccountAccess(android.accounts.Account,java.lang.String,android.os.UserHandle)>
<android.accounts.IAccountManager: void updateAppPermission(android.accounts.Account,java.lang.String,int,boolean)>
<android.accounts.IAccountManager: boolean accountAuthenticated(android.accounts.Account)>
<android.accounts.IAccountManager: int getAccountVisibility(android.accounts.Account,java.lang.String)>
<android.accounts.IAccountManager: void setAuthToken(android.accounts.Account,java.lang.String,java.lang.String)>
<android.accounts.IAccountManager: void getAccountByTypeAndFeatures(android.accounts.IAccountManagerResponse,java.lang.String,java.lang.String[],java.lang.String)>
<android.accounts.IAccountManager: void invalidateAuthToken(java.lang.String,java.lang.String)>
<android.accounts.IAccountManager: java.lang.String getPassword(android.accounts.Account)>
<android.accounts.IAccountManager: void unregisterAccountListener(java.lang.String[],java.lang.String)>
<android.accounts.IAccountManager: android.accounts.Account[] getAccountsAsUser(java.lang.String,int,java.lang.String)>
<android.accounts.IAccountManager: void removeAccountAsUser(android.accounts.IAccountManagerResponse,android.accounts.Account,boolean,int)>
<android.accounts.IAccountManager: void setUserData(android.accounts.Account,java.lang.String,java.lang.String)>
<android.accounts.IAccountManager: boolean someUserHasAccount(android.accounts.Account)>
<android.accounts.IAccountManager: void startUpdateCredentialsSession(android.accounts.IAccountManagerResponse,android.accounts.Account,java.lang.String,boolean,android.os.Bundle)>
<android.accounts.IAccountManager: void setPassword(android.accounts.Account,java.lang.String)>
<android.accounts.IAccountManager: boolean setAccountVisibility(android.accounts.Account,java.lang.String,int)>
<android.accounts.IAccountManager: void registerAccountListener(java.lang.String[],java.lang.String)>
<android.accounts.IAccountManager: java.lang.String getPreviousName(android.accounts.Account)>
<android.accounts.IAccountManager: void getAuthTokenLabel(android.accounts.IAccountManagerResponse,java.lang.String,java.lang.String)>
<android.accounts.IAccountManager: void finishSessionAsUser(android.accounts.IAccountManagerResponse,android.os.Bundle,boolean,android.os.Bundle,int)>
<android.accounts.IAccountManager: java.util.Map getPackagesAndVisibilityForAccount(android.accounts.Account)>
<android.accounts.IAccountManager: void getAccountsByFeatures(android.accounts.IAccountManagerResponse,java.lang.String,java.lang.String[],java.lang.String)>
<android.accounts.IAccountManager: void confirmCredentialsAsUser(android.accounts.IAccountManagerResponse,android.accounts.Account,android.os.Bundle,boolean,int)>
<android.accounts.IAccountManager: void isCredentialsUpdateSuggested(android.accounts.IAccountManagerResponse,android.accounts.Account,java.lang.String)>
<android.accounts.IAccountManager: void clearPassword(android.accounts.Account)>
<android.accounts.IAccountManager: void startAddAccountSession(android.accounts.IAccountManagerResponse,java.lang.String,java.lang.String,java.lang.String[],boolean,android.os.Bundle)>
<android.accounts.IAccountManager: android.accounts.Account[] getAccountsByTypeForPackage(java.lang.String,java.lang.String,java.lang.String)>
<android.accounts.IAccountManager: android.accounts.AuthenticatorDescription[] getAuthenticatorTypes(int)>
<android.accounts.IAccountManager: android.accounts.Account[] getAccountsForPackage(java.lang.String,int,java.lang.String)>
<android.accounts.IAccountManager: boolean removeAccountExplicitly(android.accounts.Account)>
<android.service.contentsuggestions.IContentSuggestionsService: void provideContextImage(int,android.hardware.HardwareBuffer,int,android.os.Bundle)>
<android.service.contentsuggestions.IContentSuggestionsService: void suggestContentSelections(android.app.contentsuggestions.SelectionsRequest,android.app.contentsuggestions.ISelectionsCallback)>
<android.service.contentsuggestions.IContentSuggestionsService: void notifyInteraction(java.lang.String,android.os.Bundle)>
<android.service.contentsuggestions.IContentSuggestionsService: void classifyContentSelections(android.app.contentsuggestions.ClassificationsRequest,android.app.contentsuggestions.IClassificationsCallback)>
<android.hardware.hdmi.IHdmiCecVolumeControlFeatureListener: void onHdmiCecVolumeControlFeature(int)>
<android.window.IWindowlessStartingSurfaceCallback: void onSurfaceAdded(android.view.SurfaceControl)>
<com.android.internal.telecom.IVideoCallback: void changePeerDimensions(int,int)>
<com.android.internal.telecom.IVideoCallback: void changeCameraCapabilities(android.telecom.VideoProfile$CameraCapabilities)>
<com.android.internal.telecom.IVideoCallback: void receiveSessionModifyRequest(android.telecom.VideoProfile)>
<com.android.internal.telecom.IVideoCallback: void receiveSessionModifyResponse(int,android.telecom.VideoProfile,android.telecom.VideoProfile)>
<com.android.internal.telecom.IVideoCallback: void changeCallDataUsage(long)>
<com.android.internal.telecom.IVideoCallback: void handleCallSessionEvent(int)>
<com.android.internal.telecom.IVideoCallback: void changeVideoQuality(int)>
<android.view.IRemoteAnimationRunner: void onAnimationStart(int,android.view.RemoteAnimationTarget[],android.view.RemoteAnimationTarget[],android.view.RemoteAnimationTarget[],android.view.IRemoteAnimationFinishedCallback)>
<android.view.IRemoteAnimationRunner: void onAnimationCancelled()>
<android.speech.tts.ITextToSpeechCallback: void onStart(java.lang.String)>
<android.speech.tts.ITextToSpeechCallback: void onError(java.lang.String,int)>
<android.speech.tts.ITextToSpeechCallback: void onSuccess(java.lang.String)>
<android.speech.tts.ITextToSpeechCallback: void onAudioAvailable(java.lang.String,byte[])>
<android.speech.tts.ITextToSpeechCallback: void onStop(java.lang.String,boolean)>
<android.speech.tts.ITextToSpeechCallback: void onBeginSynthesis(java.lang.String,int,int,int)>
<android.speech.tts.ITextToSpeechCallback: void onRangeStart(java.lang.String,int,int,int)>
<android.telephony.ims.aidl.IRcsConfigCallback: void onConfigurationChanged(byte[])>
<android.telephony.ims.aidl.IRcsConfigCallback: void onRemoved()>
<android.telephony.ims.aidl.IRcsConfigCallback: void onAutoConfigurationErrorReceived(int,java.lang.String)>
<android.telephony.ims.aidl.IRcsConfigCallback: void onConfigurationReset()>
<android.telephony.ims.aidl.IRcsConfigCallback: void onPreProvisioningReceived(byte[])>
<android.hardware.input.ITabletModeChangedListener: void onTabletModeChanged(long,boolean)>
<android.debug.IAdbTransport: void onAdbEnabled(boolean,byte)>
<android.media.IMediaRoute2ProviderService: void requestCreateSession(long,java.lang.String,java.lang.String,android.os.Bundle)>
<android.media.IMediaRoute2ProviderService: void setRouteVolume(long,java.lang.String,int)>
<android.media.IMediaRoute2ProviderService: void selectRoute(long,java.lang.String,java.lang.String)>
<android.media.IMediaRoute2ProviderService: void transferToRoute(long,java.lang.String,java.lang.String)>
<android.media.IMediaRoute2ProviderService: void updateDiscoveryPreference(android.media.RouteDiscoveryPreference)>
<android.media.IMediaRoute2ProviderService: void setSessionVolume(long,java.lang.String,int)>
<android.media.IMediaRoute2ProviderService: void setCallback(android.media.IMediaRoute2ProviderServiceCallback)>
<android.media.IMediaRoute2ProviderService: void releaseSession(long,java.lang.String)>
<android.media.IMediaRoute2ProviderService: void deselectRoute(long,java.lang.String,java.lang.String)>
<android.app.tare.IEconomyManager: int getEnabledMode()>
<com.android.ims.internal.IImsRegistrationListener: void registrationConnected()>
<com.android.ims.internal.IImsRegistrationListener: void registrationChangeFailed(int,android.telephony.ims.ImsReasonInfo)>
<com.android.ims.internal.IImsRegistrationListener: void registrationConnectedWithRadioTech(int)>
<com.android.ims.internal.IImsRegistrationListener: void registrationResumed()>
<com.android.ims.internal.IImsRegistrationListener: void registrationServiceCapabilityChanged(int,int)>
<com.android.ims.internal.IImsRegistrationListener: void registrationProgressingWithRadioTech(int)>
<com.android.ims.internal.IImsRegistrationListener: void registrationSuspended()>
<com.android.ims.internal.IImsRegistrationListener: void registrationFeatureCapabilityChanged(int,int[],int[])>
<com.android.ims.internal.IImsRegistrationListener: void voiceMessageCountUpdate(int)>
<com.android.ims.internal.IImsRegistrationListener: void registrationDisconnected(android.telephony.ims.ImsReasonInfo)>
<com.android.ims.internal.IImsRegistrationListener: void registrationProgressing()>
<com.android.ims.internal.IImsRegistrationListener: void registrationAssociatedUriChanged(android.net.Uri[])>
<android.view.accessibility.IRemoteMagnificationAnimationCallback: void onResult(boolean)>
<com.samsung.android.remoteappmode.ITaskChangeListener: void onTaskDisplayChanged(int,int)>
<com.samsung.android.remoteappmode.ITaskChangeListener: void onTaskRemoved(int)>
<com.samsung.android.remoteappmode.ITaskChangeListener: void onRecentTaskListUpdated()>
<com.samsung.android.remoteappmode.ITaskChangeListener: void onTaskTriedToGoToBackground(int,int)>
<com.samsung.android.remoteappmode.ITaskChangeListener: void onTaskPlayed(int,int)>
<android.hardware.devicestate.IDeviceStateManager: void onStateRequestOverlayDismissed(boolean)>
<android.hardware.devicestate.IDeviceStateManager: void cancelBaseStateOverride()>
<android.hardware.devicestate.IDeviceStateManager: void registerCallback(android.hardware.devicestate.IDeviceStateManagerCallback)>
<android.hardware.devicestate.IDeviceStateManager: void cancelStateRequest()>
<android.hardware.devicestate.IDeviceStateManager: void requestBaseStateOverride(android.os.IBinder,int,int)>
<android.hardware.devicestate.IDeviceStateManager: android.hardware.devicestate.DeviceStateInfo getDeviceStateInfo()>
<android.hardware.devicestate.IDeviceStateManager: void requestState(android.os.IBinder,int,int)>
<com.samsung.android.perfsdkservice.IPerfSDKService: int connectionRequest()>
<com.samsung.android.perfsdkservice.IPerfSDKService: java.lang.String getAllowedPkgName()>
<com.samsung.android.perfsdkservice.IPerfSDKService: int[] getThermalTable()>
<com.samsung.android.perfsdkservice.IPerfSDKService: int[] getHighBoostingLevel()>
<com.samsung.android.perfsdkservice.IPerfSDKService: int setSessionKey(java.lang.String)>
<com.samsung.android.perfsdkservice.IPerfSDKService: int[] getLowBoostingLevel()>
<com.samsung.android.perfsdkservice.IPerfSDKService: int initPerfSDK(java.lang.String)>
<com.samsung.android.perfsdkservice.IPerfSDKService: java.lang.String getForegroundPackagename()>
<com.samsung.android.perfsdkservice.IPerfSDKService: java.lang.String getChangedForegroundPackagename()>
<com.samsung.android.perfsdkservice.IPerfSDKService: int removeSessionKey(java.lang.String)>
<android.security.IKeyChainService: boolean deleteCaCertificate(java.lang.String)>
<android.security.IKeyChainService: java.util.List userAliases()>
<android.security.IKeyChainService: int[] getGrants(java.lang.String)>
<android.security.IKeyChainService: java.lang.String getWifiKeyGrantAsUser(java.lang.String)>
<android.security.IKeyChainService: boolean setKeyPairCertificate(java.lang.String,byte[],byte[])>
<android.security.IKeyChainService: boolean containsCaAlias(java.lang.String)>
<android.security.IKeyChainService: int generateKeyPair(java.lang.String,android.security.keystore.ParcelableKeyGenParameterSpec)>
<android.security.IKeyChainService: java.lang.String getCredentialManagementAppPackageName()>
<android.security.IKeyChainService: void setCredentialManagementApp(java.lang.String,android.security.AppUriAuthenticationPolicy)>
<android.security.IKeyChainService: java.lang.String installCaCertificate(byte[])>
<android.security.IKeyChainService: boolean isCredentialManagementApp(java.lang.String)>
<android.security.IKeyChainService: byte[] getEncodedCaCertificate(java.lang.String,boolean)>
<android.security.IKeyChainService: boolean deleteEntry(java.lang.String,int)>
<android.security.IKeyChainService: android.content.pm.StringParceledListSlice getSystemCaAliases()>
<android.security.IKeyChainService: boolean hasCredentialManagementApp()>
<android.security.IKeyChainService: android.content.pm.StringParceledListSlice getUserCaAliases()>
<android.security.IKeyChainService: java.lang.String[] listAliases(java.lang.String,int)>
<android.security.IKeyChainService: byte[] getCertificate(java.lang.String)>
<android.security.IKeyChainService: boolean setCertificateChain(java.lang.String,byte[])>
<android.security.IKeyChainService: byte[] getCertificateFromTrustCredential(java.lang.String,boolean)>
<android.security.IKeyChainService: boolean hasGrant(int,java.lang.String)>
<android.security.IKeyChainService: java.lang.String getCertificateAlias(byte[])>
<android.security.IKeyChainService: boolean reset()>
<android.security.IKeyChainService: boolean containsAlias(java.lang.String)>
<android.security.IKeyChainService: boolean isCertificateEntry(java.lang.String,int)>
<android.security.IKeyChainService: boolean setGrant(int,java.lang.String,boolean)>
<android.security.IKeyChainService: java.util.List getCaCertificateChainAliases(java.lang.String,boolean)>
<android.security.IKeyChainService: boolean contains(java.lang.String,int)>
<android.security.IKeyChainService: java.lang.String getPredefinedAliasForPackageAndUri(java.lang.String,android.net.Uri)>
<android.security.IKeyChainService: android.security.AppUriAuthenticationPolicy getCredentialManagementAppPolicy()>
<android.security.IKeyChainService: java.util.List allSystemAliases()>
<android.security.IKeyChainService: void removeCredentialManagementApp()>
<android.security.IKeyChainService: byte[] findIssuer(byte[])>
<android.security.IKeyChainService: boolean isUserSelectable(java.lang.String)>
<android.security.IKeyChainService: boolean removeKeyPair(java.lang.String)>
<android.security.IKeyChainService: java.lang.String requestPrivateKey(java.lang.String)>
<android.security.IKeyChainService: byte[] getCertificateSystem(java.lang.String,java.lang.String,int)>
<android.security.IKeyChainService: boolean updateKeyPair(java.lang.String,byte[],byte[],int)>
<android.security.IKeyChainService: boolean attestKey(java.lang.String,byte[])>
<android.security.IKeyChainService: boolean containsKeyPair(java.lang.String)>
<android.security.IKeyChainService: boolean installKeyPair(byte[],byte[],byte[],java.lang.String,int)>
<android.security.IKeyChainService: byte[] getCaCertificates(java.lang.String)>
<android.security.IKeyChainService: void setUserSelectable(java.lang.String,boolean)>
<android.media.projection.IMediaProjection: void start(android.media.projection.IMediaProjectionCallback)>
<android.media.projection.IMediaProjection: boolean canProjectSecureVideo()>
<android.media.projection.IMediaProjection: boolean canProjectVideo()>
<android.media.projection.IMediaProjection: boolean isValid()>
<android.media.projection.IMediaProjection: void unregisterCallback(android.media.projection.IMediaProjectionCallback)>
<android.media.projection.IMediaProjection: void notifyVirtualDisplayCreated(int)>
<android.media.projection.IMediaProjection: boolean canProjectAudio()>
<android.media.projection.IMediaProjection: void stop()>
<android.media.projection.IMediaProjection: android.os.IBinder getLaunchCookie()>
<android.media.projection.IMediaProjection: void registerCallback(android.media.projection.IMediaProjectionCallback)>
<android.media.projection.IMediaProjection: int applyVirtualDisplayFlags(int)>
<android.media.projection.IMediaProjection: void setLaunchCookie(android.os.IBinder)>
<android.service.controls.IControlsActionCallback: void accept(android.os.IBinder,java.lang.String,int)>
<com.android.internal.telephony.INumberVerificationCallback: void onVerificationFailed(int)>
<com.android.internal.telephony.INumberVerificationCallback: void onCallReceived(java.lang.String)>
<com.samsung.android.gesture.IMotionRecognitionService: boolean getSSPstatus()>
<com.samsung.android.gesture.IMotionRecognitionService: boolean setTestSensor()>
<com.samsung.android.gesture.IMotionRecognitionService: boolean getPickUpMotionStatus()>
<com.samsung.android.gesture.IMotionRecognitionService: void startAdaptiveBrightness()>
<com.samsung.android.gesture.IMotionRecognitionService: void registerCallback(android.os.IBinder,int,int)>
<com.samsung.android.gesture.IMotionRecognitionService: void useMotionAlways(android.os.IBinder,boolean)>
<com.samsung.android.gesture.IMotionRecognitionService: float[] getEvToLux(float[])>
<com.samsung.android.gesture.IMotionRecognitionService: void setMotionAngle(android.os.IBinder,int)>
<com.samsung.android.gesture.IMotionRecognitionService: void unregisterCallback(android.os.IBinder)>
<com.samsung.android.gesture.IMotionRecognitionService: int resetMotionEngine()>
<com.samsung.android.gesture.IMotionRecognitionService: void stopAdaptiveBrightness()>
<com.samsung.android.gesture.IMotionRecognitionService: boolean isAvailable(int)>
<com.samsung.android.gesture.IMotionRecognitionService: java.lang.String getEvLuxTableInfo(java.lang.String)>
<com.samsung.android.gesture.IMotionRecognitionService: void setMotionTiltLevel(int,int,int,int,int,int)>
<android.media.IPlayer: void setVolume(float)>
<android.media.IPlayer: void setPan(float)>
<android.media.IPlayer: void setStartDelayMs(int)>
<android.media.IPlayer: void start()>
<android.media.IPlayer: void pause()>
<android.media.IPlayer: void applyVolumeShaper(android.media.VolumeShaperConfiguration,android.media.VolumeShaperOperation)>
<android.media.IPlayer: void stop()>
<android.content.IContentService: void sync(android.content.SyncRequest,java.lang.String)>
<android.content.IContentService: java.util.List getCurrentSyncsAsUser(int)>
<android.content.IContentService: void setMasterSyncAutomaticallyAsUser(boolean,int)>
<android.content.IContentService: java.lang.String[] getSyncAdapterPackagesForAuthorityAsUser(java.lang.String,int)>
<android.content.IContentService: boolean getMasterSyncAutomaticallyAsUser(int)>
<android.content.IContentService: boolean getSyncAutomatically(android.accounts.Account,java.lang.String)>
<android.content.IContentService: android.content.SyncStatusInfo getSyncStatusAsUser(android.accounts.Account,java.lang.String,android.content.ComponentName,int)>
<android.content.IContentService: boolean isSyncPendingAsUser(android.accounts.Account,java.lang.String,android.content.ComponentName,int)>
<android.content.IContentService: int getIsSyncable(android.accounts.Account,java.lang.String)>
<android.content.IContentService: void notifyChange(android.net.Uri[],android.database.IContentObserver,boolean,int,int,int,java.lang.String)>
<android.content.IContentService: java.util.List getCurrentSyncs()>
<android.content.IContentService: void putCache(java.lang.String,android.net.Uri,android.os.Bundle,int)>
<android.content.IContentService: android.content.SyncAdapterType[] getSyncAdapterTypesAsUser(int)>
<android.content.IContentService: void registerContentObserver(android.net.Uri,boolean,android.database.IContentObserver,int,int)>
<android.content.IContentService: void setMasterSyncAutomatically(boolean)>
<android.content.IContentService: void setIsSyncableAsUser(android.accounts.Account,java.lang.String,int,int)>
<android.content.IContentService: void resetTodayStats()>
<android.content.IContentService: android.os.Bundle getCache(java.lang.String,android.net.Uri,int)>
<android.content.IContentService: android.content.SyncStatusInfo getSyncStatus(android.accounts.Account,java.lang.String,android.content.ComponentName)>
<android.content.IContentService: boolean getMasterSyncAutomatically()>
<android.content.IContentService: java.util.List getPeriodicSyncs(android.accounts.Account,java.lang.String,android.content.ComponentName)>
<android.content.IContentService: void syncAsUser(android.content.SyncRequest,int,java.lang.String)>
<android.content.IContentService: void requestSync(android.accounts.Account,java.lang.String,android.os.Bundle,java.lang.String)>
<android.content.IContentService: void addStatusChangeListener(int,android.content.ISyncStatusObserver)>
<android.content.IContentService: void setSyncAutomaticallyAsUser(android.accounts.Account,java.lang.String,boolean,int)>
<android.content.IContentService: boolean isSyncPending(android.accounts.Account,java.lang.String,android.content.ComponentName)>
<android.content.IContentService: void onDbCorruption(java.lang.String,java.lang.String,java.lang.String)>
<android.content.IContentService: void setSyncAutomatically(android.accounts.Account,java.lang.String,boolean)>
<android.content.IContentService: void addPeriodicSync(android.accounts.Account,java.lang.String,android.os.Bundle,long)>
<android.content.IContentService: void cancelRequest(android.content.SyncRequest)>
<android.content.IContentService: java.lang.String getSyncAdapterPackageAsUser(java.lang.String,java.lang.String,int)>
<android.content.IContentService: android.content.SyncAdapterType[] getSyncAdapterTypes()>
<android.content.IContentService: void removePeriodicSync(android.accounts.Account,java.lang.String,android.os.Bundle)>
<android.content.IContentService: void cancelSync(android.accounts.Account,java.lang.String,android.content.ComponentName)>
<android.content.IContentService: int getIsSyncableAsUser(android.accounts.Account,java.lang.String,int)>
<android.content.IContentService: void removeStatusChangeListener(android.content.ISyncStatusObserver)>
<android.content.IContentService: void cancelSyncAsUser(android.accounts.Account,java.lang.String,android.content.ComponentName,int)>
<android.content.IContentService: void setIsSyncable(android.accounts.Account,java.lang.String,int)>
<android.content.IContentService: boolean getSyncAutomaticallyAsUser(android.accounts.Account,java.lang.String,int)>
<android.content.IContentService: void unregisterContentObserver(android.database.IContentObserver)>
<android.content.IContentService: boolean isSyncActive(android.accounts.Account,java.lang.String,android.content.ComponentName)>
<android.hardware.gnss.IAGnssRilCallback: java.lang.String getInterfaceHash()>
<android.hardware.gnss.IAGnssRilCallback: void requestRefLocCb()>
<android.hardware.gnss.IAGnssRilCallback: int getInterfaceVersion()>
<android.hardware.gnss.IAGnssRilCallback: void requestSetIdCb(int)>
<com.samsung.android.desktopmode.IDesktopModeUiServiceCallback: void onClickButtonPositive()>
<com.samsung.android.desktopmode.IDesktopModeUiServiceCallback: void onDismiss()>
<com.samsung.android.desktopmode.IDesktopModeUiServiceCallback: void onClickButtonNegative()>
<com.samsung.android.desktopmode.IDesktopModeUiServiceCallback: void onAnimationComplete()>
<com.samsung.android.desktopmode.IDesktopModeUiServiceCallback: void onShow()>
<android.media.soundtrigger_middleware.IInjectGlobalEvent: void triggerRestart()>
<android.media.soundtrigger_middleware.IInjectGlobalEvent: void setResourceContention(boolean,android.media.soundtrigger_middleware.IAcknowledgeEvent)>
<android.media.soundtrigger_middleware.IInjectGlobalEvent: void triggerOnResourcesAvailable()>
<android.nfc.INfcControllerAlwaysOnListener: void onControllerAlwaysOnChanged(boolean)>
<android.hardware.radio.modem.IRadioModemResponse: void getDeviceIdentityResponse(android.hardware.radio.RadioResponseInfo,java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
<android.hardware.radio.modem.IRadioModemResponse: void nvResetConfigResponse(android.hardware.radio.RadioResponseInfo)>
<android.hardware.radio.modem.IRadioModemResponse: void nvWriteItemResponse(android.hardware.radio.RadioResponseInfo)>
<android.hardware.radio.modem.IRadioModemResponse: void setRadioPowerResponse(android.hardware.radio.RadioResponseInfo)>
<android.hardware.radio.modem.IRadioModemResponse: void getImeiResponse(android.hardware.radio.RadioResponseInfo,android.hardware.radio.modem.ImeiInfo)>
<android.hardware.radio.modem.IRadioModemResponse: void acknowledgeRequest(int)>
<android.hardware.radio.modem.IRadioModemResponse: void getModemActivityInfoResponse(android.hardware.radio.RadioResponseInfo,android.hardware.radio.modem.ActivityStatsInfo)>
<android.hardware.radio.modem.IRadioModemResponse: void getModemStackStatusResponse(android.hardware.radio.RadioResponseInfo,boolean)>
<android.hardware.radio.modem.IRadioModemResponse: void nvWriteCdmaPrlResponse(android.hardware.radio.RadioResponseInfo)>
<android.hardware.radio.modem.IRadioModemResponse: java.lang.String getInterfaceHash()>
<android.hardware.radio.modem.IRadioModemResponse: void enableModemResponse(android.hardware.radio.RadioResponseInfo)>
<android.hardware.radio.modem.IRadioModemResponse: void getRadioCapabilityResponse(android.hardware.radio.RadioResponseInfo,android.hardware.radio.modem.RadioCapability)>
<android.hardware.radio.modem.IRadioModemResponse: void nvReadItemResponse(android.hardware.radio.RadioResponseInfo,java.lang.String)>
<android.hardware.radio.modem.IRadioModemResponse: int getInterfaceVersion()>
<android.hardware.radio.modem.IRadioModemResponse: void sendDeviceStateResponse(android.hardware.radio.RadioResponseInfo)>
<android.hardware.radio.modem.IRadioModemResponse: void requestShutdownResponse(android.hardware.radio.RadioResponseInfo)>
<android.hardware.radio.modem.IRadioModemResponse: void getHardwareConfigResponse(android.hardware.radio.RadioResponseInfo,android.hardware.radio.modem.HardwareConfig[])>
<android.hardware.radio.modem.IRadioModemResponse: void getBasebandVersionResponse(android.hardware.radio.RadioResponseInfo,java.lang.String)>
<android.hardware.radio.modem.IRadioModemResponse: void setRadioCapabilityResponse(android.hardware.radio.RadioResponseInfo,android.hardware.radio.modem.RadioCapability)>
<android.os.IVoldListener: void onDiskMetadataChanged(java.lang.String,long,java.lang.String,java.lang.String)>
<android.os.IVoldListener: void onDiskDestroyed(java.lang.String)>
<android.os.IVoldListener: void onVolumePathChanged(java.lang.String,java.lang.String)>
<android.os.IVoldListener: void onVolumeMetadataChanged(java.lang.String,java.lang.String,java.lang.String,java.lang.String)>
<android.os.IVoldListener: void onEncryptionStateChanged(java.lang.String,java.lang.String,java.lang.String)>
<android.os.IVoldListener: void onDiskScanned(java.lang.String)>
<android.os.IVoldListener: void onDiskCreated(java.lang.String,int)>
<android.os.IVoldListener: void onVolumeDestroyed(java.lang.String)>
<android.os.IVoldListener: void sendVoldMessage(java.lang.String)>
<android.os.IVoldListener: void onVolumeStateChanged(java.lang.String,int)>
<android.os.IVoldListener: void onVolumeCreated(java.lang.String,int,java.lang.String,java.lang.String,int)>
<android.os.IVoldListener: void onVolumeInternalPathChanged(java.lang.String,java.lang.String)>
<com.android.internal.telecom.IInCallService: void onCanAddCallChanged(boolean)>
<com.android.internal.telecom.IInCallService: void onMuteStateChanged(boolean)>
<com.android.internal.telecom.IInCallService: void setInCallAdapter(com.android.internal.telecom.IInCallAdapter)>
<com.android.internal.telecom.IInCallService: void onCallAudioStateChanged(android.telecom.CallAudioState)>
<com.android.internal.telecom.IInCallService: void onHandoverFailed(java.lang.String,int)>
<com.android.internal.telecom.IInCallService: void onHandoverComplete(java.lang.String)>
<com.android.internal.telecom.IInCallService: void setPostDialWait(java.lang.String,java.lang.String)>
<com.android.internal.telecom.IInCallService: void setPostDial(java.lang.String,java.lang.String)>
<com.android.internal.telecom.IInCallService: void onConnectionEvent(java.lang.String,java.lang.String,android.os.Bundle)>
<com.android.internal.telecom.IInCallService: void onRttUpgradeRequest(java.lang.String,int)>
<com.android.internal.telecom.IInCallService: void silenceRinger()>
<com.android.internal.telecom.IInCallService: void addCall(android.telecom.ParcelableCall)>
<com.android.internal.telecom.IInCallService: void onRttInitiationFailure(java.lang.String,int)>
<com.android.internal.telecom.IInCallService: void onAvailableCallEndpointsChanged(java.util.List)>
<com.android.internal.telecom.IInCallService: void onCallEndpointChanged(android.telecom.CallEndpoint)>
<com.android.internal.telecom.IInCallService: void bringToForeground(boolean)>
<com.android.internal.telecom.IInCallService: void updateCall(android.telecom.ParcelableCall)>
<android.service.vr.IVrManager: void setVr2dDisplayProperties(android.app.Vr2dDisplayProperties)>
<android.service.vr.IVrManager: boolean getPersistentVrModeEnabled()>
<android.service.vr.IVrManager: void unregisterPersistentVrStateListener(android.service.vr.IPersistentVrStateCallbacks)>
<android.service.vr.IVrManager: void setPersistentVrModeEnabled(boolean)>
<android.service.vr.IVrManager: void setAndBindCompositor(java.lang.String)>
<android.service.vr.IVrManager: int getVr2dDisplayId()>
<android.service.vr.IVrManager: void setStandbyEnabled(boolean)>
<android.service.vr.IVrManager: boolean getVrModeState()>
<android.service.vr.IVrManager: void registerPersistentVrStateListener(android.service.vr.IPersistentVrStateCallbacks)>
<android.service.vr.IVrManager: void unregisterListener(android.service.vr.IVrStateCallbacks)>
<android.service.vr.IVrManager: void registerListener(android.service.vr.IVrStateCallbacks)>
<android.service.euicc.IDeleteSubscriptionCallback: void onComplete(int)>
<android.content.pm.ICrossProfileApps: void clearInteractAcrossProfilesAppOps(int)>
<android.content.pm.ICrossProfileApps: boolean canInteractAcrossProfiles(java.lang.String)>
<android.content.pm.ICrossProfileApps: void setInteractAcrossProfilesAppOp(int,java.lang.String,int)>
<android.content.pm.ICrossProfileApps: void startActivityAsUserByIntent(android.app.IApplicationThread,java.lang.String,java.lang.String,android.content.Intent,int,android.os.IBinder,android.os.Bundle)>
<android.content.pm.ICrossProfileApps: boolean canRequestInteractAcrossProfiles(java.lang.String)>
<android.content.pm.ICrossProfileApps: java.util.List getTargetUserProfiles(java.lang.String)>
<android.content.pm.ICrossProfileApps: boolean canConfigureInteractAcrossProfiles(int,java.lang.String)>
<android.content.pm.ICrossProfileApps: void resetInteractAcrossProfilesAppOps(int,java.util.List)>
<android.content.pm.ICrossProfileApps: boolean canUserAttemptToConfigureInteractAcrossProfiles(int,java.lang.String)>
<android.content.pm.ICrossProfileApps: void startActivityAsUser(android.app.IApplicationThread,java.lang.String,java.lang.String,android.content.ComponentName,int,boolean,android.os.IBinder,android.os.Bundle)>
<com.android.internal.telephony.IVoidConsumer: void accept()>
<android.service.notification.IConditionProvider: void onConnected()>
<android.service.notification.IConditionProvider: void onSubscribe(android.net.Uri)>
<android.service.notification.IConditionProvider: void onUnsubscribe(android.net.Uri)>
<android.hardware.tv.tuner.ITuner: android.hardware.tv.tuner.IDemux openDemuxById(int)>
<android.hardware.tv.tuner.ITuner: boolean isLnaSupported()>
<android.hardware.tv.tuner.ITuner: android.hardware.tv.tuner.FrontendInfo getFrontendInfo(int)>
<android.hardware.tv.tuner.ITuner: void setMaxNumberOfFrontends(int,int)>
<android.hardware.tv.tuner.ITuner: int[] getLnbIds()>
<android.hardware.tv.tuner.ITuner: java.lang.String getInterfaceHash()>
<android.hardware.tv.tuner.ITuner: int getInterfaceVersion()>
<android.hardware.tv.tuner.ITuner: android.hardware.tv.tuner.ILnb openLnbByName(java.lang.String,int[])>
<android.hardware.tv.tuner.ITuner: android.hardware.tv.tuner.DemuxInfo getDemuxInfo(int)>
<android.hardware.tv.tuner.ITuner: void setLna(boolean)>
<android.hardware.tv.tuner.ITuner: int getMaxNumberOfFrontends(int)>
<android.hardware.tv.tuner.ITuner: android.hardware.tv.tuner.IDescrambler openDescrambler()>
<android.hardware.tv.tuner.ITuner: android.hardware.tv.tuner.DemuxCapabilities getDemuxCaps()>
<android.hardware.tv.tuner.ITuner: int[] getDemuxIds()>
<android.hardware.tv.tuner.ITuner: android.hardware.tv.tuner.IFrontend openFrontendById(int)>
<android.hardware.tv.tuner.ITuner: android.hardware.tv.tuner.ILnb openLnbById(int)>
<android.hardware.tv.tuner.ITuner: int[] getFrontendIds()>
<android.hardware.tv.tuner.ITuner: android.hardware.tv.tuner.IDemux openDemux(int[])>
<android.media.tv.ITvInputManagerCallback: void onInputRemoved(java.lang.String)>
<android.media.tv.ITvInputManagerCallback: void onTvInputInfoUpdated(android.media.tv.TvInputInfo)>
<android.media.tv.ITvInputManagerCallback: void onInputAdded(java.lang.String)>
<android.media.tv.ITvInputManagerCallback: void onInputStateChanged(java.lang.String,int)>
<android.media.tv.ITvInputManagerCallback: void onCurrentTunedInfosUpdated(java.util.List)>
<android.media.tv.ITvInputManagerCallback: void onInputUpdated(java.lang.String)>
<android.content.pm.dex.ISnapshotRuntimeProfileCallback: void onError(int)>
<android.content.pm.dex.ISnapshotRuntimeProfileCallback: void onSuccess(android.os.ParcelFileDescriptor)>
<com.android.internal.telephony.euicc.ILoadBoundProfilePackageCallback: void onComplete(int,byte[])>
<android.media.IStrategyPreferredDevicesDispatcher: void dispatchPrefDevicesChanged(int,java.util.List)>
<com.samsung.android.gamesdk.IGameSDKStateListener: void onGameSDKInitialized()>
<com.samsung.android.gamesdk.IGameSDKStateListener: void onGameSDKFinalized()>
<com.android.internal.inputmethod.IInputMethodSessionCallback: void sessionCreated(com.android.internal.inputmethod.IInputMethodSession)>
<com.samsung.android.location.ISLocationManager: void removePassiveLocation(android.app.PendingIntent,com.samsung.android.location.ISLocationListener)>
<com.samsung.android.location.ISLocationManager: void reportGpsGeofenceAddStatus(int,int)>
<com.samsung.android.location.ISLocationManager: void setSLocationLMSHook(com.samsung.android.location.ISLocationLMSHook)>
<com.samsung.android.location.ISLocationManager: void requestPassiveLocation(android.app.PendingIntent,com.samsung.android.location.ISLocationListener,java.lang.String,java.lang.String)>
<com.samsung.android.location.ISLocationManager: int removeSingleLocation(android.app.PendingIntent,com.samsung.android.location.ISLocationListener)>
<com.samsung.android.location.ISLocationManager: int requestLocation(boolean,com.samsung.android.location.ISLocationListener,java.lang.String,java.lang.String)>
<com.samsung.android.location.ISLocationManager: void onGnssStatusChanged(boolean)>
<com.samsung.android.location.ISLocationManager: void notifyAppForeground(int,boolean)>
<com.samsung.android.location.ISLocationManager: int removeLocation(com.samsung.android.location.ISLocationListener)>
<com.samsung.android.location.ISLocationManager: int removeGeofences(java.util.List,java.lang.String,java.lang.String)>
<com.samsung.android.location.ISLocationManager: int requestSingleLocation(int,int,boolean,android.app.PendingIntent,com.samsung.android.location.ISLocationListener,java.lang.String,java.lang.String)>
<com.samsung.android.location.ISLocationManager: void flushBatchedLocations()>
<com.samsung.android.location.ISLocationManager: int removeGeofencesPendingIntent(android.app.PendingIntent)>
<com.samsung.android.location.ISLocationManager: void reportGpsGeofenceTransition(int,android.location.Location,int,long)>
<com.samsung.android.location.ISLocationManager: int addGeofences(java.util.List,android.app.PendingIntent,java.lang.String,java.lang.String)>
<com.samsung.android.location.ISLocationManager: void reportGpsGeofencePauseStatus(int,int)>
<com.samsung.android.location.ISLocationManager: int requestMostAccurateLocation(int,int,int,android.app.PendingIntent,com.samsung.android.location.ISLocationListener,java.lang.String,java.lang.String)>
<com.samsung.android.location.ISLocationManager: void reportGpsGeofenceRemoveStatus(int,int)>
<com.samsung.android.location.ISLocationManager: void reportGpsGeofenceStatus(int,android.location.Location)>
<com.samsung.android.location.ISLocationManager: void onSvStatusChanged(int,int[],float[],float[],float[],float[],float[])>
<com.samsung.android.location.ISLocationManager: int removeBatchedLocations(android.app.PendingIntent,com.samsung.android.location.ISLocationBatchingListener)>
<com.samsung.android.location.ISLocationManager: int requestBatchedLocations(com.samsung.android.location.SemLocationBatchingRequest,android.app.PendingIntent,com.samsung.android.location.ISLocationBatchingListener,java.lang.String,java.lang.String)>
<com.samsung.android.location.ISLocationManager: boolean isAvailable(int)>
<com.samsung.android.location.ISLocationManager: void reportGpsGeofenceResumeStatus(int,int)>
<android.net.vcn.IVcnStatusCallback: void onGatewayConnectionError(java.lang.String,int,java.lang.String,java.lang.String)>
<android.net.vcn.IVcnStatusCallback: void onVcnStatusChanged(int)>
<android.os.ICustomFrequencyManager: float[] supportVRTemperaturesInformation(java.lang.String,int,int)>
<android.os.ICustomFrequencyManager: boolean checkHintExist(int)>
<android.os.ICustomFrequencyManager: void setGamePowerSaving(boolean)>
<android.os.ICustomFrequencyManager: boolean checkSysfsIdExist(int)>
<android.os.ICustomFrequencyManager: java.lang.String readFile(java.lang.String,char)>
<android.os.ICustomFrequencyManager: int getGameThrottlingLevel()>
<android.os.ICustomFrequencyManager: void setGameTouchParam(java.lang.String,java.lang.String,java.lang.String)>
<android.os.ICustomFrequencyManager: void unsetGameTouchParam()>
<android.os.ICustomFrequencyManager: void sendDrawingTid(int,int,int)>
<android.os.ICustomFrequencyManager: void setFrozenTime(int)>
<android.os.ICustomFrequencyManager: void mpdUpdate(int)>
<android.os.ICustomFrequencyManager: void setGpisHint(boolean)>
<android.os.ICustomFrequencyManager: int requestFreezeSlowdown(int,boolean,java.lang.String)>
<android.os.ICustomFrequencyManager: void disableGpisHint()>
<android.os.ICustomFrequencyManager: int getSsrmStatus(int)>
<android.os.ICustomFrequencyManager: android.os.CpuTrackerInfo getProcessCpuUsage(int[])>
<android.os.ICustomFrequencyManager: void restrictApp(java.lang.String,int,int)>
<android.os.ICustomFrequencyManager: int getBatteryRemainingUsageTime(int)>
<android.os.ICustomFrequencyManager: boolean removeDvfsLockAllowedUid(int)>
<android.os.ICustomFrequencyManager: int addDvfsLockAllowedUid(int)>
<android.os.ICustomFrequencyManager: java.lang.String readSysfs(int)>
<android.os.ICustomFrequencyManager: void setGameFps(int)>
<android.os.ICustomFrequencyManager: void requestMpParameterUpdate(java.lang.String)>
<android.os.ICustomFrequencyManager: void sendCommandToSSRM(java.lang.String,java.lang.String)>
<android.os.ICustomFrequencyManager: void requestCPUUpdate(int,int)>
<android.os.ICustomFrequencyManager: void writeSysfs(int,java.lang.String)>
<android.os.ICustomFrequencyManager: boolean checkResourceExist(int)>
<android.os.ICustomFrequencyManager: void enableInteractionHint(boolean)>
<android.os.ICustomFrequencyManager: int[] getSupportedFrequency(int,int)>
<android.os.ICustomFrequencyManager: void setGameTurboMode(boolean)>
<android.os.ICustomFrequencyManager: void acquire(int,int,java.lang.String,int,int[])>
<android.os.ICustomFrequencyManager: void requestGpis(int,int,int)>
<android.os.ICustomFrequencyManager: void release(int,int)>
<android.media.ISpatializerCallback: void dispatchSpatializerAvailableChanged(boolean)>
<android.media.ISpatializerCallback: void dispatchSpatializerEnabledChanged(boolean)>
<android.service.resolver.IResolverRankerService: void predict(java.util.List,android.service.resolver.IResolverRankerResult)>
<android.service.resolver.IResolverRankerService: void train(java.util.List,int)>
<com.samsung.android.knox.dar.sdp.ISdpListener: void onStateChange(int)>
<com.samsung.android.knox.dar.sdp.ISdpListener: void onEngineRemoved()>
<com.android.internal.statusbar.ISessionListener: void onSessionStarted(int,com.android.internal.logging.InstanceId)>
<com.android.internal.statusbar.ISessionListener: void onSessionEnded(int,com.android.internal.logging.InstanceId)>
<android.net.wifi.nl80211.IPnoScanEvent: void OnPnoNetworkFound()>
<android.net.wifi.nl80211.IPnoScanEvent: void OnPnoScanFailed()>
<android.media.IAudioModeDispatcher: void dispatchAudioModeChanged(int)>
<com.samsung.android.multiwindow.IKeyEventListener: void sendShortcutKeyWithFocusedTask(int,android.view.KeyEvent)>
<com.samsung.android.knox.tima.attestation.IEnhancedAttestationPolicyCallback: void onAttestationFinished(com.samsung.android.knox.tima.attestation.EnhancedAttestationResult)>
<android.app.IAppTraceRetriever: android.os.ParcelFileDescriptor getTraceFileDescriptor(java.lang.String,int,int)>
<com.android.internal.telecom.ICallControl: void requestCallEndpointChange(android.telecom.CallEndpoint,android.os.ResultReceiver)>
<com.android.internal.telecom.ICallControl: void sendEvent(java.lang.String,java.lang.String,android.os.Bundle)>
<com.android.internal.telecom.ICallControl: void answer(int,java.lang.String,android.os.ResultReceiver)>
<com.android.internal.telecom.ICallControl: void startCallStreaming(java.lang.String,android.os.ResultReceiver)>
<com.android.internal.telecom.ICallControl: void disconnect(java.lang.String,android.telecom.DisconnectCause,android.os.ResultReceiver)>
<com.android.internal.telecom.ICallControl: void setActive(java.lang.String,android.os.ResultReceiver)>
<com.android.internal.telecom.ICallControl: void setInactive(java.lang.String,android.os.ResultReceiver)>